diff -urN dosbox-0.73/aclocal.m4 dosboxcvs/aclocal.m4
--- dosbox-0.73/aclocal.m4	2009-05-20 20:40:03.000000000 +0300
+++ dosboxcvs/aclocal.m4	2009-07-08 20:45:26.000000000 +0300
@@ -1,7 +1,7 @@
-# generated automatically by aclocal 1.10.1 -*- Autoconf -*-
+# generated automatically by aclocal 1.9.6 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2005  Free Software Foundation, Inc.
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -11,15 +11,7 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(AC_AUTOCONF_VERSION, [2.61],,
-[m4_warning([this file was generated for autoconf 2.61.
-You have another version of autoconf.  It may work, but is not guaranteed to.
-If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
-
-# Copyright (C) 2002, 2003, 2005, 2006, 2007  Free Software Foundation, Inc.
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -29,31 +21,14 @@
 # ----------------------------
 # Automake X.Y traces this macro to ensure aclocal.m4 has been
 # generated from the m4 files accompanying Automake X.Y.
-# (This private macro should not be called outside this file.)
-AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.10'
-dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
-dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.10.1], [],
-      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
-])
-
-# _AM_AUTOCONF_VERSION(VERSION)
-# -----------------------------
-# aclocal traces this macro to find the Autoconf version.
-# This is a private macro too.  Using m4_define simplifies
-# the logic in aclocal, which can simply ignore this definition.
-m4_define([_AM_AUTOCONF_VERSION], [])
+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version="1.9"])
 
 # AM_SET_CURRENT_AUTOMAKE_VERSION
 # -------------------------------
-# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
+# Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.10.1])dnl
-m4_ifndef([AC_AUTOCONF_VERSION],
-  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-_AM_AUTOCONF_VERSION(AC_AUTOCONF_VERSION)])
+	 [AM_AUTOMAKE_VERSION([1.9.6])])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
@@ -110,14 +85,14 @@
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
 # Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 8
+# serial 7
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
@@ -126,10 +101,8 @@
 [AC_PREREQ(2.52)dnl
  ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
 	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
-AC_SUBST([$1_TRUE])dnl
-AC_SUBST([$1_FALSE])dnl
-_AM_SUBST_NOTMAKE([$1_TRUE])dnl
-_AM_SUBST_NOTMAKE([$1_FALSE])dnl
+AC_SUBST([$1_TRUE])
+AC_SUBST([$1_FALSE])
 if $2; then
   $1_TRUE=
   $1_FALSE='#'
@@ -143,14 +116,15 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
 # Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 9
+# serial 8
 
 # There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
@@ -178,7 +152,6 @@
 ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
        [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
        [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
        [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
                    [depcc="$$1"   am_compiler_list=])
 
@@ -244,7 +217,6 @@
        depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
        $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
@@ -297,8 +269,7 @@
   AMDEPBACKSLASH='\'
 fi
 AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
-AC_SUBST([AMDEPBACKSLASH])dnl
-_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl
+AC_SUBST([AMDEPBACKSLASH])
 ])
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
@@ -323,9 +294,8 @@
   # some people rename them; so instead we look at the file content.
   # Grep'ing the first line is not enough: some people post-process
   # each Makefile.in and add a new line on top of each file to say so.
-  # Grep'ing the whole file is not good either: AIX grep has a line
-  # limit of 2048, but all sed's we know have understand at least 4000.
-  if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
     dirpart=`AS_DIRNAME("$mf")`
   else
     continue
@@ -384,14 +354,14 @@
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008 Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 13
+# serial 12
 
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
@@ -408,20 +378,16 @@
 # arguments mandatory, and then we can depend on a new Autoconf
 # release and drop the old call support.
 AC_DEFUN([AM_INIT_AUTOMAKE],
-[AC_PREREQ([2.60])dnl
+[AC_PREREQ([2.58])dnl
 dnl Autoconf wants to disallow AM_ names.  We explicitly allow
 dnl the ones we care about.
 m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
 AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
 AC_REQUIRE([AC_PROG_INSTALL])dnl
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
-  fi
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
 fi
 
 # test whether we have cygpath
@@ -441,9 +407,6 @@
  AC_SUBST([PACKAGE], [$1])dnl
  AC_SUBST([VERSION], [$2])],
 [_AM_SET_OPTIONS([$1])dnl
-dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
-  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
  AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
 
@@ -479,10 +442,6 @@
                   [_AM_DEPENDENCIES(CXX)],
                   [define([AC_PROG_CXX],
                           defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
-AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-                  [_AM_DEPENDENCIES(OBJC)],
-                  [define([AC_PROG_OBJC],
-                          defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
 ])
 ])
 
@@ -496,17 +455,16 @@
 # our stamp files there.
 AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
 [# Compute $1's index in $config_headers.
-_am_arg=$1
 _am_stamp_count=1
 for _am_header in $config_headers :; do
   case $_am_header in
-    $_am_arg | $_am_arg:* )
+    $1 | $1:* )
       break ;;
     * )
       _am_stamp_count=`expr $_am_stamp_count + 1` ;;
   esac
 done
-echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
+echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
 
 # Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
 #
@@ -519,7 +477,7 @@
 # Define $install_sh.
 AC_DEFUN([AM_PROG_INSTALL_SH],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-install_sh=${install_sh-"\$(SHELL) $am_aux_dir/install-sh"}
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
 AC_SUBST(install_sh)])
 
 # Copyright (C) 2003, 2005  Free Software Foundation, Inc.
@@ -597,14 +555,14 @@
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
 # Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 4
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -620,7 +578,6 @@
 # If it does, set am_missing_run to use it, otherwise, to nothing.
 AC_DEFUN([AM_MISSING_HAS_RUN],
 [AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
-AC_REQUIRE_AUX_FILE([missing])dnl
 test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
 # Use eval to expand $SHELL
 if eval "$MISSING --run true"; then
@@ -631,7 +588,7 @@
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006  Free Software Foundation, Inc.
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -639,23 +596,60 @@
 
 # AM_PROG_MKDIR_P
 # ---------------
-# Check for `mkdir -p'.
+# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
+#
+# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
+# created by `make install' are always world readable, even if the
+# installer happens to have an overly restrictive umask (e.g. 077).
+# This was a mistake.  There are at least two reasons why we must not
+# use `-m 0755':
+#   - it causes special bits like SGID to be ignored,
+#   - it may be too restrictive (some setups expect 775 directories).
+#
+# Do not use -m 0755 and let people choose whatever they expect by
+# setting umask.
+#
+# We cannot accept any implementation of `mkdir' that recognizes `-p'.
+# Some implementations (such as Solaris 8's) are not thread-safe: if a
+# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'
+# concurrently, both version can detect that a/ is missing, but only
+# one can create it and the other will error out.  Consequently we
+# restrict ourselves to GNU make (using the --version option ensures
+# this.)
 AC_DEFUN([AM_PROG_MKDIR_P],
-[AC_PREREQ([2.60])dnl
-AC_REQUIRE([AC_PROG_MKDIR_P])dnl
-dnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,
-dnl while keeping a definition of mkdir_p for backward compatibility.
-dnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.
-dnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of
-dnl Makefile.ins that do not define MKDIR_P, so we do our own
-dnl adjustment using top_builddir (which is defined more often than
-dnl MKDIR_P).
-AC_SUBST([mkdir_p], ["$MKDIR_P"])dnl
-case $mkdir_p in
-  [[\\/$]]* | ?:[[\\/]]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
-])
+[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+AC_SUBST([mkdir_p])])
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
@@ -767,21 +761,9 @@
 if test "$cross_compiling" != no; then
   AC_CHECK_TOOL([STRIP], [strip], :)
 fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006  Free Software Foundation, Inc.
-#
-# This file is free software; the Free Software Foundation
-# gives unlimited permission to copy and/or distribute it,
-# with or without modifications, as long as this notice is preserved.
-
-# _AM_SUBST_NOTMAKE(VARIABLE)
-# ---------------------------
-# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.
-# This macro is traced by Automake.
-AC_DEFUN([_AM_SUBST_NOTMAKE])
-
 # Check how to create a tarball.                            -*- Autoconf -*-
 
 # Copyright (C) 2004, 2005  Free Software Foundation, Inc.
diff -urN dosbox-0.73/config.guess dosboxcvs/config.guess
--- dosbox-0.73/config.guess	2008-12-11 11:05:36.000000000 +0200
+++ dosboxcvs/config.guess	2009-07-04 14:45:18.000000000 +0300
@@ -4,7 +4,7 @@
 #   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
 #   Inc.
 
-timestamp='2007-07-22'
+timestamp='2007-03-06'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -330,7 +330,7 @@
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
-    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+    i86pc:SunOS:5.*:*)
 	echo i386-pc-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit ;;
     sun4*:SunOS:6*:*)
@@ -793,7 +793,7 @@
 	exit ;;
     *:Interix*:[3456]*)
     	case ${UNAME_MACHINE} in
-	    x86)
+	    x86) 
 		echo i586-pc-interix${UNAME_RELEASE}
 		exit ;;
 	    EM64T | authenticamd)
diff -urN dosbox-0.73/config.h.in dosboxcvs/config.h.in
--- dosbox-0.73/config.h.in	2009-05-20 20:40:05.000000000 +0300
+++ dosboxcvs/config.h.in	2009-07-08 20:45:27.000000000 +0300
@@ -32,9 +32,15 @@
 /* Define to 1 to use inlined memory functions in cpu core */
 #undef C_CORE_INLINE
 
+/* Define to 1 to use Direct3D shaders, requires d3d9.h and libd3dx9 */
+#undef C_D3DSHADERS
+
 /* Define to 1 to enable internal debugger, requires libcurses */
 #undef C_DEBUG
 
+/* Define to 1 if you want parallel passthrough support (Win32, Linux). */
+#undef C_DIRECTLPT
+
 /* Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).
    */
 #undef C_DIRECTSERIAL
@@ -62,18 +68,30 @@
 /* Define to 1 if you have the mprotect function */
 #undef C_HAVE_MPROTECT
 
+/* Define to 1 if you have physfs library */
+#undef C_HAVE_PHYSFS
+
 /* Define to 1 to enable heavy debugging, also have to enable C_DEBUG */
 #undef C_HEAVY_DEBUG
 
 /* Define to 1 to enable IPX over Internet networking, requires SDL_net */
 #undef C_IPX
 
+/* Define to 1 if you have libpng */
+#undef C_LIBPNG
+
 /* Define to 1 to enable internal modem support, requires SDL_net */
 #undef C_MODEM
 
+/* Define to 1 to enable NE2000 ethernet passthrough, requires libpcap */
+#undef C_NE2000
+
 /* Define to 1 to use opengl display output support */
 #undef C_OPENGL
 
+/* Define to 1 to use printer support */
+#undef C_PRINTER
+
 /* Define to 1 to enable SDL_sound support */
 #undef C_SDL_SOUND
 
@@ -107,6 +125,9 @@
 /* Define to 1 to use ALSA for MIDI */
 #undef HAVE_ALSA
 
+/* Define to 1 if you have the <d3d9.h> header file. */
+#undef HAVE_D3D9_H
+
 /* Define to 1 if you have the <ddraw.h> header file. */
 #undef HAVE_DDRAW_H
 
@@ -176,22 +197,22 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
-/* The size of `int *', as computed by sizeof. */
+/* The size of a `int *', as computed by sizeof. */
 #undef SIZEOF_INT_P
 
-/* The size of `unsigned char', as computed by sizeof. */
+/* The size of a `unsigned char', as computed by sizeof. */
 #undef SIZEOF_UNSIGNED_CHAR
 
-/* The size of `unsigned int', as computed by sizeof. */
+/* The size of a `unsigned int', as computed by sizeof. */
 #undef SIZEOF_UNSIGNED_INT
 
-/* The size of `unsigned long', as computed by sizeof. */
+/* The size of a `unsigned long', as computed by sizeof. */
 #undef SIZEOF_UNSIGNED_LONG
 
-/* The size of `unsigned long long', as computed by sizeof. */
+/* The size of a `unsigned long long', as computed by sizeof. */
 #undef SIZEOF_UNSIGNED_LONG_LONG
 
-/* The size of `unsigned short', as computed by sizeof. */
+/* The size of a `unsigned short', as computed by sizeof. */
 #undef SIZEOF_UNSIGNED_SHORT
 
 /* Define to 1 if you have the ANSI C header files. */
@@ -216,7 +237,7 @@
 #undef inline
 #endif
 
-/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* Define to `unsigned' if <sys/types.h> does not define. */
 #undef size_t
 
 /* Define to `int` if you don't have socklen_t */
diff -urN dosbox-0.73/config.h.in~ dosboxcvs/config.h.in~
--- dosbox-0.73/config.h.in~	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/config.h.in~	2009-07-04 14:45:17.000000000 +0300
@@ -0,0 +1,294 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+
+/*
+ *  Copyright (C) 2002-2009  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+/* Compiling on BSD */
+#undef BSD
+
+/* Determines if the compilers supports always_inline attribute. */
+#undef C_ATTRIBUTE_ALWAYS_INLINE
+
+/* Determines if the compilers supports fastcall attribute. */
+#undef C_ATTRIBUTE_FASTCALL
+
+/* Define to 1 to use inlined memory functions in cpu core */
+#undef C_CORE_INLINE
+
+/* Define to 1 to enable internal debugger, requires libcurses */
+#undef C_DEBUG
+
+/* Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).
+   */
+#undef C_DIRECTSERIAL
+
+/* Define to 1 to use x86 dynamic cpu core */
+#undef C_DYNAMIC_X86
+
+/* Define to 1 to use recompiling cpu core. Can not be used together with the
+   dynamic-x86 core */
+#undef C_DYNREC
+
+/* Define to 1 to enable floating point emulation */
+#undef C_FPU
+
+/* Define to 1 to use a x86 assembly fpu core */
+#undef C_FPU_X86
+
+/* Determines if the compilers supports attributes for structures. */
+#undef C_HAS_ATTRIBUTE
+
+/* Determines if the compilers supports __builtin_expect for branch
+   prediction. */
+#undef C_HAS_BUILTIN_EXPECT
+
+/* Define to 1 if you have the mprotect function */
+#undef C_HAVE_MPROTECT
+
+/* Define to 1 to enable heavy debugging, also have to enable C_DEBUG */
+#undef C_HEAVY_DEBUG
+
+/* Define to 1 to enable IPX over Internet networking, requires SDL_net */
+#undef C_IPX
+
+/* Define to 1 to enable internal modem support, requires SDL_net */
+#undef C_MODEM
+
+/* Define to 1 to use opengl display output support */
+#undef C_OPENGL
+
+/* Define to 1 to enable SDL_sound support */
+#undef C_SDL_SOUND
+
+/* Define to 1 if you have setpriority support */
+#undef C_SET_PRIORITY
+
+/* Define to 1 to enable screenshots, requires libpng */
+#undef C_SSHOT
+
+/* The type of cpu this target has */
+#undef C_TARGETCPU
+
+/* Define to 1 to use a unaligned memory access */
+#undef C_UNALIGNED_MEMORY
+
+/* define to 1 if you have XKBlib.h and X11 lib */
+#undef C_X11_XKB
+
+/* libm doesn't include powf */
+#undef DB_HAVE_NO_POWF
+
+/* struct dirent has d_type */
+#undef DIRENT_HAS_D_TYPE
+
+/* environ can be included */
+#undef ENVIRON_INCLUDED
+
+/* environ can be linked */
+#undef ENVIRON_LINKED
+
+/* Define to 1 to use ALSA for MIDI */
+#undef HAVE_ALSA
+
+/* Define to 1 if you have the <ddraw.h> header file. */
+#undef HAVE_DDRAW_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `asound' library (-lasound). */
+#undef HAVE_LIBASOUND
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#undef HAVE_NETINET_IN_H
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#undef HAVE_PWD_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Compiling on GNU/Linux */
+#undef LINUX
+
+/* Compiling on Mac OS X */
+#undef MACOSX
+
+/* Compiling on OS/2 EMX */
+#undef OS2
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* The size of `int *', as computed by sizeof. */
+#undef SIZEOF_INT_P
+
+/* The size of `unsigned char', as computed by sizeof. */
+#undef SIZEOF_UNSIGNED_CHAR
+
+/* The size of `unsigned int', as computed by sizeof. */
+#undef SIZEOF_UNSIGNED_INT
+
+/* The size of `unsigned long', as computed by sizeof. */
+#undef SIZEOF_UNSIGNED_LONG
+
+/* The size of `unsigned long long', as computed by sizeof. */
+#undef SIZEOF_UNSIGNED_LONG_LONG
+
+/* The size of `unsigned short', as computed by sizeof. */
+#undef SIZEOF_UNSIGNED_SHORT
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+#undef TM_IN_SYS_TIME
+
+/* Version number of package */
+#undef VERSION
+
+/* Define to 1 if your processor stores words with the most significant byte
+   first (like Motorola and SPARC, unlike Intel and VAX). */
+#undef WORDS_BIGENDIAN
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to `int` if you don't have socklen_t */
+#undef socklen_t
+
+#if C_ATTRIBUTE_ALWAYS_INLINE
+#define INLINE inline __attribute__((always_inline))
+#else
+#define INLINE inline
+#endif
+
+#if C_ATTRIBUTE_FASTCALL
+#define DB_FASTCALL __attribute__((fastcall))
+#else
+#define DB_FASTCALL
+#endif
+
+#if C_HAS_ATTRIBUTE
+#define GCC_ATTRIBUTE(x) __attribute__ ((x))
+#else
+#define GCC_ATTRIBUTE(x) /* attribute not supported */
+#endif
+
+#if C_HAS_BUILTIN_EXPECT
+#define GCC_UNLIKELY(x) __builtin_expect((x),0)
+#else
+#define GCC_UNLIKELY(x) (x)
+#endif
+
+
+typedef         double     Real64;
+
+#if SIZEOF_UNSIGNED_CHAR != 1
+#  error "sizeof (unsigned char) != 1"
+#else
+  typedef unsigned char Bit8u;
+  typedef   signed char Bit8s;
+#endif
+
+#if SIZEOF_UNSIGNED_SHORT != 2
+#  error "sizeof (unsigned short) != 2"
+#else
+  typedef unsigned short Bit16u;
+  typedef   signed short Bit16s;
+#endif
+
+#if SIZEOF_UNSIGNED_INT == 4
+  typedef unsigned int Bit32u;
+  typedef   signed int Bit32s;
+#elif SIZEOF_UNSIGNED_LONG == 4
+  typedef unsigned long Bit32u;
+  typedef   signed long Bit32s;
+#else
+#  error "can't find sizeof(type) of 4 bytes!"
+#endif
+
+#if SIZEOF_UNSIGNED_LONG == 8
+  typedef unsigned long Bit64u;
+  typedef   signed long Bit64s;
+#elif SIZEOF_UNSIGNED_LONG_LONG == 8
+  typedef unsigned long long Bit64u;
+  typedef   signed long long Bit64s;
+#else
+#  error "can't find data type of 8 bytes"
+#endif
+
+#if SIZEOF_INT_P == 4
+  typedef Bit32u Bitu;
+  typedef Bit32s Bits;
+ #else
+  typedef Bit64u Bitu;
+  typedef Bit64s Bits;
+ #endif
+
+
diff -urN dosbox-0.73/config.sub dosboxcvs/config.sub
--- dosbox-0.73/config.sub	2008-12-11 11:05:36.000000000 +0200
+++ dosboxcvs/config.sub	2009-07-04 14:45:18.000000000 +0300
@@ -4,7 +4,7 @@
 #   2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation,
 #   Inc.
 
-timestamp='2007-06-28'
+timestamp='2007-01-18'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -475,8 +475,8 @@
 		basic_machine=craynv-cray
 		os=-unicosmp
 		;;
-	cr16)
-		basic_machine=cr16-unknown
+	cr16c)
+		basic_machine=cr16c-unknown
 		os=-elf
 		;;
 	crds | unos)
@@ -683,10 +683,6 @@
 		basic_machine=i386-pc
 		os=-mingw32
 		;;
-	mingw32ce)
-		basic_machine=arm-unknown
-		os=-mingw32ce
-		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
diff -urN dosbox-0.73/configure dosboxcvs/configure
--- dosbox-0.73/configure	2009-05-20 20:40:09.000000000 +0300
+++ dosboxcvs/configure	2009-07-08 20:46:44.000000000 +0300
@@ -1,54 +1,25 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.61 for dosbox 0.73.
+# Generated by GNU Autoconf 2.59 for dosbox 0.73.
 #
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+# Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
+# Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
   # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
 if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
@@ -58,43 +29,8 @@
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-as_nl='
-'
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
-fi
-
 # Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-done
+$as_unset ENV MAIL MAILPATH
 PS1='$ '
 PS2='> '
 PS4='+ '
@@ -108,19 +44,18 @@
   if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+    $as_unset $as_var
   fi
 done
 
 # Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+if expr a : '\(a\)' >/dev/null 2>&1; then
   as_expr=expr
 else
   as_expr=false
 fi
 
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
   as_basename=basename
 else
   as_basename=false
@@ -128,388 +63,157 @@
 
 
 # Name of the executable.
-as_me=`$as_basename -- "$0" ||
+as_me=`$as_basename "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# CDPATH.
-$as_unset CDPATH
-
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
 
-if test "x$CONFIG_SHELL" = x; then
-  if (eval ":") 2>/dev/null; then
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-
-  if test $as_have_required = yes && 	 (eval ":
-(as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
 
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
 
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
 fi
 
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
 
-test \$exitcode = 0) || { (exit 1); exit 1; }
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
 
-(
-  as_lineno_1=\$LINENO
-  as_lineno_2=\$LINENO
-  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
-  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
-") 2> /dev/null; then
-  :
-else
-  as_candidate_shells=
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
     as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
 for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
 do
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
-  case $as_dir in
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
 	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
-	   done;;
-       esac
-done
-IFS=$as_save_IFS
-
-
-      for as_shell in $as_candidate_shells $SHELL; do
-	 # Try only shells that exist, to save several forks.
-	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		{ ("$as_shell") 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-:
-_ASEOF
-}; then
-  CONFIG_SHELL=$as_shell
-	       as_have_required=yes
-	       if { "$as_shell" 2> /dev/null <<\_ASEOF
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-:
-(as_func_return () {
-  (exit $1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = "$1" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test $exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
-
-_ASEOF
-}; then
-  break
-fi
-
-fi
-
-      done
-
-      if test "x$CONFIG_SHELL" != x; then
-  for as_var in BASH_ENV ENV
-        do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-        done
-        export CONFIG_SHELL
-        exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
-fi
-
-
-    if test $as_have_required = no; then
-  echo This script requires a shell more modern than all the
-      echo shells that I found on your system.  Please install a
-      echo modern shell, or manually run the script under such a
-      echo shell if you do have one.
-      { (exit 1); exit 1; }
-fi
-
-
-fi
-
-fi
-
-
-
-(eval "as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test \$exitcode = 0") || {
-  echo No shell found that supports shell functions.
-  echo Please tell autoconf@gnu.org about your system,
-  echo including any error possibly output before this
-  echo message
-}
-
-
-
+	   if ("$as_dir/$as_base" -c '
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
   test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
 
   # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
   # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
   # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
     sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
       N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
       t loop
-      s/-\n.*//
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
     ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
+  chmod +x $as_me.lineno ||
     { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
    { (exit 1); exit 1; }; }
 
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
   # Exit status is that of the last command.
   exit
 }
 
 
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
--n*)
-  case `echo 'x\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
-  esac;;
-*)
-  ECHO_N='-n';;
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
 esac
 
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+if expr a : '\(a\)' >/dev/null 2>&1; then
   as_expr=expr
 else
   as_expr=false
 fi
 
 rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir
-fi
 echo >conf$$.file
 if ln -s conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s='ln -s'
-  # ... but there are two gotchas:
-  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-  # In both cases, we have to default to `cp -p'.
-  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
     as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
 elif ln conf$$.file conf$$ 2>/dev/null; then
   as_ln_s=ln
 else
   as_ln_s='cp -p'
 fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
+rm -f conf$$ conf$$.exe conf$$.file
 
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
@@ -518,28 +222,7 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-        test -d "$1/.";
-      else
-	case $1 in
-        -*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -548,27 +231,39 @@
 as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
 
-exec 7<&0 </dev/null 6>&1
 
 # Name of the host.
 # hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
+exec 6>&1
+
 #
 # Initializations.
 #
 ac_default_prefix=/usr/local
-ac_clean_files=
 ac_config_libobj_dir=.
-LIBOBJS=
 cross_compiling=no
 subdirs=
 MFLAGS=
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
+# Maximum number of lines to put in a shell here document.
+# This variable seems obsolete.  It should probably be removed, and
+# only ac_max_sed_lines should be used.
+: ${ac_max_here_lines=38}
+
 # Identity of this package.
 PACKAGE_NAME='dosbox'
 PACKAGE_TARNAME='dosbox'
@@ -580,160 +275,42 @@
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
+#if HAVE_SYS_TYPES_H
 # include <sys/types.h>
 #endif
-#ifdef HAVE_SYS_STAT_H
+#if HAVE_SYS_STAT_H
 # include <sys/stat.h>
 #endif
-#ifdef STDC_HEADERS
+#if STDC_HEADERS
 # include <stdlib.h>
 # include <stddef.h>
 #else
-# ifdef HAVE_STDLIB_H
+# if HAVE_STDLIB_H
 #  include <stdlib.h>
 # endif
 #endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#if HAVE_STRING_H
+# if !STDC_HEADERS && HAVE_MEMORY_H
 #  include <memory.h>
 # endif
 # include <string.h>
 #endif
-#ifdef HAVE_STRINGS_H
+#if HAVE_STRINGS_H
 # include <strings.h>
 #endif
-#ifdef HAVE_INTTYPES_H
+#if HAVE_INTTYPES_H
 # include <inttypes.h>
+#else
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
 #endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
+#if HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-build
-build_cpu
-build_vendor
-build_os
-host
-host_cpu
-host_vendor
-host_os
-target
-target_cpu
-target_vendor
-target_os
-INSTALL_PROGRAM
-INSTALL_SCRIPT
-INSTALL_DATA
-am__isrc
-CYGPATH_W
-PACKAGE
-VERSION
-ACLOCAL
-AUTOCONF
-AUTOMAKE
-AUTOHEADER
-MAKEINFO
-install_sh
-STRIP
-INSTALL_STRIP_PROGRAM
-mkdir_p
-AWK
-SET_MAKE
-am__leading_dot
-AMTAR
-am__tar
-am__untar
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-DEPDIR
-am__include
-am__quote
-AMDEP_TRUE
-AMDEP_FALSE
-AMDEPBACKSLASH
-CCDEPMODE
-am__fastdepCC_TRUE
-am__fastdepCC_FALSE
-CPP
-CXX
-CXXFLAGS
-ac_ct_CXX
-CXXDEPMODE
-am__fastdepCXX_TRUE
-am__fastdepCXX_FALSE
-RANLIB
-SDL_CONFIG
-SDL_CFLAGS
-SDL_LIBS
-GREP
-EGREP
-ALSA_CFLAGS
-ALSA_LIBS
-WINDRES
-HAVE_WINDRES_TRUE
-HAVE_WINDRES_FALSE
-LIBOBJS
-LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE CPP CXX CXXFLAGS ac_ct_CXX CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE RANLIB ac_ct_RANLIB SDL_CONFIG SDL_CFLAGS SDL_LIBS EGREP ALSA_CFLAGS ALSA_LIBS FREETYPE_CONFIG CXXCPP WINDRES ac_ct_WINDRES HAVE_WINDRES_TRUE HAVE_WINDRES_FALSE LIBOBJS LTLIBOBJS'
 ac_subst_files=''
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CC
-CFLAGS
-LDFLAGS
-LIBS
-CPPFLAGS
-CPP
-CXX
-CXXFLAGS
-CCC'
-
 
 # Initialize some variables set by options.
 ac_init_help=
@@ -760,48 +337,34 @@
 # and all the variables that are supposed to be based on exec_prefix
 # by default will actually change.
 # Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
 bindir='${exec_prefix}/bin'
 sbindir='${exec_prefix}/sbin'
 libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
+datadir='${prefix}/share'
 sysconfdir='${prefix}/etc'
 sharedstatedir='${prefix}/com'
 localstatedir='${prefix}/var'
+libdir='${exec_prefix}/lib'
 includedir='${prefix}/include'
 oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
+infodir='${prefix}/info'
+mandir='${prefix}/man'
 
 ac_prev=
-ac_dashdash=
 for ac_option
 do
   # If the previous option needs an argument, assign it.
   if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
+    eval "$ac_prev=\$ac_option"
     ac_prev=
     continue
   fi
 
-  case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
-  esac
+  ac_optarg=`expr "x$ac_option" : 'x[^=]*=\(.*\)'`
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
 
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
+  case $ac_option in
 
   -bindir | --bindir | --bindi | --bind | --bin | --bi)
     ac_prev=bindir ;;
@@ -823,45 +386,33 @@
   --config-cache | -C)
     cache_file=config.cache ;;
 
-  -datadir | --datadir | --datadi | --datad)
+  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
     ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
+  | --da=*)
     datadir=$ac_optarg ;;
 
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
   -disable-* | --disable-*)
     ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
    { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
-    eval enable_$ac_feature=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    eval "enable_$ac_feature=no" ;;
 
   -enable-* | --enable-*)
     ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
       { echo "$as_me: error: invalid feature name: $ac_feature" >&2
    { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/[-.]/_/g'`
-    eval enable_$ac_feature=\$ac_optarg ;;
+    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "enable_$ac_feature='$ac_optarg'" ;;
 
   -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
   | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
@@ -888,12 +439,6 @@
   -host=* | --host=* | --hos=* | --ho=*)
     host_alias=$ac_optarg ;;
 
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
   -includedir | --includedir | --includedi | --included | --include \
   | --includ | --inclu | --incl | --inc)
     ac_prev=includedir ;;
@@ -918,16 +463,13 @@
   | --libexe=* | --libex=* | --libe=*)
     libexecdir=$ac_optarg ;;
 
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
   -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
+  | --localstate | --localstat | --localsta | --localst \
+  | --locals | --local | --loca | --loc | --lo)
     ac_prev=localstatedir ;;
   -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
+  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
     localstatedir=$ac_optarg ;;
 
   -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
@@ -992,16 +534,6 @@
   | --progr-tra=* | --program-tr=* | --program-t=*)
     program_transform_name=$ac_optarg ;;
 
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil)
     silent=yes ;;
@@ -1054,20 +586,24 @@
   -with-* | --with-*)
     ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
       { echo "$as_me: error: invalid package name: $ac_package" >&2
    { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
-    eval with_$ac_package=\$ac_optarg ;;
+    ac_package=`echo $ac_package| sed 's/-/_/g'`
+    case $ac_option in
+      *=*) ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`;;
+      *) ac_optarg=yes ;;
+    esac
+    eval "with_$ac_package='$ac_optarg'" ;;
 
   -without-* | --without-*)
     ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
       { echo "$as_me: error: invalid package name: $ac_package" >&2
    { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/[-.]/_/g'`
-    eval with_$ac_package=no ;;
+    ac_package=`echo $ac_package | sed 's/-/_/g'`
+    eval "with_$ac_package=no" ;;
 
   --x)
     # Obsolete; use --with-x.
@@ -1098,7 +634,8 @@
     expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
       { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
    { (exit 1); exit 1; }; }
-    eval $ac_envvar=\$ac_optarg
+    ac_optarg=`echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"`
+    eval "$ac_envvar='$ac_optarg'"
     export $ac_envvar ;;
 
   *)
@@ -1118,19 +655,27 @@
    { (exit 1); exit 1; }; }
 fi
 
-# Be sure to have absolute directory names.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
+# Be sure to have absolute paths.
+for ac_var in exec_prefix prefix
 do
-  eval ac_val=\$$ac_var
+  eval ac_val=$`echo $ac_var`
   case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+    [\\/$]* | ?:[\\/]* | NONE | '' ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
+  esac
+done
+
+# Be sure to have absolute paths.
+for ac_var in bindir sbindir libexecdir datadir sysconfdir sharedstatedir \
+	      localstatedir libdir includedir oldincludedir infodir mandir
+do
+  eval ac_val=$`echo $ac_var`
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* ) ;;
+    *)  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
+   { (exit 1); exit 1; }; };;
   esac
-  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; }
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1157,76 +702,86 @@
 test "$silent" = yes && exec 6>/dev/null
 
 
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { echo "$as_me: error: Working directory cannot be determined" >&2
-   { (exit 1); exit 1; }; }
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  { echo "$as_me: error: pwd does not report name of working directory" >&2
-   { (exit 1); exit 1; }; }
-
-
 # Find the source files, if location was not specified.
 if test -z "$srcdir"; then
   ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$0" ||
+  # Try the directory containing this script, then its parent.
+  ac_confdir=`(dirname "$0") 2>/dev/null ||
 $as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$0" : 'X\(//\)[^/]' \| \
 	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$0" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$0" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
   srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
+  if test ! -r $srcdir/$ac_unique_file; then
     srcdir=..
   fi
 else
   ac_srcdir_defaulted=no
 fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
-   { (exit 1); exit 1; }; }
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || { echo "$as_me: error: $ac_msg" >&2
-   { (exit 1); exit 1; }; }
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
+if test ! -r $srcdir/$ac_unique_file; then
+  if test "$ac_srcdir_defaulted" = yes; then
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $ac_confdir or .." >&2
+   { (exit 1); exit 1; }; }
+  else
+    { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
+   { (exit 1); exit 1; }; }
+  fi
+fi
+(cd $srcdir && test -r ./$ac_unique_file) 2>/dev/null ||
+  { echo "$as_me: error: sources are in $srcdir, but \`cd $srcdir' does not work" >&2
+   { (exit 1); exit 1; }; }
+srcdir=`echo "$srcdir" | sed 's%\([^\\/]\)[\\/]*$%\1%'`
+ac_env_build_alias_set=${build_alias+set}
+ac_env_build_alias_value=$build_alias
+ac_cv_env_build_alias_set=${build_alias+set}
+ac_cv_env_build_alias_value=$build_alias
+ac_env_host_alias_set=${host_alias+set}
+ac_env_host_alias_value=$host_alias
+ac_cv_env_host_alias_set=${host_alias+set}
+ac_cv_env_host_alias_value=$host_alias
+ac_env_target_alias_set=${target_alias+set}
+ac_env_target_alias_value=$target_alias
+ac_cv_env_target_alias_set=${target_alias+set}
+ac_cv_env_target_alias_value=$target_alias
+ac_env_CC_set=${CC+set}
+ac_env_CC_value=$CC
+ac_cv_env_CC_set=${CC+set}
+ac_cv_env_CC_value=$CC
+ac_env_CFLAGS_set=${CFLAGS+set}
+ac_env_CFLAGS_value=$CFLAGS
+ac_cv_env_CFLAGS_set=${CFLAGS+set}
+ac_cv_env_CFLAGS_value=$CFLAGS
+ac_env_LDFLAGS_set=${LDFLAGS+set}
+ac_env_LDFLAGS_value=$LDFLAGS
+ac_cv_env_LDFLAGS_set=${LDFLAGS+set}
+ac_cv_env_LDFLAGS_value=$LDFLAGS
+ac_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_env_CPPFLAGS_value=$CPPFLAGS
+ac_cv_env_CPPFLAGS_set=${CPPFLAGS+set}
+ac_cv_env_CPPFLAGS_value=$CPPFLAGS
+ac_env_CPP_set=${CPP+set}
+ac_env_CPP_value=$CPP
+ac_cv_env_CPP_set=${CPP+set}
+ac_cv_env_CPP_value=$CPP
+ac_env_CXX_set=${CXX+set}
+ac_env_CXX_value=$CXX
+ac_cv_env_CXX_set=${CXX+set}
+ac_cv_env_CXX_value=$CXX
+ac_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_env_CXXFLAGS_value=$CXXFLAGS
+ac_cv_env_CXXFLAGS_set=${CXXFLAGS+set}
+ac_cv_env_CXXFLAGS_value=$CXXFLAGS
+ac_env_CXXCPP_set=${CXXCPP+set}
+ac_env_CXXCPP_value=$CXXCPP
+ac_cv_env_CXXCPP_set=${CXXCPP+set}
+ac_cv_env_CXXCPP_value=$CXXCPP
 
 #
 # Report the --help message.
@@ -1255,6 +810,9 @@
   -n, --no-create         do not create output files
       --srcdir=DIR        find the sources in DIR [configure dir or \`..']
 
+_ACEOF
+
+  cat <<_ACEOF
 Installation directories:
   --prefix=PREFIX         install architecture-independent files in PREFIX
 			  [$ac_default_prefix]
@@ -1272,22 +830,15 @@
   --bindir=DIR           user executables [EPREFIX/bin]
   --sbindir=DIR          system admin executables [EPREFIX/sbin]
   --libexecdir=DIR       program executables [EPREFIX/libexec]
+  --datadir=DIR          read-only architecture-independent data [PREFIX/share]
   --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
   --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
   --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
   --libdir=DIR           object code libraries [EPREFIX/lib]
   --includedir=DIR       C header files [PREFIX/include]
   --oldincludedir=DIR    C header files for non-gcc [/usr/include]
-  --datarootdir=DIR      read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR          read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR          info documentation [DATAROOTDIR/info]
-  --localedir=DIR        locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR           man documentation [DATAROOTDIR/man]
-  --docdir=DIR           documentation root [DATAROOTDIR/doc/dosbox]
-  --htmldir=DIR          html documentation [DOCDIR]
-  --dvidir=DIR           dvi documentation [DOCDIR]
-  --pdfdir=DIR           pdf documentation [DOCDIR]
-  --psdir=DIR            ps documentation [DOCDIR]
+  --infodir=DIR          info documentation [PREFIX/info]
+  --mandir=DIR           man documentation [PREFIX/man]
 _ACEOF
 
   cat <<\_ACEOF
@@ -1327,7 +878,10 @@
   --disable-fpu-x86       Disable x86 assembly fpu core
   --disable-unaligned-memory
                           Disable unaligned memory access
+  --disable-printer       Disable printer support
   --disable-opengl        Disable opengl support
+  --disable-shaders       Disable d3d pixelshader support (which requires
+                          libd3dx9)
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
@@ -1336,103 +890,139 @@
   --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)
   --with-alsa-prefix=PFX  Prefix where Alsa library is installed(optional)
   --with-alsa-inc-prefix=PFX  Prefix where include libraries are (optional)
+  --with-dx-headers=DIR   DirectX include files location
+  --with-dx-libs=DIR      DirectX library location
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
-  LIBS        libraries to pass to the linker, e.g. -l<library>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
+  CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have
+              headers in a nonstandard directory <include dir>
   CPP         C preprocessor
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
+  CXXCPP      C++ preprocessor
 
 Use these variables to override the choices made by `configure' or to help
 it to find libraries and programs with nonstandard names/locations.
 
 _ACEOF
-ac_status=$?
 fi
 
 if test "$ac_init_help" = "recursive"; then
   # If there are subdirs, report their specific --help.
+  ac_popdir=`pwd`
   for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" || continue
+    test -d $ac_dir || continue
     ac_builddir=.
 
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
+if test "$ac_dir" != .; then
   ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
 
 case $srcdir in
-  .)  # We are building in place.
+  .)  # No --srcdir option.  We are building in place.
     ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
     ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
+
+    cd $ac_dir
+    # Check for guested configure; otherwise get Cygnus style configure.
+    if test -f $ac_srcdir/configure.gnu; then
+      echo
+      $SHELL $ac_srcdir/configure.gnu  --help=recursive
+    elif test -f $ac_srcdir/configure; then
+      echo
+      $SHELL $ac_srcdir/configure  --help=recursive
+    elif test -f $ac_srcdir/configure.ac ||
+	   test -f $ac_srcdir/configure.in; then
+      echo
+      $ac_configure --help
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
+    fi
+    cd $ac_popdir
   done
 fi
 
-test -n "$ac_init_help" && exit $ac_status
+test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
 dosbox configure 0.73
-generated by GNU Autoconf 2.61
+generated by GNU Autoconf 2.59
 
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
-  exit
+  exit 0
 fi
-cat >config.log <<_ACEOF
+exec 5>config.log
+cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by dosbox $as_me 0.73, which was
-generated by GNU Autoconf 2.61.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
-exec 5>>config.log
 {
 cat <<_ASUNAME
 ## --------- ##
@@ -1451,7 +1041,7 @@
 /bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
 /usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
 /usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+hostinfo               = `(hostinfo) 2>/dev/null               || echo unknown`
 /bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
 /usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
 /bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
@@ -1465,7 +1055,6 @@
   test -z "$as_dir" && as_dir=.
   echo "PATH: $as_dir"
 done
-IFS=$as_save_IFS
 
 } >&5
 
@@ -1487,6 +1076,7 @@
 ac_configure_args=
 ac_configure_args0=
 ac_configure_args1=
+ac_sep=
 ac_must_keep_next=false
 for ac_pass in 1 2
 do
@@ -1497,7 +1087,7 @@
     -q | -quiet | --quiet | --quie | --qui | --qu | --q \
     | -silent | --silent | --silen | --sile | --sil)
       continue ;;
-    *\'*)
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
       ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
     esac
     case $ac_pass in
@@ -1519,7 +1109,9 @@
 	  -* ) ac_must_keep_next=true ;;
 	esac
       fi
-      ac_configure_args="$ac_configure_args '$ac_arg'"
+      ac_configure_args="$ac_configure_args$ac_sep'$ac_arg'"
+      # Get rid of the leading space.
+      ac_sep=" "
       ;;
     esac
   done
@@ -1530,8 +1122,8 @@
 # When interrupted or exit'd, cleanup temporary files, and complete
 # config.log.  We remove comments because anyway the quotes in there
 # would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+# WARNING: Be sure not to use single quotes in there, as some shells,
+# such as our DU 5.0 friend, will then `close' the trap.
 trap 'exit_status=$?
   # Save into config.log some information that might help in debugging.
   {
@@ -1544,34 +1136,20 @@
 _ASBOX
     echo
     # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
+{
   (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
+    case `(ac_space='"'"' '"'"'; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
       sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
+	"s/'"'"'/'"'"'\\\\'"'"''"'"'/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='"'"'\\2'"'"'/p"
+      ;;
     *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
-    esac |
-    sort
-)
+    esac;
+}
     echo
 
     cat <<\_ASBOX
@@ -1582,28 +1160,22 @@
     echo
     for ac_var in $ac_subst_vars
     do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      echo "$ac_var='\''$ac_val'\''"
+      eval ac_val=$`echo $ac_var`
+      echo "$ac_var='"'"'$ac_val'"'"'"
     done | sort
     echo
 
     if test -n "$ac_subst_files"; then
       cat <<\_ASBOX
-## ------------------- ##
-## File substitutions. ##
-## ------------------- ##
+## ------------- ##
+## Output files. ##
+## ------------- ##
 _ASBOX
       echo
       for ac_var in $ac_subst_files
       do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	echo "$ac_var='\''$ac_val'\''"
+	eval ac_val=$`echo $ac_var`
+	echo "$ac_var='"'"'$ac_val'"'"'"
       done | sort
       echo
     fi
@@ -1615,24 +1187,26 @@
 ## ----------- ##
 _ASBOX
       echo
-      cat confdefs.h
+      sed "/^$/d" confdefs.h | sort
       echo
     fi
     test "$ac_signal" != 0 &&
       echo "$as_me: caught signal $ac_signal"
     echo "$as_me: exit $exit_status"
   } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+  rm -f core *.core &&
+  rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
     exit $exit_status
-' 0
+     ' 0
 for ac_signal in 1 2 13 15; do
   trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
 done
 ac_signal=0
 
 # confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
+rm -rf conftest* confdefs.h
+# AIX cpp loses on an empty file, so make sure it contains at least a newline.
+echo >confdefs.h
 
 # Predefined preprocessor variables.
 
@@ -1663,17 +1237,14 @@
 
 # Let the site file select an alternate cache file if it wants to.
 # Prefer explicitly selected file to automatically selected ones.
-if test -n "$CONFIG_SITE"; then
-  set x "$CONFIG_SITE"
-elif test "x$prefix" != xNONE; then
-  set x "$prefix/share/config.site" "$prefix/etc/config.site"
-else
-  set x "$ac_default_prefix/share/config.site" \
-	"$ac_default_prefix/etc/config.site"
+if test -z "$CONFIG_SITE"; then
+  if test "x$prefix" != xNONE; then
+    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
+  else
+    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
+  fi
 fi
-shift
-for ac_site_file
-do
+for ac_site_file in $CONFIG_SITE; do
   if test -r "$ac_site_file"; then
     { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
 echo "$as_me: loading site script $ac_site_file" >&6;}
@@ -1689,8 +1260,8 @@
     { echo "$as_me:$LINENO: loading cache $cache_file" >&5
 echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
+      [\\/]* | ?:[\\/]* ) . $cache_file;;
+      *)                      . ./$cache_file;;
     esac
   fi
 else
@@ -1702,11 +1273,12 @@
 # Check that the precious variables saved in the cache have kept the same
 # value.
 ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
+for ac_var in `(set) 2>&1 |
+	       sed -n 's/^ac_env_\([a-zA-Z_0-9]*\)_set=.*/\1/p'`; do
   eval ac_old_set=\$ac_cv_env_${ac_var}_set
   eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
+  eval ac_old_val="\$ac_cv_env_${ac_var}_value"
+  eval ac_new_val="\$ac_env_${ac_var}_value"
   case $ac_old_set,$ac_new_set in
     set,)
       { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
@@ -1731,7 +1303,8 @@
   # Pass precious variables to config.status.
   if test "$ac_new_set" = set; then
     case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?\"\']*)
+      ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
     *) ac_arg=$ac_var=$ac_new_val ;;
     esac
     case " $ac_configure_args " in
@@ -1748,6 +1321,12 @@
    { (exit 1); exit 1; }; }
 fi
 
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
 
 
 
@@ -1772,165 +1351,110 @@
 
 
 
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
 
 
 
 ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
+for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+  if test -f $ac_dir/install-sh; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/install-sh -c"
     break
-  elif test -f "$ac_dir/install.sh"; then
+  elif test -f $ac_dir/install.sh; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/install.sh -c"
     break
-  elif test -f "$ac_dir/shtool"; then
+  elif test -f $ac_dir/shtool; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/shtool install -c"
     break
   fi
 done
 if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
-echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
+  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
    { (exit 1); exit 1; }; }
 fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"
+ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
 
 # Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
+$ac_config_sub sun4 >/dev/null 2>&1 ||
+  { { echo "$as_me:$LINENO: error: cannot run $ac_config_sub" >&5
+echo "$as_me: error: cannot run $ac_config_sub" >&2;}
    { (exit 1); exit 1; }; }
 
-{ echo "$as_me:$LINENO: checking build system type" >&5
-echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking build system type" >&5
+echo $ECHO_N "checking build system type... $ECHO_C" >&6
 if test "${ac_cv_build+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
+  ac_cv_build_alias=$build_alias
+test -z "$ac_cv_build_alias" &&
+  ac_cv_build_alias=`$ac_config_guess`
+test -z "$ac_cv_build_alias" &&
   { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
 echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
    { (exit 1); exit 1; }; }
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
+ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_build_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed" >&2;}
    { (exit 1); exit 1; }; }
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-echo "${ECHO_T}$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
+echo "$as_me:$LINENO: result: $ac_cv_build" >&5
+echo "${ECHO_T}$ac_cv_build" >&6
 build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 
 
-{ echo "$as_me:$LINENO: checking host system type" >&5
-echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking host system type" >&5
+echo $ECHO_N "checking host system type... $ECHO_C" >&6
 if test "${ac_cv_host+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
+  ac_cv_host_alias=$host_alias
+test -z "$ac_cv_host_alias" &&
+  ac_cv_host_alias=$ac_cv_build_alias
+ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
    { (exit 1); exit 1; }; }
-fi
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
-echo "${ECHO_T}$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
+echo "$as_me:$LINENO: result: $ac_cv_host" >&5
+echo "${ECHO_T}$ac_cv_host" >&6
 host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 
 
-{ echo "$as_me:$LINENO: checking target system type" >&5
-echo $ECHO_N "checking target system type... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking target system type" >&5
+echo $ECHO_N "checking target system type... $ECHO_C" >&6
 if test "${ac_cv_target+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
-else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
+  ac_cv_target_alias=$target_alias
+test "x$ac_cv_target_alias" = "x" &&
+  ac_cv_target_alias=$ac_cv_host_alias
+ac_cv_target=`$ac_config_sub $ac_cv_target_alias` ||
+  { { echo "$as_me:$LINENO: error: $ac_config_sub $ac_cv_target_alias failed" >&5
+echo "$as_me: error: $ac_config_sub $ac_cv_target_alias failed" >&2;}
    { (exit 1); exit 1; }; }
-fi
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_target" >&5
-echo "${ECHO_T}$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
-echo "$as_me: error: invalid value of canonical target" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
+echo "$as_me:$LINENO: result: $ac_cv_target" >&5
+echo "${ECHO_T}$ac_cv_target" >&6
 target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
+target_cpu=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+target_vendor=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+target_os=`echo $ac_cv_target | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 
 
 # The aliases save the names the user supplied, while $host etc.
@@ -1940,8 +1464,7 @@
     NONENONEs,x,x, &&
   program_prefix=${target_alias}-
 
-am__api_version='1.10'
-
+am__api_version="1.9"
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
 # incompatible versions:
@@ -1955,8 +1478,8 @@
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
-{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
 if test -z "$INSTALL"; then
 if test "${ac_cv_path_install+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -1978,7 +1501,7 @@
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
 	  if test $ac_prog = install &&
 	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
 	    # AIX install.  It has an incompatible calling convention.
@@ -1997,22 +1520,21 @@
     ;;
 esac
 done
-IFS=$as_save_IFS
 
 
 fi
   if test "${ac_cv_path_install+set}" = set; then
     INSTALL=$ac_cv_path_install
   else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
     # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
+    # removed, or if the path is relative.
     INSTALL=$ac_install_sh
   fi
 fi
-{ echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6; }
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
 
 # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
 # It thinks the first close brace ends the variable substitution.
@@ -2022,8 +1544,8 @@
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
-{ echo "$as_me:$LINENO: checking whether build environment is sane" >&5
-echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether build environment is sane" >&5
+echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6
 # Just in case
 sleep 1
 echo timestamp > conftest.file
@@ -2065,20 +1587,20 @@
 Check your system clock" >&2;}
    { (exit 1); exit 1; }; }
 fi
-{ echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 test "$program_prefix" != NONE &&
-  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+  program_transform_name="s,^,$program_prefix,;$program_transform_name"
 # Use a double $ so make ignores it.
 test "$program_suffix" != NONE &&
-  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+  program_transform_name="s,\$,$program_suffix,;$program_transform_name"
 # Double any \ or $.  echo might interpret backslashes.
 # By default was `s,x,x', remove it if useless.
 cat <<\_ACEOF >conftest.sed
 s/[\\$]/&&/g;s/;s,x,x,$//
 _ACEOF
 program_transform_name=`echo $program_transform_name | sed -f conftest.sed`
-rm -f conftest.sed
+rm conftest.sed
 
 # expand $ac_aux_dir to an absolute path
 am_aux_dir=`cd $ac_aux_dir && pwd`
@@ -2093,60 +1615,45 @@
 echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
 fi
 
-{ echo "$as_me:$LINENO: checking for a thread-safe mkdir -p" >&5
-echo $ECHO_N "checking for a thread-safe mkdir -p... $ECHO_C" >&6; }
-if test -z "$MKDIR_P"; then
-  if test "${ac_cv_path_mkdir+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in mkdir gmkdir; do
-	 for ac_exec_ext in '' $ac_executable_extensions; do
-	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
-	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
-	     'mkdir (GNU coreutils) '* | \
-	     'mkdir (coreutils) '* | \
-	     'mkdir (fileutils) '4.1*)
-	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
-	       break 3;;
-	   esac
-	 done
-       done
-done
-IFS=$as_save_IFS
-
-fi
-
-  if test "${ac_cv_path_mkdir+set}" = set; then
-    MKDIR_P="$ac_cv_path_mkdir -p"
+if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
   else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for MKDIR_P within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    test -d ./--version && rmdir ./--version
-    MKDIR_P="$ac_install_sh -d"
+    mkdir_p='$(install_sh) -d'
   fi
 fi
-{ echo "$as_me:$LINENO: result: $MKDIR_P" >&5
-echo "${ECHO_T}$MKDIR_P" >&6; }
-
-mkdir_p="$MKDIR_P"
-case $mkdir_p in
-  [\\/$]* | ?:[\\/]*) ;;
-  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
-esac
 
 for ac_prog in gawk mawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_AWK+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2159,57 +1666,54 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_AWK="$ac_prog"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 AWK=$ac_cv_prog_AWK
 if test -n "$AWK"; then
-  { echo "$as_me:$LINENO: result: $AWK" >&5
-echo "${ECHO_T}$AWK" >&6; }
+  echo "$as_me:$LINENO: result: $AWK" >&5
+echo "${ECHO_T}$AWK" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
   test -n "$AWK" && break
 done
 
-{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
-set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
 all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
+	@echo 'ac_maketemp="$(MAKE)"'
 _ACEOF
 # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
 rm -f conftest.make
 fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
   SET_MAKE=
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
@@ -2222,16 +1726,12 @@
 fi
 rmdir .tst 2>/dev/null
 
-if test "`cd $srcdir && pwd`" != "`pwd`"; then
-  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
-  # is not polluted with repeated "-I."
-  am__isrc=' -I$(srcdir)'
-  # test to see if srcdir already configured
-  if test -f $srcdir/config.status; then
-    { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  { { echo "$as_me:$LINENO: error: source directory already configured; run \"make distclean\" there first" >&5
 echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
    { (exit 1); exit 1; }; }
-  fi
 fi
 
 # test whether we have cygpath
@@ -2274,7 +1774,7 @@
 
 MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
 
-install_sh=${install_sh-"\$(SHELL) $am_aux_dir/install-sh"}
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
 
 # Installed binaries are usually stripped using `strip' when the user
 # run `make install-strip'.  However `strip' might not be the right
@@ -2284,8 +1784,8 @@
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2298,34 +1798,32 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_STRIP="${ac_tool_prefix}strip"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 STRIP=$ac_cv_prog_STRIP
 if test -n "$STRIP"; then
-  { echo "$as_me:$LINENO: result: $STRIP" >&5
-echo "${ECHO_T}$STRIP" >&6; }
+  echo "$as_me:$LINENO: result: $STRIP" >&5
+echo "${ECHO_T}$STRIP" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
 fi
 if test -z "$ac_cv_prog_STRIP"; then
   ac_ct_STRIP=$STRIP
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2338,47 +1836,33 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_STRIP="strip"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
+  test -z "$ac_cv_prog_ac_ct_STRIP" && ac_cv_prog_ac_ct_STRIP=":"
 fi
 fi
 ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
 if test -n "$ac_ct_STRIP"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
-echo "${ECHO_T}$ac_ct_STRIP" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_STRIP" >&5
+echo "${ECHO_T}$ac_ct_STRIP" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-  if test "x$ac_ct_STRIP" = x; then
-    STRIP=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    STRIP=$ac_ct_STRIP
-  fi
+  STRIP=$ac_ct_STRIP
 else
   STRIP="$ac_cv_prog_STRIP"
 fi
 
 fi
-INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
 
 # We need awk for the "check" target.  The system "awk" is bad on
 # some platforms.
@@ -2392,36 +1876,35 @@
 
 
 
-ac_config_headers="$ac_config_headers config.h"
+          ac_config_headers="$ac_config_headers config.h"
 
 
-{ echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
-echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6; }
-set x ${MAKE-make}; ac_make=`echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+echo $ECHO_N "checking whether ${MAKE-make} sets \$(MAKE)... $ECHO_C" >&6
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,:./+-,___p_,'`
+if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.make <<\_ACEOF
-SHELL = /bin/sh
 all:
-	@echo '@@@%%%=$(MAKE)=@@@%%%'
+	@echo 'ac_maketemp="$(MAKE)"'
 _ACEOF
 # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-case `${MAKE-make} -f conftest.make 2>/dev/null` in
-  *@@@%%%=?*=@@@%%%*)
-    eval ac_cv_prog_make_${ac_make}_set=yes;;
-  *)
-    eval ac_cv_prog_make_${ac_make}_set=no;;
-esac
+eval `${MAKE-make} -f conftest.make 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
 rm -f conftest.make
 fi
-if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
   SET_MAKE=
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
@@ -2433,8 +1916,8 @@
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2447,34 +1930,32 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}gcc"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2487,51 +1968,36 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="gcc"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
+  CC=$ac_ct_CC
 else
   CC="$ac_cv_prog_CC"
 fi
 
 if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2544,34 +2010,74 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="${ac_tool_prefix}cc"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
+fi
+if test -z "$ac_cv_prog_CC"; then
+  ac_ct_CC=$CC
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_CC"; then
+  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_ac_ct_CC="cc"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
   fi
+done
+done
+
+fi
+fi
+ac_ct_CC=$ac_cv_prog_ac_ct_CC
+if test -n "$ac_ct_CC"; then
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  CC=$ac_ct_CC
+else
+  CC="$ac_cv_prog_CC"
+fi
+
 fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2585,7 +2091,7 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
        ac_prog_rejected=yes
        continue
@@ -2596,7 +2102,6 @@
   fi
 done
 done
-IFS=$as_save_IFS
 
 if test $ac_prog_rejected = yes; then
   # We found a bogon in the path, so make sure we never use it.
@@ -2614,23 +2119,22 @@
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
 fi
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
+  for ac_prog in cl
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2643,38 +2147,36 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
+  echo "$as_me:$LINENO: result: $CC" >&5
+echo "${ECHO_T}$CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
     test -n "$CC" && break
   done
 fi
 if test -z "$CC"; then
   ac_ct_CC=$CC
-  for ac_prog in cl.exe
+  for ac_prog in cl
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2687,45 +2189,29 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CC="$ac_prog"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
+echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
   test -n "$ac_ct_CC" && break
 done
 
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
+  CC=$ac_ct_CC
 fi
 
 fi
@@ -2738,35 +2224,21 @@
    { (exit 1); exit 1; }; }
 
 # Provide some information about the compiler.
-echo "$as_me:$LINENO: checking for C compiler version" >&5
+echo "$as_me:$LINENO:" \
+     "checking for C compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
@@ -2791,77 +2263,47 @@
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-{ echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
-echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-#
-# List of possible output files, starting from the most likely.
-# The algorithm is not robust to junk in `.', hence go to wildcards (a.*)
-# only as a last resort.  b.out is created by i960 compilers.
-ac_files='a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out'
-#
-# The IRIX 6 linker writes into existing files which may not be
-# executable, retaining their permissions.  Remove them first so a
-# subsequent execution test works.
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { (ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link_default") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
+  (eval $ac_link_default) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
+  # Find the output, starting from the most likely.  This scheme is
+# not robust to junk in `.', hence go to wildcards (a.*) only as a last
+# resort.
+
+# Be careful to initialize this variable, since it used to be cached.
+# Otherwise an old cache value of `no' led to `EXEEXT = no' in a Makefile.
+ac_cv_exeext=
+# b.out is created by i960 compilers.
+for ac_file in a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out
 do
   test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj )
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj )
+	;;
+    conftest.$ac_ext )
+	# This is the source file.
 	;;
     [ab].out )
 	# We found the default executable, but exeext='' is most
 	# certainly right.
 	break;;
     *.* )
-        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
+	ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	# FIXME: I believe we export ac_cv_exeext for Libtool,
+	# but it would be cool to find out if it's true.  Does anybody
+	# maintain Libtool? --akim.
+	export ac_cv_exeext
 	break;;
     * )
 	break;;
   esac
 done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
 else
-  ac_file=''
-fi
-
-{ echo "$as_me:$LINENO: result: $ac_file" >&5
-echo "${ECHO_T}$ac_file" >&6; }
-if test -z "$ac_file"; then
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
@@ -2873,21 +2315,19 @@
 fi
 
 ac_exeext=$ac_cv_exeext
+echo "$as_me:$LINENO: result: $ac_file" >&5
+echo "${ECHO_T}$ac_file" >&6
 
-# Check that the compiler produces executables we can run.  If not, either
+# Check the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether the C compiler works" >&5
-echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether the C compiler works" >&5
+echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
 # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
 # If not cross compiling, check that we can run a simple program.
 if test "$cross_compiling" != yes; then
   if { ac_try='./$ac_file'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -2906,27 +2346,22 @@
     fi
   fi
 fi
-{ echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 
 rm -f a.out a.exe conftest$ac_cv_exeext b.out
 ac_clean_files=$ac_clean_files_save
-# Check that the compiler produces executables we can run.  If not, either
+# Check the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
-echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6; }
-{ echo "$as_me:$LINENO: result: $cross_compiling" >&5
-echo "${ECHO_T}$cross_compiling" >&6; }
-
-{ echo "$as_me:$LINENO: checking for suffix of executables" >&5
-echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6; }
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
+echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
+echo "$as_me:$LINENO: result: $cross_compiling" >&5
+echo "${ECHO_T}$cross_compiling" >&6
+
+echo "$as_me:$LINENO: checking for suffix of executables" >&5
+echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
@@ -2937,8 +2372,9 @@
 for ac_file in conftest.exe conftest conftest.*; do
   test -f "$ac_file" || continue
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.o | *.obj ) ;;
     *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
+	  export ac_cv_exeext
 	  break;;
     * ) break;;
   esac
@@ -2952,14 +2388,14 @@
 fi
 
 rm -f conftest$ac_cv_exeext
-{ echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
-echo "${ECHO_T}$ac_cv_exeext" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
+echo "${ECHO_T}$ac_cv_exeext" >&6
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
 ac_exeext=$EXEEXT
-{ echo "$as_me:$LINENO: checking for suffix of object files" >&5
-echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for suffix of object files" >&5
+echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
 if test "${ac_cv_objext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -2979,20 +2415,14 @@
 }
 _ACEOF
 rm -f conftest.o conftest.obj
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
+  for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
   case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf ) ;;
+    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg ) ;;
     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
        break;;
   esac
@@ -3010,12 +2440,12 @@
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
-echo "${ECHO_T}$ac_cv_objext" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
+echo "${ECHO_T}$ac_cv_objext" >&6
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-{ echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
-echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -3038,49 +2468,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_compiler_gnu=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_compiler_gnu=no
+ac_compiler_gnu=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
-echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
 GCC=`test $ac_compiler_gnu = yes && echo yes`
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
-{ echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
-echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6; }
+CFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
+echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3096,118 +2527,38 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cc_g=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	CFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); }; }; then
   ac_cv_prog_cc_g=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_cv_prog_cc_g=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_g" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
@@ -3223,12 +2574,12 @@
     CFLAGS=
   fi
 fi
-{ echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
-echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
+echo "$as_me:$LINENO: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_cv_prog_cc_c89=no
+  ac_cv_prog_cc_stdc=no
 ac_save_CC=$CC
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -3262,17 +2613,12 @@
 /* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
    function prototypes and stuff, but not '\xHH' hex character constants.
    These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
+   as 'x'.  The following induces an error, until -std1 is added to get
    proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
    array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
+   that's true only with -std1.  */
 int osf4_cc_array ['\x00' == 0 ? 1 : -1];
 
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
 int test (int i, double x);
 struct s1 {int (*f) (int a);};
 struct s2 {int (*f) (double a);};
@@ -3287,76 +2633,224 @@
   return 0;
 }
 _ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
 do
   CC="$ac_save_CC $ac_arg"
   rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cc_c89=$ac_arg
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_prog_cc_stdc=$ac_arg
+break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
 fi
-
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
+rm -f conftest.err conftest.$ac_objext
 done
-rm -f conftest.$ac_ext
+rm -f conftest.$ac_ext conftest.$ac_objext
 CC=$ac_save_CC
 
 fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
-  xno)
-    { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:$LINENO: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
   *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
+    echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
 esac
 
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-DEPDIR="${am__leading_dot}deps"
-
-ac_config_commands="$ac_config_commands depfiles"
-
-
-am_make=${MAKE-make}
-cat > confinc << 'END'
-am__doit:
+# Some people use a C++ compiler to compile C.  Since we use `exit',
+# in C++ we need to declare it.  In case someone uses the same compiler
+# for both compiling C and C++ we need to have the C++ compiler decide
+# the declaration of exit, since it's the most demanding environment.
+cat >conftest.$ac_ext <<_ACEOF
+#ifndef __cplusplus
+  choke me
+#endif
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+#include <stdlib.h>
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_declaration
+int
+main ()
+{
+exit (42);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
+fi
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+DEPDIR="${am__leading_dot}deps"
+
+          ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
 	@echo done
 .PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
-{ echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
-echo $ECHO_N "checking for style of include used by $am_make... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
+echo $ECHO_N "checking for style of include used by $am_make... $ECHO_C" >&6
 am__include="#"
 am__quote=
 _am_result=none
@@ -3383,20 +2877,22 @@
 fi
 
 
-{ echo "$as_me:$LINENO: result: $_am_result" >&5
-echo "${ECHO_T}$_am_result" >&6; }
+echo "$as_me:$LINENO: result: $_am_result" >&5
+echo "${ECHO_T}$_am_result" >&6
 rm -f confinc confmf
 
-# Check whether --enable-dependency-tracking was given.
+# Check whether --enable-dependency-tracking or --disable-dependency-tracking was given.
 if test "${enable_dependency_tracking+set}" = set; then
-  enableval=$enable_dependency_tracking;
-fi
+  enableval="$enable_dependency_tracking"
 
+fi;
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
 fi
- if test "x$enable_dependency_tracking" != xno; then
+
+
+if test "x$enable_dependency_tracking" != xno; then
   AMDEP_TRUE=
   AMDEP_FALSE='#'
 else
@@ -3406,10 +2902,11 @@
 
 
 
+
 depcc="$CC"   am_compiler_list=
 
-{ echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
-echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6
 if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -3473,7 +2970,6 @@
        depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
        $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
@@ -3499,11 +2995,13 @@
 fi
 
 fi
-{ echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
-echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6; }
+echo "$as_me:$LINENO: result: $am_cv_CC_dependencies_compiler_type" >&5
+echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6
 CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
 
- if
+
+
+if
   test "x$enable_dependency_tracking" != xno \
   && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
   am__fastdepCC_TRUE=
@@ -3519,8 +3017,8 @@
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
-echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
+echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -3554,22 +3052,24 @@
 #endif
 		     Syntax error
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   :
 else
   echo "$as_me: failed program was:" >&5
@@ -3578,10 +3078,9 @@
   # Broken: fails on valid input.
 continue
 fi
-
 rm -f conftest.err conftest.$ac_ext
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
+  # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -3591,22 +3090,24 @@
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   # Broken: success on invalid input.
 continue
 else
@@ -3617,7 +3118,6 @@
 ac_preproc_ok=:
 break
 fi
-
 rm -f conftest.err conftest.$ac_ext
 
 done
@@ -3635,8 +3135,8 @@
 else
   ac_cv_prog_CPP=$CPP
 fi
-{ echo "$as_me:$LINENO: result: $CPP" >&5
-echo "${ECHO_T}$CPP" >&6; }
+echo "$as_me:$LINENO: result: $CPP" >&5
+echo "${ECHO_T}$CPP" >&6
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
@@ -3659,22 +3159,24 @@
 #endif
 		     Syntax error
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   :
 else
   echo "$as_me: failed program was:" >&5
@@ -3683,10 +3185,9 @@
   # Broken: fails on valid input.
 continue
 fi
-
 rm -f conftest.err conftest.$ac_ext
 
-  # OK, works on sane cases.  Now check whether nonexistent headers
+  # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -3696,22 +3197,24 @@
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   # Broken: success on invalid input.
 continue
 else
@@ -3722,7 +3225,6 @@
 ac_preproc_ok=:
 break
 fi
-
 rm -f conftest.err conftest.$ac_ext
 
 done
@@ -3744,22 +3246,18 @@
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-ac_ext=cpp
+ac_ext=cc
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-if test -z "$CXX"; then
-  if test -n "$CCC"; then
-    CXX=$CCC
-  else
-    if test -n "$ac_tool_prefix"; then
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+if test -n "$ac_tool_prefix"; then
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CXX+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -3772,38 +3270,36 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_CXX="$ac_tool_prefix$ac_prog"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 CXX=$ac_cv_prog_CXX
 if test -n "$CXX"; then
-  { echo "$as_me:$LINENO: result: $CXX" >&5
-echo "${ECHO_T}$CXX" >&6; }
+  echo "$as_me:$LINENO: result: $CXX" >&5
+echo "${ECHO_T}$CXX" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
     test -n "$CXX" && break
   done
 fi
 if test -z "$CXX"; then
   ac_ct_CXX=$CXX
-  for ac_prog in g++ c++ gpp aCC CC cxx cc++ cl.exe FCC KCC RCC xlC_r xlC
+  for ac_prog in $CCC g++ c++ gpp aCC CC cxx cc++ cl FCC KCC RCC xlC_r xlC
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CXX+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -3816,85 +3312,55 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_CXX="$ac_prog"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 ac_ct_CXX=$ac_cv_prog_ac_ct_CXX
 if test -n "$ac_ct_CXX"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
-echo "${ECHO_T}$ac_ct_CXX" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_CXX" >&5
+echo "${ECHO_T}$ac_ct_CXX" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
   test -n "$ac_ct_CXX" && break
 done
+test -n "$ac_ct_CXX" || ac_ct_CXX="g++"
 
-  if test "x$ac_ct_CXX" = x; then
-    CXX="g++"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    CXX=$ac_ct_CXX
-  fi
+  CXX=$ac_ct_CXX
 fi
 
-  fi
-fi
+
 # Provide some information about the compiler.
-echo "$as_me:$LINENO: checking for C++ compiler version" >&5
+echo "$as_me:$LINENO:" \
+     "checking for C++ compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
+  (eval $ac_compiler --version </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -v </dev/null >&5\"") >&5
+  (eval $ac_compiler -v </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
+{ (eval echo "$as_me:$LINENO: \"$ac_compiler -V </dev/null >&5\"") >&5
+  (eval $ac_compiler -V </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 
-{ echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
-echo $ECHO_N "checking whether we are using the GNU C++ compiler... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether we are using the GNU C++ compiler" >&5
+echo $ECHO_N "checking whether we are using the GNU C++ compiler... $ECHO_C" >&6
 if test "${ac_cv_cxx_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -3917,49 +3383,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_compiler_gnu=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_compiler_gnu=no
+ac_compiler_gnu=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_cxx_compiler_gnu=$ac_compiler_gnu
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
-echo "${ECHO_T}$ac_cv_cxx_compiler_gnu" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_cxx_compiler_gnu" >&5
+echo "${ECHO_T}$ac_cv_cxx_compiler_gnu" >&6
 GXX=`test $ac_compiler_gnu = yes && echo yes`
 ac_test_CXXFLAGS=${CXXFLAGS+set}
 ac_save_CXXFLAGS=$CXXFLAGS
-{ echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
-echo $ECHO_N "checking whether $CXX accepts -g... $ECHO_C" >&6; }
+CXXFLAGS="-g"
+echo "$as_me:$LINENO: checking whether $CXX accepts -g" >&5
+echo $ECHO_N "checking whether $CXX accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cxx_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_save_cxx_werror_flag=$ac_cxx_werror_flag
-   ac_cxx_werror_flag=yes
-   ac_cv_prog_cxx_g=no
-   CXXFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
@@ -3975,133 +3442,159 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_prog_cxx_g=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	CXXFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
+ac_cv_prog_cxx_g=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
+echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6
+if test "$ac_test_CXXFLAGS" = set; then
+  CXXFLAGS=$ac_save_CXXFLAGS
+elif test $ac_cv_prog_cxx_g = yes; then
+  if test "$GXX" = yes; then
+    CXXFLAGS="-g -O2"
+  else
+    CXXFLAGS="-g"
+  fi
+else
+  if test "$GXX" = yes; then
+    CXXFLAGS="-O2"
+  else
+    CXXFLAGS=
+  fi
+fi
+for ac_declaration in \
+   '' \
+   'extern "C" void std::exit (int) throw (); using std::exit;' \
+   'extern "C" void std::exit (int); using std::exit;' \
+   'extern "C" void exit (int) throw ();' \
+   'extern "C" void exit (int);' \
+   'void exit (int);'
+do
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-
+$ac_declaration
+#include <stdlib.h>
 int
 main ()
 {
-
+exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-	 CXXFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
+continue
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-
+$ac_declaration
 int
 main ()
 {
-
+exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_prog_cxx_g=yes
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+rm -f conftest*
+if test -n "$ac_declaration"; then
+  echo '#ifdef __cplusplus' >>confdefs.h
+  echo $ac_declaration      >>confdefs.h
+  echo '#endif'             >>confdefs.h
 fi
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_cxx_werror_flag=$ac_save_cxx_werror_flag
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_prog_cxx_g" >&5
-echo "${ECHO_T}$ac_cv_prog_cxx_g" >&6; }
-if test "$ac_test_CXXFLAGS" = set; then
-  CXXFLAGS=$ac_save_CXXFLAGS
-elif test $ac_cv_prog_cxx_g = yes; then
-  if test "$GXX" = yes; then
-    CXXFLAGS="-g -O2"
-  else
-    CXXFLAGS="-g"
-  fi
-else
-  if test "$GXX" = yes; then
-    CXXFLAGS="-O2"
-  else
-    CXXFLAGS=
-  fi
-fi
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -4110,8 +3603,8 @@
 
 depcc="$CXX"  am_compiler_list=
 
-{ echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
-echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking dependency style of $depcc" >&5
+echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6
 if test "${am_cv_CXX_dependencies_compiler_type+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4175,7 +3668,6 @@
        depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
        $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
        grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
@@ -4201,11 +3693,13 @@
 fi
 
 fi
-{ echo "$as_me:$LINENO: result: $am_cv_CXX_dependencies_compiler_type" >&5
-echo "${ECHO_T}$am_cv_CXX_dependencies_compiler_type" >&6; }
+echo "$as_me:$LINENO: result: $am_cv_CXX_dependencies_compiler_type" >&5
+echo "${ECHO_T}$am_cv_CXX_dependencies_compiler_type" >&6
 CXXDEPMODE=depmode=$am_cv_CXX_dependencies_compiler_type
 
- if
+
+
+if
   test "x$enable_dependency_tracking" != xno \
   && test "$am_cv_CXX_dependencies_compiler_type" = gcc3; then
   am__fastdepCXX_TRUE=
@@ -4229,8 +3723,8 @@
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
-{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
+echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
 if test -z "$INSTALL"; then
 if test "${ac_cv_path_install+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -4252,7 +3746,7 @@
     # by default.
     for ac_prog in ginstall scoinst install; do
       for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	if $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
 	  if test $ac_prog = install &&
 	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
 	    # AIX install.  It has an incompatible calling convention.
@@ -4271,22 +3765,21 @@
     ;;
 esac
 done
-IFS=$as_save_IFS
 
 
 fi
   if test "${ac_cv_path_install+set}" = set; then
     INSTALL=$ac_cv_path_install
   else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
+    # As a last resort, use the slow shell script.  We don't cache a
+    # path for INSTALL within a source directory, because that will
     # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
+    # removed, or if the path is relative.
     INSTALL=$ac_install_sh
   fi
 fi
-{ echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6; }
+echo "$as_me:$LINENO: result: $INSTALL" >&5
+echo "${ECHO_T}$INSTALL" >&6
 
 # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
 # It thinks the first close brace ends the variable substitution.
@@ -4299,8 +3792,8 @@
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_RANLIB+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4313,34 +3806,32 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  { echo "$as_me:$LINENO: result: $RANLIB" >&5
-echo "${ECHO_T}$RANLIB" >&6; }
+  echo "$as_me:$LINENO: result: $RANLIB" >&5
+echo "${ECHO_T}$RANLIB" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
 fi
 if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4353,41 +3844,27 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_RANLIB="ranlib"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
+  test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
 fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
-echo "${ECHO_T}$ac_ct_RANLIB" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_RANLIB" >&5
+echo "${ECHO_T}$ac_ct_RANLIB" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-  if test "x$ac_ct_RANLIB" = x; then
-    RANLIB=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    RANLIB=$ac_ct_RANLIB
-  fi
+  RANLIB=$ac_ct_RANLIB
 else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
@@ -4402,28 +3879,28 @@
 SDL_VERSION=1.2.0
 
 
-# Check whether --with-sdl-prefix was given.
+# Check whether --with-sdl-prefix or --without-sdl-prefix was given.
 if test "${with_sdl_prefix+set}" = set; then
-  withval=$with_sdl_prefix; sdl_prefix="$withval"
+  withval="$with_sdl_prefix"
+  sdl_prefix="$withval"
 else
   sdl_prefix=""
-fi
-
+fi;
 
-# Check whether --with-sdl-exec-prefix was given.
+# Check whether --with-sdl-exec-prefix or --without-sdl-exec-prefix was given.
 if test "${with_sdl_exec_prefix+set}" = set; then
-  withval=$with_sdl_exec_prefix; sdl_exec_prefix="$withval"
+  withval="$with_sdl_exec_prefix"
+  sdl_exec_prefix="$withval"
 else
   sdl_exec_prefix=""
-fi
-
-# Check whether --enable-sdltest was given.
+fi;
+# Check whether --enable-sdltest or --disable-sdltest was given.
 if test "${enable_sdltest+set}" = set; then
-  enableval=$enable_sdltest;
+  enableval="$enable_sdltest"
+
 else
   enable_sdltest=yes
-fi
-
+fi;
 
   if test x$sdl_exec_prefix != x ; then
      sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
@@ -4440,8 +3917,8 @@
 
   # Extract the first word of "sdl-config", so it can be a program name with args.
 set dummy sdl-config; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_path_SDL_CONFIG+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4456,32 +3933,31 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_path_SDL_CONFIG="$as_dir/$ac_word$ac_exec_ext"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
   test -z "$ac_cv_path_SDL_CONFIG" && ac_cv_path_SDL_CONFIG="no"
   ;;
 esac
 fi
 SDL_CONFIG=$ac_cv_path_SDL_CONFIG
+
 if test -n "$SDL_CONFIG"; then
-  { echo "$as_me:$LINENO: result: $SDL_CONFIG" >&5
-echo "${ECHO_T}$SDL_CONFIG" >&6; }
+  echo "$as_me:$LINENO: result: $SDL_CONFIG" >&5
+echo "${ECHO_T}$SDL_CONFIG" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
   min_sdl_version=$SDL_VERSION
-  { echo "$as_me:$LINENO: checking for SDL - version >= $min_sdl_version" >&5
-echo $ECHO_N "checking for SDL - version >= $min_sdl_version... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for SDL - version >= $min_sdl_version" >&5
+echo $ECHO_N "checking for SDL - version >= $min_sdl_version... $ECHO_C" >&6
   no_sdl=""
   if test "$SDL_CONFIG" = "no" ; then
     no_sdl=yes
@@ -4570,22 +4046,13 @@
 
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4598,21 +4065,19 @@
 ( exit $ac_status )
 no_sdl=yes
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-
-
        CFLAGS="$ac_save_CFLAGS"
        LIBS="$ac_save_LIBS"
      fi
   fi
   if test "x$no_sdl" = x ; then
-     { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+     echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
      :
   else
-     { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+     echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
      if test "$SDL_CONFIG" = "no" ; then
        echo "*** The sdl-config script installed by SDL could not be found"
        echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
@@ -4644,23 +4109,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
    echo "*** The test program compiled, but did not run. This usually means"
           echo "*** that the run-time linker is not finding SDL or finding the wrong"
           echo "*** version of SDL. If it is not finding SDL, you'll need to set your"
@@ -4674,13 +4143,12 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	 echo "*** The test program failed to compile or link. See the file config.log for the"
+ echo "*** The test program failed to compile or link. See the file config.log for the"
           echo "*** exact error that occured. This usually means SDL was incorrectly installed"
           echo "*** or that you have moved SDL since it was installed. In the latter case, you"
           echo "*** may want to edit the sdl-config script: $SDL_CONFIG"
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
           CFLAGS="$ac_save_CFLAGS"
           LIBS="$ac_save_LIBS"
@@ -4700,8 +4168,8 @@
 LIBS="$LIBS $SDL_LIBS"
 CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
 
-{ echo "$as_me:$LINENO: checking SDL version only being 1.2.X" >&5
-echo $ECHO_N "checking SDL version only being 1.2.X... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking SDL version only being 1.2.X" >&5
+echo $ECHO_N "checking SDL version only being 1.2.X... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 
 #include "SDL.h"
@@ -4714,41 +4182,45 @@
 
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 
- { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+ echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
  { { echo "$as_me:$LINENO: error: Only libSDL 1.2.X supported" >&5
 echo "$as_me: error: Only libSDL 1.2.X supported" >&2;}
    { (exit 1); exit 1; }; }
 fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
-
-{ echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
-echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
 if test "${ac_cv_c_const+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4766,10 +4238,10 @@
 #ifndef __cplusplus
   /* Ultrix mips cc rejects this.  */
   typedef int charset[2];
-  const charset cs;
+  const charset x;
   /* SunOS 4.1.1 cc rejects this.  */
-  char const *const *pcpcc;
-  char **ppc;
+  char const *const *ccp;
+  char **p;
   /* NEC SVR4.0.2 mips cc rejects this.  */
   struct point {int x, y;};
   static struct point const zero = {0,0};
@@ -4778,17 +4250,16 @@
      an arm of an if-expression whose if-part is not a constant
      expression */
   const char *g = "string";
-  pcpcc = &g + (g ? g-g : 0);
+  ccp = &g + (g ? g-g : 0);
   /* HPUX 7.0 cc rejects these. */
-  ++pcpcc;
-  ppc = (char**) pcpcc;
-  pcpcc = (char const *const *) ppc;
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
   { /* SCO 3.2v4 cc rejects this.  */
     char *t;
     char const *s = 0 ? (char *) 0 : (char const *) 0;
 
     *t++ = 0;
-    if (s) return 0;
   }
   { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
     int x[] = {25, 17};
@@ -4807,9 +4278,7 @@
   }
   { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
     const int foo = 10;
-    if (!foo) return 0;
   }
-  return !cs[0] && !zero.x;
 #endif
 
   ;
@@ -4817,34 +4286,38 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_const=yes
-else
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_const=yes
+else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_c_const=no
+ac_cv_c_const=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
-echo "${ECHO_T}$ac_cv_c_const" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
 if test $ac_cv_c_const = no; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -4853,8 +4326,8 @@
 
 fi
 
-{ echo "$as_me:$LINENO: checking for inline" >&5
-echo $ECHO_N "checking for inline... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
 if test "${ac_cv_c_inline+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -4874,37 +4347,39 @@
 
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_cv_c_inline=$ac_kw
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  test "$ac_cv_c_inline" != no && break
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
-echo "${ECHO_T}$ac_cv_c_inline" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
 
 
 case $ac_cv_c_inline in
@@ -4923,170 +4398,23 @@
 esac
 
 
-{ echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
-echo $ECHO_N "checking for grep that handles long lines and -e... $ECHO_C" >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  # Extract the first word of "grep ggrep" to use in msg output
-if test -z "$GREP"; then
-set dummy grep ggrep; ac_prog_name=$2
-if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_path_GREP_found=false
-# Loop through the user's path and test for each of PROGNAME-LIST
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in grep ggrep; do
-  for ac_exec_ext in '' $ac_executable_extensions; do
-    ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-    { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
-    # Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-
-    $ac_path_GREP_found && break 3
-  done
-done
-
-done
-IFS=$as_save_IFS
-
-
-fi
-
-GREP="$ac_cv_path_GREP"
-if test -z "$GREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
-echo "${ECHO_T}$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     # Extract the first word of "egrep" to use in msg output
-if test -z "$EGREP"; then
-set dummy egrep; ac_prog_name=$2
-if test "${ac_cv_path_EGREP+set}" = set; then
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_path_EGREP_found=false
-# Loop through the user's path and test for each of PROGNAME-LIST
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in egrep; do
-  for ac_exec_ext in '' $ac_executable_extensions; do
-    ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-    { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
-    # Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
     fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-
-    $ac_path_EGREP_found && break 3
-  done
-done
-
-done
-IFS=$as_save_IFS
-
-
-fi
-
-EGREP="$ac_cv_path_EGREP"
-if test -z "$EGREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-
-   fi
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
-echo "${ECHO_T}$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
 
 
-{ echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
 if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -5110,31 +4438,35 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_header_stdc=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_header_stdc=no
+ac_cv_header_stdc=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
@@ -5190,7 +4522,6 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <ctype.h>
-#include <stdlib.h>
 #if ((' ' & 0x0FF) == 0x020)
 # define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 # define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
@@ -5210,27 +4541,18 @@
   for (i = 0; i < 256; i++)
     if (XOR (islower (i), ISLOWER (i))
 	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
+      exit(2);
+  exit (0);
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5243,14 +4565,12 @@
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-
-
 fi
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
 if test $ac_cv_header_stdc = yes; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -5273,9 +4593,9 @@
 		  inttypes.h stdint.h unistd.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -5289,35 +4609,38 @@
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_Header=no"
+eval "$as_ac_Header=no"
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -5328,8 +4651,8 @@
 done
 
 
-{ echo "$as_me:$LINENO: checking for size_t" >&5
-echo $ECHO_N "checking for size_t... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6
 if test "${ac_cv_type_size_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -5340,59 +4663,62 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef size_t ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((size_t *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (size_t))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_size_t=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_size_t=no
+ac_cv_type_size_t=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
-echo "${ECHO_T}$ac_cv_type_size_t" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6
 if test $ac_cv_type_size_t = yes; then
   :
 else
 
 cat >>confdefs.h <<_ACEOF
-#define size_t unsigned int
+#define size_t unsigned
 _ACEOF
 
 fi
 
-{ echo "$as_me:$LINENO: checking whether struct tm is in sys/time.h or time.h" >&5
-echo $ECHO_N "checking whether struct tm is in sys/time.h or time.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether struct tm is in sys/time.h or time.h" >&5
+echo $ECHO_N "checking whether struct tm is in sys/time.h or time.h... $ECHO_C" >&6
 if test "${ac_cv_struct_tm+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -5408,42 +4734,44 @@
 int
 main ()
 {
-struct tm tm;
-				     int *p = &tm.tm_sec;
- 				     return !p;
+struct tm *tp; tp->tm_sec;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_struct_tm=time.h
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_struct_tm=sys/time.h
+ac_cv_struct_tm=sys/time.h
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_struct_tm" >&5
-echo "${ECHO_T}$ac_cv_struct_tm" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_struct_tm" >&5
+echo "${ECHO_T}$ac_cv_struct_tm" >&6
 if test $ac_cv_struct_tm = sys/time.h; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -5452,8 +4780,8 @@
 
 fi
 
-{ echo "$as_me:$LINENO: checking for unsigned char" >&5
-echo $ECHO_N "checking for unsigned char... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for unsigned char" >&5
+echo $ECHO_N "checking for unsigned char... $ECHO_C" >&6
 if test "${ac_cv_type_unsigned_char+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -5464,57 +4792,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef unsigned char ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((unsigned char *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (unsigned char))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_unsigned_char=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_unsigned_char=no
+ac_cv_type_unsigned_char=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_char" >&5
-echo "${ECHO_T}$ac_cv_type_unsigned_char" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_char" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_char" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of unsigned char" >&5
-echo $ECHO_N "checking size of unsigned char... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of unsigned char" >&5
+echo $ECHO_N "checking size of unsigned char... $ECHO_C" >&6
 if test "${ac_cv_sizeof_unsigned_char+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_unsigned_char" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -5524,11 +4856,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned char))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -5536,22 +4867,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -5561,11 +4897,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned char))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -5573,53 +4908,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned char))) < 0)];
 test_array [0] = 0
 
   ;
@@ -5627,22 +4965,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -5652,11 +4995,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned char))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -5664,48 +5006,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -5716,11 +5060,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned char))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -5728,45 +5071,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_unsigned_char=$ac_lo;;
-'') if test "$ac_cv_type_unsigned_char" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned char)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned char), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned char)
+echo "$as_me: error: cannot compute sizeof (unsigned char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_char=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -5774,9 +5124,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned char ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (unsigned char)); }
+unsigned long ulongval () { return (long) (sizeof (unsigned char)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -5785,44 +5134,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (unsigned char))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (unsigned char))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (unsigned char))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5833,32 +5173,29 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_unsigned_char" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned char)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned char), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned char)
+echo "$as_me: error: cannot compute sizeof (unsigned char), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_char=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_unsigned_char=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_char" >&5
-echo "${ECHO_T}$ac_cv_sizeof_unsigned_char" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_char" >&5
+echo "${ECHO_T}$ac_cv_sizeof_unsigned_char" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_UNSIGNED_CHAR $ac_cv_sizeof_unsigned_char
 _ACEOF
 
 
-{ echo "$as_me:$LINENO: checking for unsigned short" >&5
-echo $ECHO_N "checking for unsigned short... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for unsigned short" >&5
+echo $ECHO_N "checking for unsigned short... $ECHO_C" >&6
 if test "${ac_cv_type_unsigned_short+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -5869,57 +5206,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef unsigned short ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((unsigned short *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (unsigned short))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_unsigned_short=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_unsigned_short=no
+ac_cv_type_unsigned_short=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_short" >&5
-echo "${ECHO_T}$ac_cv_type_unsigned_short" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_short" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_short" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of unsigned short" >&5
-echo $ECHO_N "checking size of unsigned short... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of unsigned short" >&5
+echo $ECHO_N "checking size of unsigned short... $ECHO_C" >&6
 if test "${ac_cv_sizeof_unsigned_short+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_unsigned_short" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -5929,11 +5270,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned short))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -5941,22 +5281,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -5966,11 +5311,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned short))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -5978,53 +5322,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned short))) < 0)];
 test_array [0] = 0
 
   ;
@@ -6032,22 +5379,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -6057,11 +5409,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned short))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6069,48 +5420,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -6121,11 +5474,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned short))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6133,45 +5485,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_unsigned_short=$ac_lo;;
-'') if test "$ac_cv_type_unsigned_short" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned short)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned short), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned short)
+echo "$as_me: error: cannot compute sizeof (unsigned short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_short=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -6179,9 +5538,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned short ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (unsigned short)); }
+unsigned long ulongval () { return (long) (sizeof (unsigned short)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -6190,44 +5548,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (unsigned short))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (unsigned short))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (unsigned short))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6238,32 +5587,29 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_unsigned_short" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned short)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned short), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned short)
+echo "$as_me: error: cannot compute sizeof (unsigned short), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_short=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_unsigned_short=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_short" >&5
-echo "${ECHO_T}$ac_cv_sizeof_unsigned_short" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_short" >&5
+echo "${ECHO_T}$ac_cv_sizeof_unsigned_short" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_UNSIGNED_SHORT $ac_cv_sizeof_unsigned_short
 _ACEOF
 
 
-{ echo "$as_me:$LINENO: checking for unsigned int" >&5
-echo $ECHO_N "checking for unsigned int... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for unsigned int" >&5
+echo $ECHO_N "checking for unsigned int... $ECHO_C" >&6
 if test "${ac_cv_type_unsigned_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -6274,57 +5620,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef unsigned int ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((unsigned int *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (unsigned int))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_unsigned_int=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_unsigned_int=no
+ac_cv_type_unsigned_int=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_int" >&5
-echo "${ECHO_T}$ac_cv_type_unsigned_int" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_int" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_int" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of unsigned int" >&5
-echo $ECHO_N "checking size of unsigned int... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of unsigned int" >&5
+echo $ECHO_N "checking size of unsigned int... $ECHO_C" >&6
 if test "${ac_cv_sizeof_unsigned_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_unsigned_int" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -6334,11 +5684,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned int))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -6346,22 +5695,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -6371,11 +5725,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned int))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6383,53 +5736,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  ac_hi=$ac_mid; break
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned int))) < 0)];
 test_array [0] = 0
 
   ;
@@ -6437,22 +5793,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -6462,11 +5823,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned int))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6474,48 +5834,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -6526,11 +5888,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned int))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6538,45 +5899,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_unsigned_int=$ac_lo;;
-'') if test "$ac_cv_type_unsigned_int" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned int)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned int), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned int)
+echo "$as_me: error: cannot compute sizeof (unsigned int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_int=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -6584,9 +5952,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned int ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (unsigned int)); }
+unsigned long ulongval () { return (long) (sizeof (unsigned int)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -6595,44 +5962,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (unsigned int))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (unsigned int))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (unsigned int))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6643,32 +6001,29 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_unsigned_int" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned int)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned int), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned int)
+echo "$as_me: error: cannot compute sizeof (unsigned int), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_int=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_unsigned_int=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_int" >&5
-echo "${ECHO_T}$ac_cv_sizeof_unsigned_int" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_int" >&5
+echo "${ECHO_T}$ac_cv_sizeof_unsigned_int" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_UNSIGNED_INT $ac_cv_sizeof_unsigned_int
 _ACEOF
 
 
-{ echo "$as_me:$LINENO: checking for unsigned long" >&5
-echo $ECHO_N "checking for unsigned long... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for unsigned long" >&5
+echo $ECHO_N "checking for unsigned long... $ECHO_C" >&6
 if test "${ac_cv_type_unsigned_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -6679,57 +6034,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef unsigned long ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((unsigned long *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (unsigned long))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_unsigned_long=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_unsigned_long=no
+ac_cv_type_unsigned_long=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_long" >&5
-echo "${ECHO_T}$ac_cv_type_unsigned_long" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_long" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_long" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of unsigned long" >&5
-echo $ECHO_N "checking size of unsigned long... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of unsigned long" >&5
+echo $ECHO_N "checking size of unsigned long... $ECHO_C" >&6
 if test "${ac_cv_sizeof_unsigned_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_unsigned_long" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -6739,11 +6098,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -6751,22 +6109,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -6776,11 +6139,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6788,53 +6150,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long))) < 0)];
 test_array [0] = 0
 
   ;
@@ -6842,22 +6207,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -6867,11 +6237,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6879,48 +6248,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -6931,11 +6302,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -6943,45 +6313,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_unsigned_long=$ac_lo;;
-'') if test "$ac_cv_type_unsigned_long" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned long)
+echo "$as_me: error: cannot compute sizeof (unsigned long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_long=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -6989,9 +6366,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (unsigned long)); }
+unsigned long ulongval () { return (long) (sizeof (unsigned long)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -7000,44 +6376,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (unsigned long))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (unsigned long))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (unsigned long))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7048,32 +6415,29 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_unsigned_long" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned long)
+echo "$as_me: error: cannot compute sizeof (unsigned long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_long=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_unsigned_long=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_long" >&5
-echo "${ECHO_T}$ac_cv_sizeof_unsigned_long" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_long" >&5
+echo "${ECHO_T}$ac_cv_sizeof_unsigned_long" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_UNSIGNED_LONG $ac_cv_sizeof_unsigned_long
 _ACEOF
 
 
-{ echo "$as_me:$LINENO: checking for unsigned long long" >&5
-echo $ECHO_N "checking for unsigned long long... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for unsigned long long" >&5
+echo $ECHO_N "checking for unsigned long long... $ECHO_C" >&6
 if test "${ac_cv_type_unsigned_long_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -7084,57 +6448,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef unsigned long long ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((unsigned long long *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (unsigned long long))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_unsigned_long_long=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_unsigned_long_long=no
+ac_cv_type_unsigned_long_long=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_long_long" >&5
-echo "${ECHO_T}$ac_cv_type_unsigned_long_long" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_long_long" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_long_long" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of unsigned long long" >&5
-echo $ECHO_N "checking size of unsigned long long... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of unsigned long long" >&5
+echo $ECHO_N "checking size of unsigned long long... $ECHO_C" >&6
 if test "${ac_cv_sizeof_unsigned_long_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_unsigned_long_long" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -7144,11 +6512,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long long))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -7156,22 +6523,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -7181,11 +6553,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long long))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7193,53 +6564,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long long))) < 0)];
 test_array [0] = 0
 
   ;
@@ -7247,22 +6621,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -7272,11 +6651,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long long))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7284,48 +6662,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -7336,11 +6716,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (unsigned long long))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7348,45 +6727,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_unsigned_long_long=$ac_lo;;
-'') if test "$ac_cv_type_unsigned_long_long" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long long)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long long), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned long long)
+echo "$as_me: error: cannot compute sizeof (unsigned long long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_long_long=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -7394,9 +6780,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef unsigned long long ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (unsigned long long)); }
+unsigned long ulongval () { return (long) (sizeof (unsigned long long)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -7405,44 +6790,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (unsigned long long))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (unsigned long long))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (unsigned long long))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7453,32 +6829,29 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_unsigned_long_long" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long long)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (unsigned long long), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (unsigned long long)
+echo "$as_me: error: cannot compute sizeof (unsigned long long), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_unsigned_long_long=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_unsigned_long_long=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_long_long" >&5
-echo "${ECHO_T}$ac_cv_sizeof_unsigned_long_long" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_unsigned_long_long" >&5
+echo "${ECHO_T}$ac_cv_sizeof_unsigned_long_long" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_UNSIGNED_LONG_LONG $ac_cv_sizeof_unsigned_long_long
 _ACEOF
 
 
-{ echo "$as_me:$LINENO: checking for int *" >&5
-echo $ECHO_N "checking for int *... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for int *" >&5
+echo $ECHO_N "checking for int *... $ECHO_C" >&6
 if test "${ac_cv_type_int_p+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -7489,57 +6862,61 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-typedef int * ac__type_new_;
 int
 main ()
 {
-if ((ac__type_new_ *) 0)
+if ((int * *) 0)
   return 0;
-if (sizeof (ac__type_new_))
+if (sizeof (int *))
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_type_int_p=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_type_int_p=no
+ac_cv_type_int_p=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_int_p" >&5
-echo "${ECHO_T}$ac_cv_type_int_p" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_type_int_p" >&5
+echo "${ECHO_T}$ac_cv_type_int_p" >&6
 
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of int *" >&5
-echo $ECHO_N "checking size of int *... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking size of int *" >&5
+echo $ECHO_N "checking size of int *... $ECHO_C" >&6
 if test "${ac_cv_sizeof_int_p+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$ac_cv_type_int_p" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
@@ -7549,11 +6926,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (int *))) >= 0)];
 test_array [0] = 0
 
   ;
@@ -7561,22 +6937,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -7586,11 +6967,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (int *))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7598,53 +6978,56 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_lo=`expr $ac_mid + 1`
+		    if test $ac_lo -le $ac_mid; then
+		      ac_lo= ac_hi=
+		      break
+		    fi
+		    ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	cat >conftest.$ac_ext <<_ACEOF
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+static int test_array [1 - 2 * !(((long) (sizeof (int *))) < 0)];
 test_array [0] = 0
 
   ;
@@ -7652,22 +7035,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
@@ -7677,11 +7065,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (int *))) >= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7689,48 +7076,50 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_lo=$ac_mid; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
+ac_hi=`expr '(' $ac_mid ')' - 1`
+		       if test $ac_mid -le $ac_hi; then
+			 ac_lo= ac_hi=
+			 break
+		       fi
+		       ac_mid=`expr 2 '*' $ac_mid`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo= ac_hi=
+ac_lo= ac_hi=
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
@@ -7741,11 +7130,10 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
 int
 main ()
 {
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+static int test_array [1 - 2 * !(((long) (sizeof (int *))) <= $ac_mid)];
 test_array [0] = 0
 
   ;
@@ -7753,45 +7141,52 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_hi=$ac_mid
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_lo=`expr '(' $ac_mid ')' + 1`
+ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int_p=$ac_lo;;
-'') if test "$ac_cv_type_int_p" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (int *)
+'') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int *), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (int *)
+echo "$as_me: error: cannot compute sizeof (int *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_int_p=0
-   fi ;;
+   { (exit 1); exit 1; }; } ;;
 esac
 else
+  if test "$cross_compiling" = yes; then
+  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot run test program while cross compiling
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -7799,9 +7194,8 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-   typedef int * ac__type_sizeof_;
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+long longval () { return (long) (sizeof (int *)); }
+unsigned long ulongval () { return (long) (sizeof (int *)); }
 #include <stdio.h>
 #include <stdlib.h>
 int
@@ -7810,44 +7204,35 @@
 
   FILE *f = fopen ("conftest.val", "w");
   if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    exit (1);
+  if (((long) (sizeof (int *))) < 0)
     {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      long i = longval ();
+      if (i != ((long) (sizeof (int *))))
+	exit (1);
       fprintf (f, "%ld\n", i);
     }
   else
     {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
+      unsigned long i = ulongval ();
+      if (i != ((long) (sizeof (int *))))
+	exit (1);
       fprintf (f, "%lu\n", i);
     }
-  return ferror (f) || fclose (f) != 0;
+  exit (ferror (f) || fclose (f) != 0);
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7858,25 +7243,22 @@
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-if test "$ac_cv_type_int_p" = yes; then
-     { { echo "$as_me:$LINENO: error: cannot compute sizeof (int *)
+{ { echo "$as_me:$LINENO: error: cannot compute sizeof (int *), 77
 See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (int *)
+echo "$as_me: error: cannot compute sizeof (int *), 77
 See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-   else
-     ac_cv_sizeof_int_p=0
-   fi
+   { (exit 1); exit 1; }; }
+fi
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 rm -f conftest.val
+else
+  ac_cv_sizeof_int_p=0
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_int_p" >&5
-echo "${ECHO_T}$ac_cv_sizeof_int_p" >&6; }
-
-
-
+fi
+echo "$as_me:$LINENO: result: $ac_cv_sizeof_int_p" >&5
+echo "${ECHO_T}$ac_cv_sizeof_int_p" >&6
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_INT_P $ac_cv_sizeof_int_p
 _ACEOF
@@ -7888,19 +7270,18 @@
 for ac_header in stdlib.h sys/types.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -7911,37 +7292,41 @@
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -7950,22 +7335,24 @@
 /* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -7973,10 +7360,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -8000,19 +7386,25 @@
 echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   eval "$as_ac_Header=\$ac_header_preproc"
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 
 fi
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
@@ -8030,9 +7422,9 @@
 for ac_header in sys/socket.h  netinet/in.h pwd.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
@@ -8058,35 +7450,38 @@
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	eval "$as_ac_Header=no"
+eval "$as_ac_Header=no"
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -8117,22 +7512,27 @@
 
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: failed program was:" >&5
@@ -8144,11 +7544,10 @@
 _ACEOF
 
 fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-{ echo "$as_me:$LINENO: checking if environ can be included" >&5
-echo $ECHO_N "checking if environ can be included... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if environ can be included" >&5
+echo $ECHO_N "checking if environ can be included... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -8167,25 +7566,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;
 cat >>confdefs.h <<\_ACEOF
 #define ENVIRON_INCLUDED 1
 _ACEOF
@@ -8194,15 +7597,14 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 
-{ echo "$as_me:$LINENO: checking if environ can be linked" >&5
-echo $ECHO_N "checking if environ can be linked... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if environ can be linked" >&5
+echo $ECHO_N "checking if environ can be linked... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -8219,25 +7621,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;
 cat >>confdefs.h <<\_ACEOF
 #define ENVIRON_LINKED 1
 _ACEOF
@@ -8246,15 +7652,14 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 
-{ echo "$as_me:$LINENO: checking if dirent includes d_type" >&5
-echo $ECHO_N "checking if dirent includes d_type... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if dirent includes d_type" >&5
+echo $ECHO_N "checking if dirent includes d_type... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 
 #include <sys/types.h>
@@ -8265,24 +7670,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;
 cat >>confdefs.h <<\_ACEOF
 #define DIRENT_HAS_D_TYPE 1
 _ACEOF
@@ -8291,15 +7701,14 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
-{ echo "$as_me:$LINENO: checking for powf in libm" >&5
-echo $ECHO_N "checking for powf in libm... $ECHO_C" >&6; };
+echo "$as_me:$LINENO: checking for powf in libm" >&5
+echo $ECHO_N "checking for powf in libm... $ECHO_C" >&6;
 LIBS_BACKUP=$LIBS;
 LIBS="$LIBS -lm";
 cat >conftest.$ac_ext <<_ACEOF
@@ -8320,25 +7729,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
@@ -8349,8 +7762,7 @@
 _ACEOF
 
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$LIBS_BACKUP
 
@@ -8359,8 +7771,8 @@
 #Check if the compiler support attributes
 
 
-{ echo "$as_me:$LINENO: checking if compiler allows __attribute__" >&5
-echo $ECHO_N "checking if compiler allows __attribute__... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if compiler allows __attribute__" >&5
+echo $ECHO_N "checking if compiler allows __attribute__... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -8378,24 +7790,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-   { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };cat >>confdefs.h <<\_ACEOF
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+   echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;cat >>confdefs.h <<\_ACEOF
 #define C_HAS_ATTRIBUTE 1
 _ACEOF
 
@@ -8403,11 +7820,10 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
 #Check if the compiler supports certain attributes
@@ -8416,31 +7832,36 @@
 
 
 
-{ echo "$as_me:$LINENO: checking if compiler allows __attribute__((always_inline)) " >&5
-echo $ECHO_N "checking if compiler allows __attribute__((always_inline)) ... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if compiler allows __attribute__((always_inline)) " >&5
+echo $ECHO_N "checking if compiler allows __attribute__((always_inline)) ... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
  void __attribute__((always_inline)) test(){}
 
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-   { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };cat >>confdefs.h <<\_ACEOF
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+   echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;cat >>confdefs.h <<\_ACEOF
 #define C_ATTRIBUTE_ALWAYS_INLINE 1
 _ACEOF
 
@@ -8448,39 +7869,43 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
-
-{ echo "$as_me:$LINENO: checking if compiler allows __attribute__((fastcall)) " >&5
-echo $ECHO_N "checking if compiler allows __attribute__((fastcall)) ... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if compiler allows __attribute__((fastcall)) " >&5
+echo $ECHO_N "checking if compiler allows __attribute__((fastcall)) ... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
  void __attribute__((fastcall)) test(){}
 
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-   { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };cat >>confdefs.h <<\_ACEOF
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+   echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;cat >>confdefs.h <<\_ACEOF
 #define C_ATTRIBUTE_FASTCALL 1
 _ACEOF
 
@@ -8488,11 +7913,10 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 
 CFLAGS="$OLDCFLAGS"
@@ -8500,7 +7924,7 @@
 
 #Check if the compiler supports __builtin_expect
 #Switch language to c++
-ac_ext=cpp
+ac_ext=cc
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
@@ -8508,8 +7932,8 @@
 
 
 
-{ echo "$as_me:$LINENO: checking if compiler allows __builtin_expect" >&5
-echo $ECHO_N "checking if compiler allows __builtin_expect... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking if compiler allows __builtin_expect" >&5
+echo $ECHO_N "checking if compiler allows __builtin_expect... $ECHO_C" >&6
 
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -8529,24 +7953,29 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_cxx_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-   { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };cat >>confdefs.h <<\_ACEOF
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+   echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;cat >>confdefs.h <<\_ACEOF
 #define C_HAS_BUILTIN_EXPECT 1
 _ACEOF
 
@@ -8554,11 +7983,10 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 #switch language back
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -8567,16 +7995,16 @@
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-# Check whether --enable-alsa-midi was given.
+# Check whether --enable-alsa-midi or --disable-alsa-midi was given.
 if test "${enable_alsa_midi+set}" = set; then
-  enableval=$enable_alsa_midi;  case "${enableval}" in
+  enableval="$enable_alsa_midi"
+   case "${enableval}" in
  yes) alsa_midi=true;;
  no)  alsa_midi=false;;
 esac
 else
   alsa_midi=true
-fi
-
+fi;
 if test x$alsa_midi = xtrue ; then
   alsa_save_CFLAGS="$CFLAGS"
 alsa_save_LDFLAGS="$LDFLAGS"
@@ -8584,42 +8012,42 @@
 alsa_found=yes
 
 
-# Check whether --with-alsa-prefix was given.
+# Check whether --with-alsa-prefix or --without-alsa-prefix was given.
 if test "${with_alsa_prefix+set}" = set; then
-  withval=$with_alsa_prefix; alsa_prefix="$withval"
+  withval="$with_alsa_prefix"
+  alsa_prefix="$withval"
 else
   alsa_prefix=""
-fi
+fi;
 
 
-
-# Check whether --with-alsa-inc-prefix was given.
+# Check whether --with-alsa-inc-prefix or --without-alsa-inc-prefix was given.
 if test "${with_alsa_inc_prefix+set}" = set; then
-  withval=$with_alsa_inc_prefix; alsa_inc_prefix="$withval"
+  withval="$with_alsa_inc_prefix"
+  alsa_inc_prefix="$withval"
 else
   alsa_inc_prefix=""
-fi
+fi;
 
-
-# Check whether --enable-alsatest was given.
+# Check whether --enable-alsatest or --disable-alsatest was given.
 if test "${enable_alsatest+set}" = set; then
-  enableval=$enable_alsatest; enable_alsatest=no
+  enableval="$enable_alsatest"
+  enable_alsatest=no
 else
   enable_alsatest=yes
-fi
+fi;
 
-
-{ echo "$as_me:$LINENO: checking for ALSA CFLAGS" >&5
-echo $ECHO_N "checking for ALSA CFLAGS... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for ALSA CFLAGS" >&5
+echo $ECHO_N "checking for ALSA CFLAGS... $ECHO_C" >&6
 if test "$alsa_inc_prefix" != "" ; then
 	ALSA_CFLAGS="$ALSA_CFLAGS -I$alsa_inc_prefix"
 	CFLAGS="$CFLAGS -I$alsa_inc_prefix"
 fi
-{ echo "$as_me:$LINENO: result: $ALSA_CFLAGS" >&5
-echo "${ECHO_T}$ALSA_CFLAGS" >&6; }
+echo "$as_me:$LINENO: result: $ALSA_CFLAGS" >&5
+echo "${ECHO_T}$ALSA_CFLAGS" >&6
 
-{ echo "$as_me:$LINENO: checking for ALSA LDFLAGS" >&5
-echo $ECHO_N "checking for ALSA LDFLAGS... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for ALSA LDFLAGS" >&5
+echo $ECHO_N "checking for ALSA LDFLAGS... $ECHO_C" >&6
 if test "$alsa_prefix" != "" ; then
 	ALSA_LIBS="$ALSA_LIBS -L$alsa_prefix"
 	LDFLAGS="$LDFLAGS $ALSA_LIBS"
@@ -8631,12 +8059,12 @@
 LIBS=`echo $LIBS | sed 's/-lpthread//'`
 LIBS=`echo $LIBS | sed 's/  //'`
 LIBS="$ALSA_LIBS $LIBS"
-{ echo "$as_me:$LINENO: result: $ALSA_LIBS" >&5
-echo "${ECHO_T}$ALSA_LIBS" >&6; }
+echo "$as_me:$LINENO: result: $ALSA_LIBS" >&5
+echo "${ECHO_T}$ALSA_LIBS" >&6
 
 min_alsa_version=0.9.0
-{ echo "$as_me:$LINENO: checking for libasound headers version >= $min_alsa_version" >&5
-echo $ECHO_N "checking for libasound headers version >= $min_alsa_version... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for libasound headers version >= $min_alsa_version" >&5
+echo $ECHO_N "checking for libasound headers version >= $min_alsa_version... $ECHO_C" >&6
 no_alsa=""
     alsa_min_major_version=`echo $min_alsa_version | \
            sed 's/\([0-9]*\).\([0-9]*\).\([0-9]*\)/\1/'`
@@ -8646,6 +8074,7 @@
            sed 's/\([0-9]*\).\([0-9]*\).\([0-9]*\)/\3/'`
 
 
+
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -8702,36 +8131,40 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
-  { echo "$as_me:$LINENO: result: found." >&5
-echo "${ECHO_T}found." >&6; }
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: found." >&5
+echo "${ECHO_T}found." >&6
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: not present." >&5
-echo "${ECHO_T}not present." >&6; }
+echo "$as_me:$LINENO: result: not present." >&5
+echo "${ECHO_T}not present." >&6
 
    alsa_found=no
 
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
@@ -8740,8 +8173,8 @@
 
 
 
-{ echo "$as_me:$LINENO: checking for snd_ctl_open in -lasound" >&5
-echo $ECHO_N "checking for snd_ctl_open in -lasound... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for snd_ctl_open in -lasound" >&5
+echo $ECHO_N "checking for snd_ctl_open in -lasound... $ECHO_C" >&6
 if test "${ac_cv_lib_asound_snd_ctl_open+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -8754,53 +8187,56 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char snd_ctl_open ();
 int
 main ()
 {
-return snd_ctl_open ();
+snd_ctl_open ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_asound_snd_ctl_open=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_asound_snd_ctl_open=no
+ac_cv_lib_asound_snd_ctl_open=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_asound_snd_ctl_open" >&5
-echo "${ECHO_T}$ac_cv_lib_asound_snd_ctl_open" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_asound_snd_ctl_open" >&5
+echo "${ECHO_T}$ac_cv_lib_asound_snd_ctl_open" >&6
 if test $ac_cv_lib_asound_snd_ctl_open = yes; then
   cat >>confdefs.h <<_ACEOF
 #define HAVE_LIBASOUND 1
@@ -8841,8 +8277,8 @@
 fi
 
 #Check for big endian machine, should #define WORDS_BIGENDIAN if so
-{ echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
-echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
+echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
 if test "${ac_cv_c_bigendian+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -8859,8 +8295,7 @@
 int
 main ()
 {
-#if  ! (defined BYTE_ORDER && defined BIG_ENDIAN && defined LITTLE_ENDIAN \
-	&& BYTE_ORDER && BIG_ENDIAN && LITTLE_ENDIAN)
+#if !BYTE_ORDER || !BIG_ENDIAN || !LITTLE_ENDIAN
  bogus endian macros
 #endif
 
@@ -8869,22 +8304,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -8907,36 +8347,40 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_c_bigendian=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_c_bigendian=no
+ac_cv_c_bigendian=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	# It does not; compile a test program.
+# It does not; compile a test program.
 if test "$cross_compiling" = yes; then
   # try to guess the endianness by grepping values into an object file
   ac_cv_c_bigendian=unknown
@@ -8946,11 +8390,11 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-short int ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
-short int ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
+short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
+short ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
 void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
-short int ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
-short int ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
+short ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
+short ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
 void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
 int
 main ()
@@ -8961,22 +8405,27 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
   ac_cv_c_bigendian=yes
 fi
@@ -8992,10 +8441,8 @@
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -9003,41 +8450,27 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
 int
 main ()
 {
-
   /* Are we little or big endian?  From Harbison&Steele.  */
   union
   {
-    long int l;
-    char c[sizeof (long int)];
+    long l;
+    char c[sizeof (long)];
   } u;
   u.l = 1;
-  return u.c[sizeof (long int) - 1] == 1;
-
-  ;
-  return 0;
+  exit (u.c[sizeof (long) - 1] == 1);
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -9050,16 +8483,13 @@
 ( exit $ac_status )
 ac_cv_c_bigendian=yes
 fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-
-
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
-echo "${ECHO_T}$ac_cv_c_bigendian" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
+echo "${ECHO_T}$ac_cv_c_bigendian" >&6
 case $ac_cv_c_bigendian in
   yes)
 
@@ -9083,21 +8513,22 @@
 
 
 
-# Check whether --enable-debug was given.
+# Check whether --enable-debug or --disable-debug was given.
 if test "${enable_debug+set}" = set; then
-  enableval=$enable_debug;
+  enableval="$enable_debug"
+
    if test "${ac_cv_header_curses_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for curses.h" >&5
-echo $ECHO_N "checking for curses.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for curses.h" >&5
+echo $ECHO_N "checking for curses.h... $ECHO_C" >&6
 if test "${ac_cv_header_curses_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_curses_h" >&5
-echo "${ECHO_T}$ac_cv_header_curses_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_curses_h" >&5
+echo "${ECHO_T}$ac_cv_header_curses_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking curses.h usability" >&5
-echo $ECHO_N "checking curses.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking curses.h usability" >&5
+echo $ECHO_N "checking curses.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9108,37 +8539,41 @@
 #include <curses.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking curses.h presence" >&5
-echo $ECHO_N "checking curses.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking curses.h presence" >&5
+echo $ECHO_N "checking curses.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9147,22 +8582,24 @@
 /* end confdefs.h.  */
 #include <curses.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -9170,10 +8607,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -9197,18 +8633,25 @@
 echo "$as_me: WARNING: curses.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: curses.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: curses.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for curses.h" >&5
-echo $ECHO_N "checking for curses.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for curses.h" >&5
+echo $ECHO_N "checking for curses.h... $ECHO_C" >&6
 if test "${ac_cv_header_curses_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_curses_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_curses_h" >&5
-echo "${ECHO_T}$ac_cv_header_curses_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_curses_h" >&5
+echo "${ECHO_T}$ac_cv_header_curses_h" >&6
 
 fi
 if test $ac_cv_header_curses_h = yes; then
@@ -9216,8 +8659,8 @@
 fi
 
 
-   { echo "$as_me:$LINENO: checking for initscr in -lcurses" >&5
-echo $ECHO_N "checking for initscr in -lcurses... $ECHO_C" >&6; }
+   echo "$as_me:$LINENO: checking for initscr in -lcurses" >&5
+echo $ECHO_N "checking for initscr in -lcurses... $ECHO_C" >&6
 if test "${ac_cv_lib_curses_initscr+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -9230,59 +8673,62 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char initscr ();
 int
 main ()
 {
-return initscr ();
+initscr ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_curses_initscr=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_curses_initscr=no
+ac_cv_lib_curses_initscr=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_curses_initscr" >&5
-echo "${ECHO_T}$ac_cv_lib_curses_initscr" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_curses_initscr" >&5
+echo "${ECHO_T}$ac_cv_lib_curses_initscr" >&6
 if test $ac_cv_lib_curses_initscr = yes; then
   have_curses_lib=yes
 fi
 
-   { echo "$as_me:$LINENO: checking for initscr in -lncurses" >&5
-echo $ECHO_N "checking for initscr in -lncurses... $ECHO_C" >&6; }
+   echo "$as_me:$LINENO: checking for initscr in -lncurses" >&5
+echo $ECHO_N "checking for initscr in -lncurses... $ECHO_C" >&6
 if test "${ac_cv_lib_ncurses_initscr+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -9295,59 +8741,62 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char initscr ();
 int
 main ()
 {
-return initscr ();
+initscr ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_ncurses_initscr=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_ncurses_initscr=no
+ac_cv_lib_ncurses_initscr=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_ncurses_initscr" >&5
-echo "${ECHO_T}$ac_cv_lib_ncurses_initscr" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_ncurses_initscr" >&5
+echo "${ECHO_T}$ac_cv_lib_ncurses_initscr" >&6
 if test $ac_cv_lib_ncurses_initscr = yes; then
   have_ncurses_lib=yes
 fi
 
-   { echo "$as_me:$LINENO: checking for initscr in -lpdcurses" >&5
-echo $ECHO_N "checking for initscr in -lpdcurses... $ECHO_C" >&6; }
+   echo "$as_me:$LINENO: checking for initscr in -lpdcurses" >&5
+echo $ECHO_N "checking for initscr in -lpdcurses... $ECHO_C" >&6
 if test "${ac_cv_lib_pdcurses_initscr+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -9360,61 +8809,64 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char initscr ();
 int
 main ()
 {
-return initscr ();
+initscr ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_pdcurses_initscr=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_pdcurses_initscr=no
+ac_cv_lib_pdcurses_initscr=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_pdcurses_initscr" >&5
-echo "${ECHO_T}$ac_cv_lib_pdcurses_initscr" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_pdcurses_initscr" >&5
+echo "${ECHO_T}$ac_cv_lib_pdcurses_initscr" >&6
 if test $ac_cv_lib_pdcurses_initscr = yes; then
   have_pdcurses_lib=yes
 fi
 
 
    if test x$enable_debug = xno; then
-     { echo "$as_me:$LINENO: result: Debugger not enabled" >&5
-echo "${ECHO_T}Debugger not enabled" >&6; }
+     echo "$as_me:$LINENO: result: Debugger not enabled" >&5
+echo "${ECHO_T}Debugger not enabled" >&6
    elif test x$have_curses_lib = xyes -a x$have_curses_h = xyes ; then
      LIBS="$LIBS -lcurses"
      cat >>confdefs.h <<\_ACEOF
@@ -9457,39 +8909,38 @@
    { (exit 1); exit 1; }; }
    fi
 
-fi
-
+fi;
 
 
 
-# Check whether --enable-core-inline was given.
+# Check whether --enable-core-inline or --disable-core-inline was given.
 if test "${enable_core_inline+set}" = set; then
-  enableval=$enable_core_inline;
+  enableval="$enable_core_inline"
+
   if test x$enable_core_inline = xyes ; then
-    { echo "$as_me:$LINENO: result: enabling inlined memory handling in CPU Core" >&5
-echo "${ECHO_T}enabling inlined memory handling in CPU Core" >&6; }
+    echo "$as_me:$LINENO: result: enabling inlined memory handling in CPU Core" >&5
+echo "${ECHO_T}enabling inlined memory handling in CPU Core" >&6
     cat >>confdefs.h <<\_ACEOF
 #define C_CORE_INLINE 1
 _ACEOF
 
   fi
 
-fi
-
+fi;
 
 
 
 
-{ echo "$as_me:$LINENO: checking for target cpu type" >&5
-echo $ECHO_N "checking for target cpu type... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for target cpu type" >&5
+echo $ECHO_N "checking for target cpu type... $ECHO_C" >&6
 case "$target_cpu" in
   x86_64 | amd64)
     cat >>confdefs.h <<\_ACEOF
 #define C_TARGETCPU X86_64
 _ACEOF
 
-    { echo "$as_me:$LINENO: result: x86-64 bit compatible" >&5
-echo "${ECHO_T}x86-64 bit compatible" >&6; }
+    echo "$as_me:$LINENO: result: x86-64 bit compatible" >&5
+echo "${ECHO_T}x86-64 bit compatible" >&6
     c_targetcpu="x86_64"
     c_unalignedmemory=yes
     ;;
@@ -9498,8 +8949,8 @@
 #define C_TARGETCPU X86
 _ACEOF
 
-    { echo "$as_me:$LINENO: result: x86 compatible" >&5
-echo "${ECHO_T}x86 compatible" >&6; }
+    echo "$as_me:$LINENO: result: x86 compatible" >&5
+echo "${ECHO_T}x86 compatible" >&6
     c_targetcpu="x86"
     c_unalignedmemory=yes
     ;;
@@ -9508,8 +8959,8 @@
 #define C_TARGETCPU POWERPC
 _ACEOF
 
-    { echo "$as_me:$LINENO: result: Power PC" >&5
-echo "${ECHO_T}Power PC" >&6; }
+    echo "$as_me:$LINENO: result: Power PC" >&5
+echo "${ECHO_T}Power PC" >&6
     c_targetcpu="powerpc"
     c_unalignedmemory=yes
     ;;
@@ -9518,8 +8969,8 @@
 #define C_TARGETCPU M68K
 _ACEOF
 
-    { echo "$as_me:$LINENO: result: Motorola 68000" >&5
-echo "${ECHO_T}Motorola 68000" >&6; }
+    echo "$as_me:$LINENO: result: Motorola 68000" >&5
+echo "${ECHO_T}Motorola 68000" >&6
     c_targetcpu="m68k"
     c_unalignedmemory=yes
     ;;
@@ -9528,62 +8979,62 @@
 #define C_TARGETCPU UNKNOWN
 _ACEOF
 
-    { echo "$as_me:$LINENO: result: unknown" >&5
-echo "${ECHO_T}unknown" >&6; }
+    echo "$as_me:$LINENO: result: unknown" >&5
+echo "${ECHO_T}unknown" >&6
     c_unalignedmemory=no
     ;;
 esac
 
-# Check whether --enable-dynamic-core was given.
+# Check whether --enable-dynamic-core or --disable-dynamic-core was given.
 if test "${enable_dynamic_core+set}" = set; then
-  enableval=$enable_dynamic_core;
+  enableval="$enable_dynamic_core"
+
 else
   enable_dynamic_core=yes
-fi
+fi;
 
 
 
-
-# Check whether --enable-dynamic-x86 was given.
+# Check whether --enable-dynamic-x86 or --disable-dynamic-x86 was given.
 if test "${enable_dynamic_x86+set}" = set; then
-  enableval=$enable_dynamic_x86;
+  enableval="$enable_dynamic_x86"
+
 else
   enable_dynamic_x86=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether x86 dynamic cpu core will be enabled" >&5
-echo $ECHO_N "checking whether x86 dynamic cpu core will be enabled... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether x86 dynamic cpu core will be enabled" >&5
+echo $ECHO_N "checking whether x86 dynamic cpu core will be enabled... $ECHO_C" >&6
 if test x$enable_dynamic_x86 = xno -o x$enable_dynamic_core = xno; then
-   { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+   echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 else
   if test x$c_targetcpu = xx86 ; then
       cat >>confdefs.h <<\_ACEOF
 #define C_DYNAMIC_X86 1
 _ACEOF
 
-      { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+      echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
   else
-      { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+      echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
   fi
 fi
 
 
 
-# Check whether --enable-dynrec was given.
+# Check whether --enable-dynrec or --disable-dynrec was given.
 if test "${enable_dynrec+set}" = set; then
-  enableval=$enable_dynrec;
+  enableval="$enable_dynrec"
+
 else
   enable_dynrec=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether recompiling cpu core will be enabled" >&5
-echo $ECHO_N "checking whether recompiling cpu core will be enabled... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether recompiling cpu core will be enabled" >&5
+echo $ECHO_N "checking whether recompiling cpu core will be enabled... $ECHO_C" >&6
 if test x$enable_dynrec = xno -o x$enable_dynamic_core = xno; then
-   { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+   echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 else
   if test x$c_targetcpu = xx86 ; then
     if test x$enable_dynamic_x86 = xno ; then
@@ -9591,11 +9042,11 @@
 #define C_DYNREC 1
 _ACEOF
 
-        { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+        echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
     else
-        { echo "$as_me:$LINENO: result: no, using dynamic-x86" >&5
-echo "${ECHO_T}no, using dynamic-x86" >&6; }
+        echo "$as_me:$LINENO: result: no, using dynamic-x86" >&5
+echo "${ECHO_T}no, using dynamic-x86" >&6
     fi
   else
     if test x$c_targetcpu = xx86_64 ; then
@@ -9603,52 +9054,52 @@
 #define C_DYNREC 1
 _ACEOF
 
-        { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+        echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
     else
-      { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+      echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
     fi
   fi
 fi
 
 
 
-# Check whether --enable-fpu was given.
+# Check whether --enable-fpu or --disable-fpu was given.
 if test "${enable_fpu+set}" = set; then
-  enableval=$enable_fpu;
+  enableval="$enable_fpu"
+
 else
   enable_fpu=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether fpu emulation will be enabled" >&5
-echo $ECHO_N "checking whether fpu emulation will be enabled... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether fpu emulation will be enabled" >&5
+echo $ECHO_N "checking whether fpu emulation will be enabled... $ECHO_C" >&6
 if test x$enable_fpu = xyes ; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
   cat >>confdefs.h <<\_ACEOF
 #define C_FPU 1
 _ACEOF
 
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
 
 
-# Check whether --enable-fpu-x86 was given.
+# Check whether --enable-fpu-x86 or --disable-fpu-x86 was given.
 if test "${enable_fpu_x86+set}" = set; then
-  enableval=$enable_fpu_x86;
+  enableval="$enable_fpu_x86"
+
 else
   enable_fpu_x86=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether x86 assembly fpu core will be enabled" >&5
-echo $ECHO_N "checking whether x86 assembly fpu core will be enabled... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether x86 assembly fpu core will be enabled" >&5
+echo $ECHO_N "checking whether x86 assembly fpu core will be enabled... $ECHO_C" >&6
 if test x$enable_fpu_x86 = xno ; then
-   { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+   echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 else
   if test x$enable_fpu = xyes; then
     if test x$c_targetcpu = xx86 ; then
@@ -9656,55 +9107,57 @@
 #define C_FPU_X86 1
 _ACEOF
 
-        { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+        echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
     else
-        { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+        echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
     fi
   else
-      { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+      echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
   fi
 fi
 
 
 
-# Check whether --enable-unaligned_memory was given.
+# Check whether --enable-unaligned_memory or --disable-unaligned_memory was given.
 if test "${enable_unaligned_memory+set}" = set; then
-  enableval=$enable_unaligned_memory;
+  enableval="$enable_unaligned_memory"
+
 else
   enable_unaligned_memory=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether to enable unaligned memory access" >&5
-echo $ECHO_N "checking whether to enable unaligned memory access... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether to enable unaligned memory access" >&5
+echo $ECHO_N "checking whether to enable unaligned memory access... $ECHO_C" >&6
 if test x$enable_unaligned_memory = xyes -a x$c_unalignedmemory = xyes; then
   cat >>confdefs.h <<\_ACEOF
 #define C_UNALIGNED_MEMORY 1
 _ACEOF
 
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
 
 
+
+
 if test "${ac_cv_header_png_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for png.h" >&5
-echo $ECHO_N "checking for png.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for png.h" >&5
+echo $ECHO_N "checking for png.h... $ECHO_C" >&6
 if test "${ac_cv_header_png_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_png_h" >&5
-echo "${ECHO_T}$ac_cv_header_png_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_png_h" >&5
+echo "${ECHO_T}$ac_cv_header_png_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking png.h usability" >&5
-echo $ECHO_N "checking png.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking png.h usability" >&5
+echo $ECHO_N "checking png.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9715,37 +9168,41 @@
 #include <png.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking png.h presence" >&5
-echo $ECHO_N "checking png.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking png.h presence" >&5
+echo $ECHO_N "checking png.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9754,22 +9211,24 @@
 /* end confdefs.h.  */
 #include <png.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -9777,10 +9236,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -9804,18 +9262,25 @@
 echo "$as_me: WARNING: png.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: png.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: png.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for png.h" >&5
-echo $ECHO_N "checking for png.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for png.h" >&5
+echo $ECHO_N "checking for png.h... $ECHO_C" >&6
 if test "${ac_cv_header_png_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_png_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_png_h" >&5
-echo "${ECHO_T}$ac_cv_header_png_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_png_h" >&5
+echo "${ECHO_T}$ac_cv_header_png_h" >&6
 
 fi
 if test $ac_cv_header_png_h = yes; then
@@ -9823,8 +9288,8 @@
 fi
 
 
-{ echo "$as_me:$LINENO: checking for png_check_sig in -lpng" >&5
-echo $ECHO_N "checking for png_check_sig in -lpng... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for png_check_sig in -lpng" >&5
+echo $ECHO_N "checking for png_check_sig in -lpng... $ECHO_C" >&6
 if test "${ac_cv_lib_png_png_check_sig+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -9837,53 +9302,56 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char png_check_sig ();
 int
 main ()
 {
-return png_check_sig ();
+png_check_sig ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_png_png_check_sig=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_png_png_check_sig=no
+ac_cv_lib_png_png_check_sig=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_png_png_check_sig" >&5
-echo "${ECHO_T}$ac_cv_lib_png_png_check_sig" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_png_png_check_sig" >&5
+echo "${ECHO_T}$ac_cv_lib_png_png_check_sig" >&6
 if test $ac_cv_lib_png_png_check_sig = yes; then
   have_png_lib=yes
 fi
@@ -9891,6 +9359,10 @@
 if test x$have_png_lib = xyes -a x$have_png_h = xyes ; then
   LIBS="$LIBS -lpng -lz"
   cat >>confdefs.h <<\_ACEOF
+#define C_LIBPNG 1
+_ACEOF
+
+  cat >>confdefs.h <<\_ACEOF
 #define C_SSHOT 1
 _ACEOF
 
@@ -9901,20 +9373,79 @@
 
 
 
+# Check whether --enable-printer or --disable-printer was given.
+if test "${enable_printer+set}" = set; then
+  enableval="$enable_printer"
+
+else
+  enable_printer=yes
+fi;
+# Extract the first word of "freetype-config", so it can be a program name with args.
+set dummy freetype-config; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_FREETYPE_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $FREETYPE_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_FREETYPE_CONFIG="$FREETYPE_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_FREETYPE_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_FREETYPE_CONFIG" && ac_cv_path_FREETYPE_CONFIG="no"
+  ;;
+esac
+fi
+FREETYPE_CONFIG=$ac_cv_path_FREETYPE_CONFIG
+
+if test -n "$FREETYPE_CONFIG"; then
+  echo "$as_me:$LINENO: result: $FREETYPE_CONFIG" >&5
+echo "${ECHO_T}$FREETYPE_CONFIG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+if test "$FREETYPE_CONFIG" = "no" ; then
+   { echo "$as_me:$LINENO: WARNING: Can't find FreeType2, printer disabled" >&5
+echo "$as_me: WARNING: Can't find FreeType2, printer disabled" >&2;}
+else
+    cat >>confdefs.h <<\_ACEOF
+#define C_PRINTER 1
+_ACEOF
+
+    CXXFLAGS="$CXXFLAGS `$FREETYPE_CONFIG --cflags`"
+    LIBS="$LIBS `$FREETYPE_CONFIG --libs`"
+fi
+
 
 
-if test "${ac_cv_header_SDL_net_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for SDL_net.h" >&5
-echo $ECHO_N "checking for SDL_net.h... $ECHO_C" >&6; }
-if test "${ac_cv_header_SDL_net_h+set}" = set; then
+if test "${ac_cv_header_pcap_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for pcap.h" >&5
+echo $ECHO_N "checking for pcap.h... $ECHO_C" >&6
+if test "${ac_cv_header_pcap_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_SDL_net_h" >&5
-echo "${ECHO_T}$ac_cv_header_SDL_net_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_pcap_h" >&5
+echo "${ECHO_T}$ac_cv_header_pcap_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking SDL_net.h usability" >&5
-echo $ECHO_N "checking SDL_net.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking pcap.h usability" >&5
+echo $ECHO_N "checking pcap.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9922,40 +9453,269 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <SDL_net.h>
+#include <pcap.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking pcap.h presence" >&5
+echo $ECHO_N "checking pcap.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <pcap.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: pcap.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: pcap.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: pcap.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: pcap.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: pcap.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: pcap.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: pcap.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: pcap.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: pcap.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: pcap.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: pcap.h: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for pcap.h" >&5
+echo $ECHO_N "checking for pcap.h... $ECHO_C" >&6
+if test "${ac_cv_header_pcap_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_pcap_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_pcap_h" >&5
+echo "${ECHO_T}$ac_cv_header_pcap_h" >&6
+
+fi
+if test $ac_cv_header_pcap_h = yes; then
+  have_pcap_h=yes
+fi
+
+
+echo "$as_me:$LINENO: checking for pcap_open_live in -lpcap" >&5
+echo $ECHO_N "checking for pcap_open_live in -lpcap... $ECHO_C" >&6
+if test "${ac_cv_lib_pcap_pcap_open_live+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpcap -lz $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char pcap_open_live ();
+int
+main ()
+{
+pcap_open_live ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_pcap_pcap_open_live=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_pcap_pcap_open_live=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_pcap_pcap_open_live" >&5
+echo "${ECHO_T}$ac_cv_lib_pcap_pcap_open_live" >&6
+if test $ac_cv_lib_pcap_pcap_open_live = yes; then
+  have_pcap_lib=yes
+fi
+
+if test x$have_pcap_lib = xyes -a x$have_pcap_h = xyes ; then
+  LIBS="$LIBS -lpcap";
+  cat >>confdefs.h <<\_ACEOF
+#define C_NE2000 1
+_ACEOF
+
+else
+  { echo "$as_me:$LINENO: WARNING: Can't find libpcap, NE2000 ethernet passthrough disabled" >&5
+echo "$as_me: WARNING: Can't find libpcap, NE2000 ethernet passthrough disabled" >&2;}
+fi
+
+
+
+
+
+if test "${ac_cv_header_SDL_net_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for SDL_net.h" >&5
+echo $ECHO_N "checking for SDL_net.h... $ECHO_C" >&6
+if test "${ac_cv_header_SDL_net_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
+echo "$as_me:$LINENO: result: $ac_cv_header_SDL_net_h" >&5
+echo "${ECHO_T}$ac_cv_header_SDL_net_h" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking SDL_net.h usability" >&5
+echo $ECHO_N "checking SDL_net.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <SDL_net.h>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking SDL_net.h presence" >&5
-echo $ECHO_N "checking SDL_net.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking SDL_net.h presence" >&5
+echo $ECHO_N "checking SDL_net.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -9964,22 +9724,24 @@
 /* end confdefs.h.  */
 #include <SDL_net.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -9987,10 +9749,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -10014,18 +9775,25 @@
 echo "$as_me: WARNING: SDL_net.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: SDL_net.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: SDL_net.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for SDL_net.h" >&5
-echo $ECHO_N "checking for SDL_net.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for SDL_net.h" >&5
+echo $ECHO_N "checking for SDL_net.h... $ECHO_C" >&6
 if test "${ac_cv_header_SDL_net_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_SDL_net_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_SDL_net_h" >&5
-echo "${ECHO_T}$ac_cv_header_SDL_net_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_SDL_net_h" >&5
+echo "${ECHO_T}$ac_cv_header_SDL_net_h" >&6
 
 fi
 if test $ac_cv_header_SDL_net_h = yes; then
@@ -10035,8 +9803,8 @@
 
 
 if test x$target = xi386-pc-os2-emx ; then
-  { echo "$as_me:$LINENO: checking for SDLNet_Init in SDL_net" >&5
-echo $ECHO_N "checking for SDLNet_Init in SDL_net... $ECHO_C" >&6; };
+  echo "$as_me:$LINENO: checking for SDLNet_Init in SDL_net" >&5
+echo $ECHO_N "checking for SDLNet_Init in SDL_net... $ECHO_C" >&6;
   LIBS_BACKUP=$LIBS;
   LIBS="$LIBS -lSDL_Net";
   cat >conftest.$ac_ext <<_ACEOF
@@ -10057,39 +9825,42 @@
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }; have_sdl_net_lib=yes
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; have_sdl_net_lib=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
   LIBS=$LIBS_BACKUP
 else
-{ echo "$as_me:$LINENO: checking for SDLNet_Init in -lSDL_net" >&5
-echo $ECHO_N "checking for SDLNet_Init in -lSDL_net... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for SDLNet_Init in -lSDL_net" >&5
+echo $ECHO_N "checking for SDLNet_Init in -lSDL_net... $ECHO_C" >&6
 if test "${ac_cv_lib_SDL_net_SDLNet_Init+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10102,53 +9873,56 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char SDLNet_Init ();
 int
 main ()
 {
-return SDLNet_Init ();
+SDLNet_Init ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_SDL_net_SDLNet_Init=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_SDL_net_SDLNet_Init=no
+ac_cv_lib_SDL_net_SDLNet_Init=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_net_SDLNet_Init" >&5
-echo "${ECHO_T}$ac_cv_lib_SDL_net_SDLNet_Init" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_net_SDLNet_Init" >&5
+echo "${ECHO_T}$ac_cv_lib_SDL_net_SDLNet_Init" >&6
 if test $ac_cv_lib_SDL_net_SDLNet_Init = yes; then
   have_sdl_net_lib=yes
 fi
@@ -10171,8 +9945,8 @@
 
 
 
-{ echo "$as_me:$LINENO: checking for main in -lX11" >&5
-echo $ECHO_N "checking for main in -lX11... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for main in -lX11" >&5
+echo $ECHO_N "checking for main in -lX11... $ECHO_C" >&6
 if test "${ac_cv_lib_X11_main+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10189,43 +9963,46 @@
 int
 main ()
 {
-return main ();
+main ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_X11_main=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_X11_main=no
+ac_cv_lib_X11_main=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_X11_main" >&5
-echo "${ECHO_T}$ac_cv_lib_X11_main" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_X11_main" >&5
+echo "${ECHO_T}$ac_cv_lib_X11_main" >&6
 if test $ac_cv_lib_X11_main = yes; then
   have_x11_lib=yes
 else
@@ -10233,17 +10010,17 @@
 fi
 
 if test "${ac_cv_header_X11_XKBlib_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for X11/XKBlib.h" >&5
-echo $ECHO_N "checking for X11/XKBlib.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for X11/XKBlib.h" >&5
+echo $ECHO_N "checking for X11/XKBlib.h... $ECHO_C" >&6
 if test "${ac_cv_header_X11_XKBlib_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_X11_XKBlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_X11_XKBlib_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_X11_XKBlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_X11_XKBlib_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking X11/XKBlib.h usability" >&5
-echo $ECHO_N "checking X11/XKBlib.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking X11/XKBlib.h usability" >&5
+echo $ECHO_N "checking X11/XKBlib.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10254,37 +10031,41 @@
 #include <X11/XKBlib.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking X11/XKBlib.h presence" >&5
-echo $ECHO_N "checking X11/XKBlib.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking X11/XKBlib.h presence" >&5
+echo $ECHO_N "checking X11/XKBlib.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10293,22 +10074,24 @@
 /* end confdefs.h.  */
 #include <X11/XKBlib.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -10316,10 +10099,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -10343,18 +10125,25 @@
 echo "$as_me: WARNING: X11/XKBlib.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: X11/XKBlib.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: X11/XKBlib.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for X11/XKBlib.h" >&5
-echo $ECHO_N "checking for X11/XKBlib.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for X11/XKBlib.h" >&5
+echo $ECHO_N "checking for X11/XKBlib.h... $ECHO_C" >&6
 if test "${ac_cv_header_X11_XKBlib_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_X11_XKBlib_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_X11_XKBlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_X11_XKBlib_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_X11_XKBlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_X11_XKBlib_h" >&6
 
 fi
 if test $ac_cv_header_X11_XKBlib_h = yes; then
@@ -10364,25 +10153,25 @@
 fi
 
 
-{ echo "$as_me:$LINENO: checking for XKBlib support" >&5
-echo $ECHO_N "checking for XKBlib support... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for XKBlib support" >&5
+echo $ECHO_N "checking for XKBlib support... $ECHO_C" >&6
 if test x$have_x11_lib = xyes -a x$have_x11_h = xyes ; then
    LIBS="$LIBS -lX11"
    cat >>confdefs.h <<\_ACEOF
 #define C_X11_XKB 1
 _ACEOF
 
-   { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+   echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 else
-   { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+   echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
 
 
-{ echo "$as_me:$LINENO: checking for main in -lGL" >&5
-echo $ECHO_N "checking for main in -lGL... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for main in -lGL" >&5
+echo $ECHO_N "checking for main in -lGL... $ECHO_C" >&6
 if test "${ac_cv_lib_GL_main+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10399,51 +10188,54 @@
 int
 main ()
 {
-return main ();
+main ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_GL_main=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_GL_main=no
+ac_cv_lib_GL_main=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_GL_main" >&5
-echo "${ECHO_T}$ac_cv_lib_GL_main" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_GL_main" >&5
+echo "${ECHO_T}$ac_cv_lib_GL_main" >&6
 if test $ac_cv_lib_GL_main = yes; then
   have_gl_lib=yes
 else
   have_gl_lib=no
 fi
 
-{ echo "$as_me:$LINENO: checking for main in -lopengl32" >&5
-echo $ECHO_N "checking for main in -lopengl32... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for main in -lopengl32" >&5
+echo $ECHO_N "checking for main in -lopengl32... $ECHO_C" >&6
 if test "${ac_cv_lib_opengl32_main+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10460,43 +10252,46 @@
 int
 main ()
 {
-return main ();
+main ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_opengl32_main=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_opengl32_main=no
+ac_cv_lib_opengl32_main=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_opengl32_main" >&5
-echo "${ECHO_T}$ac_cv_lib_opengl32_main" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_opengl32_main" >&5
+echo "${ECHO_T}$ac_cv_lib_opengl32_main" >&6
 if test $ac_cv_lib_opengl32_main = yes; then
   have_opengl32_lib=yes
 else
@@ -10504,17 +10299,17 @@
 fi
 
 if test "${ac_cv_header_GL_gl_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for GL/gl.h" >&5
-echo $ECHO_N "checking for GL/gl.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for GL/gl.h" >&5
+echo $ECHO_N "checking for GL/gl.h... $ECHO_C" >&6
 if test "${ac_cv_header_GL_gl_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_GL_gl_h" >&5
-echo "${ECHO_T}$ac_cv_header_GL_gl_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_GL_gl_h" >&5
+echo "${ECHO_T}$ac_cv_header_GL_gl_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking GL/gl.h usability" >&5
-echo $ECHO_N "checking GL/gl.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking GL/gl.h usability" >&5
+echo $ECHO_N "checking GL/gl.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10525,37 +10320,41 @@
 #include <GL/gl.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking GL/gl.h presence" >&5
-echo $ECHO_N "checking GL/gl.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking GL/gl.h presence" >&5
+echo $ECHO_N "checking GL/gl.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10564,22 +10363,24 @@
 /* end confdefs.h.  */
 #include <GL/gl.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -10587,10 +10388,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -10614,18 +10414,25 @@
 echo "$as_me: WARNING: GL/gl.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: GL/gl.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: GL/gl.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for GL/gl.h" >&5
-echo $ECHO_N "checking for GL/gl.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for GL/gl.h" >&5
+echo $ECHO_N "checking for GL/gl.h... $ECHO_C" >&6
 if test "${ac_cv_header_GL_gl_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_GL_gl_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_GL_gl_h" >&5
-echo "${ECHO_T}$ac_cv_header_GL_gl_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_GL_gl_h" >&5
+echo "${ECHO_T}$ac_cv_header_GL_gl_h" >&6
 
 fi
 if test $ac_cv_header_GL_gl_h = yes; then
@@ -10635,20 +10442,20 @@
 fi
 
 
-# Check whether --enable-opengl was given.
+# Check whether --enable-opengl or --disable-opengl was given.
 if test "${enable_opengl+set}" = set; then
-  enableval=$enable_opengl;
+  enableval="$enable_opengl"
+
 else
   enable_opengl=yes
-fi
-
-{ echo "$as_me:$LINENO: checking whether opengl display output will be enabled" >&5
-echo $ECHO_N "checking whether opengl display output will be enabled... $ECHO_C" >&6; }
+fi;
+echo "$as_me:$LINENO: checking whether opengl display output will be enabled" >&5
+echo $ECHO_N "checking whether opengl display output will be enabled... $ECHO_C" >&6
 if test x$enable_opengl = xyes; then
 case "$target" in
     *-*-darwin*)
-       { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+       echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
        LIBS="$LIBS -framework OpenGL"
        cat >>confdefs.h <<\_ACEOF
 #define C_OPENGL 1
@@ -10657,24 +10464,24 @@
        ;;
     *)
        if test x$have_gl_h = xyes -a x$have_gl_lib = xyes ; then
-         { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+         echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
          LIBS="$LIBS -lGL"
          cat >>confdefs.h <<\_ACEOF
 #define C_OPENGL 1
 _ACEOF
 
        elif test x$have_gl_h = xyes -a x$have_opengl32_lib = xyes ; then
-         { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
+         echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
          LIBS="$LIBS -lopengl32"
          cat >>confdefs.h <<\_ACEOF
 #define C_OPENGL 1
 _ACEOF
 
        else
-         { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+         echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
        fi
        ;;
 esac
@@ -10683,17 +10490,17 @@
 
 
 if test "${ac_cv_header_SDL_sound_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for SDL_sound.h" >&5
-echo $ECHO_N "checking for SDL_sound.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for SDL_sound.h" >&5
+echo $ECHO_N "checking for SDL_sound.h... $ECHO_C" >&6
 if test "${ac_cv_header_SDL_sound_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_SDL_sound_h" >&5
-echo "${ECHO_T}$ac_cv_header_SDL_sound_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_SDL_sound_h" >&5
+echo "${ECHO_T}$ac_cv_header_SDL_sound_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking SDL_sound.h usability" >&5
-echo $ECHO_N "checking SDL_sound.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking SDL_sound.h usability" >&5
+echo $ECHO_N "checking SDL_sound.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10704,37 +10511,41 @@
 #include <SDL_sound.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking SDL_sound.h presence" >&5
-echo $ECHO_N "checking SDL_sound.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking SDL_sound.h presence" >&5
+echo $ECHO_N "checking SDL_sound.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10743,22 +10554,24 @@
 /* end confdefs.h.  */
 #include <SDL_sound.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -10766,10 +10579,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -10793,18 +10605,25 @@
 echo "$as_me: WARNING: SDL_sound.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: SDL_sound.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: SDL_sound.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for SDL_sound.h" >&5
-echo $ECHO_N "checking for SDL_sound.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for SDL_sound.h" >&5
+echo $ECHO_N "checking for SDL_sound.h... $ECHO_C" >&6
 if test "${ac_cv_header_SDL_sound_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_SDL_sound_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_SDL_sound_h" >&5
-echo "${ECHO_T}$ac_cv_header_SDL_sound_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_SDL_sound_h" >&5
+echo "${ECHO_T}$ac_cv_header_SDL_sound_h" >&6
 
 fi
 if test $ac_cv_header_SDL_sound_h = yes; then
@@ -10812,8 +10631,8 @@
 fi
 
 
-{ echo "$as_me:$LINENO: checking for Sound_Init in -lSDL_sound" >&5
-echo $ECHO_N "checking for Sound_Init in -lSDL_sound... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for Sound_Init in -lSDL_sound" >&5
+echo $ECHO_N "checking for Sound_Init in -lSDL_sound... $ECHO_C" >&6
 if test "${ac_cv_lib_SDL_sound_Sound_Init+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10826,59 +10645,62 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char Sound_Init ();
 int
 main ()
 {
-return Sound_Init ();
+Sound_Init ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_SDL_sound_Sound_Init=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_SDL_sound_Sound_Init=no
+ac_cv_lib_SDL_sound_Sound_Init=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_sound_Sound_Init" >&5
-echo "${ECHO_T}$ac_cv_lib_SDL_sound_Sound_Init" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_sound_Sound_Init" >&5
+echo "${ECHO_T}$ac_cv_lib_SDL_sound_Sound_Init" >&6
 if test $ac_cv_lib_SDL_sound_Sound_Init = yes; then
   have_SDL_sound_init=yes
 fi
 
-{ echo "$as_me:$LINENO: checking for Sound_Seek in -lSDL_sound" >&5
-echo $ECHO_N "checking for Sound_Seek in -lSDL_sound... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for Sound_Seek in -lSDL_sound" >&5
+echo $ECHO_N "checking for Sound_Seek in -lSDL_sound... $ECHO_C" >&6
 if test "${ac_cv_lib_SDL_sound_Sound_Seek+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -10891,53 +10713,56 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char Sound_Seek ();
 int
 main ()
 {
-return Sound_Seek ();
+Sound_Seek ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_lib_SDL_sound_Sound_Seek=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_SDL_sound_Sound_Seek=no
+ac_cv_lib_SDL_sound_Sound_Seek=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_sound_Sound_Seek" >&5
-echo "${ECHO_T}$ac_cv_lib_SDL_sound_Sound_Seek" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_lib_SDL_sound_Sound_Seek" >&5
+echo "${ECHO_T}$ac_cv_lib_SDL_sound_Sound_Seek" >&6
 if test $ac_cv_lib_SDL_sound_Sound_Seek = yes; then
   have_SDL_sound_seek=yes
 fi
@@ -10961,17 +10786,17 @@
 
 
 if test "${ac_cv_header_sys_mman_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for sys/mman.h" >&5
-echo $ECHO_N "checking for sys/mman.h... $ECHO_C" >&6; }
+  echo "$as_me:$LINENO: checking for sys/mman.h" >&5
+echo $ECHO_N "checking for sys/mman.h... $ECHO_C" >&6
 if test "${ac_cv_header_sys_mman_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_mman_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_mman_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_mman_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_mman_h" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking sys/mman.h usability" >&5
-echo $ECHO_N "checking sys/mman.h usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking sys/mman.h usability" >&5
+echo $ECHO_N "checking sys/mman.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -10982,37 +10807,41 @@
 #include <sys/mman.h>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking sys/mman.h presence" >&5
-echo $ECHO_N "checking sys/mman.h presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking sys/mman.h presence" >&5
+echo $ECHO_N "checking sys/mman.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -11021,22 +10850,24 @@
 /* end confdefs.h.  */
 #include <sys/mman.h>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -11044,10 +10875,9 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
@@ -11071,24 +10901,31 @@
 echo "$as_me: WARNING: sys/mman.h: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: sys/mman.h: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: sys/mman.h: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for sys/mman.h" >&5
-echo $ECHO_N "checking for sys/mman.h... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for sys/mman.h" >&5
+echo $ECHO_N "checking for sys/mman.h... $ECHO_C" >&6
 if test "${ac_cv_header_sys_mman_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_header_sys_mman_h=$ac_header_preproc
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_mman_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_mman_h" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_mman_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_mman_h" >&6
 
 fi
 if test $ac_cv_header_sys_mman_h = yes; then
 
-{ echo "$as_me:$LINENO: checking for mprotect" >&5
-echo $ECHO_N "checking for mprotect... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for mprotect" >&5
+echo $ECHO_N "checking for mprotect... $ECHO_C" >&6
 if test "${ac_cv_func_mprotect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -11115,59 +10952,68 @@
 
 #undef mprotect
 
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
+/* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
+{
 #endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
 char mprotect ();
 /* The GNU C library defines this for functions which it implements
     to always fail with ENOSYS.  Some functions are actually named
     something starting with __ and the normal name is an alias.  */
-#if defined __stub_mprotect || defined __stub___mprotect
+#if defined (__stub_mprotect) || defined (__stub___mprotect)
 choke me
+#else
+char (*f) () = mprotect;
+#endif
+#ifdef __cplusplus
+}
 #endif
 
 int
 main ()
 {
-return mprotect ();
+return f != mprotect;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_cv_func_mprotect=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_func_mprotect=no
+ac_cv_func_mprotect=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
+rm -f conftest.err conftest.$ac_objext \
       conftest$ac_exeext conftest.$ac_ext
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_mprotect" >&5
-echo "${ECHO_T}$ac_cv_func_mprotect" >&6; }
+echo "$as_me:$LINENO: result: $ac_cv_func_mprotect" >&5
+echo "${ECHO_T}$ac_cv_func_mprotect" >&6
 if test $ac_cv_func_mprotect = yes; then
   cat >>confdefs.h <<\_ACEOF
 #define C_HAVE_MPROTECT 1
@@ -11182,8 +11028,8 @@
 
 
 
-{ echo "$as_me:$LINENO: checking for setpriority support" >&5
-echo $ECHO_N "checking for setpriority support... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for setpriority support" >&5
+echo $ECHO_N "checking for setpriority support... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 
 #include <sys/resource.h>
@@ -11192,61 +11038,552 @@
 };
 
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6;cat >>confdefs.h <<\_ACEOF
+#define C_SET_PRIORITY 1
+_ACEOF
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+
+
+
+echo "$as_me:$LINENO: checking for PHYSFS_init in -lphysfs" >&5
+echo $ECHO_N "checking for PHYSFS_init in -lphysfs... $ECHO_C" >&6
+if test "${ac_cv_lib_physfs_PHYSFS_init+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lphysfs  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char PHYSFS_init ();
+int
+main ()
+{
+PHYSFS_init ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_physfs_PHYSFS_init=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_physfs_PHYSFS_init=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_physfs_PHYSFS_init" >&5
+echo "${ECHO_T}$ac_cv_lib_physfs_PHYSFS_init" >&6
+if test $ac_cv_lib_physfs_PHYSFS_init = yes; then
+  have_PHYSFS_init=yes
+fi
+
+if test x$have_PHYSFS_init = xyes ; then
+    cat >>confdefs.h <<\_ACEOF
+#define C_HAVE_PHYSFS 1
+_ACEOF
+
+    LIBS="$LIBS -lphysfs -lz"
+else
+    { echo "$as_me:$LINENO: WARNING: Can't find PHYSFS_init" >&5
+echo "$as_me: WARNING: Can't find PHYSFS_init" >&2;}
+fi
+
+case "$target" in
+    *-*-cygwin* | *-*-mingw32*)
+       LIBS="$LIBS -lwinmm"
+
+
+
+# Check whether --with-dx-headers or --without-dx-headers was given.
+if test "${with_dx_headers+set}" = set; then
+  withval="$with_dx_headers"
+  dx_headers="$withval"
+else
+  dx_headers=""
+fi;
+
+# Check whether --with-dx-libs or --without-dx-libs was given.
+if test "${with_dx_libs+set}" = set; then
+  withval="$with_dx_libs"
+  dx_libs="$withval"
+else
+  dx_libs=""
+fi;
+       ac_save_CPPFLAGS=$CPPFLAGS
+       if test x$dx_headers != x ; then
+        CPPFLAGS="$CPPFLAGS -I$dx_headers"
+       fi
+       ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+       ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+echo "$as_me:$LINENO: checking how to run the C++ preprocessor" >&5
+echo $ECHO_N "checking how to run the C++ preprocessor... $ECHO_C" >&6
+if test -z "$CXXCPP"; then
+  if test "${ac_cv_prog_CXXCPP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+      # Double quotes because CXXCPP needs to be expanded
+    for CXXCPP in "$CXX -E" "/lib/cpp"
+    do
+      ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  break
+fi
+
+    done
+    ac_cv_prog_CXXCPP=$CXXCPP
+
+fi
+  CXXCPP=$ac_cv_prog_CXXCPP
+else
+  ac_cv_prog_CXXCPP=$CXXCPP
+fi
+echo "$as_me:$LINENO: result: $CXXCPP" >&5
+echo "${ECHO_T}$CXXCPP" >&6
+ac_preproc_ok=false
+for ac_cxx_preproc_warn_flag in '' yes
+do
+  # Use a header file that comes with gcc, so configuring glibc
+  # with a fresh cross-compiler works.
+  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+  # <limits.h> exists even on freestanding compilers.
+  # On the NeXT, cc -E runs the code through the compiler's parser,
+  # not just through cpp. "Syntax error" is here to catch this case.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+		     Syntax error
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  :
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Broken: fails on valid input.
+continue
+fi
+rm -f conftest.err conftest.$ac_ext
+
+  # OK, works on sane cases.  Now check whether non-existent headers
+  # can be detected and how.
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <ac_nonexistent.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  # Broken: success on invalid input.
+continue
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  # Passes both tests.
+ac_preproc_ok=:
+break
+fi
+rm -f conftest.err conftest.$ac_ext
+
+done
+# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
+rm -f conftest.err conftest.$ac_ext
+if $ac_preproc_ok; then
+  :
+else
+  { { echo "$as_me:$LINENO: error: C++ preprocessor \"$CXXCPP\" fails sanity check
+See \`config.log' for more details." >&5
+echo "$as_me: error: C++ preprocessor \"$CXXCPP\" fails sanity check
+See \`config.log' for more details." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+
+ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+
+
+for ac_header in ddraw.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest$ac_exeext &&
-       $as_test_x conftest$ac_exeext; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; };cat >>confdefs.h <<\_ACEOF
-#define C_SET_PRIORITY 1
-_ACEOF
-
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  ac_header_preproc=no
 fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc:$ac_cxx_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
+    ;;
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=\$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
 
-case "$target" in
-    *-*-cygwin* | *-*-mingw32*)
-       LIBS="$LIBS -lwinmm"
+fi
 
-for ac_header in ddraw.h
+done
+
+
+for ac_header in d3d9.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 else
   # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -11257,37 +11594,41 @@
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && {
-	 test -z "$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       } && test -s conftest.$ac_objext; then
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
   ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_header_compiler=no
+ac_header_compiler=no
 fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
@@ -11296,22 +11637,24 @@
 /* end confdefs.h.  */
 #include <$ac_header>
 _ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null && {
-	 test -z "$ac_c_preproc_warn_flag$ac_c_werror_flag" ||
-	 test ! -s conftest.err
-       }; then
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_cxx_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_cxx_werror_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
   ac_header_preproc=yes
 else
   echo "$as_me: failed program was:" >&5
@@ -11319,13 +11662,12 @@
 
   ac_header_preproc=no
 fi
-
 rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+case $ac_header_compiler:$ac_header_preproc:$ac_cxx_preproc_warn_flag in
   yes:no: )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
@@ -11346,35 +11688,132 @@
 echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
 echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
+    (
+      cat <<\_ASBOX
+## --------------------------------- ##
+## Report this to the dosbox lists.  ##
+## --------------------------------- ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   eval "$as_ac_Header=\$ac_header_preproc"
 fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 
 fi
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
-
+ have_d3d9_h=yes
 fi
 
 done
 
+       echo "$as_me:$LINENO: checking whether direct3d display output will be enabled" >&5
+echo $ECHO_N "checking whether direct3d display output will be enabled... $ECHO_C" >&6
+       if test x$have_d3d9_h = xyes ; then
+        echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+        # Check whether --enable-shaders or --disable-shaders was given.
+if test "${enable_shaders+set}" = set; then
+  enableval="$enable_shaders"
+
+else
+
+     		echo "$as_me:$LINENO: checking whether direct3d pixelshaders will be enabled" >&5
+echo $ECHO_N "checking whether direct3d pixelshaders will be enabled... $ECHO_C" >&6
+ 		ac_save_LIBS=$LIBS
+ 		if test x$dx_libs != x ; then
+ 		 dx_libs=" -L$dx_libs"
+ 		fi
+ 		LIBS="$LIBS$dx_libs -ld3dx9"
+ 		cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <d3d9.h>
+ 		    	     #include <d3dx9.h>
+ 			     extern "C" int main();
+int
+main ()
+{
+D3DXCreateEffect(0, 0, 0, 0, 0, 0, 0, 0, 0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  have_d3dx9_lib=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+ 		if test x$have_d3dx9_lib = xyes ; then
+     		 echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+ 		 cat >>confdefs.h <<\_ACEOF
+#define C_D3DSHADERS 1
+_ACEOF
+
+ 		else
+ 		 LIBS=$ac_save_LIBS
+     		 echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+ 		 { echo "$as_me:$LINENO: WARNING: Can't find libd3dx9, pixelshader support disabled" >&5
+echo "$as_me: WARNING: Can't find libd3dx9, pixelshader support disabled" >&2;}
+ 		fi
+
+fi;
+       else
+	CPPFLAGS=$ac_save_CPPFLAGS
+        echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+       fi
 
 cat >>confdefs.h <<\_ACEOF
 #define C_DIRECTSERIAL 1
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define C_DIRECTLPT 1
+_ACEOF
+
        if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
          LIBS="$LIBS -lws2_32"
        fi
@@ -11403,6 +11842,11 @@
 #define C_DIRECTSERIAL 1
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define C_DIRECTLPT 1
+_ACEOF
+
        ;;
     *-*-freebsd* | *-*-dragonfly* | *-*-netbsd* | *-*-openbsd*)
 
@@ -11435,8 +11879,8 @@
               if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}windres", so it can be a program name with args.
 set dummy ${ac_tool_prefix}windres; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_WINDRES+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -11449,34 +11893,32 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_WINDRES="${ac_tool_prefix}windres"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
 fi
 fi
 WINDRES=$ac_cv_prog_WINDRES
 if test -n "$WINDRES"; then
-  { echo "$as_me:$LINENO: result: $WINDRES" >&5
-echo "${ECHO_T}$WINDRES" >&6; }
+  echo "$as_me:$LINENO: result: $WINDRES" >&5
+echo "${ECHO_T}$WINDRES" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-
 fi
 if test -z "$ac_cv_prog_WINDRES"; then
   ac_ct_WINDRES=$WINDRES
   # Extract the first word of "windres", so it can be a program name with args.
 set dummy windres; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_WINDRES+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -11489,41 +11931,27 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
     ac_cv_prog_ac_ct_WINDRES="windres"
     echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
     break 2
   fi
 done
 done
-IFS=$as_save_IFS
 
+  test -z "$ac_cv_prog_ac_ct_WINDRES" && ac_cv_prog_ac_ct_WINDRES=":"
 fi
 fi
 ac_ct_WINDRES=$ac_cv_prog_ac_ct_WINDRES
 if test -n "$ac_ct_WINDRES"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_WINDRES" >&5
-echo "${ECHO_T}$ac_ct_WINDRES" >&6; }
+  echo "$as_me:$LINENO: result: $ac_ct_WINDRES" >&5
+echo "${ECHO_T}$ac_ct_WINDRES" >&6
 else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
 
-  if test "x$ac_ct_WINDRES" = x; then
-    WINDRES=":"
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    WINDRES=$ac_ct_WINDRES
-  fi
+  WINDRES=$ac_ct_WINDRES
 else
   WINDRES="$ac_cv_prog_WINDRES"
 fi
@@ -11533,7 +11961,9 @@
        WINDRES=":"
     ;;
 esac
-        if test "x$WINDRES" != "x:"; then
+
+
+if test "x$WINDRES" != "x:"; then
   HAVE_WINDRES_TRUE=
   HAVE_WINDRES_FALSE='#'
 else
@@ -11544,7 +11974,7 @@
 
 
 
-ac_config_files="$ac_config_files Makefile src/Makefile src/cpu/Makefile src/cpu/core_full/Makefile src/cpu/core_normal/Makefile src/cpu/core_dyn_x86/Makefile src/cpu/core_dynrec/Makefile src/debug/Makefile src/dos/Makefile src/fpu/Makefile src/gui/Makefile src/hardware/Makefile src/hardware/serialport/Makefile src/ints/Makefile src/libs/Makefile src/libs/zmbv/Makefile src/libs/gui_tk/Makefile src/misc/Makefile src/shell/Makefile src/platform/Makefile src/platform/visualc/Makefile visualc_net/Makefile include/Makefile docs/Makefile"
+                                                                                                                                                                                                                                                                    ac_config_files="$ac_config_files Makefile src/Makefile src/cpu/Makefile src/cpu/core_full/Makefile src/cpu/core_normal/Makefile src/cpu/core_dyn_x86/Makefile src/cpu/core_dynrec/Makefile src/debug/Makefile src/dos/Makefile src/fpu/Makefile src/gui/Makefile src/hardware/Makefile src/hardware/serialport/Makefile src/hardware/parport/Makefile src/ints/Makefile src/libs/Makefile src/libs/zmbv/Makefile src/libs/gui_tk/Makefile src/libs/porttalk/Makefile src/misc/Makefile src/shell/Makefile src/platform/Makefile src/platform/visualc/Makefile visualc_net/Makefile include/Makefile docs/Makefile"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
@@ -11564,58 +11994,39 @@
 
 # The following way of writing the cache mishandles newlines in values,
 # but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
+# So, don't put newlines in cache variables' values.
 # Ultrix sh set writes to stderr and can't be redirected directly,
 # and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
-
+{
   (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
+    case `(ac_space=' '; set | grep ac_space) 2>&1` in
+    *ac_space=\ *)
       # `set' does not quote correctly, so add quotes (double-quote
       # substitution turns \\\\ into \\, and sed turns \\ into \).
       sed -n \
 	"s/'/'\\\\''/g;
 	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
+      ;;
     *)
       # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      sed -n \
+	"s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1=\\2/p"
       ;;
-    esac |
-    sort
-) |
+    esac;
+} |
   sed '
-     /^ac_cv_env_/b end
      t clear
-     :clear
+     : clear
      s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
      t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
-echo "$as_me: updating cache $cache_file" >&6;}
+     /^ac_cv_env/!s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     : end' >>confcache
+if diff $cache_file confcache >/dev/null 2>&1; then :; else
+  if test -w $cache_file; then
+    test "x$cache_file" != "x/dev/null" && echo "updating cache $cache_file"
     cat confcache >$cache_file
   else
-    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
-echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+    echo "not updating unwritable cache $cache_file"
   fi
 fi
 rm -f confcache
@@ -11624,18 +12035,32 @@
 # Let make expand exec_prefix.
 test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
 
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/;
+s/:*\${srcdir}:*/:/;
+s/:*@srcdir@:*/:/;
+s/^\([^=]*=[	 ]*\):*/\1/;
+s/:*$//;
+s/^[^=]*=[	 ]*$//;
+}'
+fi
+
 DEFS=-DHAVE_CONFIG_H
 
 ac_libobjs=
 ac_ltlibobjs=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
+  ac_i=`echo "$ac_i" |
+	 sed 's/\$U\././;s/\.o$//;s/\.obj$//'`
+  # 2. Add them.
+  ac_libobjs="$ac_libobjs $ac_i\$U.$ac_objext"
+  ac_ltlibobjs="$ac_ltlibobjs $ac_i"'$U.lo'
 done
 LIBOBJS=$ac_libobjs
 
@@ -11694,45 +12119,17 @@
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
-# Be more Bourne compatible
-DUALCASE=1; export DUALCASE # for MKS sh
+# Be Bourne compatible
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
   # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in
-  *posix*) set -o posix ;;
-esac
-
-fi
-
-
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
+elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
+  set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
 if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
@@ -11742,43 +12139,8 @@
 fi
 
 
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-as_nl='
-'
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
-fi
-
 # Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-done
+$as_unset ENV MAIL MAILPATH
 PS1='$ '
 PS2='> '
 PS4='+ '
@@ -11792,19 +12154,18 @@
   if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
+    $as_unset $as_var
   fi
 done
 
 # Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+if expr a : '\(a\)' >/dev/null 2>&1; then
   as_expr=expr
 else
   as_expr=false
 fi
 
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+if (basename /) >/dev/null 2>&1 && test "X`basename / 2>&1`" = "X/"; then
   as_basename=basename
 else
   as_basename=false
@@ -11812,120 +12173,159 @@
 
 
 # Name of the executable.
-as_me=`$as_basename -- "$0" ||
+as_me=`$as_basename "$0" ||
 $as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
 	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$0" : 'X\(/\)$' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
+    sed '/^.*\/\([^/][^/]*\)\/*$/{ s//\1/; q; }
+  	  /^X\/\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\/\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
 
-# CDPATH.
-$as_unset CDPATH
+
+# PATH needs CR, and LINENO needs CR and PATH.
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  echo "#! /bin/sh" >conf$$.sh
+  echo  "exit 0"   >>conf$$.sh
+  chmod +x conf$$.sh
+  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
+    PATH_SEPARATOR=';'
+  else
+    PATH_SEPARATOR=:
+  fi
+  rm -f conf$$.sh
+fi
 
 
+  as_lineno_1=$LINENO
+  as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
+  test "x$as_lineno_1" != "x$as_lineno_2" &&
+  test "x$as_lineno_3"  = "x$as_lineno_2"  || {
+  # Find who we are.  Look in the path if we contain no path at all
+  # relative or not.
+  case $0 in
+    *[\\/]* ) as_myself=$0 ;;
+    *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+done
 
+       ;;
+  esac
+  # We did not find ourselves, most probably we were run as `sh COMMAND'
+  # in which case we are not to be found in the path.
+  if test "x$as_myself" = x; then
+    as_myself=$0
+  fi
+  if test ! -f "$as_myself"; then
+    { { echo "$as_me:$LINENO: error: cannot find myself; rerun with an absolute path" >&5
+echo "$as_me: error: cannot find myself; rerun with an absolute path" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+  case $CONFIG_SHELL in
+  '')
+    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for as_base in sh bash ksh sh5; do
+	 case $as_dir in
+	 /*)
+	   if ("$as_dir/$as_base" -c '
   as_lineno_1=$LINENO
   as_lineno_2=$LINENO
+  as_lineno_3=`(expr $as_lineno_1 + 1) 2>/dev/null`
   test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
+  test "x$as_lineno_3"  = "x$as_lineno_2" ') 2>/dev/null; then
+	     $as_unset BASH_ENV || test "${BASH_ENV+set}" != set || { BASH_ENV=; export BASH_ENV; }
+	     $as_unset ENV || test "${ENV+set}" != set || { ENV=; export ENV; }
+	     CONFIG_SHELL=$as_dir/$as_base
+	     export CONFIG_SHELL
+	     exec "$CONFIG_SHELL" "$0" ${1+"$@"}
+	   fi;;
+	 esac
+       done
+done
+;;
+  esac
 
   # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
   # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
+  # line-number line before each line; the second 'sed' does the real
+  # work.  The second script uses 'N' to pair each line-number line
+  # with the numbered line, and appends trailing '-' during
+  # substitution so that $LINENO is not a special case at line end.
   # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
+  # second 'sed' script.  Blame Lee E. McMahon for sed's syntax.  :-)
+  sed '=' <$as_myself |
     sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
       N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      s,$,-,
+      : loop
+      s,^\(['$as_cr_digits']*\)\(.*\)[$]LINENO\([^'$as_cr_alnum'_]\),\1\2\1\3,
       t loop
-      s/-\n.*//
+      s,-$,,
+      s,^['$as_cr_digits']*\n,,
     ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
+  chmod +x $as_me.lineno ||
+    { { echo "$as_me:$LINENO: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&5
+echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2;}
    { (exit 1); exit 1; }; }
 
   # Don't try to exec as it changes $[0], causing all sort of problems
   # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
+  # original and so on.  Autoconf is especially sensible to this).
+  . ./$as_me.lineno
   # Exit status is that of the last command.
   exit
 }
 
 
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
--n*)
-  case `echo 'x\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
-  esac;;
-*)
-  ECHO_N='-n';;
+case `echo "testing\c"; echo 1,2,3`,`echo -n testing; echo 1,2,3` in
+  *c*,-n*) ECHO_N= ECHO_C='
+' ECHO_T='	' ;;
+  *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
+  *)       ECHO_N= ECHO_C='\c' ECHO_T= ;;
 esac
 
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+if expr a : '\(a\)' >/dev/null 2>&1; then
   as_expr=expr
 else
   as_expr=false
 fi
 
 rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir
-fi
 echo >conf$$.file
 if ln -s conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s='ln -s'
-  # ... but there are two gotchas:
-  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-  # In both cases, we have to default to `cp -p'.
-  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+  # We could just check for DJGPP; but this test a) works b) is more generic
+  # and c) will remain valid once DJGPP supports symlinks (DJGPP 2.04).
+  if test -f conf$$.exe; then
+    # Don't use ln at all; we don't have any links
     as_ln_s='cp -p'
+  else
+    as_ln_s='ln -s'
+  fi
 elif ln conf$$.file conf$$ 2>/dev/null; then
   as_ln_s=ln
 else
   as_ln_s='cp -p'
 fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
+rm -f conf$$ conf$$.exe conf$$.file
 
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
@@ -11934,28 +12334,7 @@
   as_mkdir_p=false
 fi
 
-if test -x / >/dev/null 2>&1; then
-  as_test_x='test -x'
-else
-  if ls -dL / >/dev/null 2>&1; then
-    as_ls_L_option=L
-  else
-    as_ls_L_option=
-  fi
-  as_test_x='
-    eval sh -c '\''
-      if test -d "$1"; then
-        test -d "$1/.";
-      else
-	case $1 in
-        -*)set "./$1";;
-	esac;
-	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in
-	???[sx]*):;;*)false;;esac;fi
-    '\'' sh
-  '
-fi
-as_executable_p=$as_test_x
+as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
 as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
@@ -11964,14 +12343,31 @@
 as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
+# IFS
+# We need space, tab and new line, in precisely that order.
+as_nl='
+'
+IFS=" 	$as_nl"
+
+# CDPATH.
+$as_unset CDPATH
+
 exec 6>&1
 
-# Save the log message, to keep $[0] and so on meaningful, and to
+# Open the log real soon, to keep \$[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
+# values after options handling.  Logging --version etc. is OK.
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+} >&5
+cat >&5 <<_CSEOF
+
 This file was extended by dosbox $as_me 0.73, which was
-generated by GNU Autoconf 2.61.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -11979,20 +12375,30 @@
   CONFIG_COMMANDS = $CONFIG_COMMANDS
   $ $0 $@
 
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
+_CSEOF
+echo "on `(hostname || uname -n) 2>/dev/null | sed 1q`" >&5
+echo >&5
 _ACEOF
 
-cat >>$CONFIG_STATUS <<_ACEOF
 # Files that config.status was made for.
-config_files="$ac_config_files"
-config_headers="$ac_config_headers"
-config_commands="$ac_config_commands"
+if test -n "$ac_config_files"; then
+  echo "config_files=\"$ac_config_files\"" >>$CONFIG_STATUS
+fi
 
-_ACEOF
+if test -n "$ac_config_headers"; then
+  echo "config_headers=\"$ac_config_headers\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_links"; then
+  echo "config_links=\"$ac_config_links\"" >>$CONFIG_STATUS
+fi
+
+if test -n "$ac_config_commands"; then
+  echo "config_commands=\"$ac_config_commands\"" >>$CONFIG_STATUS
+fi
 
 cat >>$CONFIG_STATUS <<\_ACEOF
+
 ac_cs_usage="\
 \`$as_me' instantiates files from templates according to the
 current configuration.
@@ -12000,7 +12406,7 @@
 Usage: $0 [OPTIONS] [FILE]...
 
   -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
+  -V, --version    print version number, then exit
   -q, --quiet      do not print progress messages
   -d, --debug      don't remove temporary files
       --recheck    update $as_me by reconfiguring in the same conditions
@@ -12019,22 +12425,19 @@
 $config_commands
 
 Report bugs to <bug-autoconf@gnu.org>."
-
 _ACEOF
+
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
 dosbox config.status 0.73
-configured by $0, generated by GNU Autoconf 2.61,
-  with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+configured by $0, generated by GNU Autoconf 2.59,
+  with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright (C) 2006 Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-MKDIR_P='$MKDIR_P'
+srcdir=$srcdir
+INSTALL="$INSTALL"
 _ACEOF
 
 cat >>$CONFIG_STATUS <<\_ACEOF
@@ -12045,24 +12448,39 @@
 do
   case $1 in
   --*=*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_option=`expr "x$1" : 'x\([^=]*\)='`
+    ac_optarg=`expr "x$1" : 'x[^=]*=\(.*\)'`
     ac_shift=:
     ;;
-  *)
+  -*)
     ac_option=$1
     ac_optarg=$2
     ac_shift=shift
     ;;
+  *) # This is not an option, so the user has probably given explicit
+     # arguments.
+     ac_option=$1
+     ac_need_defaults=false;;
   esac
 
   case $ac_option in
   # Handling of the options.
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
     ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    echo "$ac_cs_version"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
+  --version | --vers* | -V )
+    echo "$ac_cs_version"; exit 0 ;;
+  --he | --h)
+    # Conflict between --help and --header
+    { { echo "$as_me:$LINENO: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: ambiguous option: $1
+Try \`$0 --help' for more information." >&2;}
+   { (exit 1); exit 1; }; };;
+  --help | --hel | -h )
+    echo "$ac_cs_usage"; exit 0 ;;
+  --debug | --d* | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
@@ -12072,24 +12490,18 @@
     $ac_shift
     CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
     ac_need_defaults=false;;
-  --he | --h)
-    # Conflict between --help and --header
-    { echo "$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; };;
-  --help | --hel | -h )
-    echo "$ac_cs_usage"; exit ;;
   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
   | -silent | --silent | --silen | --sile | --sil | --si | --s)
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) { echo "$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&2
+  -*) { { echo "$as_me:$LINENO: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&5
+echo "$as_me: error: unrecognized option: $1
+Try \`$0 --help' for more information." >&2;}
    { (exit 1); exit 1; }; } ;;
 
-  *) ac_config_targets="$ac_config_targets $1"
-     ac_need_defaults=false ;;
+  *) ac_config_targets="$ac_config_targets $1" ;;
 
   esac
   shift
@@ -12105,72 +12517,62 @@
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 if \$ac_cs_recheck; then
-  echo "running CONFIG_SHELL=$SHELL $SHELL $0 "$ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
-  CONFIG_SHELL=$SHELL
-  export CONFIG_SHELL
-  exec $SHELL "$0"$ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  echo "running $SHELL $0 " $ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
+  exec $SHELL $0 $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
 fi
 
 _ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  echo "$ac_log"
-} >&5
 
-_ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 #
-# INIT-COMMANDS
+# INIT-COMMANDS section.
 #
+
 AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
 
 _ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
 
-# Handling of arguments.
+
+cat >>$CONFIG_STATUS <<\_ACEOF
 for ac_config_target in $ac_config_targets
 do
-  case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "src/Makefile") CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
-    "src/cpu/Makefile") CONFIG_FILES="$CONFIG_FILES src/cpu/Makefile" ;;
-    "src/cpu/core_full/Makefile") CONFIG_FILES="$CONFIG_FILES src/cpu/core_full/Makefile" ;;
-    "src/cpu/core_normal/Makefile") CONFIG_FILES="$CONFIG_FILES src/cpu/core_normal/Makefile" ;;
-    "src/cpu/core_dyn_x86/Makefile") CONFIG_FILES="$CONFIG_FILES src/cpu/core_dyn_x86/Makefile" ;;
-    "src/cpu/core_dynrec/Makefile") CONFIG_FILES="$CONFIG_FILES src/cpu/core_dynrec/Makefile" ;;
-    "src/debug/Makefile") CONFIG_FILES="$CONFIG_FILES src/debug/Makefile" ;;
-    "src/dos/Makefile") CONFIG_FILES="$CONFIG_FILES src/dos/Makefile" ;;
-    "src/fpu/Makefile") CONFIG_FILES="$CONFIG_FILES src/fpu/Makefile" ;;
-    "src/gui/Makefile") CONFIG_FILES="$CONFIG_FILES src/gui/Makefile" ;;
-    "src/hardware/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/Makefile" ;;
-    "src/hardware/serialport/Makefile") CONFIG_FILES="$CONFIG_FILES src/hardware/serialport/Makefile" ;;
-    "src/ints/Makefile") CONFIG_FILES="$CONFIG_FILES src/ints/Makefile" ;;
-    "src/libs/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/Makefile" ;;
-    "src/libs/zmbv/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/zmbv/Makefile" ;;
-    "src/libs/gui_tk/Makefile") CONFIG_FILES="$CONFIG_FILES src/libs/gui_tk/Makefile" ;;
-    "src/misc/Makefile") CONFIG_FILES="$CONFIG_FILES src/misc/Makefile" ;;
-    "src/shell/Makefile") CONFIG_FILES="$CONFIG_FILES src/shell/Makefile" ;;
-    "src/platform/Makefile") CONFIG_FILES="$CONFIG_FILES src/platform/Makefile" ;;
-    "src/platform/visualc/Makefile") CONFIG_FILES="$CONFIG_FILES src/platform/visualc/Makefile" ;;
-    "visualc_net/Makefile") CONFIG_FILES="$CONFIG_FILES visualc_net/Makefile" ;;
-    "include/Makefile") CONFIG_FILES="$CONFIG_FILES include/Makefile" ;;
-    "docs/Makefile") CONFIG_FILES="$CONFIG_FILES docs/Makefile" ;;
-
+  case "$ac_config_target" in
+  # Handling of arguments.
+  "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+  "src/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
+  "src/cpu/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/cpu/Makefile" ;;
+  "src/cpu/core_full/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/cpu/core_full/Makefile" ;;
+  "src/cpu/core_normal/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/cpu/core_normal/Makefile" ;;
+  "src/cpu/core_dyn_x86/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/cpu/core_dyn_x86/Makefile" ;;
+  "src/cpu/core_dynrec/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/cpu/core_dynrec/Makefile" ;;
+  "src/debug/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/debug/Makefile" ;;
+  "src/dos/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/dos/Makefile" ;;
+  "src/fpu/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/fpu/Makefile" ;;
+  "src/gui/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/gui/Makefile" ;;
+  "src/hardware/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/hardware/Makefile" ;;
+  "src/hardware/serialport/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/hardware/serialport/Makefile" ;;
+  "src/hardware/parport/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/hardware/parport/Makefile" ;;
+  "src/ints/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/ints/Makefile" ;;
+  "src/libs/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/libs/Makefile" ;;
+  "src/libs/zmbv/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/libs/zmbv/Makefile" ;;
+  "src/libs/gui_tk/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/libs/gui_tk/Makefile" ;;
+  "src/libs/porttalk/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/libs/porttalk/Makefile" ;;
+  "src/misc/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/misc/Makefile" ;;
+  "src/shell/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/shell/Makefile" ;;
+  "src/platform/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/platform/Makefile" ;;
+  "src/platform/visualc/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/platform/visualc/Makefile" ;;
+  "visualc_net/Makefile" ) CONFIG_FILES="$CONFIG_FILES visualc_net/Makefile" ;;
+  "include/Makefile" ) CONFIG_FILES="$CONFIG_FILES include/Makefile" ;;
+  "docs/Makefile" ) CONFIG_FILES="$CONFIG_FILES docs/Makefile" ;;
+  "depfiles" ) CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
   *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
 echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
    { (exit 1); exit 1; }; };;
   esac
 done
 
-
 # If the user did not use the arguments to specify the items to instantiate,
 # then the envvar interface is used.  Set only those that are not.
 # We use the long form for the default assignment because of an extremely
@@ -12182,467 +12584,357 @@
 fi
 
 # Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
+# simply because there is no reason to put it here, and in addition,
 # creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
+# Create a temporary directory, and hook for its removal unless debugging.
 $debug ||
 {
-  tmp=
-  trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
-' 0
+  trap 'exit_status=$?; rm -rf $tmp && exit $exit_status' 0
   trap '{ (exit 1); exit 1; }' 1 2 13 15
 }
+
 # Create a (secure) tmp directory for tmp files.
 
 {
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  tmp=`(umask 077 && mktemp -d -q "./confstatXXXXXX") 2>/dev/null` &&
   test -n "$tmp" && test -d "$tmp"
 }  ||
 {
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
+  tmp=./confstat$$-$RANDOM
+  (umask 077 && mkdir $tmp)
 } ||
 {
    echo "$me: cannot create a temporary directory in ." >&2
    { (exit 1); exit 1; }
 }
 
-#
-# Set up the sed scripts for CONFIG_FILES section.
-#
-
-# No need to generate the scripts if there are no CONFIG_FILES.
-# This happens for instance when ./config.status config.h
-if test -n "$CONFIG_FILES"; then
-
-_ACEOF
-
-
-
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  cat >conf$$subs.sed <<_ACEOF
-SHELL!$SHELL$ac_delim
-PATH_SEPARATOR!$PATH_SEPARATOR$ac_delim
-PACKAGE_NAME!$PACKAGE_NAME$ac_delim
-PACKAGE_TARNAME!$PACKAGE_TARNAME$ac_delim
-PACKAGE_VERSION!$PACKAGE_VERSION$ac_delim
-PACKAGE_STRING!$PACKAGE_STRING$ac_delim
-PACKAGE_BUGREPORT!$PACKAGE_BUGREPORT$ac_delim
-exec_prefix!$exec_prefix$ac_delim
-prefix!$prefix$ac_delim
-program_transform_name!$program_transform_name$ac_delim
-bindir!$bindir$ac_delim
-sbindir!$sbindir$ac_delim
-libexecdir!$libexecdir$ac_delim
-datarootdir!$datarootdir$ac_delim
-datadir!$datadir$ac_delim
-sysconfdir!$sysconfdir$ac_delim
-sharedstatedir!$sharedstatedir$ac_delim
-localstatedir!$localstatedir$ac_delim
-includedir!$includedir$ac_delim
-oldincludedir!$oldincludedir$ac_delim
-docdir!$docdir$ac_delim
-infodir!$infodir$ac_delim
-htmldir!$htmldir$ac_delim
-dvidir!$dvidir$ac_delim
-pdfdir!$pdfdir$ac_delim
-psdir!$psdir$ac_delim
-libdir!$libdir$ac_delim
-localedir!$localedir$ac_delim
-mandir!$mandir$ac_delim
-DEFS!$DEFS$ac_delim
-ECHO_C!$ECHO_C$ac_delim
-ECHO_N!$ECHO_N$ac_delim
-ECHO_T!$ECHO_T$ac_delim
-LIBS!$LIBS$ac_delim
-build_alias!$build_alias$ac_delim
-host_alias!$host_alias$ac_delim
-target_alias!$target_alias$ac_delim
-build!$build$ac_delim
-build_cpu!$build_cpu$ac_delim
-build_vendor!$build_vendor$ac_delim
-build_os!$build_os$ac_delim
-host!$host$ac_delim
-host_cpu!$host_cpu$ac_delim
-host_vendor!$host_vendor$ac_delim
-host_os!$host_os$ac_delim
-target!$target$ac_delim
-target_cpu!$target_cpu$ac_delim
-target_vendor!$target_vendor$ac_delim
-target_os!$target_os$ac_delim
-INSTALL_PROGRAM!$INSTALL_PROGRAM$ac_delim
-INSTALL_SCRIPT!$INSTALL_SCRIPT$ac_delim
-INSTALL_DATA!$INSTALL_DATA$ac_delim
-am__isrc!$am__isrc$ac_delim
-CYGPATH_W!$CYGPATH_W$ac_delim
-PACKAGE!$PACKAGE$ac_delim
-VERSION!$VERSION$ac_delim
-ACLOCAL!$ACLOCAL$ac_delim
-AUTOCONF!$AUTOCONF$ac_delim
-AUTOMAKE!$AUTOMAKE$ac_delim
-AUTOHEADER!$AUTOHEADER$ac_delim
-MAKEINFO!$MAKEINFO$ac_delim
-install_sh!$install_sh$ac_delim
-STRIP!$STRIP$ac_delim
-INSTALL_STRIP_PROGRAM!$INSTALL_STRIP_PROGRAM$ac_delim
-mkdir_p!$mkdir_p$ac_delim
-AWK!$AWK$ac_delim
-SET_MAKE!$SET_MAKE$ac_delim
-am__leading_dot!$am__leading_dot$ac_delim
-AMTAR!$AMTAR$ac_delim
-am__tar!$am__tar$ac_delim
-am__untar!$am__untar$ac_delim
-CC!$CC$ac_delim
-CFLAGS!$CFLAGS$ac_delim
-LDFLAGS!$LDFLAGS$ac_delim
-CPPFLAGS!$CPPFLAGS$ac_delim
-ac_ct_CC!$ac_ct_CC$ac_delim
-EXEEXT!$EXEEXT$ac_delim
-OBJEXT!$OBJEXT$ac_delim
-DEPDIR!$DEPDIR$ac_delim
-am__include!$am__include$ac_delim
-am__quote!$am__quote$ac_delim
-AMDEP_TRUE!$AMDEP_TRUE$ac_delim
-AMDEP_FALSE!$AMDEP_FALSE$ac_delim
-AMDEPBACKSLASH!$AMDEPBACKSLASH$ac_delim
-CCDEPMODE!$CCDEPMODE$ac_delim
-am__fastdepCC_TRUE!$am__fastdepCC_TRUE$ac_delim
-am__fastdepCC_FALSE!$am__fastdepCC_FALSE$ac_delim
-CPP!$CPP$ac_delim
-CXX!$CXX$ac_delim
-CXXFLAGS!$CXXFLAGS$ac_delim
-ac_ct_CXX!$ac_ct_CXX$ac_delim
-CXXDEPMODE!$CXXDEPMODE$ac_delim
-am__fastdepCXX_TRUE!$am__fastdepCXX_TRUE$ac_delim
-am__fastdepCXX_FALSE!$am__fastdepCXX_FALSE$ac_delim
-RANLIB!$RANLIB$ac_delim
-SDL_CONFIG!$SDL_CONFIG$ac_delim
-SDL_CFLAGS!$SDL_CFLAGS$ac_delim
 _ACEOF
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 97; then
-    break
-  elif $ac_last_try; then
-    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-
-ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
-if test -n "$ac_eof"; then
-  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
-  ac_eof=`expr $ac_eof + 1`
-fi
-
 cat >>$CONFIG_STATUS <<_ACEOF
-cat >"\$tmp/subs-1.sed" <<\CEOF$ac_eof
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-_ACEOF
-sed '
-s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
-s/^/s,@/; s/!/@,|#_!!_#|/
-:n
-t n
-s/'"$ac_delim"'$/,g/; t
-s/$/\\/; p
-N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
-' >>$CONFIG_STATUS <conf$$subs.sed
-rm -f conf$$subs.sed
-cat >>$CONFIG_STATUS <<_ACEOF
-CEOF$ac_eof
-_ACEOF
 
+#
+# CONFIG_FILES section.
+#
 
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  cat >conf$$subs.sed <<_ACEOF
-SDL_LIBS!$SDL_LIBS$ac_delim
-GREP!$GREP$ac_delim
-EGREP!$EGREP$ac_delim
-ALSA_CFLAGS!$ALSA_CFLAGS$ac_delim
-ALSA_LIBS!$ALSA_LIBS$ac_delim
-WINDRES!$WINDRES$ac_delim
-HAVE_WINDRES_TRUE!$HAVE_WINDRES_TRUE$ac_delim
-HAVE_WINDRES_FALSE!$HAVE_WINDRES_FALSE$ac_delim
-LIBOBJS!$LIBOBJS$ac_delim
-LTLIBOBJS!$LTLIBOBJS$ac_delim
-_ACEOF
-
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 10; then
-    break
-  elif $ac_last_try; then
-    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+# No need to generate the scripts if there are no CONFIG_FILES.
+# This happens for instance when ./config.status config.h
+if test -n "\$CONFIG_FILES"; then
+  # Protect against being on the right side of a sed subst in config.status.
+  sed 's/,@/@@/; s/@,/@@/; s/,;t t\$/@;t t/; /@;t t\$/s/[\\\\&,]/\\\\&/g;
+   s/@@/,@/; s/@@/@,/; s/@;t t\$/,;t t/' >\$tmp/subs.sed <<\\CEOF
+s,@SHELL@,$SHELL,;t t
+s,@PATH_SEPARATOR@,$PATH_SEPARATOR,;t t
+s,@PACKAGE_NAME@,$PACKAGE_NAME,;t t
+s,@PACKAGE_TARNAME@,$PACKAGE_TARNAME,;t t
+s,@PACKAGE_VERSION@,$PACKAGE_VERSION,;t t
+s,@PACKAGE_STRING@,$PACKAGE_STRING,;t t
+s,@PACKAGE_BUGREPORT@,$PACKAGE_BUGREPORT,;t t
+s,@exec_prefix@,$exec_prefix,;t t
+s,@prefix@,$prefix,;t t
+s,@program_transform_name@,$program_transform_name,;t t
+s,@bindir@,$bindir,;t t
+s,@sbindir@,$sbindir,;t t
+s,@libexecdir@,$libexecdir,;t t
+s,@datadir@,$datadir,;t t
+s,@sysconfdir@,$sysconfdir,;t t
+s,@sharedstatedir@,$sharedstatedir,;t t
+s,@localstatedir@,$localstatedir,;t t
+s,@libdir@,$libdir,;t t
+s,@includedir@,$includedir,;t t
+s,@oldincludedir@,$oldincludedir,;t t
+s,@infodir@,$infodir,;t t
+s,@mandir@,$mandir,;t t
+s,@build_alias@,$build_alias,;t t
+s,@host_alias@,$host_alias,;t t
+s,@target_alias@,$target_alias,;t t
+s,@DEFS@,$DEFS,;t t
+s,@ECHO_C@,$ECHO_C,;t t
+s,@ECHO_N@,$ECHO_N,;t t
+s,@ECHO_T@,$ECHO_T,;t t
+s,@LIBS@,$LIBS,;t t
+s,@build@,$build,;t t
+s,@build_cpu@,$build_cpu,;t t
+s,@build_vendor@,$build_vendor,;t t
+s,@build_os@,$build_os,;t t
+s,@host@,$host,;t t
+s,@host_cpu@,$host_cpu,;t t
+s,@host_vendor@,$host_vendor,;t t
+s,@host_os@,$host_os,;t t
+s,@target@,$target,;t t
+s,@target_cpu@,$target_cpu,;t t
+s,@target_vendor@,$target_vendor,;t t
+s,@target_os@,$target_os,;t t
+s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
+s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
+s,@INSTALL_DATA@,$INSTALL_DATA,;t t
+s,@CYGPATH_W@,$CYGPATH_W,;t t
+s,@PACKAGE@,$PACKAGE,;t t
+s,@VERSION@,$VERSION,;t t
+s,@ACLOCAL@,$ACLOCAL,;t t
+s,@AUTOCONF@,$AUTOCONF,;t t
+s,@AUTOMAKE@,$AUTOMAKE,;t t
+s,@AUTOHEADER@,$AUTOHEADER,;t t
+s,@MAKEINFO@,$MAKEINFO,;t t
+s,@install_sh@,$install_sh,;t t
+s,@STRIP@,$STRIP,;t t
+s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t
+s,@INSTALL_STRIP_PROGRAM@,$INSTALL_STRIP_PROGRAM,;t t
+s,@mkdir_p@,$mkdir_p,;t t
+s,@AWK@,$AWK,;t t
+s,@SET_MAKE@,$SET_MAKE,;t t
+s,@am__leading_dot@,$am__leading_dot,;t t
+s,@AMTAR@,$AMTAR,;t t
+s,@am__tar@,$am__tar,;t t
+s,@am__untar@,$am__untar,;t t
+s,@CC@,$CC,;t t
+s,@CFLAGS@,$CFLAGS,;t t
+s,@LDFLAGS@,$LDFLAGS,;t t
+s,@CPPFLAGS@,$CPPFLAGS,;t t
+s,@ac_ct_CC@,$ac_ct_CC,;t t
+s,@EXEEXT@,$EXEEXT,;t t
+s,@OBJEXT@,$OBJEXT,;t t
+s,@DEPDIR@,$DEPDIR,;t t
+s,@am__include@,$am__include,;t t
+s,@am__quote@,$am__quote,;t t
+s,@AMDEP_TRUE@,$AMDEP_TRUE,;t t
+s,@AMDEP_FALSE@,$AMDEP_FALSE,;t t
+s,@AMDEPBACKSLASH@,$AMDEPBACKSLASH,;t t
+s,@CCDEPMODE@,$CCDEPMODE,;t t
+s,@am__fastdepCC_TRUE@,$am__fastdepCC_TRUE,;t t
+s,@am__fastdepCC_FALSE@,$am__fastdepCC_FALSE,;t t
+s,@CPP@,$CPP,;t t
+s,@CXX@,$CXX,;t t
+s,@CXXFLAGS@,$CXXFLAGS,;t t
+s,@ac_ct_CXX@,$ac_ct_CXX,;t t
+s,@CXXDEPMODE@,$CXXDEPMODE,;t t
+s,@am__fastdepCXX_TRUE@,$am__fastdepCXX_TRUE,;t t
+s,@am__fastdepCXX_FALSE@,$am__fastdepCXX_FALSE,;t t
+s,@RANLIB@,$RANLIB,;t t
+s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
+s,@SDL_CONFIG@,$SDL_CONFIG,;t t
+s,@SDL_CFLAGS@,$SDL_CFLAGS,;t t
+s,@SDL_LIBS@,$SDL_LIBS,;t t
+s,@EGREP@,$EGREP,;t t
+s,@ALSA_CFLAGS@,$ALSA_CFLAGS,;t t
+s,@ALSA_LIBS@,$ALSA_LIBS,;t t
+s,@FREETYPE_CONFIG@,$FREETYPE_CONFIG,;t t
+s,@CXXCPP@,$CXXCPP,;t t
+s,@WINDRES@,$WINDRES,;t t
+s,@ac_ct_WINDRES@,$ac_ct_WINDRES,;t t
+s,@HAVE_WINDRES_TRUE@,$HAVE_WINDRES_TRUE,;t t
+s,@HAVE_WINDRES_FALSE@,$HAVE_WINDRES_FALSE,;t t
+s,@LIBOBJS@,$LIBOBJS,;t t
+s,@LTLIBOBJS@,$LTLIBOBJS,;t t
+CEOF
+
+_ACEOF
+
+  cat >>$CONFIG_STATUS <<\_ACEOF
+  # Split the substitutions into bite-sized pieces for seds with
+  # small command number limits, like on Digital OSF/1 and HP-UX.
+  ac_max_sed_lines=48
+  ac_sed_frag=1 # Number of current file.
+  ac_beg=1 # First line for current file.
+  ac_end=$ac_max_sed_lines # Line after last line for current file.
+  ac_more_lines=:
+  ac_sed_cmds=
+  while $ac_more_lines; do
+    if test $ac_beg -gt 1; then
+      sed "1,${ac_beg}d; ${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    else
+      sed "${ac_end}q" $tmp/subs.sed >$tmp/subs.frag
+    fi
+    if test ! -s $tmp/subs.frag; then
+      ac_more_lines=false
+    else
+      # The purpose of the label and of the branching condition is to
+      # speed up the sed processing (if there are no `@' at all, there
+      # is no need to browse any of the substitutions).
+      # These are the two extra sed commands mentioned above.
+      (echo ':t
+  /@[a-zA-Z_][a-zA-Z_0-9]*@/!b' && cat $tmp/subs.frag) >$tmp/subs-$ac_sed_frag.sed
+      if test -z "$ac_sed_cmds"; then
+	ac_sed_cmds="sed -f $tmp/subs-$ac_sed_frag.sed"
+      else
+	ac_sed_cmds="$ac_sed_cmds | sed -f $tmp/subs-$ac_sed_frag.sed"
+      fi
+      ac_sed_frag=`expr $ac_sed_frag + 1`
+      ac_beg=$ac_end
+      ac_end=`expr $ac_end + $ac_max_sed_lines`
+    fi
+  done
+  if test -z "$ac_sed_cmds"; then
+    ac_sed_cmds=cat
   fi
-done
-
-ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
-if test -n "$ac_eof"; then
-  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
-  ac_eof=`expr $ac_eof + 1`
-fi
+fi # test -n "$CONFIG_FILES"
 
-cat >>$CONFIG_STATUS <<_ACEOF
-cat >"\$tmp/subs-2.sed" <<\CEOF$ac_eof
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
-_ACEOF
-sed '
-s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
-s/^/s,@/; s/!/@,|#_!!_#|/
-:n
-t n
-s/'"$ac_delim"'$/,g/; t
-s/$/\\/; p
-N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
-' >>$CONFIG_STATUS <conf$$subs.sed
-rm -f conf$$subs.sed
-cat >>$CONFIG_STATUS <<_ACEOF
-:end
-s/|#_!!_#|//g
-CEOF$ac_eof
 _ACEOF
-
-
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
-s/:*$//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
 cat >>$CONFIG_STATUS <<\_ACEOF
-fi # test -n "$CONFIG_FILES"
-
-
-for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS    :C $CONFIG_COMMANDS
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-echo "$as_me: error: Invalid tag $ac_tag." >&2;}
-   { (exit 1); exit 1; }; };;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
-echo "$as_me: error: cannot find input file: $ac_f" >&2;}
-   { (exit 1); exit 1; }; };;
-      esac
-      ac_file_inputs="$ac_file_inputs $ac_f"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input="Generated from "`IFS=:
-	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    fi
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin";;
-    esac
-    ;;
+for ac_file in : $CONFIG_FILES; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
+  case $ac_file in
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
   esac
 
-  ac_dir=`$as_dirname -- "$ac_file" ||
+  # Compute @srcdir@, @top_srcdir@, and @INSTALL@ for subdirectories.
+  ac_dir=`(dirname "$ac_file") 2>/dev/null ||
 $as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$ac_file" : 'X\(//\)[^/]' \| \
 	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  { as_dir="$ac_dir"
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
     as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
     done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-echo "$as_me: error: cannot create directory $as_dir" >&2;}
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
    { (exit 1); exit 1; }; }; }
+
   ac_builddir=.
 
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
+if test "$ac_dir" != .; then
   ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
 
 case $srcdir in
-  .)  # We are building in place.
+  .)  # No --srcdir option.  We are building in place.
     ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
     ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
 
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
 
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
-  ac_MKDIR_P=$MKDIR_P
-  case $MKDIR_P in
-  [\\/$]* | ?:[\\/]* ) ;;
-  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
-  esac
-_ACEOF
 
-cat >>$CONFIG_STATUS <<\_ACEOF
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-
-case `sed -n '/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p
-' $ac_file_inputs` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-    s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    configure_input=
+  else
+    configure_input="$ac_file.  "
+  fi
+  configure_input=$configure_input"Generated from `echo $ac_file_in |
+				     sed 's,.*/,,'` by configure."
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
 _ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
 $extrasub
@@ -12650,175 +12942,387 @@
 cat >>$CONFIG_STATUS <<\_ACEOF
 :t
 /@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s&@configure_input@&$configure_input&;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-s&@MKDIR_P@&$ac_MKDIR_P&;t t
-$ac_datarootdir_hack
-" $ac_file_inputs | sed -f "$tmp/subs-1.sed" | sed -f "$tmp/subs-2.sed" >$tmp/out
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
-echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
+s,@configure_input@,$configure_input,;t t
+s,@srcdir@,$ac_srcdir,;t t
+s,@abs_srcdir@,$ac_abs_srcdir,;t t
+s,@top_srcdir@,$ac_top_srcdir,;t t
+s,@abs_top_srcdir@,$ac_abs_top_srcdir,;t t
+s,@builddir@,$ac_builddir,;t t
+s,@abs_builddir@,$ac_abs_builddir,;t t
+s,@top_builddir@,$ac_top_builddir,;t t
+s,@abs_top_builddir@,$ac_abs_top_builddir,;t t
+s,@INSTALL@,$ac_INSTALL,;t t
+" $ac_file_inputs | (eval "$ac_sed_cmds") >$tmp/out
+  rm -f $tmp/stdin
+  if test x"$ac_file" != x-; then
+    mv $tmp/out $ac_file
+  else
+    cat $tmp/out
+    rm -f $tmp/out
+  fi
+
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
+
+#
+# CONFIG_HEADER section.
+#
+
+# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
+# NAME is the cpp macro being defined and VALUE is the value it is being given.
+#
+# ac_d sets the value in "#define NAME VALUE" lines.
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
+ac_dC=' '
+ac_dD=',;t'
+# ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
+ac_uB='$,\1#\2define\3'
+ac_uC=' '
+ac_uD=',;t'
 
-  rm -f "$tmp/stdin"
+for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
+  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case $ac_file in
-  -) cat "$tmp/out"; rm -f "$tmp/out";;
-  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
+  - | *:- | *:-:* ) # input from stdin
+	cat >$tmp/stdin
+	ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
+	ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
+  * )   ac_file_in=$ac_file.in ;;
   esac
- ;;
-  :H)
-  #
-  # CONFIG_HEADER
-  #
-_ACEOF
-
-# Transform confdefs.h into a sed script `conftest.defines', that
-# substitutes the proper values into config.h.in to produce config.h.
-rm -f conftest.defines conftest.tail
-# First, append a space to every undef/define line, to ease matching.
-echo 's/$/ /' >conftest.defines
-# Then, protect against being on the right side of a sed subst, or in
-# an unquoted here document, in config.status.  If some macros were
-# called several times there might be several #defines for the same
-# symbol, which is useless.  But do not sort them, since the last
-# AC_DEFINE must be honored.
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-# These sed commands are passed to sed as "A NAME B PARAMS C VALUE D", where
-# NAME is the cpp macro being defined, VALUE is the value it is being given.
-# PARAMS is the parameter list in the macro definition--in most cases, it's
-# just an empty string.
-ac_dA='s,^\\([	 #]*\\)[^	 ]*\\([	 ]*'
-ac_dB='\\)[	 (].*,\\1define\\2'
-ac_dC=' '
-ac_dD=' ,'
 
-uniq confdefs.h |
-  sed -n '
-	t rset
-	:rset
-	s/^[	 ]*#[	 ]*define[	 ][	 ]*//
-	t ok
-	d
-	:ok
-	s/[\\&,]/\\&/g
-	s/^\('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/ '"$ac_dA"'\1'"$ac_dB"'\2'"${ac_dC}"'\3'"$ac_dD"'/p
-	s/^\('"$ac_word_re"'\)[	 ]*\(.*\)/'"$ac_dA"'\1'"$ac_dB$ac_dC"'\2'"$ac_dD"'/p
-  ' >>conftest.defines
+  test x"$ac_file" != x- && { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+
+  # First look for the input files in the build tree, otherwise in the
+  # src tree.
+  ac_file_inputs=`IFS=:
+    for f in $ac_file_in; do
+      case $f in
+      -) echo $tmp/stdin ;;
+      [\\/$]*)
+	 # Absolute (can't be DOS-style, as IFS=:)
+	 test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
+      *) # Relative
+	 if test -f "$f"; then
+	   # Build tree
+	   echo "$f"
+	 elif test -f "$srcdir/$f"; then
+	   # Source tree
+	   echo "$srcdir/$f"
+	 else
+	   # /dev/null tree
+	   { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
+echo "$as_me: error: cannot find input file: $f" >&2;}
+   { (exit 1); exit 1; }; }
+	 fi;;
+      esac
+    done` || { (exit 1); exit 1; }
+  # Remove the trailing spaces.
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
+
+_ACEOF
+
+# Transform confdefs.h into two sed scripts, `conftest.defines' and
+# `conftest.undefs', that substitutes the proper values into
+# config.h.in to produce config.h.  The first handles `#define'
+# templates, and the second `#undef' templates.
+# And first: Protect against being on the right side of a sed subst in
+# config.status.  Protect against being in an unquoted here document
+# in config.status.
+rm -f conftest.defines conftest.undefs
+# Using a here document instead of a string reduces the quoting nightmare.
+# Putting comments in sed scripts is not portable.
+#
+# `end' is used to avoid that the second main sed command (meant for
+# 0-ary CPP macros) applies to n-ary macro definitions.
+# See the Autoconf documentation for `clear'.
+cat >confdef2sed.sed <<\_ACEOF
+s/[\\&,]/\\&/g
+s,[\\$`],\\&,g
+t clear
+: clear
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+t end
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+: end
+_ACEOF
+# If some macros were called several times there might be several times
+# the same #defines, which is useless.  Nevertheless, we may not want to
+# sort them, since we want the *last* AC-DEFINE to be honored.
+uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
+sed 's/ac_d/ac_u/g' conftest.defines >conftest.undefs
+rm -f confdef2sed.sed
 
-# Remove the space that was appended to ease matching.
-# Then replace #undef with comments.  This is necessary, for
+# This sed command replaces #undef with comments.  This is necessary, for
 # example, in the case of _POSIX_SOURCE, which is predefined and required
 # on some systems where configure will not decide to define it.
-# (The regexp can be short, since the line contains either #define or #undef.)
-echo 's/ $//
-s,^[	 #]*u.*,/* & */,' >>conftest.defines
-
-# Break up conftest.defines:
-ac_max_sed_lines=50
-
-# First sed command is:	 sed -f defines.sed $ac_file_inputs >"$tmp/out1"
-# Second one is:	 sed -f defines.sed "$tmp/out1" >"$tmp/out2"
-# Third one will be:	 sed -f defines.sed "$tmp/out2" >"$tmp/out1"
-# et cetera.
-ac_in='$ac_file_inputs'
-ac_out='"$tmp/out1"'
-ac_nxt='"$tmp/out2"'
-
-while :
-do
-  # Write a here document:
-    cat >>$CONFIG_STATUS <<_ACEOF
-    # First, check the format of the line:
-    cat >"\$tmp/defines.sed" <<\\CEOF
-/^[	 ]*#[	 ]*undef[	 ][	 ]*$ac_word_re[	 ]*\$/b def
-/^[	 ]*#[	 ]*define[	 ][	 ]*$ac_word_re[(	 ]/b def
-b
-:def
+cat >>conftest.undefs <<\_ACEOF
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
 _ACEOF
-  sed ${ac_max_sed_lines}q conftest.defines >>$CONFIG_STATUS
+
+# Break up conftest.defines because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
+echo '  :' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.defines >/dev/null
+do
+  # Write a limited-size here document to $tmp/defines.sed.
+  echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#define' lines.
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
   echo 'CEOF
-    sed -f "$tmp/defines.sed"' "$ac_in >$ac_out" >>$CONFIG_STATUS
-  ac_in=$ac_out; ac_out=$ac_nxt; ac_nxt=$ac_in
-  sed 1,${ac_max_sed_lines}d conftest.defines >conftest.tail
-  grep . conftest.tail >/dev/null || break
+  sed -f $tmp/defines.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.defines >conftest.tail
   rm -f conftest.defines
   mv conftest.tail conftest.defines
 done
-rm -f conftest.defines conftest.tail
+rm -f conftest.defines
+echo '  fi # grep' >>$CONFIG_STATUS
+echo >>$CONFIG_STATUS
+
+# Break up conftest.undefs because some shells have a limit on the size
+# of here documents, and old seds have small limits too (100 cmds).
+echo '  # Handle all the #undef templates' >>$CONFIG_STATUS
+rm -f conftest.tail
+while grep . conftest.undefs >/dev/null
+do
+  # Write a limited-size here document to $tmp/undefs.sed.
+  echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
+  # Speed up: don't consider the non `#undef'
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
+  # Work around the forget-to-reset-the-flag bug.
+  echo 't clr' >>$CONFIG_STATUS
+  echo ': clr' >>$CONFIG_STATUS
+  sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
+  echo 'CEOF
+  sed -f $tmp/undefs.sed $tmp/in >$tmp/out
+  rm -f $tmp/in
+  mv $tmp/out $tmp/in
+' >>$CONFIG_STATUS
+  sed 1,${ac_max_here_lines}d conftest.undefs >conftest.tail
+  rm -f conftest.undefs
+  mv conftest.tail conftest.undefs
+done
+rm -f conftest.undefs
 
-echo "ac_result=$ac_in" >>$CONFIG_STATUS
 cat >>$CONFIG_STATUS <<\_ACEOF
+  # Let's still pretend it is `configure' which instantiates (i.e., don't
+  # use $as_me), people would be surprised to read:
+  #    /* config.h.  Generated by config.status.  */
+  if test x"$ac_file" = x-; then
+    echo "/* Generated by configure.  */" >$tmp/config.h
+  else
+    echo "/* $ac_file.  Generated by configure.  */" >$tmp/config.h
+  fi
+  cat $tmp/in >>$tmp/config.h
+  rm -f $tmp/in
   if test x"$ac_file" != x-; then
-    echo "/* $configure_input  */" >"$tmp/config.h"
-    cat "$ac_result" >>"$tmp/config.h"
-    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
+    if diff $ac_file $tmp/config.h >/dev/null 2>&1; then
       { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
 echo "$as_me: $ac_file is unchanged" >&6;}
     else
+      ac_dir=`(dirname "$ac_file") 2>/dev/null ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+      { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
       rm -f $ac_file
-      mv "$tmp/config.h" $ac_file
+      mv $tmp/config.h $ac_file
     fi
   else
-    echo "/* $configure_input  */"
-    cat "$ac_result"
+    cat $tmp/config.h
+    rm -f $tmp/config.h
   fi
-  rm -f "$tmp/out12"
 # Compute $ac_file's index in $config_headers.
-_am_arg=$ac_file
 _am_stamp_count=1
 for _am_header in $config_headers :; do
   case $_am_header in
-    $_am_arg | $_am_arg:* )
+    $ac_file | $ac_file:* )
       break ;;
     * )
       _am_stamp_count=`expr $_am_stamp_count + 1` ;;
   esac
 done
-echo "timestamp for $_am_arg" >`$as_dirname -- "$_am_arg" ||
-$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$_am_arg" : 'X\(//\)[^/]' \| \
-	 X"$_am_arg" : 'X\(//\)$' \| \
-	 X"$_am_arg" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$_am_arg" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`/stamp-h$_am_stamp_count
- ;;
+echo "timestamp for $ac_file" >`(dirname $ac_file) 2>/dev/null ||
+$as_expr X$ac_file : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X$ac_file : 'X\(//\)[^/]' \| \
+	 X$ac_file : 'X\(//\)$' \| \
+	 X$ac_file : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X$ac_file |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`/stamp-h$_am_stamp_count
+done
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF
 
-  :C)  { echo "$as_me:$LINENO: executing $ac_file commands" >&5
-echo "$as_me: executing $ac_file commands" >&6;}
- ;;
-  esac
+#
+# CONFIG_COMMANDS section.
+#
+for ac_file in : $CONFIG_COMMANDS; do test "x$ac_file" = x: && continue
+  ac_dest=`echo "$ac_file" | sed 's,:.*,,'`
+  ac_source=`echo "$ac_file" | sed 's,[^:]*:,,'`
+  ac_dir=`(dirname "$ac_dest") 2>/dev/null ||
+$as_expr X"$ac_dest" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_dest" : 'X\(//\)[^/]' \| \
+	 X"$ac_dest" : 'X\(//\)$' \| \
+	 X"$ac_dest" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$ac_dest" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+  { if $as_mkdir_p; then
+    mkdir -p "$ac_dir"
+  else
+    as_dir="$ac_dir"
+    as_dirs=
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
+echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    done
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory \"$ac_dir\"" >&5
+echo "$as_me: error: cannot create directory \"$ac_dir\"" >&2;}
+   { (exit 1); exit 1; }; }; }
+
+  ac_builddir=.
+
+if test "$ac_dir" != .; then
+  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
+  # A "../" for each directory in $ac_dir_suffix.
+  ac_top_builddir=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,../,g'`
+else
+  ac_dir_suffix= ac_top_builddir=
+fi
+
+case $srcdir in
+  .)  # No --srcdir option.  We are building in place.
+    ac_srcdir=.
+    if test -z "$ac_top_builddir"; then
+       ac_top_srcdir=.
+    else
+       ac_top_srcdir=`echo $ac_top_builddir | sed 's,/$,,'`
+    fi ;;
+  [\\/]* | ?:[\\/]* )  # Absolute path.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir ;;
+  *) # Relative path.
+    ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_builddir$srcdir ;;
+esac
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
-  case $ac_file$ac_mode in
-    "depfiles":C) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
+  { echo "$as_me:$LINENO: executing $ac_dest commands" >&5
+echo "$as_me: executing $ac_dest commands" >&6;}
+  case $ac_dest in
+    depfiles ) test x"$AMDEP_TRUE" != x"" || for mf in $CONFIG_FILES; do
   # Strip MF so we end up with the name of the file.
   mf=`echo "$mf" | sed -e 's/:.*$//'`
   # Check whether this is an Automake generated Makefile or not.
@@ -12826,32 +13330,20 @@
   # some people rename them; so instead we look at the file content.
   # Grep'ing the first line is not enough: some people post-process
   # each Makefile.in and add a new line on top of each file to say so.
-  # Grep'ing the whole file is not good either: AIX grep has a line
-  # limit of 2048, but all sed's we know have understand at least 4000.
-  if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
-    dirpart=`$as_dirname -- "$mf" ||
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`(dirname "$mf") 2>/dev/null ||
 $as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$mf" : 'X\(//\)[^/]' \| \
 	 X"$mf" : 'X\(//\)$' \| \
-	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$mf" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$mf" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
   else
     continue
   fi
@@ -12873,79 +13365,53 @@
        sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
     # Make sure the directory exists.
     test -f "$dirpart/$file" && continue
-    fdir=`$as_dirname -- "$file" ||
+    fdir=`(dirname "$file") 2>/dev/null ||
 $as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$file" : 'X\(//\)[^/]' \| \
 	 X"$file" : 'X\(//\)$' \| \
-	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$file" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-    { as_dir=$dirpart/$fdir
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
+    { if $as_mkdir_p; then
+    mkdir -p $dirpart/$fdir
+  else
+    as_dir=$dirpart/$fdir
     as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
+    while test ! -d "$as_dir"; do
+      as_dirs="$as_dir $as_dirs"
+      as_dir=`(dirname "$as_dir") 2>/dev/null ||
 $as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
 	 X"$as_dir" : 'X\(//\)[^/]' \| \
 	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+	 X"$as_dir" : 'X\(/\)' \| \
+	 .     : '\(.\)' 2>/dev/null ||
 echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{ s//\1/; q; }
+  	  /^X\(\/\/\)[^/].*/{ s//\1/; q; }
+  	  /^X\(\/\/\)$/{ s//\1/; q; }
+  	  /^X\(\/\).*/{ s//\1/; q; }
+  	  s/.*/./; q'`
     done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-echo "$as_me: error: cannot create directory $as_dir" >&2;}
+    test ! -n "$as_dirs" || mkdir $as_dirs
+  fi || { { echo "$as_me:$LINENO: error: cannot create directory $dirpart/$fdir" >&5
+echo "$as_me: error: cannot create directory $dirpart/$fdir" >&2;}
    { (exit 1); exit 1; }; }; }
+
     # echo "creating $dirpart/$file"
     echo '# dummy' > "$dirpart/$file"
   done
 done
  ;;
-
   esac
-done # for ac_tag
+done
+_ACEOF
 
+cat >>$CONFIG_STATUS <<\_ACEOF
 
 { (exit 0); exit 0; }
 _ACEOF
diff -urN dosbox-0.73/configure.in dosboxcvs/configure.in
--- dosbox-0.73/configure.in	2009-05-20 20:34:13.000000000 +0300
+++ dosboxcvs/configure.in	2009-07-08 20:43:48.000000000 +0300
@@ -341,16 +341,39 @@
   AC_MSG_RESULT(no)
 fi
 
+AH_TEMPLATE(C_LIBPNG,[Define to 1 if you have libpng])
 AH_TEMPLATE(C_SSHOT,[Define to 1 to enable screenshots, requires libpng])
 AC_CHECK_HEADER(png.h,have_png_h=yes,)
 AC_CHECK_LIB(png, png_check_sig, have_png_lib=yes, ,-lz)
 if test x$have_png_lib = xyes -a x$have_png_h = xyes ; then
   LIBS="$LIBS -lpng -lz"
+  AC_DEFINE(C_LIBPNG,1)
   AC_DEFINE(C_SSHOT,1)
 else
   AC_MSG_WARN([Can't find libpng, screenshot support disabled])
 fi
 
+AH_TEMPLATE(C_PRINTER,[Define to 1 to use printer support])
+AC_ARG_ENABLE(printer,AC_HELP_STRING([--disable-printer],[Disable printer support]),,enable_printer=yes)
+AC_PATH_PROG(FREETYPE_CONFIG, freetype-config, no)
+if test "$FREETYPE_CONFIG" = "no" ; then
+   AC_MSG_WARN([Can't find FreeType2, printer disabled])
+else
+    AC_DEFINE(C_PRINTER,1)
+    CXXFLAGS="$CXXFLAGS `$FREETYPE_CONFIG --cflags`"
+    LIBS="$LIBS `$FREETYPE_CONFIG --libs`"
+fi
+
+AH_TEMPLATE(C_NE2000,[Define to 1 to enable NE2000 ethernet passthrough, requires libpcap])
+AC_CHECK_HEADER(pcap.h,have_pcap_h=yes,)
+AC_CHECK_LIB(pcap, pcap_open_live, have_pcap_lib=yes, ,-lz)
+if test x$have_pcap_lib = xyes -a x$have_pcap_h = xyes ; then
+  LIBS="$LIBS -lpcap";
+  AC_DEFINE(C_NE2000,1)
+else
+  AC_MSG_WARN([Can't find libpcap, NE2000 ethernet passthrough disabled])
+fi
+
 AH_TEMPLATE(C_MODEM,[Define to 1 to enable internal modem support, requires SDL_net])
 AH_TEMPLATE(C_IPX,[Define to 1 to enable IPX over Internet networking, requires SDL_net])
 AC_CHECK_HEADER(SDL_net.h,have_sdl_net_h=yes,)
@@ -446,13 +469,59 @@
 };
 ],AC_MSG_RESULT(yes);AC_DEFINE(C_SET_PRIORITY,1),AC_MSG_RESULT(no))
 
+AH_TEMPLATE(C_HAVE_PHYSFS,[Define to 1 if you have physfs library])
+AC_CHECK_LIB(physfs, PHYSFS_init, have_PHYSFS_init=yes,,)
+if test x$have_PHYSFS_init = xyes ; then
+    AC_DEFINE(C_HAVE_PHYSFS,1)
+    LIBS="$LIBS -lphysfs -lz"
+else
+    AC_MSG_WARN([Can't find PHYSFS_init])
+fi
 
 dnl Some target detection and actions for them
 case "$target" in
     *-*-cygwin* | *-*-mingw32*)
        LIBS="$LIBS -lwinmm"
+       AH_TEMPLATE(C_D3DSHADERS,[Define to 1 to use Direct3D shaders, requires d3d9.h and libd3dx9])
+       AC_ARG_WITH(dx-headers,[  --with-dx-headers=DIR   DirectX include files location],
+     		   dx_headers="$withval", dx_headers="")
+       AC_ARG_WITH(dx-libs,[  --with-dx-libs=DIR      DirectX library location],
+     		   dx_libs="$withval", dx_libs="")
+       ac_save_CPPFLAGS=$CPPFLAGS
+       if test x$dx_headers != x ; then
+        CPPFLAGS="$CPPFLAGS -I$dx_headers"
+       fi
+       AC_LANG(C++)
        AC_CHECK_HEADERS(ddraw.h)
+       AC_CHECK_HEADERS(d3d9.h,have_d3d9_h=yes,)
+       AC_MSG_CHECKING(whether direct3d display output will be enabled)
+       if test x$have_d3d9_h = xyes ; then
+        AC_MSG_RESULT(yes)
+        AC_ARG_ENABLE(shaders,AC_HELP_STRING([--disable-shaders],[Disable d3d pixelshader support (which requires libd3dx9)]),,[
+     		AC_MSG_CHECKING(whether direct3d pixelshaders will be enabled)
+ 		ac_save_LIBS=$LIBS
+ 		if test x$dx_libs != x ; then
+ 		 dx_libs=" -L$dx_libs"
+ 		fi
+ 		LIBS="$LIBS$dx_libs -ld3dx9"
+ 		AC_TRY_LINK([#include <d3d9.h>
+ 		    	     #include <d3dx9.h>
+ 			     extern "C" int main();],D3DXCreateEffect(0, 0, 0, 0, 0, 0, 0, 0, 0), have_d3dx9_lib=yes,)
+ 		if test x$have_d3dx9_lib = xyes ; then
+     		 AC_MSG_RESULT(yes)
+ 		 AC_DEFINE(C_D3DSHADERS,1)
+ 		else
+ 		 LIBS=$ac_save_LIBS
+     		 AC_MSG_RESULT(no)
+ 		 AC_MSG_WARN([Can't find libd3dx9, pixelshader support disabled])
+ 		fi
+	],)
+       else
+	CPPFLAGS=$ac_save_CPPFLAGS
+        AC_MSG_RESULT(no)
+       fi
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2 only).])
+       AC_DEFINE(C_DIRECTLPT, 1, [ Define to 1 if you want parallel passthrough support (Win32 only).])
        if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
          LIBS="$LIBS -lws2_32"
        fi
@@ -469,6 +538,7 @@
     *-*-linux*)
        AC_DEFINE(LINUX, 1, [Compiling on GNU/Linux])
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).])
+       AC_DEFINE(C_DIRECTLPT, 1, [ Define to 1 if you want parallel passthrough support (Win32, Linux).])
        ;;
     *-*-freebsd* | *-*-dragonfly* | *-*-netbsd* | *-*-openbsd*)
        dnl Disabled directserial for now. It doesn't do anything without
@@ -513,10 +583,12 @@
 src/gui/Makefile
 src/hardware/Makefile
 src/hardware/serialport/Makefile
+src/hardware/parport/Makefile
 src/ints/Makefile
 src/libs/Makefile
 src/libs/zmbv/Makefile
 src/libs/gui_tk/Makefile
+src/libs/porttalk/Makefile
 src/misc/Makefile
 src/shell/Makefile
 src/platform/Makefile
diff -urN dosbox-0.73/.cvsignore dosboxcvs/.cvsignore
--- dosbox-0.73/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/.cvsignore	2004-07-18 19:56:07.000000000 +0300
@@ -0,0 +1,16 @@
+aclocal.m4
+autom4te.cache
+config.h
+config.h.in
+config.log
+config.status
+config.guess
+config.sub
+configure
+depcomp
+install-sh
+Makefile
+Makefile.in
+missing
+mkinstalldirs
+stamp-h1
diff -urN dosbox-0.73/depcomp dosboxcvs/depcomp
--- dosbox-0.73/depcomp	2008-12-11 11:05:36.000000000 +0200
+++ dosboxcvs/depcomp	2009-07-04 14:45:18.000000000 +0300
@@ -1,9 +1,9 @@
 #! /bin/sh
 # depcomp - compile a program generating dependencies as side-effects
 
-scriptversion=2007-03-29.01
+scriptversion=2006-10-15.18
 
-# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006, 2007 Free Software
+# Copyright (C) 1999, 2000, 2003, 2004, 2005, 2006 Free Software
 # Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
@@ -215,39 +215,34 @@
   # current directory.  Also, the AIX compiler puts `$object:' at the
   # start of each line; $object doesn't have directory information.
   # Version 6 uses the directory in both cases.
-  dir=`echo "$object" | sed -e 's|/[^/]*$|/|'`
-  test "x$dir" = "x$object" && dir=
-  base=`echo "$object" | sed -e 's|^.*/||' -e 's/\.o$//' -e 's/\.lo$//'`
+  stripped=`echo "$object" | sed 's/\(.*\)\..*$/\1/'`
+  tmpdepfile="$stripped.u"
   if test "$libtool" = yes; then
-    tmpdepfile1=$dir$base.u
-    tmpdepfile2=$base.u
-    tmpdepfile3=$dir.libs/$base.u
     "$@" -Wc,-M
   else
-    tmpdepfile1=$dir$base.u
-    tmpdepfile2=$dir$base.u
-    tmpdepfile3=$dir$base.u
     "$@" -M
   fi
   stat=$?
 
+  if test -f "$tmpdepfile"; then :
+  else
+    stripped=`echo "$stripped" | sed 's,^.*/,,'`
+    tmpdepfile="$stripped.u"
+  fi
+
   if test $stat -eq 0; then :
   else
-    rm -f "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
+    rm -f "$tmpdepfile"
     exit $stat
   fi
 
-  for tmpdepfile in "$tmpdepfile1" "$tmpdepfile2" "$tmpdepfile3"
-  do
-    test -f "$tmpdepfile" && break
-  done
   if test -f "$tmpdepfile"; then
+    outname="$stripped.o"
     # Each line is of the form `foo.o: dependent.h'.
     # Do two passes, one to just change these to
     # `$object: dependent.h' and one to simply `dependent.h:'.
-    sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
-    # That's a tab and a space in the [].
-    sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+    sed -e "s,^$outname:,$object :," < "$tmpdepfile" > "$depfile"
+    sed -e "s,^$outname: \(.*\)$,\1:," < "$tmpdepfile" >> "$depfile"
   else
     # The sourcefile does not contain any dependencies, so just
     # store a dummy comment line, to avoid errors with the Makefile
diff -urN dosbox-0.73/docs/.cvsignore dosboxcvs/docs/.cvsignore
--- dosbox-0.73/docs/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/docs/.cvsignore	2003-03-31 11:57:47.000000000 +0300
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
\ No newline at end of file
diff -urN dosbox-0.73/docs/Makefile.in dosboxcvs/docs/Makefile.in
--- dosbox-0.73/docs/Makefile.in	2009-05-20 21:29:05.000000000 +0300
+++ dosboxcvs/docs/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,11 +15,15 @@
 @SET_MAKE@
 
 # Main Makefile for DOSBox
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -54,6 +58,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -65,6 +71,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -75,8 +82,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -86,7 +94,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -104,12 +111,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -121,43 +131,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 man_MANS = dosbox.1 
 EXTRA_DIST = $(man_MANS) README.video PORTING
 all: all-am
@@ -192,9 +191,10 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 install-man1: $(man1_MANS) $(man_MANS)
 	@$(NORMAL_INSTALL)
-	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
+	test -z "$(man1dir)" || $(mkdir_p) "$(DESTDIR)$(man1dir)"
 	@list='$(man1_MANS) $(dist_man1_MANS) $(nodist_man1_MANS)'; \
 	l2='$(man_MANS) $(dist_man_MANS) $(nodist_man_MANS)'; \
 	for i in $$l2; do \
@@ -245,21 +245,22 @@
 
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -275,7 +276,7 @@
 all-am: Makefile $(MANS)
 installdirs:
 	for dir in "$(DESTDIR)$(man1dir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
 	done
 install: install-am
 install-exec: install-exec-am
@@ -321,20 +322,12 @@
 
 install-data-am: install-man
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man: install-man1
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -353,22 +346,18 @@
 
 ps-am:
 
-uninstall-am: uninstall-man
+uninstall-am: uninstall-info-am uninstall-man
 
 uninstall-man: uninstall-man1
 
-.MAKE: install-am install-strip
-
 .PHONY: all all-am check check-am clean clean-generic distclean \
 	distclean-generic distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-man1 install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-man1 install-strip installcheck installcheck-am \
 	installdirs maintainer-clean maintainer-clean-generic \
 	mostlyclean mostlyclean-generic pdf pdf-am ps ps-am uninstall \
-	uninstall-am uninstall-man uninstall-man1
+	uninstall-am uninstall-info-am uninstall-man uninstall-man1
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/include/bios.h dosboxcvs/include/bios.h
--- dosbox-0.73/include/bios.h	2009-05-25 21:44:43.000000000 +0300
+++ dosboxcvs/include/bios.h	2009-07-08 20:43:08.000000000 +0300
@@ -101,6 +101,12 @@
 
 #define BIOS_VIDEO_SAVEPTR              0x4a8
 
+
+#define BIOS_DEFAULT_HANDLER_LOCATION	(RealMake(0xf000,0xff53))
+#define BIOS_DEFAULT_IRQ0_LOCATION		(RealMake(0xf000,0xfea5))
+#define BIOS_DEFAULT_IRQ1_LOCATION		(RealMake(0xf000,0xe987))
+#define BIOS_DEFAULT_IRQ2_LOCATION		(RealMake(0xf000,0xff55))
+
 /* maximum of scancodes handled by keyboard bios routines */
 #define MAX_SCAN_CODE 0x58
 
@@ -123,5 +129,6 @@
 void INT10_ReloadRomFonts();
 
 void BIOS_SetComPorts (Bit16u baseaddr[]);
+void BIOS_SetLPTPorts (Bit16u baseaddr[]);
 
 #endif
diff -urN dosbox-0.73/include/callback.h dosboxcvs/include/callback.h
--- dosbox-0.73/include/callback.h	2009-05-27 12:15:40.000000000 +0300
+++ dosboxcvs/include/callback.h	2009-07-08 20:43:08.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: callback.h,v 1.24 2009/05/27 09:15:40 qbix79 Exp $ */
+/* $Id: callback.h,v 1.25 2009/06/11 16:05:17 c2woody Exp $ */
 
 #ifndef DOSBOX_CALLBACK_H
 #define DOSBOX_CALLBACK_H
@@ -30,12 +30,13 @@
 
 enum { CB_RETN,CB_RETF,CB_RETF8,CB_IRET,CB_IRETD,CB_IRET_STI,CB_IRET_EOI_PIC1,
 		CB_IRQ0,CB_IRQ1,CB_IRQ9,CB_IRQ12,CB_IRQ12_RET,CB_IRQ6_PCJR,CB_MOUSE,
-		CB_INT29,CB_INT16,CB_HOOKABLE,CB_TDE_IRET,CB_IPXESR,CB_IPXESR_RET,
+		CB_INT29,CB_INT16,CB_HOOKABLE,CB_TDE_IRET,CB_IPXESR,CB_IPXESR_RET,CB_VESA_START,
 		CB_INT21 };
 
-#define CB_MAX 128
-#define CB_SIZE 32
-#define CB_SEG 0xF100
+#define CB_MAX		128
+#define CB_SIZE		32
+#define CB_SEG		0xF000
+#define CB_SOFFSET	0x1000
 
 enum {	
 	CBRET_NONE=0,CBRET_STOP=1
@@ -44,14 +45,14 @@
 extern Bit8u lastint;
 
 static INLINE RealPt CALLBACK_RealPointer(Bitu callback) {
-	return RealMake(CB_SEG,(Bit16u)(callback*CB_SIZE));
+	return RealMake(CB_SEG,(Bit16u)(CB_SOFFSET+callback*CB_SIZE));
 }
 static INLINE PhysPt CALLBACK_PhysPointer(Bitu callback) {
-	return PhysMake(CB_SEG,(Bit16u)(callback*CB_SIZE));
+	return PhysMake(CB_SEG,(Bit16u)(CB_SOFFSET+callback*CB_SIZE));
 }
 
 static INLINE PhysPt CALLBACK_GetBase(void) {
-	return CB_SEG << 4;
+	return (CB_SEG << 4) + CB_SOFFSET;
 }
 
 Bitu CALLBACK_Allocate();
@@ -77,7 +78,7 @@
 class CALLBACK_HandlerObject{
 private:
 	bool installed;
-	Bit16u m_callback;
+	Bitu m_callback;
 	enum {NONE,SETUP,SETUPAT} m_type;
     struct {	
 		RealPt old_vector;
@@ -85,15 +86,23 @@
 		bool installed;
 	} vectorhandler;
 public:
-	CALLBACK_HandlerObject():installed(false),m_type(NONE){vectorhandler.installed=false;}
+	CALLBACK_HandlerObject():installed(false),m_type(NONE) {
+		vectorhandler.installed=false;
+	}
 	~CALLBACK_HandlerObject();
+
 	//Install and allocate a callback.
 	void Install(CallBack_Handler handler,Bitu type,const char* description);
 	void Install(CallBack_Handler handler,Bitu type,PhysPt addr,const char* description);
+
 	//Only allocate a callback number
 	void Allocate(CallBack_Handler handler,const char* description=0);
-	Bit16u Get_callback(){return m_callback;}
-	RealPt Get_RealPointer(){ return CALLBACK_RealPointer(m_callback);}
+	Bit16u Get_callback() {
+		return (Bit16u)m_callback;
+	}
+	RealPt Get_RealPointer() {
+		return CALLBACK_RealPointer(m_callback);
+	}
 	void Set_RealVec(Bit8u vec);
 };
 #endif
diff -urN dosbox-0.73/include/cpu.h dosboxcvs/include/cpu.h
--- dosbox-0.73/include/cpu.h	2009-05-27 12:15:40.000000000 +0300
+++ dosboxcvs/include/cpu.h	2009-07-08 20:43:15.000000000 +0300
@@ -59,6 +59,9 @@
 extern bool CPU_CycleAutoAdjust;
 extern bool CPU_SkipCycleAutoAdjust;
 extern Bitu CPU_AutoDetermineMode;
+extern Bitu CPU_CyclesCur;
+extern Bit32s CPU_CyclesSet;
+extern char core_mode[16];
 
 extern Bitu CPU_ArchitectureType;
 
diff -urN dosbox-0.73/include/.cvsignore dosboxcvs/include/.cvsignore
--- dosbox-0.73/include/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/.cvsignore	2003-03-06 14:03:39.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/include/delayReverb.h dosboxcvs/include/delayReverb.h
--- dosbox-0.73/include/delayReverb.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/delayReverb.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,57 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_DELAYREVERB_H
+#define MT32EMU_DELAYREVERB_H
+
+namespace MT32Emu {
+
+class DelayReverb : public ReverbModel {
+private:
+	float *buf;
+
+	unsigned int sampleRate;
+	unsigned int bufSize;
+	unsigned int bufIx;
+	unsigned int rampCount;
+	unsigned int rampTarget;
+
+	unsigned int leftDelay;
+	unsigned int rightDelay;
+
+	float leftDelaySeconds;
+	float rightDelaySeconds;
+	float targetReverbLevel;
+	float reverbLevelRampInc;
+	float reverbLevel;
+
+	float targetFeedbackLevel;
+	float feedbackLevelRampInc;
+	float feedbackLevel;
+
+	void resetBuffer();
+	void resetParameters();
+
+public:
+	DelayReverb();
+	~DelayReverb();
+	void setSampleRate(unsigned int sampleRate);
+	void setParameters(Bit8u mode, Bit8u time, Bit8u level);
+	void process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, long numSamples);
+	void reset();
+};
+}
+#endif
diff -urN dosbox-0.73/include/dos_inc.h dosboxcvs/include/dos_inc.h
--- dosbox-0.73/include/dos_inc.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/include/dos_inc.h	2009-07-08 20:43:08.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: dos_inc.h,v 1.78 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: dos_inc.h,v 1.79 2009/07/02 18:56:11 c2woody Exp $ */
 
 #ifndef DOSBOX_DOS_INC_H
 #define DOSBOX_DOS_INC_H
@@ -86,7 +86,7 @@
 #define DOS_SDA_OFS 0
 #define DOS_CDS_SEG 0x108
 #define DOS_FIRST_SHELL 0x118
-#define DOS_MEM_START 0x158		//First Segment that DOS can use
+#define DOS_MEM_START 0x170		//First Segment that DOS can use
 
 #define DOS_PRIVATE_SEGMENT 0xc800
 #define DOS_PRIVATE_SEGMENT_END 0xd000
@@ -605,6 +605,7 @@
 
 struct DOS_Block {
 	DOS_Date date;
+	bool hostdate;
 	DOS_Version version;
 	Bit16u firstMCB;
 	Bit16u errorcode;
diff -urN dosbox-0.73/include/dos_system.h dosboxcvs/include/dos_system.h
--- dosbox-0.73/include/dos_system.h	2009-05-25 21:44:43.000000000 +0300
+++ dosboxcvs/include/dos_system.h	2009-07-08 20:43:48.000000000 +0300
@@ -121,18 +121,19 @@
 /* The following variable can be lowered to free up some memory.
  * The negative side effect: The stored searches will be turned over faster.
  * Should not have impact on systems with few directory entries. */
+class DOS_Drive;
 #define MAX_OPENDIRS 2048
 //Can be high as it's only storage (16 bit variable)
 
 class DOS_Drive_Cache {
 public:
 	DOS_Drive_Cache					(void);
-	DOS_Drive_Cache					(const char* path);
+	DOS_Drive_Cache					(const char* path, DOS_Drive *drive); 
 	~DOS_Drive_Cache				(void);
 
 	enum TDirSort { NOSORT, ALPHABETICAL, DIRALPHABETICAL, ALPHABETICALREV, DIRALPHABETICALREV };
 
-	void		SetBaseDir			(const char* path);
+	void		SetBaseDir			(const char* path, DOS_Drive *drive);
 	void		SetDirSort			(TDirSort sort) { sortDirType = sort; };
 	bool		OpenDir				(const char* path, Bit16u& id);
 	bool		ReadDir				(Bit16u id, char* &result);
@@ -193,6 +194,7 @@
 
 	CFileInfo*	dirBase;
 	char		dirPath				[CROSS_LEN];
+	DOS_Drive*	drive;
 	char		basePath			[CROSS_LEN];
 	bool		dirFirstTime;
 	TDirSort	sortDirType;
@@ -215,33 +217,38 @@
 public:
 	DOS_Drive();
 	virtual ~DOS_Drive(){};
-	virtual bool FileOpen(DOS_File * * file,char * name,Bit32u flags)=0;
-	virtual bool FileCreate(DOS_File * * file,char * name,Bit16u attributes)=0;
-	virtual bool FileUnlink(char * _name)=0;
-	virtual bool RemoveDir(char * _dir)=0;
-	virtual bool MakeDir(char * _dir)=0;
-	virtual bool TestDir(char * _dir)=0;
-	virtual bool FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst=false)=0;
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags)=0;
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes)=0;
+	virtual bool FileUnlink(const char * _name)=0;
+	virtual bool RemoveDir(const char * _dir)=0;
+	virtual bool MakeDir(const char * _dir)=0;
+	virtual bool TestDir(const char * _dir)=0;
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false)=0;
 	virtual bool FindNext(DOS_DTA & dta)=0;
-	virtual bool GetFileAttr(char * name,Bit16u * attr)=0;
-	virtual bool Rename(char * oldname,char * newname)=0;
+	virtual bool GetFileAttr(const char * name,Bit16u * attr)=0;
+	virtual bool Rename(const char * oldname,const char * newname)=0;
 	virtual bool AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters)=0;
 	virtual bool FileExists(const char* name)=0;
 	virtual bool FileStat(const char* name, FileStat_Block * const stat_block)=0;
 	virtual Bit8u GetMediaByte(void)=0;
 	virtual void SetDir(const char* path) { strcpy(curdir,path); };
-	virtual void EmptyCache(void) { dirCache.EmptyCache(); };
 	virtual bool isRemote(void)=0;
 	virtual bool isRemovable(void)=0;
 	virtual Bits UnMount(void)=0;
 
-	char * GetInfo(void);
+	/* these 4 may only be used by DOS_Drive_Cache because they have special calling conventions */
+	virtual void *opendir(const char *dir) {return NULL;};
+	virtual void closedir(void *handle) {};
+	virtual bool read_directory_first(void *handle, char* entry_name, bool& is_directory) { return false; };
+	virtual bool read_directory_next(void *handle, char* entry_name, bool& is_directory) { return false; };
+
+	virtual const char * GetInfo(void);
 	char curdir[DOS_PATHLENGTH];
 	char info[256];
 	/* Can be overridden for example in iso images */
-	virtual char const * GetLabel(){return dirCache.GetLabel();};
-
-	DOS_Drive_Cache dirCache;
+	virtual char const * GetLabel() {return "NOLABEL";}; 
+	virtual void SetLabel(const char *label, bool iscdrom, bool updatable) {}; 
+	virtual void EmptyCache() {};
 
 	// disk cycling functionality (request resources)
 	virtual void Activate(void) {};
diff -urN dosbox-0.73/include/externalInterface.h dosboxcvs/include/externalInterface.h
--- dosbox-0.73/include/externalInterface.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/externalInterface.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,64 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_EXTINT_H
+#define MT32EMU_EXTINT_H
+
+#include <SDL_net.h>
+
+namespace MT32Emu {
+
+class ExternalInterface {
+private:
+	Bit8u inBuffer[4096];
+
+public:
+	ExternalInterface() {
+		SDLNet_Init();
+		this->openedPort = false;
+		this->textToDisplay = false;
+		this->knownClient = false;
+	}
+
+	~ExternalInterface() {
+		SDLNet_Quit();
+	}
+
+	bool start();
+
+	void doControlPanelComm(Synth *synth, int sndBufLength);
+	bool getStatusRequest(int *requestType, char * buffer);
+
+	bool sendResponse(int requestType, char *requestBuf, int requestLen);
+
+	bool sendDisplayText(char *requestBuf, int requestLen);
+
+	void handleReport(Synth *synth, ReportType type, const void *reportData);
+
+	bool stop();
+private:
+	bool openedPort;
+	char txtBuffer[512];
+	bool textToDisplay;
+	bool knownClient;
+	IPaddress ipxServerIp;  // IPAddress for server's listening port
+	IPaddress ipxClientIp;  // IPAddress for last accessed client request
+	UDPsocket ipxServerSocket;  // Listening server socket
+	UDPpacket *regPacket;
+};
+
+}
+#endif
diff -urN dosbox-0.73/include/file.h dosboxcvs/include/file.h
--- dosbox-0.73/include/file.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/file.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,62 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_FILE_H
+#define MT32EMU_FILE_H
+
+#include <stdio.h>
+
+namespace MT32Emu {
+
+class File {
+public:
+	enum OpenMode {
+		OpenMode_read  = 0,
+		OpenMode_write = 1
+	};
+	virtual ~File() {}
+	virtual void close() = 0;
+	virtual size_t read(void *in, size_t size) = 0;
+	virtual bool readLine(char *in, size_t size) = 0;
+	virtual bool readBit8u(Bit8u *in) = 0;
+	virtual bool readBit16u(Bit16u *in);
+	virtual bool readBit32u(Bit32u *in);
+	virtual size_t write(const void *out, size_t size) = 0;
+	virtual bool writeBit8u(Bit8u out) = 0;
+	// Note: May write a single byte to the file before failing
+	virtual bool writeBit16u(Bit16u out);
+	// Note: May write some (<4) bytes to the file before failing
+	virtual bool writeBit32u(Bit32u out);
+	virtual bool isEOF() = 0;
+};
+
+class ANSIFile: public File {
+private:
+	FILE *fp;
+public:
+	bool open(const char *filename, OpenMode mode);
+	void close();
+	size_t read(void *in, size_t size);
+	bool readLine(char *in, size_t size);
+	bool readBit8u(Bit8u *in);
+	size_t write(const void *out, size_t size);
+	bool writeBit8u(Bit8u out);
+	bool isEOF();
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/freeverb/allpass.h dosboxcvs/include/freeverb/allpass.h
--- dosbox-0.73/include/freeverb/allpass.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/freeverb/allpass.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,46 @@
+// Allpass filter declaration
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#ifndef _allpass_
+#define _allpass_
+#include "denormals.h"
+
+class allpass
+{
+public:
+	                allpass();
+	        void    setbuffer(float *buf, int size);
+	inline  float   process(float inp);
+	        void    mute();
+	        void    setfeedback(float val);
+	        float   getfeedback();
+// private:
+	float   feedback;
+	float   *buffer;
+	int     bufsize;
+	int     bufidx;
+};
+
+
+// Big to inline - but crucial for speed
+
+inline float allpass::process(float input)
+{
+	float output;
+	float bufout;
+
+	bufout = buffer[bufidx];
+	undenormalise(bufout);
+
+	output = -input + bufout;
+	buffer[bufidx] = input + (bufout*feedback);
+
+	if (++bufidx>=bufsize) bufidx = 0;
+
+	return output;
+}
+
+#endif//_allpass
diff -urN dosbox-0.73/include/freeverb/comb.h dosboxcvs/include/freeverb/comb.h
--- dosbox-0.73/include/freeverb/comb.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/freeverb/comb.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,53 @@
+// Comb filter class declaration
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#ifndef _comb_
+#define _comb_
+
+#include "denormals.h"
+
+class comb
+{
+public:
+	                comb();
+	        void    setbuffer(float *buf, int size);
+	inline  float   process(float inp);
+	        void    mute();
+	        void    setdamp(float val);
+	        float   getdamp();
+	        void    setfeedback(float val);
+	        float   getfeedback();
+private:
+	float   feedback;
+	float   filterstore;
+	float   damp1;
+	float   damp2;
+	float   *buffer;
+	int     bufsize;
+	int     bufidx;
+};
+
+
+// Big to inline - but crucial for speed
+
+inline float comb::process(float input)
+{
+	float output;
+
+	output = buffer[bufidx];
+	undenormalise(output);
+
+	filterstore = (output*damp2) + (filterstore*damp1);
+	undenormalise(filterstore);
+
+	buffer[bufidx] = input + (filterstore*feedback);
+
+	if (++bufidx>=bufsize) bufidx = 0;
+
+	return output;
+}
+
+#endif //_comb_
diff -urN dosbox-0.73/include/freeverb/denormals.h dosboxcvs/include/freeverb/denormals.h
--- dosbox-0.73/include/freeverb/denormals.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/freeverb/denormals.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,13 @@
+// Macro for killing denormalled numbers
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// Based on IS_DENORMAL macro by Jon Watte
+// This code is public domain
+
+#ifndef _denormals_
+#define _denormals_
+
+#define undenormalise(sample) if (((*(unsigned int*)&sample)&0x7f800000)==0) sample=0.0f
+
+#endif//_denormals_
diff -urN dosbox-0.73/include/freeverb/revmodel.h dosboxcvs/include/freeverb/revmodel.h
--- dosbox-0.73/include/freeverb/revmodel.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/freeverb/revmodel.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,85 @@
+// Reverb model declaration
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#ifndef _revmodel_
+#define _revmodel_
+
+#include "comb.h"
+#include "allpass.h"
+#include "tuning.h"
+
+class revmodel
+{
+public:
+			       revmodel();
+			void   mute();
+			void   processmix(float *inputL, float *inputR, float *outputL, float *outputR, long numsamples, int skip);
+			void   processreplace(const float *inputL, const float *inputR, float *outputL, float *outputR, long numsamples, int skip);
+			void   setroomsize(float value);
+			float  getroomsize();
+			void   setdamp(float value);
+			float  getdamp();
+			void   setwet(float value);
+			float  getwet();
+			void   setdry(float value);
+			float  getdry();
+			void   setwidth(float value);
+			float  getwidth();
+			void   setmode(float value);
+			float  getmode();
+private:
+			void   update();
+private:
+	float  gain;
+	float  roomsize,roomsize1;
+	float  damp,damp1;
+	float  wet,wet1,wet2;
+	float  dry;
+	float  width;
+	float  mode;
+
+	// The following are all declared inline
+	// to remove the need for dynamic allocation
+	// with its subsequent error-checking messiness
+
+	// Comb filters
+	comb   combL[numcombs];
+	comb   combR[numcombs];
+
+	// Allpass filters
+	allpass	allpassL[numallpasses];
+	allpass	allpassR[numallpasses];
+
+	// Buffers for the combs
+	float  bufcombL1[combtuningL1];
+	float  bufcombR1[combtuningR1];
+	float  bufcombL2[combtuningL2];
+	float  bufcombR2[combtuningR2];
+	float  bufcombL3[combtuningL3];
+	float  bufcombR3[combtuningR3];
+	float  bufcombL4[combtuningL4];
+	float  bufcombR4[combtuningR4];
+	float  bufcombL5[combtuningL5];
+	float  bufcombR5[combtuningR5];
+	float  bufcombL6[combtuningL6];
+	float  bufcombR6[combtuningR6];
+	float  bufcombL7[combtuningL7];
+	float  bufcombR7[combtuningR7];
+	float  bufcombL8[combtuningL8];
+	float  bufcombR8[combtuningR8];
+
+	// Buffers for the allpasses
+	float  bufallpassL1[allpasstuningL1];
+	float  bufallpassR1[allpasstuningR1];
+	float  bufallpassL2[allpasstuningL2];
+	float  bufallpassR2[allpasstuningR2];
+	float  bufallpassL3[allpasstuningL3];
+	float  bufallpassR3[allpasstuningR3];
+	float  bufallpassL4[allpasstuningL4];
+	float  bufallpassR4[allpasstuningR4];
+};
+
+#endif//_revmodel_
diff -urN dosbox-0.73/include/freeverb/tuning.h dosboxcvs/include/freeverb/tuning.h
--- dosbox-0.73/include/freeverb/tuning.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/freeverb/tuning.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,57 @@
+// Reverb model tuning values
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#ifndef _tuning_
+#define _tuning_
+
+const int   numcombs        = 8;
+const int   numallpasses    = 4;
+const float muted           = 0;
+const float fixedgain       = 0.015f;
+const float scalewet        = 3;
+const float scaledry        = 2;
+const float scaledamp       = 0.4f;
+const float scaleroom       = 0.28f;
+const float offsetroom      = 0.7f;
+const float initialroom     = 0.5f;
+const float initialdamp     = 0.5f;
+const float initialwet      = 1/scalewet;
+const float initialdry      = 0;
+const float initialwidth    = 1;
+const float initialmode     = 0;
+const float freezemode      = 0.5f;
+const int   stereospread    = 23;
+
+// These values assume 44.1KHz sample rate
+// they will probably be OK for 48KHz sample rate
+// but would need scaling for 96KHz (or other) sample rates.
+// The values were obtained by listening tests.
+const int combtuningL1      = 1116;
+const int combtuningR1      = 1116+stereospread;
+const int combtuningL2      = 1188;
+const int combtuningR2      = 1188+stereospread;
+const int combtuningL3      = 1277;
+const int combtuningR3      = 1277+stereospread;
+const int combtuningL4      = 1356;
+const int combtuningR4      = 1356+stereospread;
+const int combtuningL5      = 1422;
+const int combtuningR5      = 1422+stereospread;
+const int combtuningL6      = 1491;
+const int combtuningR6      = 1491+stereospread;
+const int combtuningL7      = 1557;
+const int combtuningR7      = 1557+stereospread;
+const int combtuningL8      = 1617;
+const int combtuningR8      = 1617+stereospread;
+const int allpasstuningL1   = 556;
+const int allpasstuningR1   = 556+stereospread;
+const int allpasstuningL2   = 441;
+const int allpasstuningR2   = 441+stereospread;
+const int allpasstuningL3   = 341;
+const int allpasstuningR3   = 341+stereospread;
+const int allpasstuningL4   = 225;
+const int allpasstuningR4   = 225+stereospread;
+
+#endif//_tuning_
diff -urN dosbox-0.73/include/hardware.h dosboxcvs/include/hardware.h
--- dosbox-0.73/include/hardware.h	2009-05-25 21:44:43.000000000 +0300
+++ dosboxcvs/include/hardware.h	2009-07-08 20:43:08.000000000 +0300
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: hardware.h,v 1.17 2009/06/23 17:46:05 c2woody Exp $ */
+
 #ifndef DOSBOX_HARDWARE_H
 #define DOSBOX_HARDWARE_H
 
@@ -23,7 +25,7 @@
 
 class Section;
 enum OPL_Mode {
-	OPL_none,OPL_cms,OPL_opl2,OPL_dualopl2,OPL_opl3
+	OPL_none,OPL_cms,OPL_opl2,OPL_dualopl2,OPL_opl3,OPL_hardware
 };
 #define CAPTURE_WAVE	0x01
 #define CAPTURE_OPL		0x02
@@ -38,6 +40,9 @@
 void OPL_ShutDown(Section* sec);
 void CMS_ShutDown(Section* sec);
 
+bool SB_Get_Address(Bitu& sbaddr, Bitu& sbirq, Bitu& sbdma);
+bool TS_Get_Address(Bitu& tsaddr, Bitu& tsirq, Bitu& tsdma);
+
 extern Bit8u adlib_commandreg;
 FILE * OpenCaptureFile(const char * type,const char * ext);
 
diff -urN dosbox-0.73/include/Makefile.am dosboxcvs/include/Makefile.am
--- dosbox-0.73/include/Makefile.am	2009-02-01 15:20:56.000000000 +0200
+++ dosboxcvs/include/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -23,6 +23,7 @@
 mixer.h \
 modules.h \
 mouse.h \
+parport.h \
 paging.h \
 pic.h \
 programs.h \
@@ -35,5 +36,7 @@
 support.h \
 timer.h \
 vga.h \
-video.h
+video.h \
+ne2000.h
+
 
diff -urN dosbox-0.73/include/Makefile.in dosboxcvs/include/Makefile.in
--- dosbox-0.73/include/Makefile.in	2009-05-20 21:29:05.000000000 +0300
+++ dosboxcvs/include/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -53,6 +57,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -64,6 +70,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -74,8 +81,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -85,7 +93,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -103,12 +110,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -120,43 +130,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 noinst_HEADERS = \
 bios.h \
 bios_disk.h \
@@ -182,6 +181,7 @@
 mixer.h \
 modules.h \
 mouse.h \
+parport.h \
 paging.h \
 pic.h \
 programs.h \
@@ -194,7 +194,8 @@
 support.h \
 timer.h \
 vga.h \
-video.h
+video.h \
+ne2000.h
 
 all: all-am
 
@@ -228,14 +229,15 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -247,8 +249,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -258,12 +260,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -277,21 +280,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -350,20 +354,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -382,20 +378,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	ctags distclean distclean-generic distclean-tags distdir dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/include/mapper.h dosboxcvs/include/mapper.h
--- dosbox-0.73/include/mapper.h	2009-05-25 21:44:43.000000000 +0300
+++ dosboxcvs/include/mapper.h	2009-07-08 20:43:15.000000000 +0300
@@ -21,7 +21,8 @@
 
 enum MapKeys {
 	MK_f1,MK_f2,MK_f3,MK_f4,MK_f5,MK_f6,MK_f7,MK_f8,MK_f9,MK_f10,MK_f11,MK_f12,
-	MK_return,MK_kpminus,MK_scrolllock,MK_printscreen,MK_pause
+	MK_return,MK_kpminus,MK_equals,MK_scrolllock,MK_printscreen,MK_pause,
+	MK_1, MK_2, MK_3, MK_4
 
 };
 
@@ -30,6 +31,7 @@
 void MAPPER_Init(void);
 void MAPPER_StartUp(Section * sec);
 void MAPPER_Run(bool pressed);
+void MAPPER_RunInternal();
 void MAPPER_LosingFocus(void);
 
 
diff -urN dosbox-0.73/include/mt32emu.h dosboxcvs/include/mt32emu.h
--- dosbox-0.73/include/mt32emu.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/mt32emu.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,52 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_MT32EMU_H
+#define MT32EMU_MT32EMU_H
+
+#include "dosbox.h"
+
+// Debugging
+//#define MT32DEBUG
+// Show the instruments played
+#define MT32EMU_MONITOR_INSTRUMENTS 0
+// Shows number of partials MT-32 is playing, and on which parts
+#define MT32EMU_MONITOR_PARTIALS 0
+
+#define MT32EMU_USE_EXTINT 0
+
+// Configuration
+// The maximum number of partials playing simultaneously
+#define MT32EMU_MAX_PARTIALS 32
+// The maximum number of notes playing simultaneously per part.
+// No point making it more than MT32EMU_MAX_PARTIALS, since each note needs at least one partial.
+#define MT32EMU_MAX_POLY 32
+
+#include "freeverb/revmodel.h"
+
+#include "structures.h"
+#include "file.h"
+#include "tables.h"
+#include "poly.h"
+#include "tva.h"
+#include "tvp.h"
+#include "tvf.h"
+#include "partial.h"
+#include "partialManager.h"
+#include "part.h"
+#include "synth.h"
+
+#endif
diff -urN dosbox-0.73/include/ne2000.h dosboxcvs/include/ne2000.h
--- dosbox-0.73/include/ne2000.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/ne2000.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,251 @@
+/////////////////////////////////////////////////////////////////////////
+// $Id: ne2k.h,v 1.11.2.3 2003/04/06 17:29:49 bdenney Exp $
+/////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (C) 2001  MandrakeSoft S.A.
+//
+//    MandrakeSoft S.A.
+//    43, rue d'Aboukir
+//    75002 Paris - France
+//    http://www.linux-mandrake.com/
+//    http://www.mandrakesoft.com/
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+// Peter Grehan (grehan@iprg.nokia.com) coded all of this
+// NE2000/ether stuff.
+
+//
+// An implementation of an ne2000 ISA ethernet adapter. This part uses
+// a National Semiconductor DS-8390 ethernet MAC chip, with some h/w
+// to provide a windowed memory region for the chip and a MAC address.
+//
+
+#include "dosbox.h"
+
+#define bx_bool int
+#define bx_param_c Bit8u
+
+
+#  define BX_NE2K_SMF
+#  define BX_NE2K_THIS_PTR 
+#  define BX_NE2K_THIS	
+#define BX_INFO 
+//LOG_MSG
+#define BX_DEBUG 
+//LOG_MSG
+
+#define  BX_NE2K_MEMSIZ    (32*1024)
+#define  BX_NE2K_MEMSTART  (16*1024)
+#define  BX_NE2K_MEMEND    (BX_NE2K_MEMSTART + BX_NE2K_MEMSIZ)
+
+typedef struct {
+  //
+  // ne2k register state
+   
+  //
+  // Page 0
+  //
+  //  Command Register - 00h read/write
+  struct CR_t {
+    bx_bool  stop;		// STP - Software Reset command
+    bx_bool  start;		// START - start the NIC
+    bx_bool  tx_packet;	// TXP - initiate packet transmission
+    Bit8u    rdma_cmd;      // RD0,RD1,RD2 - Remote DMA command
+    Bit8u	 pgsel;		// PS0,PS1 - Page select
+  } CR;
+  // Interrupt Status Register - 07h read/write
+  struct ISR_t {  
+    bx_bool  pkt_rx;       	// PRX - packet received with no errors
+    bx_bool  pkt_tx;       	// PTX - packet transmitted with no errors
+    bx_bool  rx_err;	// RXE - packet received with 1 or more errors
+    bx_bool  tx_err;	// TXE - packet tx'd       "  " "    "    "
+    bx_bool  overwrite;	// OVW - rx buffer resources exhausted
+    bx_bool  cnt_oflow;     // CNT - network tally counter MSB's set
+    bx_bool  rdma_done;     // RDC - remote DMA complete
+    bx_bool  reset;		// RST - reset status
+  } ISR;
+  // Interrupt Mask Register - 0fh write
+  struct IMR_t {
+    bx_bool  rx_inte;	// PRXE - packet rx interrupt enable
+    bx_bool  tx_inte;	// PTXE - packet tx interrput enable
+    bx_bool  rxerr_inte;	// RXEE - rx error interrupt enable
+    bx_bool  txerr_inte;	// TXEE - tx error interrupt enable
+    bx_bool  overw_inte;	// OVWE - overwrite warn int enable
+    bx_bool  cofl_inte;	// CNTE - counter o'flow int enable
+    bx_bool  rdma_inte;	// RDCE - remote DMA complete int enable
+    bx_bool  reserved;	//  D7 - reserved
+  } IMR;
+  // Data Configuration Register - 0eh write
+  struct DCR_t {
+    bx_bool  wdsize;	// WTS - 8/16-bit select
+    bx_bool  endian;	// BOS - byte-order select
+    bx_bool  longaddr;	// LAS - long-address select
+    bx_bool  loop;		// LS  - loopback select
+    bx_bool  auto_rx;	// AR  - auto-remove rx packets with remote DMA
+    Bit8u    fifo_size;	// FT0,FT1 - fifo threshold
+  } DCR;
+  // Transmit Configuration Register - 0dh write
+  struct TCR_t {
+    bx_bool  crc_disable;	// CRC - inhibit tx CRC
+    Bit8u    loop_cntl;	// LB0,LB1 - loopback control
+    bx_bool  ext_stoptx;    // ATD - allow tx disable by external mcast
+    bx_bool  coll_prio;	// OFST - backoff algorithm select
+    Bit8u    reserved;      //  D5,D6,D7 - reserved
+  } TCR;
+  // Transmit Status Register - 04h read
+  struct TSR_t {
+    bx_bool  tx_ok;		// PTX - tx complete without error
+    bx_bool  reserved;	//  D1 - reserved
+    bx_bool  collided;	// COL - tx collided >= 1 times
+    bx_bool  aborted;	// ABT - aborted due to excessive collisions
+    bx_bool  no_carrier;	// CRS - carrier-sense lost
+    bx_bool  fifo_ur;	// FU  - FIFO underrun
+    bx_bool  cd_hbeat;	// CDH - no tx cd-heartbeat from transceiver
+    bx_bool  ow_coll;	// OWC - out-of-window collision
+  } TSR;
+  // Receive Configuration Register - 0ch write
+  struct RCR_t {
+    bx_bool  errors_ok;	// SEP - accept pkts with rx errors
+    bx_bool  runts_ok;	// AR  - accept < 64-byte runts
+    bx_bool  broadcast;	// AB  - accept eth broadcast address
+    bx_bool  multicast;	// AM  - check mcast hash array
+    bx_bool  promisc;	// PRO - accept all packets
+    bx_bool  monitor;	// MON - check pkts, but don't rx
+    Bit8u    reserved;	//  D6,D7 - reserved
+  } RCR;
+  // Receive Status Register - 0ch read
+  struct RSR_t {
+    bx_bool  rx_ok;		// PRX - rx complete without error
+    bx_bool  bad_crc;	// CRC - Bad CRC detected
+    bx_bool  bad_falign;	// FAE - frame alignment error
+    bx_bool  fifo_or;	// FO  - FIFO overrun
+    bx_bool  rx_missed;	// MPA - missed packet error
+    bx_bool  rx_mbit;	// PHY - unicast or mcast/bcast address match
+    bx_bool  rx_disabled;   // DIS - set when in monitor mode
+    bx_bool  deferred;	// DFR - collision active
+  } RSR;
+
+  Bit16u local_dma;	// 01,02h read ; current local DMA addr
+  Bit8u  page_start;  // 01h write ; page start register
+  Bit8u  page_stop;   // 02h write ; page stop register
+  Bit8u  bound_ptr;   // 03h read/write ; boundary pointer
+  Bit8u  tx_page_start; // 04h write ; transmit page start register
+  Bit8u  num_coll;    // 05h read  ; number-of-collisions register
+  Bit16u tx_bytes;    // 05,06h write ; transmit byte-count register
+  Bit8u  fifo;	// 06h read  ; FIFO
+  Bit16u remote_dma;  // 08,09h read ; current remote DMA addr
+  Bit16u remote_start;  // 08,09h write ; remote start address register
+  Bit16u remote_bytes;  // 0a,0bh write ; remote byte-count register
+  Bit8u  tallycnt_0;  // 0dh read  ; tally counter 0 (frame align errors)
+  Bit8u  tallycnt_1;  // 0eh read  ; tally counter 1 (CRC errors)
+  Bit8u  tallycnt_2;  // 0fh read  ; tally counter 2 (missed pkt errors)
+
+  //
+  // Page 1
+  //
+  //   Command Register 00h (repeated)
+  //
+  Bit8u  physaddr[6];  // 01-06h read/write ; MAC address
+  Bit8u  curr_page;    // 07h read/write ; current page register
+  Bit8u  mchash[8];    // 08-0fh read/write ; multicast hash array
+
+  //
+  // Page 2  - diagnostic use only
+  // 
+  //   Command Register 00h (repeated)
+  //
+  //   Page Start Register 01h read  (repeated)
+  //   Page Stop Register  02h read  (repeated)
+  //   Current Local DMA Address 01,02h write (repeated)
+  //   Transmit Page start address 04h read (repeated)
+  //   Receive Configuration Register 0ch read (repeated)
+  //   Transmit Configuration Register 0dh read (repeated)
+  //   Data Configuration Register 0eh read (repeated)
+  //   Interrupt Mask Register 0fh read (repeated)
+  //
+  Bit8u  rempkt_ptr;   // 03h read/write ; remote next-packet pointer
+  Bit8u  localpkt_ptr; // 05h read/write ; local next-packet pointer
+  Bit16u address_cnt;  // 06,07h read/write ; address counter
+
+    //
+    // Page 3  - should never be modified.
+    //
+
+    // Novell ASIC state
+  Bit8u  macaddr[32];          // ASIC ROM'd MAC address, even bytes
+  Bit8u  mem[BX_NE2K_MEMSIZ];  // on-chip packet memory
+
+    // ne2k internal state
+  Bit32u base_address;
+  int    base_irq;
+  int    tx_timer_index;
+  int    tx_timer_active;
+
+  void register_state(bx_param_c *list_p);
+  
+} bx_ne2k_t;
+
+
+
+class bx_ne2k_c  {
+public:
+  bx_ne2k_c(void);
+  ~bx_ne2k_c(void);
+  virtual void init(void);
+  virtual void reset(unsigned type);
+
+public:
+  bx_ne2k_t s;
+
+  /* TODO: Setup SDL */
+  //eth_pktmover_c *ethdev;
+
+  BX_NE2K_SMF Bit32u read_cr(void);
+  BX_NE2K_SMF void   write_cr(Bit32u value);
+
+  BX_NE2K_SMF Bit32u chipmem_read(Bit32u address, unsigned io_len);
+  BX_NE2K_SMF Bit32u asic_read(Bit32u offset, unsigned io_len); 
+  BX_NE2K_SMF Bit32u page0_read(Bit32u offset, unsigned io_len);
+  BX_NE2K_SMF Bit32u page1_read(Bit32u offset, unsigned io_len);
+  BX_NE2K_SMF Bit32u page2_read(Bit32u offset, unsigned io_len);
+  BX_NE2K_SMF Bit32u page3_read(Bit32u offset, unsigned io_len);
+
+  BX_NE2K_SMF void chipmem_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void asic_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void page0_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void page1_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void page2_write(Bit32u address, Bit32u value, unsigned io_len);
+  BX_NE2K_SMF void page3_write(Bit32u address, Bit32u value, unsigned io_len);
+
+public:
+  static void tx_timer_handler(void *);
+  BX_NE2K_SMF void tx_timer(void);
+
+  static void rx_handler(void *arg, const void *buf, unsigned len);
+  BX_NE2K_SMF unsigned mcast_index(const void *dst);
+  BX_NE2K_SMF void rx_frame(const void *buf, unsigned io_len);
+
+
+  static Bit32u read_handler(void *this_ptr, Bit32u address, unsigned io_len);
+  static void   write_handler(void *this_ptr, Bit32u address, Bit32u value, unsigned io_len);
+#if !BX_USE_NE2K_SMF
+  Bit32u read(Bit32u address, unsigned io_len);
+  void   write(Bit32u address, Bit32u value, unsigned io_len);
+#endif
+
+
+};
+
diff -urN dosbox-0.73/include/parport.h dosboxcvs/include/parport.h
--- dosbox-0.73/include/parport.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/parport.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,107 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef DOSBOX_PARPORT_H
+#define DOSBOX_PARPORT_H
+
+// set to 1 for debug messages and debugging log:
+#define PARALLEL_DEBUG 1
+
+#ifndef DOSBOX_DOSBOX_H
+#include "dosbox.h"
+#endif
+#ifndef DOSBOX_INOUT_H
+#include "inout.h"
+#endif
+
+#include "setup.h"
+#include "dos_inc.h"
+#include "programs.h"
+
+class device_LPT : public DOS_Device {
+public:
+	// Creates a LPT device that communicates with the num-th parallel port, i.e. is LPTnum
+	device_LPT(Bit8u num, class CParallel* pp);
+	~device_LPT();
+	bool Read(Bit8u * data,Bit16u * size);
+	bool Write(Bit8u * data,Bit16u * size);
+	bool Seek(Bit32u * pos,Bit32u type);
+	bool Close();
+	Bit16u GetInformation(void);
+private:
+	CParallel* pportclass;
+	Bit8u num; // This device is LPTnum
+};
+
+
+class CParallel {
+public:
+#if PARALLEL_DEBUG
+	FILE * debugfp;
+	bool dbg_data;
+	bool dbg_putchar;
+	bool dbg_cregs;
+	bool dbg_plainputchar;
+	bool dbg_plaindr;
+	void log_par(bool active, char const* format,...);
+#endif
+
+	// Constructor
+	CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq);
+	
+	virtual ~CParallel();
+
+	IO_ReadHandleObject ReadHandler[3];
+	IO_WriteHandleObject WriteHandler[3];
+
+	void Timer(void);
+	virtual void Timer2(void)=0;
+	
+	Bitu base;
+	Bitu irq;
+	
+	// read data line register
+	virtual Bitu Read_PR()=0;
+	virtual Bitu Read_COM()=0;
+	virtual Bitu Read_SR()=0;
+
+	virtual void Write_PR(Bitu)=0;
+	virtual void Write_CON(Bitu)=0;
+	virtual void Write_IOSEL(Bitu)=0;
+
+	void Write_reserved(Bit8u data, Bit8u address);
+
+	virtual bool Putchar(Bit8u)=0;
+	bool Putchar_default(Bit8u);
+	Bit8u getPrinterStatus();
+	void initialize();
+	
+
+
+private:
+	 DOS_Device* mydosdevice;
+		
+};
+
+extern CParallel* parallelPortObjects[];
+void PARALLEL_Init (Section * sec);
+
+const Bit16u parallel_baseaddr[3] = {0x378,0x278,0x3bc};
+
+#endif
+
diff -urN dosbox-0.73/include/part.h dosboxcvs/include/part.h
--- dosbox-0.73/include/part.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/part.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,130 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_PART_H
+#define MT32EMU_PART_H
+
+#include <list>
+
+namespace MT32Emu {
+
+class PartialManager;
+class Synth;
+
+class Part {
+private:
+	// Pointers to the areas of the MT-32's memory dedicated to this part (for parts 1-8)
+	MemParams::PatchTemp *patchTemp;
+	TimbreParam *timbreTemp;
+
+	// 0=Part 1, .. 7=Part 8, 8=Rhythm
+	unsigned int partNum;
+
+	bool holdpedal;
+
+	unsigned int activePartialCount;
+	PatchCache patchCache[4];
+	std::list<Poly*> freePolys;
+	std::list<Poly*> activePolys;
+
+	static int fixKeyfollow(int srckey);
+	static int fixBiaslevel(int srcpnt, int *dir);
+
+	void setPatch(const PatchParam *patch);
+	unsigned int midiKeyToKey(unsigned int midiKey, const char *debugAction);
+
+	bool abortFirstPoly(unsigned int key);
+
+protected:
+	Synth *synth;
+	char name[8]; // "Part 1".."Part 8", "Rhythm"
+	char currentInstr[11];
+	Bit8u modulation;
+	Bit8u expression;
+	Bit32s pitchBend;
+	bool nrpn;
+	Bit16u rpn;
+	Bit16u pitchBenderRange; // (patchTemp->patch.benderRange * 683) at the time of the last MIDI program change or MIDI data entry.
+
+	void backupCacheToPartials(PatchCache cache[4]);
+	void cacheTimbre(PatchCache cache[4], const TimbreParam *timbre);
+	void playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhythmTemp, unsigned int midiKey, unsigned int key, unsigned int velocity);
+	void stopNote(unsigned int key);
+	const char *getName() const;
+
+public:
+	Part(Synth *synth, unsigned int usePartNum);
+	~Part();
+	void reset();
+	void setDataEntryMSB(unsigned char midiDataEntryMSB);
+	void setNRPN();
+	void setRPNLSB(unsigned char midiRPNLSB);
+	void setRPNMSB(unsigned char midiRPNMSB);
+	void resetAllControllers();
+	virtual void noteOn(unsigned int midiKey, unsigned int velocity);
+	virtual void noteOff(unsigned int midiKey);
+	void allNotesOff();
+	void allSoundOff();
+	void setVolume(unsigned int midiVolume);
+	Bit8u getModulation() const;
+	void setModulation(unsigned int midiModulation);
+	Bit8u getExpression() const;
+	void setExpression(unsigned int midiExpression);
+	virtual void setPan(unsigned int midiPan);
+	Bit32s getPitchBend() const;
+	void setBend(unsigned int midiBend);
+	virtual void setProgram(unsigned int midiProgram);
+	void setHoldPedal(bool pedalval);
+	void stopPedalHold();
+	void updatePitchBenderRange();
+	virtual void refresh();
+	virtual void refreshTimbre(unsigned int absTimbreNum);
+	virtual void setTimbre(TimbreParam *timbre);
+	virtual unsigned int getAbsTimbreNum() const;
+	const char *getCurrentInstr() const;
+	unsigned int getActivePartialCount() const;
+	unsigned int getActiveNonReleasingPartialCount() const;
+
+	const MemParams::PatchTemp *getPatchTemp() const;
+
+	// This should only be called by Poly
+	void partialDeactivated(Poly *poly);
+
+	// These are rather specialised, and should probably only be used by PartialManager
+	bool abortFirstPoly(PolyState polyState);
+	bool abortFirstPoly();
+};
+
+class RhythmPart: public Part {
+	// Pointer to the area of the MT-32's memory dedicated to rhythm
+	const MemParams::RhythmTemp *rhythmTemp;
+
+	// This caches the timbres/settings in use by the rhythm part
+	PatchCache drumCache[85][4];
+public:
+	RhythmPart(Synth *synth, unsigned int usePartNum);
+	void refresh();
+	void refreshTimbre(unsigned int timbreNum);
+	void setTimbre(TimbreParam *timbre);
+	void noteOn(unsigned int key, unsigned int velocity);
+	void noteOff(unsigned int midiKey);
+	unsigned int getAbsTimbreNum() const;
+	void setPan(unsigned int midiPan);
+	void setProgram(unsigned int patchNum);
+};
+
+}
+#endif
diff -urN dosbox-0.73/include/partial.h dosboxcvs/include/partial.h
--- dosbox-0.73/include/partial.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/partial.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,142 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_PARTIAL_H
+#define MT32EMU_PARTIAL_H
+
+namespace MT32Emu {
+
+class Synth;
+class Part;
+class TVA;
+struct ControlROMPCMStruct;
+
+struct EnvelopeStatus {
+	Bit32s envpos;
+	Bit32s envstat;
+	Bit32s envbase;
+	Bit32s envdist;
+	Bit32s envsize;
+
+	bool sustaining;
+	bool decaying;
+	Bit32s prevlevel;
+
+	Bit32s counter;
+	Bit32s count;
+};
+
+// A partial represents one of up to four waveform generators currently playing within a poly.
+class Partial {
+private:
+	Synth *synth;
+	const int debugPartialNum; // Only used for debugging
+
+	int ownerPart; // -1 if unassigned
+	int mixType;
+	int structurePosition; // 0 or 1 of a structure pair
+	bool useNoisePair;
+	StereoVolume stereoVolume;
+
+	bool firstSample;
+
+	Bit16s myBuffer[MAX_SAMPLE_OUTPUT];
+
+	// Keyfollowed note value
+	BlitSaw *posSaw;
+	BlitSaw *negSaw;
+
+	const KeyLookup *keyLookup; // LUTs for the clamped (12..108) key
+
+	// Keyfollowed filter value
+	int filtVal;
+
+	// Only used for PCM partials
+	int pcmNum;
+	// FIXME: Give this a better name (e.g. pcmWaveInfo)
+	PCMWaveEntry *pcmWave;
+
+	int pulsewidth;
+
+	float pcmPosition;
+	int intPCMPosition;
+
+	Bit32u pitchEnvVal;
+
+	float history[32];
+
+	int loopPos;
+
+	Poly *poly;
+
+	Bit32s pastCarrier;
+	Bit32s pastOsc;
+
+	Bit32s pastDesCarrier;
+	Bit32s pastDesOsc;
+
+	Bit16s *mixBuffers(Bit16s *buf1, Bit16s *buf2, int len);
+	Bit16s *mixBuffersRingMix(Bit16s *buf1, Bit16s *buf2, int len);
+	Bit16s *mixBuffersRing(Bit16s *buf1, Bit16s *buf2, int len);
+
+	Bit16s getPCMSample(unsigned int position);
+	Bit32s getFiltEnvelope();
+
+	void initKeyFollow(int freqNum);
+
+public:
+	const PatchCache *patchCache;
+	TVA *tva;
+	TVP *tvp;
+	EnvelopeStatus filtEnv;
+	bool play;
+
+	PatchCache cachebackup;
+
+	Partial *pair;
+	bool alreadyOutputed;
+
+	Partial(Synth *synth, int debugPartialNum);
+	~Partial();
+
+	int getOwnerPart() const;
+	int getKey() const;
+	const Poly *getPoly() const;
+	bool isActive() const;
+	void activate(int part);
+	void deactivate(void);
+	void startPartial(const Part *part, Poly *usePoly, const PatchCache *useCache, const MemParams::RhythmTemp *rhythmTemp, Partial *pairPartial);
+	void startFiltDecay(Bit32s startval);
+	void startDecayAll();
+	bool shouldReverb();
+	bool hasRingModulatingSlave() const;
+	bool isRingModulatingSlave() const;
+	bool isPCM() const;
+	const ControlROMPCMStruct *getControlROMPCMStruct() const;
+	Synth *getSynth() const;
+
+	// Returns true only if data written to buffer
+	// This function (unlike the one below it) returns processed stereo samples
+	// made from combining this single partial with its pair, if it has one.
+	bool produceOutput(Bit16s * partialBuf, long length);
+
+	// This function produces mono sample output using the partial's private internal buffer
+	Bit16s *generateSamples(long length);
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/partialManager.h dosboxcvs/include/partialManager.h
--- dosbox-0.73/include/partialManager.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/partialManager.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,51 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_PARTIALMANAGER_H
+#define MT32EMU_PARTIALMANAGER_H
+
+namespace MT32Emu {
+
+class Synth;
+
+class PartialManager {
+private:
+	Synth *synth; // Only used for sending debug output
+	Part **parts;
+
+	Partial *partialTable[MT32EMU_MAX_PARTIALS];
+	Bit8u numReservedPartialsForPart[9];
+
+	bool abortWhereReserveExceeded(PolyState polyState, int minPart);
+
+public:
+
+	PartialManager(Synth *synth, Part **parts);
+	~PartialManager();
+	Partial *allocPartial(int partNum);
+	unsigned int getFreePartialCount(void);
+	bool freePartials(unsigned int needed, int partNum);
+	unsigned int setReserve(Bit8u *rset);
+	void deactivateAll();
+	bool produceOutput(int i, Bit16s *buffer, Bit32u bufferLength);
+	bool shouldReverb(int i);
+	void clearAlreadyOutputed();
+	const Partial *getPartial(unsigned int partialNum) const;
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/poly.h dosboxcvs/include/poly.h
--- dosbox-0.73/include/poly.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/poly.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,65 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_POLY_H
+#define MT32EMU_POLY_H
+
+namespace MT32Emu {
+
+class Part;
+
+enum PolyState {
+	POLY_Playing,
+	POLY_Held, // This marks keys that have been released on the keyboard, but are being held by the pedal
+	POLY_Releasing,
+	POLY_Inactive
+};
+
+class Poly {
+private:
+	Part *part;
+	unsigned int key;
+	unsigned int velocity;
+	unsigned int activePartialCount;
+	bool sustain;
+
+	PolyState state;
+
+	Partial *partials[4];
+
+public:
+	Poly(Part *part);
+	void reset(unsigned int key, unsigned int velocity, bool sustain, Partial **partials);
+	bool noteOff(bool pedalHeld);
+	bool stopPedalHold();
+	bool startDecay();
+	void abort();
+
+	void backupCacheToPartials(PatchCache cache[4]);
+
+	unsigned int getKey() const;
+	unsigned int getVelocity() const;
+	bool canSustain() const;
+	PolyState getState() const;
+	unsigned int getActivePartialCount() const;
+	bool isActive() const;
+
+	void partialDeactivated(Partial *partial);
+};
+
+}
+
+#endif /* POLY_H_ */
diff -urN dosbox-0.73/include/serialport.h dosboxcvs/include/serialport.h
--- dosbox-0.73/include/serialport.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/include/serialport.h	2009-07-08 20:43:08.000000000 +0300
@@ -48,6 +48,78 @@
 
 // Serial port interface 
 
+class MyFifo {
+public:
+	MyFifo(Bitu maxsize_) {
+		maxsize=size=maxsize_;
+		pos=used=0;
+		data=new Bit8u[size];
+	}
+	~MyFifo() {
+		delete[] data;
+	}
+	INLINE Bitu getFree(void) {
+		return size-used;
+	}
+	bool isEmpty() {
+		return used==0;
+	}
+	bool isFull() {
+		return (size-used)==0;
+	}
+
+	INLINE Bitu getUsage(void) {
+		return used;
+	}
+	void setSize(Bitu newsize)
+	{
+		size=newsize;
+		pos=used=0;
+	}
+	void clear(void) {
+		pos=used=0;
+		data[0]=0;
+	}
+
+	bool addb(Bit8u _val) {
+		Bitu where=pos+used;
+		if (where>=size) where-=size;
+		if(used>=size) {
+			// overwrite last byte
+			if(where==0) where=size-1;
+			else where--;
+			data[where]=_val;
+			return false;
+		}
+		data[where]=_val;
+		used++;
+		return true;
+	}
+	Bit8u getb() {
+		if (!used) return data[pos];
+		Bitu where=pos;
+		if (++pos>=size) pos-=size;
+		used--;
+		return data[where];
+	}
+	Bit8u getTop() {
+		Bitu where=pos+used;
+		if (where>=size) where-=size;
+		if(used>=size) {
+			if(where==0) where=size-1;
+			else where--;
+		}
+		return data[where];
+	}
+
+	Bit8u probeByte() {
+		return data[pos];
+	}
+private:
+	Bit8u * data;
+	Bitu maxsize,size,pos,used;
+};
+
 class CSerial {
 public:
 
@@ -58,7 +130,7 @@
 	bool dbg_register;
 	bool dbg_interrupt;
 	bool dbg_aux;
-
+	void log_ser(bool active, char const* format,...);
 #endif
 
 	static bool getBituSubstring(const char* name,Bitu* data, CommandLine* cmd);
@@ -92,8 +164,9 @@
 #define SERIAL_RX_EVENT 4
 #define SERIAL_POLLING_EVENT 5
 #define SERIAL_THR_EVENT 6
+#define SERIAL_RX_TIMEOUT_EVENT 7
 
-#define	SERIAL_BASE_EVENT_COUNT 6
+#define	SERIAL_BASE_EVENT_COUNT 7
 
 #define COMNUMBER idnumber+1
 
@@ -144,6 +217,7 @@
 	
 	// If a byte comes from loopback or prepherial, put it in here.
 	void receiveByte(Bit8u data);
+	void receiveByteEx(Bit8u data, Bit8u error);
 
 	// If an error was received, put it here (in LSR register format)
 	void receiveError(Bit8u errorword);
@@ -191,23 +265,20 @@
 	#define RX_PRIORITY 1		// a byte has been received
 	#define TX_PRIORITY 2		// tx buffer has become empty
 	#define MSR_PRIORITY 8		// CRS, DSR, RI, DCD change 
+	#define TIMEOUT_PRIORITY 0x10
 	#define NONE_PRIORITY 0
 
 	Bit8u waiting_interrupts;	// these are on, but maybe not enabled
 	
-	// 16C450 (no FIFO)
+	// 16C550
 	//				read/write		name
 
 	Bit16u baud_divider;
-	Bit8u RHR;	//	r				Receive Holding Register, also LSB of Divisor Latch (r/w)
-	#define RHR_OFFSET 0
-				// Data: whole byte
-
-	Bit8u THR;	//	w				Transmit Holding Register
-	#define THR_OFFSET 0
-				// Data: whole byte
-
-	Bit8u IER;	//	r/w				Interrupt Enable Register, also MSB of Divisor Latch
+	#define RHR_OFFSET 0	// r Receive Holding Register, also LSB of Divisor Latch (r/w)
+							// Data: whole byte
+	#define THR_OFFSET 0	// w Transmit Holding Register
+							// Data: whole byte
+	Bit8u IER;	//	r/w		Interrupt Enable Register, also MSB of Divisor Latch
 	#define IER_OFFSET 1
 
 	bool irq_active;
@@ -221,6 +292,7 @@
 	#define ISR_OFFSET 2
 
 	#define ISR_CLEAR_VAL 0x1
+	#define ISR_FIFOTIMEOUT_VAL 0xc
 	#define ISR_ERROR_VAL 0x6
 	#define ISR_RX_VAL 0x4
 	#define ISR_TX_VAL 0x2
@@ -292,6 +364,7 @@
 	Bitu framingErrors;
 	Bitu parityErrors;
 	Bitu overrunErrors;
+	Bitu txOverrunErrors;
 	Bitu overrunIF0;
 	Bitu breakErrors;
 
@@ -329,16 +402,28 @@
 	void transmitLoopbackByte(Bit8u val, bool value);
 
 	// 16C550 (FIFO)
-	// TODO
+	public: // todo remove
+	MyFifo* rxfifo;
+	private:
+	MyFifo* txfifo;
+	MyFifo* errorfifo;
+	Bitu errors_in_fifo;
+	Bitu rx_interrupt_threshold;
+	Bitu fifosize;
+	Bit8u FCR;
+	bool sync_guardtime;
+	#define FIFO_STATUS_ACTIVE 0xc0 // FIFO is active AND works ;)
+	#define FIFO_ERROR 0x80
+	#define FCR_ACTIVATE 0x01
+	#define FCR_CLEAR_RX 0x02
+	#define FCR_CLEAR_TX 0x04
 	#define FCR_OFFSET 2
-	bool fifo_warn;
-	//Bit8u FCR;	// FIFO Control Register
-	
+	#define FIFO_FLOWCONTROL 0x20
 };
 
 extern CSerial* serialports[];
-const Bit8u serial_defaultirq[4] = { 4, 3, 4, 3 };
-const Bit16u serial_baseaddr[4] = {0x3f8,0x2f8,0x3e8,0x2e8};
+const Bit8u serial_defaultirq[] = { 4, 3, 4, 3 };
+const Bit16u serial_baseaddr[] = {0x3f8,0x2f8,0x3e8,0x2e8};
 const char* const serial_comname[]={"COM1","COM2","COM3","COM4"};
 
 // the COM devices
diff -urN dosbox-0.73/include/shell.h dosboxcvs/include/shell.h
--- dosbox-0.73/include/shell.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/include/shell.h	2009-07-08 20:43:08.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: shell.h,v 1.27 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: shell.h,v 1.28 2009/07/03 19:36:57 qbix79 Exp $ */
 
 #ifndef DOSBOX_SHELL_H
 #define DOSBOX_SHELL_H
@@ -55,6 +55,7 @@
 	DOS_Shell * shell;
 	BatchFile * prev;
 	CommandLine * cmd;
+	std::string filename;
 };
 
 class AutoexecEditor;
@@ -87,6 +88,8 @@
 	void CMD_HELP(char * args);
 	void CMD_CLS(char * args);
 	void CMD_COPY(char * args);
+	void CMD_DATE(char * args);
+	void CMD_TIME(char * args);
 	void CMD_DIR(char * args);
 	void CMD_DELETE(char * args);
 	void CMD_ECHO(char * args);
diff -urN dosbox-0.73/include/structures.h dosboxcvs/include/structures.h
--- dosbox-0.73/include/structures.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/structures.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,233 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_STRUCTURES_H
+#define MT32EMU_STRUCTURES_H
+
+namespace MT32Emu {
+
+const unsigned int MAX_SAMPLE_OUTPUT = 4096;
+
+// MT32EMU_MEMADDR() converts from sysex-padded, MT32EMU_SYSEXMEMADDR converts to it
+// Roland provides documentation using the sysex-padded addresses, so we tend to use that in code and output
+#define MT32EMU_MEMADDR(x) ((((x) & 0x7f0000) >> 2) | (((x) & 0x7f00) >> 1) | ((x) & 0x7f))
+#define MT32EMU_SYSEXMEMADDR(x) ((((x) & 0x1FC000) << 2) | (((x) & 0x3F80) << 1) | ((x) & 0x7f))
+
+#ifdef _MSC_VER
+#define  MT32EMU_ALIGN_PACKED __declspec(align(1))
+#ifndef DOSBOX_DOSBOX_H
+typedef unsigned __int64   Bit64u;
+typedef   signed __int64   Bit64s;
+#endif
+#else
+#define MT32EMU_ALIGN_PACKED __attribute__((packed))
+#ifndef DOSBOX_DOSBOX_H
+typedef unsigned long long Bit64u;
+typedef   signed long long Bit64s;
+#endif
+#endif
+
+#ifndef DOSBOX_DOSBOX_H
+typedef unsigned int       Bit32u;
+typedef   signed int       Bit32s;
+typedef unsigned short int Bit16u;
+typedef   signed short int Bit16s;
+typedef unsigned char      Bit8u;
+typedef   signed char      Bit8s;
+#endif
+
+// The following structures represent the MT-32's memory
+// Since sysex allows this memory to be written to in blocks of bytes,
+// we keep this packed so that we can copy data into the various
+// banks directly
+#if defined(_MSC_VER) || defined (__MINGW32__)
+#pragma pack(push, 1)
+#else
+#pragma pack(1)
+#endif
+
+struct TimbreParam {
+	struct CommonParam {
+		char name[10];
+		Bit8u partialStructure12;  // 1 & 2  0-12 (1-13)
+		Bit8u partialStructure34;  // 3 & 4  0-12 (1-13)
+		Bit8u partialMute;  // 0-15 (0000-1111)
+		Bit8u noSustain; // ENV MODE 0-1 (Normal, No sustain)
+	} MT32EMU_ALIGN_PACKED common;
+
+	struct PartialParam {
+		struct WGParam {
+			Bit8u pitchCoarse;  // 0-96 (C1,C#1-C9)
+			Bit8u pitchFine;  // 0-100 (-50 to +50 (cents - confirmed by Mok))
+			Bit8u pitchKeyfollow;  // 0-16 (-1, -1/2, -1/4, 0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1, 5/4, 3/2, 2, s1, s2)
+			Bit8u pitchBenderEnabled;  // 0-1 (OFF, ON)
+			Bit8u waveform; // MT-32: 0-1 (SQU/SAW); LAPC-I: WG WAVEFORM/PCM BANK 0 - 3 (SQU/1, SAW/1, SQU/2, SAW/2)
+			Bit8u pcmWave; // 0-127 (1-128)
+			Bit8u pulseWidth; // 0-100
+			Bit8u pulseWidthVeloSensitivity; // 0-14 (-7 - +7)
+		} MT32EMU_ALIGN_PACKED wg;
+
+		struct PitchEnvParam {
+			Bit8u depth; // 0-10
+			Bit8u veloSensitivity; // 0-100
+			Bit8u timeKeyfollow; // 0-4
+			Bit8u time[4]; // 0-100
+			Bit8u level[5]; // 0-100 (-50 - +50) // [3]: SUSTAIN LEVEL, [4]: END LEVEL
+		} MT32EMU_ALIGN_PACKED pitchEnv;
+
+		struct PitchLFOParam {
+			Bit8u rate; // 0-100
+			Bit8u depth; // 0-100
+			Bit8u modSensitivity; // 0-100
+		} MT32EMU_ALIGN_PACKED pitchLFO;
+
+		struct TVFParam {
+			Bit8u cutoff; // 0-100
+			Bit8u resonance; // 0-30
+			Bit8u keyfollow; // -1, -1/2, -1/4, 0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1, 5/4, 3/2, 2
+			Bit8u biasPoint; // 0-127 (<1A-<7C >1A-7C)
+			Bit8u biasLevel; // 0-14 (-7 - +7)
+			Bit8u envDepth; // 0-100
+			Bit8u envVeloSensitivity; // 0-100
+			Bit8u envDepthKeyfollow; // DEPTH KEY FOLL0W 0-4
+			Bit8u envTimeKeyfollow; // TIME KEY FOLLOW 0-4
+			Bit8u envTime[5]; // 0-100
+			Bit8u envLevel[4]; // 0-100 // [3]: SUSTAIN LEVEL
+		} MT32EMU_ALIGN_PACKED tvf;
+
+		struct TVAParam {
+			Bit8u level; // 0-100
+			Bit8u veloSensitivity; // 0-100
+			Bit8u biasPoint1; // 0-127 (<1A-<7C >1A-7C)
+			Bit8u biasLevel1; // 0-12 (-12 - 0)
+			Bit8u biasPoint2; // 0-127 (<1A-<7C >1A-7C)
+			Bit8u biasLevel2; // 0-12 (-12 - 0)
+			Bit8u envTimeKeyfollow; // TIME KEY FOLLOW 0-4
+			Bit8u envTimeVeloSensitivity; // VELOS KEY FOLL0W 0-4
+			Bit8u envTime[5]; // 0-100
+			Bit8u envLevel[4]; // 0-100 // [3]: SUSTAIN LEVEL
+		} MT32EMU_ALIGN_PACKED tva;
+	} MT32EMU_ALIGN_PACKED partial[4];
+} MT32EMU_ALIGN_PACKED;
+
+struct PatchParam {
+	Bit8u timbreGroup; // TIMBRE GROUP  0-3 (group A, group B, Memory, Rhythm)
+	Bit8u timbreNum; // TIMBRE NUMBER 0-63
+	Bit8u keyShift; // KEY SHIFT 0-48 (-24 - +24 semitones)
+	Bit8u fineTune; // FINE TUNE 0-100 (-50 - +50 cents)
+	Bit8u benderRange; // BENDER RANGE 0-24
+	Bit8u assignMode;  // ASSIGN MODE 0-3 (POLY1, POLY2, POLY3, POLY4)
+	Bit8u reverbSwitch;  // REVERB SWITCH 0-1 (OFF,ON)
+	Bit8u dummy; // (DUMMY)
+} MT32EMU_ALIGN_PACKED;
+
+struct MemParams {
+	// NOTE: The MT-32 documentation only specifies PatchTemp areas for parts 1-8.
+	// The LAPC-I documentation specified an additional area for rhythm at the end,
+	// where all parameters but fine tune, assign mode and output level are ignored
+	struct PatchTemp {
+		PatchParam patch;
+		Bit8u outputLevel; // OUTPUT LEVEL 0-100
+		Bit8u panpot; // PANPOT 0-14 (R-L)
+		Bit8u dummyv[6];
+	} MT32EMU_ALIGN_PACKED patchTemp[9];
+
+	struct RhythmTemp {
+		Bit8u timbre; // TIMBRE  0-94 (M1-M64,R1-30,OFF); LAPC-I: 0-127 (M01-M64,R01-R63)
+		Bit8u outputLevel; // OUTPUT LEVEL 0-100
+		Bit8u panpot; // PANPOT 0-14 (R-L)
+		Bit8u reverbSwitch;  // REVERB SWITCH 0-1 (OFF,ON)
+	} MT32EMU_ALIGN_PACKED rhythmTemp[85];
+
+	TimbreParam timbreTemp[8];
+
+	PatchParam patches[128];
+
+	// NOTE: There are only 30 timbres in the "rhythm" bank for MT-32; the additional 34 are for LAPC-I and above
+	struct PaddedTimbre {
+		TimbreParam timbre;
+		Bit8u padding[10];
+	} MT32EMU_ALIGN_PACKED timbres[64 + 64 + 64 + 64]; // Group A, Group B, Memory, Rhythm
+
+	struct System {
+		Bit8u masterTune; // MASTER TUNE 0-127 432.1-457.6Hz
+		Bit8u reverbMode; // REVERB MODE 0-3 (room, hall, plate, tap delay)
+		Bit8u reverbTime; // REVERB TIME 0-7 (1-8)
+		Bit8u reverbLevel; // REVERB LEVEL 0-7 (1-8)
+		Bit8u reserveSettings[9]; // PARTIAL RESERVE (PART 1) 0-32
+		Bit8u chanAssign[9]; // MIDI CHANNEL (PART1) 0-16 (1-16,OFF)
+		Bit8u masterVol; // MASTER VOLUME 0-100
+	} MT32EMU_ALIGN_PACKED system;
+};
+
+#if defined(_MSC_VER) || defined (__MINGW32__)
+#pragma pack(pop)
+#else
+#pragma pack()
+#endif
+
+struct ControlROMPCMStruct;
+
+struct PCMWaveEntry {
+	Bit32u addr;
+	Bit32u len;
+	double tune;
+	bool loop;
+	bool unaffectedByMasterTune;
+	ControlROMPCMStruct *controlROMPCMStruct;
+};
+
+struct StereoVolume {
+	Bit16u leftvol;
+	Bit16u rightvol;
+};
+
+// This is basically a per-partial, pre-processed combination of timbre and patch/rhythm settings
+struct PatchCache {
+	bool playPartial;
+	bool PCMPartial;
+	int pcm;
+	char waveform;
+	int pulsewidth;
+	int pwsens;
+
+	int filtkeyfollow;
+
+	TimbreParam::PartialParam::TVFParam filtEnv;
+
+	Bit32s filtsustain;
+
+	Bit32u structureMix;
+	int structurePosition;
+	int structurePair;
+
+	// The following fields are actually common to all partials in the timbre
+	bool dirty;
+	Bit32u partialCount;
+	bool sustain;
+	bool reverb;
+
+	TimbreParam::PartialParam srcPartial;
+
+	// The following directly points into live sysex-addressable memory
+	const TimbreParam::PartialParam *partialParam;
+};
+
+class Partial; // Forward reference for class defined in partial.h
+
+}
+
+#endif
diff -urN dosbox-0.73/include/synth.h dosboxcvs/include/synth.h
--- dosbox-0.73/include/synth.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/synth.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,407 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_SYNTH_H
+#define MT32EMU_SYNTH_H
+
+#include <stdarg.h>
+
+class revmodel;
+
+namespace MT32Emu {
+
+class File;
+class TableInitialiser;
+class Partial;
+class PartialManager;
+class Part;
+
+enum ReportType {
+	// Errors
+	ReportType_errorControlROM = 1,
+	ReportType_errorPCMROM,
+	ReportType_errorSampleRate,
+
+	// Progress
+	ReportType_progressInit,
+
+	// HW spec
+	ReportType_availableSSE,
+	ReportType_available3DNow,
+	ReportType_usingSSE,
+	ReportType_using3DNow,
+
+	// General info
+	ReportType_lcdMessage,
+	ReportType_devReset,
+	ReportType_devReconfig,
+	ReportType_newReverbMode,
+	ReportType_newReverbTime,
+	ReportType_newReverbLevel
+};
+
+struct SynthProperties {
+	// Sample rate to use in mixing
+	unsigned int sampleRate;
+
+	// Deprecated - ignored. Use Synth::setReverbEnabled() instead.
+	bool useReverb;
+	// Deprecated - ignored. Use Synth::setReverbOverridden() instead.
+	bool useDefaultReverb;
+	// Deprecated - ignored. Use Synth::setReverbParameters() instead.
+	unsigned char reverbType;
+	// Deprecated - ignored. Use Synth::setReverbParameters() instead.
+	unsigned char reverbTime;
+	// Deprecated - ignored. Use Synth::setReverbParameters() instead.
+	unsigned char reverbLevel;
+	// The name of the directory in which the ROM and data files are stored (with trailing slash/backslash)
+	// Not used if "openFile" is set. May be NULL in any case.
+	char *baseDir;
+	// This is used as the first argument to all callbacks
+	void *userData;
+	// Callback for reporting various errors and information. May be NULL
+	int (*report)(void *userData, ReportType type, const void *reportData);
+	// Callback for providing an implementation of File, opened and ready for use
+	// May be NULL, in which case a default implementation will be used.
+	File *(*openFile)(void *userData, const char *filename, File::OpenMode mode);
+	// Callback for closing a File. May be NULL, in which case the File will automatically be close()d/deleted.
+	void (*closeFile)(void *userData, File *file);
+};
+
+// This is the specification of the Callback routine used when calling the RecalcWaveforms
+// function
+typedef void (*recalcStatusCallback)(int percDone);
+
+// This external function recreates the base waveform file (waveforms.raw) using a specifed
+// sampling rate.  The callback routine provides interactivity to let the user know what
+// percentage is complete in regenerating the waveforms.  When a NULL pointer is used as the
+// callback routine, no status is reported.
+bool RecalcWaveforms(char * baseDir, int sampRate, recalcStatusCallback callBack);
+
+typedef float (*iir_filter_type)(float input,float *hist1_ptr, const float *coef_ptr);
+
+const Bit8u SYSEX_MANUFACTURER_ROLAND = 0x41;
+
+const Bit8u SYSEX_MDL_MT32 = 0x16;
+const Bit8u SYSEX_MDL_D50 = 0x14;
+
+const Bit8u SYSEX_CMD_RQ1 = 0x11; // Request data #1
+const Bit8u SYSEX_CMD_DT1 = 0x12; // Data set 1
+const Bit8u SYSEX_CMD_WSD = 0x40; // Want to send data
+const Bit8u SYSEX_CMD_RQD = 0x41; // Request data
+const Bit8u SYSEX_CMD_DAT = 0x42; // Data set
+const Bit8u SYSEX_CMD_ACK = 0x43; // Acknowledge
+const Bit8u SYSEX_CMD_EOD = 0x45; // End of data
+const Bit8u SYSEX_CMD_ERR = 0x4E; // Communications error
+const Bit8u SYSEX_CMD_RJC = 0x4F; // Rejection
+
+const int MAX_SYSEX_SIZE = 512;
+
+const unsigned int CONTROL_ROM_SIZE = 64 * 1024;
+
+struct ControlROMPCMStruct
+{
+	Bit8u pos;
+	Bit8u len;
+	Bit8u pitchLSB;
+	Bit8u pitchMSB;
+};
+
+struct ControlROMMap {
+	Bit16u idPos;
+	Bit16u idLen;
+	const char *idBytes;
+	Bit16u pcmTable; // 4 * pcmCount bytes
+	Bit16u pcmCount;
+	Bit16u timbreAMap; // 128 bytes
+	Bit16u timbreAOffset;
+	bool timbreACompressed;
+	Bit16u timbreBMap; // 128 bytes
+	Bit16u timbreBOffset;
+	bool timbreBCompressed;
+	Bit16u timbreRMap; // 2 * timbreRCount bytes
+	Bit16u timbreRCount;
+	Bit16u rhythmSettings; // 4 * rhythmSettingsCount bytes
+	Bit16u rhythmSettingsCount;
+	Bit16u reserveSettings; // 9 bytes
+	Bit16u panSettings; // 8 bytes
+	Bit16u programSettings; // 8 bytes
+	Bit16u rhythmMaxTable; // 4 bytes
+	Bit16u patchMaxTable; // 16 bytes
+	Bit16u systemMaxTable; // 23 bytes
+	Bit16u timbreMaxTable; // 72 bytes
+};
+
+enum MemoryRegionType {
+	MR_PatchTemp, MR_RhythmTemp, MR_TimbreTemp, MR_Patches, MR_Timbres, MR_System, MR_Display, MR_Reset
+};
+
+class MemoryRegion {
+private:
+	Synth *synth;
+	Bit8u *realMemory;
+	Bit8u *maxTable;
+public:
+	MemoryRegionType type;
+	Bit32u startAddr, entrySize, entries;
+
+	MemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable, MemoryRegionType type, Bit32u startAddr, Bit32u entrySize, Bit32u entries) {
+		this->synth = synth;
+		this->realMemory = realMemory;
+		this->maxTable = maxTable;
+		this->type = type;
+		this->startAddr = startAddr;
+		this->entrySize = entrySize;
+		this->entries = entries;
+	}
+	int lastTouched(Bit32u addr, Bit32u len) const {
+		return (offset(addr) + len - 1) / entrySize;
+	}
+	int firstTouchedOffset(Bit32u addr) const {
+		return offset(addr) % entrySize;
+	}
+	int firstTouched(Bit32u addr) const {
+		return offset(addr) / entrySize;
+	}
+	Bit32u regionEnd() const {
+		return startAddr + entrySize * entries;
+	}
+	bool contains(Bit32u addr) const {
+		return addr >= startAddr && addr < regionEnd();
+	}
+	int offset(Bit32u addr) const {
+		return addr - startAddr;
+	}
+	Bit32u getClampedLen(Bit32u addr, Bit32u len) const {
+		if (addr + len > regionEnd())
+			return regionEnd() - addr;
+		return len;
+	}
+	Bit32u next(Bit32u addr, Bit32u len) const {
+		if (addr + len > regionEnd()) {
+			return regionEnd() - addr;
+		}
+		return 0;
+	}
+	Bit8u getMaxValue(int off) const {
+		if (maxTable == NULL)
+			return 0xFF;
+		return maxTable[off % entrySize];
+	}
+	Bit8u *getRealMemory() const {
+		return realMemory;
+	}
+	bool isReadable() const {
+		return getRealMemory() != NULL;
+	}
+	void read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const;
+	void write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init = false) const;
+};
+
+class PatchTempMemoryRegion : public MemoryRegion {
+public:
+	PatchTempMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_PatchTemp, MT32EMU_MEMADDR(0x030000), sizeof(MemParams::PatchTemp), 9) {}
+};
+class RhythmTempMemoryRegion : public MemoryRegion {
+public:
+	RhythmTempMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_RhythmTemp, MT32EMU_MEMADDR(0x030110), sizeof(MemParams::RhythmTemp), 85) {}
+};
+class TimbreTempMemoryRegion : public MemoryRegion {
+public:
+	TimbreTempMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_TimbreTemp, MT32EMU_MEMADDR(0x040000), sizeof(TimbreParam), 8) {}
+};
+class PatchesMemoryRegion : public MemoryRegion {
+public:
+	PatchesMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_Patches, MT32EMU_MEMADDR(0x050000), sizeof(PatchParam), 128) {}
+};
+class TimbresMemoryRegion : public MemoryRegion {
+public:
+	TimbresMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_Timbres, MT32EMU_MEMADDR(0x080000), sizeof(MemParams::PaddedTimbre), 64 + 64 + 64 + 64) {}
+};
+class SystemMemoryRegion : public MemoryRegion {
+public:
+	SystemMemoryRegion(Synth *synth, Bit8u *realMemory, Bit8u *maxTable) : MemoryRegion(synth, realMemory, maxTable, MR_System, MT32EMU_MEMADDR(0x100000), sizeof(MemParams::System), 1) {}
+};
+class DisplayMemoryRegion : public MemoryRegion {
+public:
+	DisplayMemoryRegion(Synth *synth) : MemoryRegion(synth, NULL, NULL, MR_Display, MT32EMU_MEMADDR(0x200000), MAX_SYSEX_SIZE - 1, 1) {}
+};
+class ResetMemoryRegion : public MemoryRegion {
+public:
+	ResetMemoryRegion(Synth *synth) : MemoryRegion(synth, NULL, NULL, MR_Reset, MT32EMU_MEMADDR(0x7F0000), 0x3FFF, 1) {}
+};
+
+class ReverbModel {
+public:
+	virtual ~ReverbModel() {};
+	virtual void setSampleRate(unsigned int sampleRate) = 0;
+	virtual void setParameters(Bit8u mode, Bit8u time, Bit8u level) = 0;
+	virtual void process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, long numSamples) = 0;
+	virtual void reset() = 0;
+};
+
+class FreeverbModel : public ReverbModel {
+	revmodel *freeverb;
+public:
+	FreeverbModel();
+	~FreeverbModel();
+	void setSampleRate(unsigned int sampleRate);
+	void setParameters(Bit8u mode, Bit8u time, Bit8u level);
+	void process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, long numSamples);
+	void reset();
+};
+
+class Synth {
+friend class Part;
+friend class RhythmPart;
+friend class Partial;
+friend class Tables;
+friend class MemoryRegion;
+friend class TVA;
+friend class TVP;
+friend class TVF;
+private:
+	PatchTempMemoryRegion *patchTempMemoryRegion;
+	RhythmTempMemoryRegion *rhythmTempMemoryRegion;
+	TimbreTempMemoryRegion *timbreTempMemoryRegion;
+	PatchesMemoryRegion *patchesMemoryRegion;
+	TimbresMemoryRegion *timbresMemoryRegion;
+	SystemMemoryRegion *systemMemoryRegion;
+	DisplayMemoryRegion *displayMemoryRegion;
+	ResetMemoryRegion *resetMemoryRegion;
+
+	Bit8u *paddedTimbreMaxTable;
+
+	bool isEnabled;
+
+	iir_filter_type iirFilter;
+
+	PCMWaveEntry *pcmWaves; // Array
+
+	const ControlROMMap *controlROMMap;
+	Bit8u controlROMData[CONTROL_ROM_SIZE];
+	Bit16s *pcmROMData;
+	int pcmROMSize; // This is in 16-bit samples, therefore half the number of bytes in the ROM
+
+	Bit8s chantable[32];
+
+	#if MT32EMU_MONITOR_PARTIALS == 1
+	static Bit32s samplepos = 0;
+	#endif
+
+	Tables tables;
+
+	MemParams mt32ram, mt32default;
+
+	ReverbModel *reverbModel;
+	ReverbModel *delayReverbModel;
+	bool reverbEnabled;
+	bool reverbOverridden;
+
+	float masterTune;
+
+	bool isOpen;
+
+	PartialManager *partialManager;
+	Part *parts[9];
+
+	Bit16s tmpBuffer[MAX_SAMPLE_OUTPUT * 2];
+	float sndbufl[MAX_SAMPLE_OUTPUT];
+	float sndbufr[MAX_SAMPLE_OUTPUT];
+	float outbufl[MAX_SAMPLE_OUTPUT];
+	float outbufr[MAX_SAMPLE_OUTPUT];
+
+	SynthProperties myProp;
+
+	bool loadPreset(File *file);
+	void doRender(Bit16s * stream, Bit32u len);
+
+	void playAddressedSysex(unsigned char channel, const Bit8u *sysex, Bit32u len);
+	void readSysex(unsigned char channel, const Bit8u *sysex, Bit32u len);
+	void initMemoryRegions();
+	void deleteMemoryRegions();
+	MemoryRegion *findMemoryRegion(Bit32u addr);
+	void writeMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u len, const Bit8u *data);
+	void readMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u len, Bit8u *data);
+
+	bool loadControlROM(const char *filename);
+	bool loadPCMROM(const char *filename);
+	bool dumpTimbre(File *file, const TimbreParam *timbre, Bit32u addr);
+	int dumpTimbres(const char *filename, int start, int len);
+
+	bool initPCMList(Bit16u mapAddress, Bit16u count);
+	bool initTimbres(Bit16u mapAddress, Bit16u offset, int timbreCount, int startTimbre, bool compressed);
+	bool initCompressedTimbre(int drumNum, const Bit8u *mem, unsigned int memLen);
+	bool refreshSystem();
+	void reset();
+
+	unsigned int getSampleRate() const;
+protected:
+	int report(ReportType type, const void *reportData);
+	File *openFile(const char *filename, File::OpenMode mode);
+	void closeFile(File *file);
+
+public:
+	static Bit8u calcSysexChecksum(const Bit8u *data, Bit32u len, Bit8u checksum);
+
+	Synth();
+	~Synth();
+
+	// Used to initialise the MT-32. Must be called before any other function.
+	// Returns true if initialization was sucessful, otherwise returns false.
+	bool open(SynthProperties &useProp);
+
+	// Closes the MT-32 and deallocates any memory used by the synthesizer
+	void close(void);
+
+	// Sends a 4-byte MIDI message to the MT-32 for immediate playback
+	void playMsg(Bit32u msg);
+	void playMsgOnPart(unsigned char part, unsigned char code, unsigned char note, unsigned char velocity);
+
+	// Sends a string of Sysex commands to the MT-32 for immediate interpretation
+	// The length is in bytes
+	void playSysex(const Bit8u *sysex, Bit32u len);
+	void playSysexWithoutFraming(const Bit8u *sysex, Bit32u len);
+	void playSysexWithoutHeader(unsigned char device, unsigned char command, const Bit8u *sysex, Bit32u len);
+	void writeSysex(unsigned char channel, const Bit8u *sysex, Bit32u len);
+
+	void setReverbModel(ReverbModel *reverbModel);
+	void setDelayReverbModel(ReverbModel *reverbModel);
+	void setReverbEnabled(bool reverbEnabled);
+	bool isReverbEnabled() const;
+	void setReverbOverridden(bool reverbOverridden);
+	bool isReverbOverridden() const;
+	void setReverbParameters(Bit8u mode, Bit8u time, Bit8u level);
+
+	// Renders samples to the specified output stream.
+	// The length is in frames, not bytes (in 16-bit stereo,
+	// one frame is 4 bytes).
+	void render(Bit16s *stream, Bit32u len);
+
+	// Returns true when there is at least one active partial, otherwise false.
+	bool isActive() const;
+
+	const Partial *getPartial(unsigned int partialNum) const;
+
+	void readMemory(Bit32u addr, Bit32u len, Bit8u *data);
+
+	// partNum should be 0..7 for Part 1..8, or 8 for Rhythm
+	const Part *getPart(unsigned int partNum) const;
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/tables.h dosboxcvs/include/tables.h
--- dosbox-0.73/include/tables.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/tables.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,119 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_TABLES_H
+#define MT32EMU_TABLES_H
+
+#include "blit/BlitSaw.h"
+#include "blit/BlitSquare.h"
+
+namespace MT32Emu {
+
+// Mathematical constants
+const double DOUBLE_PI = 3.1415926535897932384626433832795;
+const double DOUBLE_LN_10 = 2.3025850929940456840179914546844;
+const float FLOAT_PI = 3.1415926535897932384626433832795f;
+const float FLOAT_LN_10 = 2.3025850929940456840179914546844f;
+const float FLOAT_LN_2 = 0.6931472f;
+
+// Filter settings
+//const int FILTERGRAN = 512;
+//const int FILTERGRAN = 32768;
+const int FILTERGRAN = 16000;
+
+
+// Amplitude of waveform generator
+// FIXME: This value is the amplitude possible whilst avoiding
+// overdriven values immediately after filtering when playing
+// back SQ3MT.MID. Needs to be checked.
+const int WGAMP = 12382;
+
+const int MIDDLEC = 60;
+const int MIDDLEA = 69; // By this I mean "A above middle C"
+
+// FIXME:KG: may only need to do 12 to 108
+// 12..108 is the range allowed by note on commands, but the key can be modified by pitch keyfollow
+// and adjustment for timbre pitch, so the results can be outside that range.
+// Should we move it (by octave) into the 12..108 range, or keep it in 0..127 range,
+// or something else altogether?
+const int LOWEST_NOTE = 12;
+const int HIGHEST_NOTE = 127;
+const int NUM_NOTES = HIGHEST_NOTE - LOWEST_NOTE + 1; // Number of slots for note LUT
+
+static const int filtMultKeyfollow[17] = {
+	-21, -10, -5, 0, 2, 5, 8, 10, 13, 16, 18, 21, 26, 32, 42, 21, 21
+};
+
+static const int BiasLevel_MulTable[15] = {
+	85, 42, 21, 16, 10, 5, 2, 0, -2, -5, -10, -16, -21, -74, -85
+};
+
+class Synth;
+
+struct KeyLookup {
+	Bit32s envTimeMult[5]; // For envelope time adjustment for key pressed
+};
+
+class Tables {
+	float initialisedSampleRate;
+	float initialisedMasterTune;
+	void initMT32ConstantTables(Synth *synth);
+	static Bit16s clampWF(Synth *synth, const char *n, float ampVal, double input);
+	static File *initWave(Synth *synth, float ampsize, float div2, File *file);
+	void initEnvelopes(float sampleRate);
+	void initFiltCoeff(float samplerate);
+public:
+	// Constant LUTs
+
+	// CONFIRMED: This is used to convert several parameters to amp-modifying values in the TVA envelope:
+	// - PatchTemp.outputLevel
+	// - RhythmTemp.outlevel
+	// - PartialParam.tva.level
+	// - expression
+	// It's used to determine how much to subtract from the amp envelope's target value
+	Bit8u levelToAmpSubtraction[101];
+
+	// CONFIRMED: ...
+	Bit8u envLogarithmicTime[256];
+
+	// CONFIRMED: ...
+	Bit8u masterVolToAmpSubtraction[101];
+
+	// CONFIRMED:
+	Bit8u pulseWidth100To255[101];
+
+	Bit32s tvfKeyfollowMult[217];
+	Bit16s noiseBuf[MAX_SAMPLE_OUTPUT];
+	Bit32s pwVelfollowAdd[15][128];
+	float resonanceFactor[31];
+	float pwFactorf[101];
+
+	// LUTs varying with sample rate
+	Bit32u envTime[101];
+	Bit32u envDeltaMaxTime[101];
+	Bit32u envDecayTime[101];
+	float filtCoeff[FILTERGRAN][31][12];
+
+	// Various LUTs for each key
+	KeyLookup keyLookups[97];
+
+	Tables();
+	bool init(Synth *synth, PCMWaveEntry *pcmWaves, float sampleRate, float masterTune);
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/tva.h dosboxcvs/include/tva.h
--- dosbox-0.73/include/tva.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/tva.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,60 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_TVA_H
+#define MT32EMU_TVA_H
+
+namespace MT32Emu {
+
+class Part;
+
+class TVA {
+private:
+	const Partial * const partial;
+	const MemParams::System * const system;
+
+	const Part *part;
+	const TimbreParam::PartialParam *partialParam;
+	const MemParams::PatchTemp *patchTemp;
+	const MemParams::RhythmTemp *rhythmTemp;
+
+	int biasAmpSubtraction;
+	int veloAmpSubtraction;
+	int keyTimeSubtraction;
+
+	int targetPhase;
+	Bit32u currentAmp;
+	// AFAICT: Lower 7 bits indicate how quickly currentAmp should be changed, most significant bit indicates change direction (set=downward)
+	Bit8u targetAmp;
+	Bit8u ampIncrement;
+	unsigned int largeAmpInc;
+	void setAmpIncrement(Bit8u ampIncrement);
+	void nextPhase();
+
+public:
+	// FIXME: This should probably have a getter
+	bool play;
+
+	TVA(const Partial *partial);
+	void reset(const Part *part, const PatchCache *patchCache, const MemParams::RhythmTemp *rhythmTemp);
+	float nextAmp();
+	void recalcSustain();
+	void startDecay();
+};
+
+}
+
+#endif /* TVA_H_ */
diff -urN dosbox-0.73/include/tvf.h dosboxcvs/include/tvf.h
--- dosbox-0.73/include/tvf.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/tvf.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,48 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_TVF_H
+#define MT32EMU_TVF_H
+
+namespace MT32Emu {
+
+class TVF {
+private:
+	const Partial * const partial;
+	const TimbreParam::PartialParam *partialParam;
+
+	Bit8u baseCutoff;
+	int keyTimeSubtraction;
+	unsigned int levelMult;
+
+	unsigned int targetPhase;
+	Bit32u current;
+	Bit8u target;
+	Bit8u increment;
+	unsigned int bigIncrement;
+	void setIncrement(Bit8u ampIncrement);
+	void nextPhase();
+
+public:
+	TVF(const Partial *partial);
+	void reset(const TimbreParam::PartialParam *partialParam, Bit32u basePitch);
+	unsigned int nextFilt();
+	void startDecay();
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/tvp.h dosboxcvs/include/tvp.h
--- dosbox-0.73/include/tvp.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/include/tvp.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,66 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MT32EMU_TVP_H
+#define MT32EMU_TVP_H
+
+namespace MT32Emu {
+
+class TVP {
+private:
+	const Partial * const partial;
+	const MemParams::System * const system; // FIXME: Only necessary because masterTune calculation is done in the wrong place atm.
+
+	const Part *part;
+	const TimbreParam::PartialParam *partialParam;
+	const MemParams::PatchTemp *patchTemp;
+
+	int maxCounter;
+	int processTimerIncrement;
+	int counter;
+	Bit32u timeElapsed;
+
+	int phase;
+	Bit32u basePitch;
+	Bit32u targetPitchOffsetWithoutLFO;
+	Bit32u currentPitchOffset;
+
+	Bit8s lfoPitchOffset;
+	// In range -12 - 36
+	Bit8s timeKeyfollowSubtraction;
+
+	Bit16s pitchOffsetChangePerBigTick;
+	int targetPitchOffsetReachedBigTick;
+	unsigned int shifts;
+
+	Bit16u pitch;
+
+	void updatePitch();
+	void setupPitchChange(int targetPitchOffset, Bit8u changeDuration);
+	void targetPitchOffsetReached();
+	void nextPhase();
+	void process();
+public:
+	TVP(const Partial *partial);
+	void reset(const Part *part, const PatchCache *patchCache);
+	Bit32u getBasePitch() const;
+	Bit16u nextPitch();
+	void startDecay();
+};
+
+}
+
+#endif
diff -urN dosbox-0.73/include/vga.h dosboxcvs/include/vga.h
--- dosbox-0.73/include/vga.h	2009-05-25 21:44:44.000000000 +0300
+++ dosboxcvs/include/vga.h	2009-06-29 21:43:33.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: vga.h,v 1.46 2009/03/15 11:28:34 c2woody Exp $ */
+/* $Id: vga.h,v 1.47 2009/06/29 18:43:33 c2woody Exp $ */
 
 #ifndef DOSBOX_VGA_H
 #define DOSBOX_VGA_H
@@ -222,7 +222,8 @@
 	Bit8u vsyncp;
 	Bit8u vsyncw;
 	Bit8u max_scanline;
-	Bit8u lpen_low, lpen_high;
+	Bit16u lightpen;
+	bool lightpen_triggered;
 	Bit8u cursor_start;
 	Bit8u cursor_end;
 } VGA_OTHER;
diff -urN dosbox-0.73/install-sh dosboxcvs/install-sh
--- dosbox-0.73/install-sh	2008-12-11 11:05:36.000000000 +0200
+++ dosboxcvs/install-sh	2009-07-04 14:45:18.000000000 +0300
@@ -1,7 +1,7 @@
 #!/bin/sh
 # install - install a program, script, or datafile
 
-scriptversion=2006-12-25.00
+scriptversion=2006-10-14.15
 
 # This originates from X11R5 (mit/util/scripts/install.sh), which was
 # later released in X11R6 (xc/config/util/install.sh) with the
@@ -48,7 +48,7 @@
 # set DOITPROG to echo to test this script
 
 # Don't use :- since 4.3BSD and earlier shells don't like it.
-doit=${DOITPROG-}
+doit="${DOITPROG-}"
 if test -z "$doit"; then
   doit_exec=exec
 else
@@ -58,49 +58,34 @@
 # Put in absolute file names if you don't have them in your path;
 # or use environment vars.
 
-chgrpprog=${CHGRPPROG-chgrp}
-chmodprog=${CHMODPROG-chmod}
-chownprog=${CHOWNPROG-chown}
-cmpprog=${CMPPROG-cmp}
-cpprog=${CPPROG-cp}
-mkdirprog=${MKDIRPROG-mkdir}
-mvprog=${MVPROG-mv}
-rmprog=${RMPROG-rm}
-stripprog=${STRIPPROG-strip}
-
-posix_glob='?'
-initialize_posix_glob='
-  test "$posix_glob" != "?" || {
-    if (set -f) 2>/dev/null; then
-      posix_glob=
-    else
-      posix_glob=:
-    fi
-  }
-'
+mvprog="${MVPROG-mv}"
+cpprog="${CPPROG-cp}"
+chmodprog="${CHMODPROG-chmod}"
+chownprog="${CHOWNPROG-chown}"
+chgrpprog="${CHGRPPROG-chgrp}"
+stripprog="${STRIPPROG-strip}"
+rmprog="${RMPROG-rm}"
+mkdirprog="${MKDIRPROG-mkdir}"
 
+posix_glob=
 posix_mkdir=
 
 # Desired mode of installed file.
 mode=0755
 
-chgrpcmd=
 chmodcmd=$chmodprog
 chowncmd=
-mvcmd=$mvprog
-rmcmd="$rmprog -f"
+chgrpcmd=
 stripcmd=
-
+rmcmd="$rmprog -f"
+mvcmd="$mvprog"
 src=
 dst=
 dir_arg=
-dst_arg=
-
-copy_on_change=false
+dstarg=
 no_target_directory=
 
-usage="\
-Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
+usage="Usage: $0 [OPTION]... [-T] SRCFILE DSTFILE
    or: $0 [OPTION]... SRCFILES... DIRECTORY
    or: $0 [OPTION]... -t DIRECTORY SRCFILES...
    or: $0 [OPTION]... -d DIRECTORIES...
@@ -110,55 +95,65 @@
 In the 4th, create DIRECTORIES.
 
 Options:
-     --help     display this help and exit.
-     --version  display version info and exit.
-
-  -c            (ignored)
-  -C            install only if different (preserve the last data modification time)
-  -d            create directories instead of installing files.
-  -g GROUP      $chgrpprog installed files to GROUP.
-  -m MODE       $chmodprog installed files to MODE.
-  -o USER       $chownprog installed files to USER.
-  -s            $stripprog installed files.
-  -t DIRECTORY  install into DIRECTORY.
-  -T            report an error if DSTFILE is a directory.
+-c         (ignored)
+-d         create directories instead of installing files.
+-g GROUP   $chgrpprog installed files to GROUP.
+-m MODE    $chmodprog installed files to MODE.
+-o USER    $chownprog installed files to USER.
+-s         $stripprog installed files.
+-t DIRECTORY  install into DIRECTORY.
+-T         report an error if DSTFILE is a directory.
+--help     display this help and exit.
+--version  display version info and exit.
 
 Environment variables override the default commands:
-  CHGRPPROG CHMODPROG CHOWNPROG CMPPROG CPPROG MKDIRPROG MVPROG
-  RMPROG STRIPPROG
+  CHGRPPROG CHMODPROG CHOWNPROG CPPROG MKDIRPROG MVPROG RMPROG STRIPPROG
 "
 
 while test $# -ne 0; do
   case $1 in
-    -c) ;;
-
-    -C) copy_on_change=true;;
+    -c) shift
+        continue;;
 
-    -d) dir_arg=true;;
+    -d) dir_arg=true
+        shift
+        continue;;
 
     -g) chgrpcmd="$chgrpprog $2"
-	shift;;
+        shift
+        shift
+        continue;;
 
     --help) echo "$usage"; exit $?;;
 
     -m) mode=$2
+        shift
+        shift
 	case $mode in
 	  *' '* | *'	'* | *'
 '*	  | *'*'* | *'?'* | *'['*)
 	    echo "$0: invalid mode: $mode" >&2
 	    exit 1;;
 	esac
-	shift;;
+        continue;;
 
     -o) chowncmd="$chownprog $2"
-	shift;;
-
-    -s) stripcmd=$stripprog;;
-
-    -t) dst_arg=$2
-	shift;;
-
-    -T) no_target_directory=true;;
+        shift
+        shift
+        continue;;
+
+    -s) stripcmd=$stripprog
+        shift
+        continue;;
+
+    -t) dstarg=$2
+	shift
+	shift
+	continue;;
+
+    -T) no_target_directory=true
+	shift
+	continue;;
 
     --version) echo "$0 $scriptversion"; exit $?;;
 
@@ -170,22 +165,21 @@
 
     *)  break;;
   esac
-  shift
 done
 
-if test $# -ne 0 && test -z "$dir_arg$dst_arg"; then
+if test $# -ne 0 && test -z "$dir_arg$dstarg"; then
   # When -d is used, all remaining arguments are directories to create.
   # When -t is used, the destination is already specified.
   # Otherwise, the last argument is the destination.  Remove it from $@.
   for arg
   do
-    if test -n "$dst_arg"; then
+    if test -n "$dstarg"; then
       # $@ is not empty: it contains at least $arg.
-      set fnord "$@" "$dst_arg"
+      set fnord "$@" "$dstarg"
       shift # fnord
     fi
     shift # arg
-    dst_arg=$arg
+    dstarg=$arg
   done
 fi
 
@@ -230,7 +224,7 @@
 do
   # Protect names starting with `-'.
   case $src in
-    -*) src=./$src;;
+    -*) src=./$src ;;
   esac
 
   if test -n "$dir_arg"; then
@@ -248,22 +242,22 @@
       exit 1
     fi
 
-    if test -z "$dst_arg"; then
+    if test -z "$dstarg"; then
       echo "$0: no destination specified." >&2
       exit 1
     fi
 
-    dst=$dst_arg
+    dst=$dstarg
     # Protect names starting with `-'.
     case $dst in
-      -*) dst=./$dst;;
+      -*) dst=./$dst ;;
     esac
 
     # If destination is a directory, append the input filename; won't work
     # if double slashes aren't ignored.
     if test -d "$dst"; then
       if test -n "$no_target_directory"; then
-	echo "$0: $dst_arg: Is a directory" >&2
+	echo "$0: $dstarg: Is a directory" >&2
 	exit 1
       fi
       dstdir=$dst
@@ -384,19 +378,26 @@
       # directory the slow way, step by step, checking for races as we go.
 
       case $dstdir in
-	/*) prefix='/';;
-	-*) prefix='./';;
-	*)  prefix='';;
+	/*) prefix=/ ;;
+	-*) prefix=./ ;;
+	*)  prefix= ;;
       esac
 
-      eval "$initialize_posix_glob"
+      case $posix_glob in
+        '')
+	  if (set -f) 2>/dev/null; then
+	    posix_glob=true
+	  else
+	    posix_glob=false
+	  fi ;;
+      esac
 
       oIFS=$IFS
       IFS=/
-      $posix_glob set -f
+      $posix_glob && set -f
       set fnord $dstdir
       shift
-      $posix_glob set +f
+      $posix_glob && set +f
       IFS=$oIFS
 
       prefixes=
@@ -458,54 +459,41 @@
     # ignore errors from any of these, just make sure not to ignore
     # errors from the above "$doit $cpprog $src $dsttmp" command.
     #
-    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } &&
-    { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } &&
-    { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } &&
-    { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
-
-    # If -C, don't bother to copy if it wouldn't change the file.
-    if $copy_on_change &&
-       old=`LC_ALL=C ls -dlL "$dst"	2>/dev/null` &&
-       new=`LC_ALL=C ls -dlL "$dsttmp"	2>/dev/null` &&
-
-       eval "$initialize_posix_glob" &&
-       $posix_glob set -f &&
-       set X $old && old=:$2:$4:$5:$6 &&
-       set X $new && new=:$2:$4:$5:$6 &&
-       $posix_glob set +f &&
-
-       test "$old" = "$new" &&
-       $cmpprog "$dst" "$dsttmp" >/dev/null 2>&1
-    then
-      rm -f "$dsttmp"
-    else
-      # Rename the file to the real destination.
-      $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null ||
-
-      # The rename failed, perhaps because mv can't rename something else
-      # to itself, or perhaps because mv is so ancient that it does not
-      # support -f.
-      {
-	# Now remove or move aside any old file at destination location.
-	# We try this two ways since rm can't unlink itself on some
-	# systems and the destination file might be busy for other
-	# reasons.  In this case, the final cleanup might fail but the new
-	# file should still install successfully.
-	{
-	  test ! -f "$dst" ||
-	  $doit $rmcmd -f "$dst" 2>/dev/null ||
-	  { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null &&
-	    { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }
-	  } ||
-	  { echo "$0: cannot unlink or rename $dst" >&2
-	    (exit 1); exit 1
-	  }
-	} &&
-
-	# Now rename the file to the real destination.
-	$doit $mvcmd "$dsttmp" "$dst"
-      }
-    fi || exit 1
+    { test -z "$chowncmd" || $doit $chowncmd "$dsttmp"; } \
+      && { test -z "$chgrpcmd" || $doit $chgrpcmd "$dsttmp"; } \
+      && { test -z "$stripcmd" || $doit $stripcmd "$dsttmp"; } \
+      && { test -z "$chmodcmd" || $doit $chmodcmd $mode "$dsttmp"; } &&
+
+    # Now rename the file to the real destination.
+    { $doit $mvcmd -f "$dsttmp" "$dst" 2>/dev/null \
+      || {
+	   # The rename failed, perhaps because mv can't rename something else
+	   # to itself, or perhaps because mv is so ancient that it does not
+	   # support -f.
+
+	   # Now remove or move aside any old file at destination location.
+	   # We try this two ways since rm can't unlink itself on some
+	   # systems and the destination file might be busy for other
+	   # reasons.  In this case, the final cleanup might fail but the new
+	   # file should still install successfully.
+	   {
+	     if test -f "$dst"; then
+	       $doit $rmcmd -f "$dst" 2>/dev/null \
+	       || { $doit $mvcmd -f "$dst" "$rmtmp" 2>/dev/null \
+		     && { $doit $rmcmd -f "$rmtmp" 2>/dev/null; :; }; }\
+	       || {
+		 echo "$0: cannot unlink or rename $dst" >&2
+		 (exit 1); exit 1
+	       }
+	     else
+	       :
+	     fi
+	   } &&
+
+	   # Now rename the file to the real destination.
+	   $doit $mvcmd "$dsttmp" "$dst"
+	 }
+    } || exit 1
 
     trap '' 0
   fi
diff -urN dosbox-0.73/Makefile.in dosboxcvs/Makefile.in
--- dosbox-0.73/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/Makefile.in	2009-07-08 20:46:44.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,11 +15,15 @@
 @SET_MAKE@
 
 # Main Makefile for DOSBox
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = .
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -34,18 +38,18 @@
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-subdir = .
 DIST_COMMON = README $(am__configure_deps) $(srcdir)/Makefile.am \
 	$(srcdir)/Makefile.in $(srcdir)/config.h.in \
 	$(top_srcdir)/configure AUTHORS COPYING ChangeLog INSTALL NEWS \
 	THANKS config.guess config.sub depcomp install-sh missing
+subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/configure.in
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno config.status.lineno
+ configure.lineno configure.status.lineno
 mkinstalldirs = $(install_sh) -d
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES =
@@ -53,13 +57,10 @@
 DIST_SOURCES =
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -77,6 +78,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -88,6 +91,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -98,8 +102,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -109,7 +114,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -127,12 +131,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -144,43 +151,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 EXTRA_DIST = autogen.sh
 SUBDIRS = src include docs visualc_net
 all: config.h
@@ -224,7 +220,7 @@
 config.h: stamp-h1
 	@if test ! -f $@; then \
 	  rm -f stamp-h1; \
-	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
+	  $(MAKE) stamp-h1; \
 	else :; fi
 
 stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
@@ -237,6 +233,7 @@
 
 distclean-hdr:
 	-rm -f config.h stamp-h1
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -269,7 +266,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -313,8 +311,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -339,8 +337,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -350,12 +348,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -370,22 +369,23 @@
 
 distdir: $(DISTFILES)
 	$(am__remove_distdir)
-	test -d $(distdir) || mkdir $(distdir)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	mkdir $(distdir)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -399,7 +399,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -407,8 +407,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -416,7 +414,7 @@
 	-find $(distdir) -type d ! -perm -777 -exec chmod a+rwx {} \; -o \
 	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
 	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
-	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	  ! -type d ! -perm -444 -exec $(SHELL) $(install_sh) -c -m a+r {} {} \; \
 	|| chmod -R a+r $(distdir)
 dist-gzip: distdir
 	tardir=$(distdir) && $(am__tar) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
@@ -426,10 +424,6 @@
 	tardir=$(distdir) && $(am__tar) | bzip2 -9 -c >$(distdir).tar.bz2
 	$(am__remove_distdir)
 
-dist-lzma: distdir
-	tardir=$(distdir) && $(am__tar) | lzma -9 -c >$(distdir).tar.lzma
-	$(am__remove_distdir)
-
 dist-tarZ: distdir
 	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
 	$(am__remove_distdir)
@@ -456,8 +450,6 @@
 	  GZIP=$(GZIP_ENV) gunzip -c $(distdir).tar.gz | $(am__untar) ;;\
 	*.tar.bz2*) \
 	  bunzip2 -c $(distdir).tar.bz2 | $(am__untar) ;;\
-	*.tar.lzma*) \
-	  unlzma -c $(distdir).tar.lzma | $(am__untar) ;;\
 	*.tar.Z*) \
 	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
 	*.shar.gz*) \
@@ -497,7 +489,7 @@
 	$(am__remove_distdir)
 	@(echo "$(distdir) archives ready for distribution: "; \
 	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
-	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+	  sed -e '1{h;s/./=/g;p;x;}' -e '$${p;x;}'
 distuninstallcheck:
 	@cd $(distuninstallcheck_dir) \
 	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
@@ -566,20 +558,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am:
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -600,25 +584,24 @@
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am am--refresh check check-am clean clean-generic \
-	ctags ctags-recursive dist dist-all dist-bzip2 dist-gzip \
-	dist-lzma dist-shar dist-tarZ dist-zip distcheck distclean \
-	distclean-generic distclean-hdr distclean-tags distcleancheck \
-	distdir distuninstallcheck dvi dvi-am html html-am info \
-	info-am install install-am install-data install-data-am \
-	install-dvi install-dvi-am install-exec install-exec-am \
-	install-html install-html-am install-info install-info-am \
-	install-man install-pdf install-pdf-am install-ps \
-	install-ps-am install-strip installcheck installcheck-am \
-	installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags tags-recursive uninstall uninstall-am
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \
+	check-am clean clean-generic clean-recursive ctags \
+	ctags-recursive dist dist-all dist-bzip2 dist-gzip dist-shar \
+	dist-tarZ dist-zip distcheck distclean distclean-generic \
+	distclean-hdr distclean-recursive distclean-tags \
+	distcleancheck distdir distuninstallcheck dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive \
+	mostlyclean mostlyclean-generic mostlyclean-recursive pdf \
+	pdf-am ps ps-am tags tags-recursive uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/scripts/dosbox-installer.nsi dosboxcvs/scripts/dosbox-installer.nsi
--- dosbox-0.73/scripts/dosbox-installer.nsi	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/scripts/dosbox-installer.nsi	2009-05-27 19:14:38.000000000 +0300
@@ -0,0 +1,157 @@
+!define VER_MAYOR 0
+!define VER_MINOR 73
+!define APP_NAME "DOSBox ${VER_MAYOR}.${VER_MINOR} Installer"
+!define COMP_NAME "DOSBox Team"
+!define COPYRIGHT "Copyright  2002-2009 DOSBox Team"
+!define DESCRIPTION "DOSBox Installer"
+
+VIProductVersion "${VER_MAYOR}.${VER_MINOR}.0.0"
+VIAddVersionKey  "ProductName"  "${APP_NAME}"
+VIAddVersionKey  "CompanyName"  "${COMP_NAME}"
+VIAddVersionKey  "FileDescription"  "${DESCRIPTION}"
+VIAddVersionKey  "FileVersion"  "${VER_MAYOR}.${VER_MINOR}.0.0"
+VIAddVersionKey  "ProductVersion"  "${VER_MAYOR}, ${VER_MINOR}, 0, 0"
+VIAddVersionKey  "LegalCopyright"  "${COPYRIGHT}"
+
+; The name of the installer
+Name "${APP_NAME}"
+
+; The file to write
+OutFile "DOSBox${VER_MAYOR}.${VER_MINOR}-win32-installer.exe"
+
+; The default installation directory
+InstallDir "$PROGRAMFILES\DOSBox-${VER_MAYOR}.${VER_MINOR}"
+
+; The text to prompt the user to enter a directory
+DirText "This will install DOSBox v${VER_MAYOR}.${VER_MINOR} on your computer. Choose a directory"
+SetCompressor /solid lzma
+
+
+LicenseData COPYING
+LicenseText "DOSBox v${VER_MAYOR}.${VER_MINOR} License" "Next >"
+
+; Else vista enables compatibility mode
+RequestExecutionLevel admin
+; Shortcuts in all users
+
+ComponentText "Select components for DOSBox"
+; The stuff to install
+Section "!Core files" Core
+SetShellVarContext all
+
+  ; Set output path to the installation directory.
+  ClearErrors
+  SetOutPath $INSTDIR
+  IfErrors error_createdir
+  SectionIn RO
+
+  ; Put file there
+  
+  CreateDirectory "$INSTDIR\zmbv"
+  File /oname=README.txt README
+  File /oname=COPYING.txt COPYING
+  File /oname=THANKS.txt THANKS
+  File /oname=NEWS.txt NEWS
+  File /oname=AUTHORS.txt AUTHORS
+  File /oname=INSTALL.txt INSTALL
+  File DOSBox.exe
+  File SDL.dll
+  File SDL_net.dll
+  File /oname=zmbv\zmbv.dll zmbv.dll
+  File /oname=zmbv\zmbv.inf zmbv.inf
+  File /oname=zmbv\README.txt README.video
+  
+  CreateDirectory "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}"
+  CreateDirectory "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video"
+  CreateDirectory "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration"
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Uninstall.lnk" "$INSTDIR\uninstall.exe" "" "$INSTDIR\uninstall.exe" 0
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\DOSBox.lnk" "$INSTDIR\DOSBox.exe" "" "$INSTDIR\DOSBox.exe" 0
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\DOSBox (noconsole).lnk" "$INSTDIR\DOSBox.exe" "-noconsole" "$INSTDIR\DOSBox.exe" 0
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\README.lnk" "$INSTDIR\README.txt"
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration\Edit Configuration.lnk" "$INSTDIR\DOSBox.exe" "-editconf notepad.exe -editconf $\"%SystemRoot%\system32\notepad.exe$\" -editconf $\"%WINDIR%\notepad.exe$\""
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration\Reset Configuration.lnk" "$INSTDIR\DOSBox.exe" "-eraseconf"
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Capture folder.lnk" "$INSTDIR\DOSBox.exe" "-opencaptures explorer.exe"
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video\Video instructions.lnk" "$INSTDIR\zmbv\README.txt"
+;change outpath so the working directory gets set to zmbv
+SetOutPath "$INSTDIR\zmbv"
+  ; Shortcut creation depends on wether we are 9x of NT
+  ClearErrors
+  ReadRegStr $R0 HKLM "SOFTWARE\Microsoft\Windows NT\CurrentVersion" CurrentVersion
+  IfErrors we_9x we_nt
+we_nt:
+  ;shortcut for win NT
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video\Install movie codec.lnk" "rundll32" "setupapi,InstallHinfSection DefaultInstall 128 $INSTDIR\zmbv\zmbv.inf"
+  goto end
+we_9x:
+  ;shortcut for we_9x
+  CreateShortCut "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video\Install movie codec.lnk" "rundll" "setupx.dll,InstallHinfSection DefaultInstall 128 $INSTDIR\zmbv\zmbv.inf"
+end:
+SetOutPath $INSTDIR
+WriteUninstaller "uninstall.exe"
+
+  goto end_section
+
+error_createdir:
+  MessageBox MB_OK "Can't create DOSBox program directory, aborting."
+  Abort
+  goto end_section
+
+end_section:
+SectionEnd ; end the section
+
+Section "Desktop Shortcut" SecDesktop
+SetShellVarContext all
+
+CreateShortCut "$DESKTOP\DOSBox ${VER_MAYOR}.${VER_MINOR}.lnk" "$INSTDIR\DOSBox.exe" "" "$INSTDIR\DOSBox.exe" 0
+
+ SectionEnd ; end the section 
+
+
+UninstallText "This will uninstall DOSBox  v${VER_MAYOR}.${VER_MINOR}. Hit next to continue."
+
+Section "Uninstall"
+
+; Shortcuts in all users
+SetShellVarContext all
+
+  Delete "$DESKTOP\DOSBox ${VER_MAYOR}.${VER_MINOR}.lnk"
+  ; remove registry keys
+  ; remove files
+  Delete $INSTDIR\README.txt
+  Delete $INSTDIR\COPYING.txt
+  Delete $INSTDIR\THANKS.txt
+  Delete $INSTDIR\NEWS.txt
+  Delete $INSTDIR\AUTHORS.txt
+  Delete $INSTDIR\INSTALL.txt
+  Delete $INSTDIR\DOSBox.exe
+  Delete $INSTDIR\SDL.dll
+  Delete $INSTDIR\SDL_net.dll
+  Delete $INSTDIR\zmbv\zmbv.dll
+  Delete $INSTDIR\zmbv\zmbv.inf
+  Delete $INSTDIR\zmbv\README.txt
+  ;Files left by sdl taking over the console
+  Delete $INSTDIR\stdout.txt
+  Delete $INSTDIR\stderr.txt
+
+  ; MUST REMOVE UNINSTALLER, too
+  Delete $INSTDIR\uninstall.exe
+
+  ; remove shortcuts, if any.
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Uninstall.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\README.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\DOSBox.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\DOSBox (noconsole).lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration\Edit Configuration.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration\Reset Configuration.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Capture folder.lnk"  
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video\Install movie codec.lnk"
+  Delete "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video\Video instructions.lnk"
+; remove directories used.
+  RMDir "$INSTDIR\zmbv"
+  RMDir "$INSTDIR"
+  RMDir "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Configuration"
+  RMDir "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}\Video"
+  RMDir "$SMPROGRAMS\DOSBox-${VER_MAYOR}.${VER_MINOR}"
+SectionEnd
+
+; eof
diff -urN dosbox-0.73/scripts/ega-switch.pl dosboxcvs/scripts/ega-switch.pl
--- dosbox-0.73/scripts/ega-switch.pl	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/scripts/ega-switch.pl	2002-07-27 16:08:47.000000000 +0300
@@ -0,0 +1,32 @@
+#!/usr/bin/perl
+use integer;
+open (THEFILE,'>','../src/hardware/ega-switch.h')
+	or die "Can't open my file $!";
+
+print THEFILE "switch (bit_mask) {\n";
+for ($i = 0; $i < 256; $i++) {
+	print THEFILE "\tcase $i:\n";
+	$b=128;
+	$add=0;
+	do  {
+		if ($i & $b) {
+			print THEFILE "\t{\n";
+			print THEFILE "\t\tBit8u color=0;\n";
+			print THEFILE "\t\tif (pixels.b[0] & $b) color|=1;\n";
+			print THEFILE "\t\tif (pixels.b[1] & $b) color|=2;\n";
+			print THEFILE "\t\tif (pixels.b[2] & $b) color|=4;\n";
+			print THEFILE "\t\tif (pixels.b[3] & $b) color|=8;\n";
+			print THEFILE "\t\t*(write_pixels+$add)=color;\n";
+			print THEFILE "\t\t*(write_pixels+$add+512*1024)=color;\n";
+			print THEFILE "\t}\n";
+		}
+
+		$b=$b >> 1;
+		$add=$add+1;
+	} until ($b == 0);
+	print THEFILE "\tbreak;\n";
+} 
+print THEFILE "}\n";
+
+
+close (THEFILE);
diff -urN dosbox-0.73/scripts/font-switch.pl dosboxcvs/scripts/font-switch.pl
--- dosbox-0.73/scripts/font-switch.pl	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/scripts/font-switch.pl	2002-07-27 16:08:47.000000000 +0300
@@ -0,0 +1,25 @@
+#!/usr/bin/perl
+use integer;
+open (THEFILE,'>','../src/hardware/font-switch.h')
+	or die "Can't open my file $!";
+
+print THEFILE "switch (bit_mask) {\n";
+for ($i = 0; $i < 256; $i++) {
+	print THEFILE "\tcase $i:\n";
+	$b=128;
+	$add=0;
+	do  {
+		if ($i & $b) {
+			print THEFILE "\t\t*(draw+$add)=fg;\n";
+		} else {
+			print THEFILE "\t\t*(draw+$add)=bg;\n";
+		}
+		$b=$b >> 1;
+		$add=$add+1;
+	} until ($b == 0);
+	print THEFILE "\tbreak;\n";
+} 
+print THEFILE "}\n";
+
+
+close (THEFILE);
diff -urN dosbox-0.73/src/cpu/callback.cpp dosboxcvs/src/cpu/callback.cpp
--- dosbox-0.73/src/cpu/callback.cpp	2009-05-25 21:44:44.000000000 +0300
+++ dosboxcvs/src/cpu/callback.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: callback.cpp,v 1.40 2009/03/03 18:30:41 c2woody Exp $ */
+/* $Id: callback.cpp,v 1.41 2009/06/11 16:05:17 c2woody Exp $ */
 
 #include <stdlib.h>
 #include <string.h>
@@ -26,7 +26,7 @@
 #include "mem.h"
 #include "cpu.h"
 
-/* CallBack are located at 0xF100:0  (see CB_SEG in callback.h)
+/* CallBack are located at 0xF000:0x1000  (see CB_SEG and CB_SOFFSET in callback.h)
    And they are 16 bytes each and you can define them to behave in certain ways like a
    far return or and IRET
 */
@@ -87,8 +87,8 @@
 
 void CALLBACK_RunRealFar(Bit16u seg,Bit16u off) {
 	reg_sp-=4;
-	mem_writew(SegPhys(ss)+reg_sp,call_stop*CB_SIZE);
-	mem_writew(SegPhys(ss)+reg_sp+2,CB_SEG);
+	mem_writew(SegPhys(ss)+reg_sp,RealOff(CALLBACK_RealPointer(call_stop)));
+	mem_writew(SegPhys(ss)+reg_sp+2,RealSeg(CALLBACK_RealPointer(call_stop)));
 	Bit32u oldeip=reg_eip;
 	Bit16u oldcs=SegValue(cs);
 	reg_eip=off;
@@ -101,7 +101,7 @@
 void CALLBACK_RunRealInt(Bit8u intnum) {
 	Bit32u oldeip=reg_eip;
 	Bit16u oldcs=SegValue(cs);
-	reg_eip=(CB_MAX*CB_SIZE)+(intnum*6);
+	reg_eip=CB_SOFFSET+(CB_MAX*CB_SIZE)+(intnum*6);
 	SegSet16(cs,CB_SEG);
 	DOSBOX_RunMachine();
 	reg_eip=oldeip;
@@ -141,7 +141,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02, callback);	//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xC3);		//A RETN Instruction
@@ -150,7 +150,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02, callback);	//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xCB);		//A RETF Instruction
@@ -159,7 +159,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02, callback);	//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xCA);		//A RETF 8 Instruction
@@ -169,7 +169,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xCF);		//An IRET Instruction
@@ -178,7 +178,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x66);		//An IRETD Instruction
@@ -189,7 +189,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x01,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x02,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x03, callback);	//The immediate word
+			phys_writew(physAddress+0x03,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x01,(Bit8u)0xCF);		//An IRET Instruction
@@ -198,7 +198,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x50);		// push ax
@@ -213,7 +213,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x50);		// push ax
@@ -238,7 +238,7 @@
 			phys_writew(physAddress+0x08,(Bit16u)0x0473);	// jc skip
 			phys_writeb(physAddress+0x0a,(Bit8u)0xFE);		//GRP 4
 			phys_writeb(physAddress+0x0b,(Bit8u)0x38);		//Extra Callback instruction
-			phys_writew(physAddress+0x0c,callback);			//The immediate word
+			phys_writew(physAddress+0x0c,(Bit16u)callback);			//The immediate word
 			// jump here to (skip):
 			physAddress+=6;
 		}
@@ -252,7 +252,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x50);		// push ax
@@ -272,13 +272,13 @@
 		phys_writeb(physAddress+0x05,(Bit8u)0xfb);		// sti
 		phys_writeb(physAddress+0x06,(Bit8u)0xFE);		//GRP 4
 		phys_writeb(physAddress+0x07,(Bit8u)0x38);		//Extra Callback instruction
-		phys_writew(physAddress+0x08,callback);			//The immediate word
+		phys_writew(physAddress+0x08,(Bit16u)callback);			//The immediate word
 		return 0x0a;
 	case CB_IRQ12_RET:	// ps2 mouse int74 return
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xfa);		// cli
@@ -298,7 +298,7 @@
 			phys_writew(physAddress+0x05,(Bit16u)0x0674);	// je skip
 			phys_writeb(physAddress+0x07,(Bit8u)0xFE);		//GRP 4
 			phys_writeb(physAddress+0x08,(Bit8u)0x38);		//Extra Callback instruction
-			phys_writew(physAddress+0x09,callback);			//The immediate word
+			phys_writew(physAddress+0x09,(Bit16u)callback);			//The immediate word
 			physAddress+=4;
 		} else {
 			phys_writew(physAddress+0x05,(Bit16u)0x0274);	// je skip
@@ -318,7 +318,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0xCF);		//An IRET Instruction
@@ -328,7 +328,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x01,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x02,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x03, callback);	//The immediate word
+			phys_writew(physAddress+0x03,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x01,(Bit8u)0xCF);		//An IRET Instruction
@@ -339,7 +339,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x50);		// push ax
@@ -357,7 +357,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x05,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x06,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x07,callback);		//The immediate word
+			phys_writew(physAddress+0x07,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x05,(Bit8u)0xCB);		//A RETF Instruction
@@ -366,7 +366,7 @@
 		if (use_cb) {
 			phys_writeb(physAddress+0x00,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x01,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x02,callback);		//The immediate word
+			phys_writew(physAddress+0x02,(Bit16u)callback);		//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x00,(Bit8u)0x50);		// push ax
@@ -388,7 +388,7 @@
 		phys_writeb(physAddress+0x06,(Bit8u)0x60);		// pusha
 		phys_writeb(physAddress+0x07,(Bit8u)0xFE);		//GRP 4
 		phys_writeb(physAddress+0x08,(Bit8u)0x38);		//Extra Callback instruction
-		phys_writew(physAddress+0x09,callback);			//The immediate word
+		phys_writew(physAddress+0x09,(Bit16u)callback);	//The immediate word
 		phys_writeb(physAddress+0x0b,(Bit8u)0xCB);		//A RETF Instruction
 		return 0x0c;
 	case CB_IPXESR_RET:		// IPX ESR return
@@ -404,12 +404,49 @@
 		phys_writeb(physAddress+0x0d,(Bit8u)0x1f);		// pop ds
 		phys_writeb(physAddress+0x0e,(Bit8u)0xcf);		//An IRET Instruction
 		return 0x0f; */
+	case CB_VESA_START: {
+		PhysPt writer = physAddress;
+		// GRP 4
+		phys_writeb(writer,(Bit8u)0xFE);		writer+=1;
+		// Extra Callback instruction
+		phys_writeb(writer,(Bit8u)0x38);		writer+=1;
+		// The immediate word
+		phys_writew(writer, callback);			writer+=2;
+		
+		// pseudocode: if(reg_bl==0x80) while(!(inportb(0x3da)&0x8));
+		// 80 FB 80		cmp         bl,80h
+		phys_writew(writer,(Bit16u)0xFB80);		writer+=2;
+		phys_writeb(writer,(Bit8u)0x80);		writer+=1;
+		// 75 11		jne         NOVRET
+		phys_writew(writer,(Bit16u)0x1175);		writer+=2;
+		// 66 50		push        ax
+		phys_writew(writer,(Bit16u)0x5066);		writer+=2;
+		// 66 52		push        dx
+		phys_writew(writer,(Bit16u)0x5266);		writer+=2;
+		// 66 BA DA 03	mov         dx,3DAh 
+		phys_writed(writer,(Bit32u)0x03DABA66);	writer+=4;
+		// AGAIN:
+		// EC			in          al,dx
+		phys_writeb(writer,(Bit8u)0xEC);		writer+=1;
+		// 24 08		and         al,8 
+		phys_writew(writer,(Bit16u)0x0824);		writer+=2;
+		// 74 FB		je          AGAIN
+		phys_writew(writer,(Bit16u)0xFB74);		writer+=2;
+		// 66 5A		pop         dx
+		phys_writew(writer,(Bit16u)0x5A66);		writer+=2;
+		// 66 58		pop         ax
+		phys_writew(writer,(Bit16u)0x5866);		writer+=2;
+		// NOVRET:
+		// RETN
+		phys_writeb(writer,(Bit8u)0xC3);		writer+=1;
+		return writer-physAddress;
+	}
 	case CB_INT21:
 		phys_writeb(physAddress+0x00,(Bit8u)0xFB);		//STI
 		if (use_cb) {
 			phys_writeb(physAddress+0x01,(Bit8u)0xFE);	//GRP 4
 			phys_writeb(physAddress+0x02,(Bit8u)0x38);	//Extra Callback instruction
-			phys_writew(physAddress+0x03, callback);	//The immediate word
+			phys_writew(physAddress+0x03,(Bit16u)callback);	//The immediate word
 			physAddress+=4;
 		}
 		phys_writeb(physAddress+0x01,(Bit8u)0xCF);		//An IRET Instruction
@@ -502,7 +539,7 @@
 	} else E_Exit ("double usage of vector handler");
 }
 
-void CALLBACK_Init(Section* sec) {
+void CALLBACK_Init(Section* /*sec*/) {
 	Bitu i;
 	for (i=0;i<CB_MAX;i++) {
 		CallBack_Handlers[i]=&illegal_handler;
@@ -514,7 +551,7 @@
 	CALLBACK_SetDescription(call_stop,"stop");
 	phys_writeb(CALLBACK_PhysPointer(call_stop)+0,0xFE);
 	phys_writeb(CALLBACK_PhysPointer(call_stop)+1,0x38);
-	phys_writew(CALLBACK_PhysPointer(call_stop)+2,call_stop);
+	phys_writew(CALLBACK_PhysPointer(call_stop)+2,(Bit16u)call_stop);
 
 	/* Setup the idle handler */
 	call_idle=CALLBACK_Allocate();
@@ -523,7 +560,7 @@
 	for (i=0;i<=11;i++) phys_writeb(CALLBACK_PhysPointer(call_idle)+i,0x90);
 	phys_writeb(CALLBACK_PhysPointer(call_idle)+12,0xFE);
 	phys_writeb(CALLBACK_PhysPointer(call_idle)+13,0x38);
-	phys_writew(CALLBACK_PhysPointer(call_idle)+14,call_idle);
+	phys_writew(CALLBACK_PhysPointer(call_idle)+14,(Bit16u)call_idle);
 
 	/* Default handlers for unhandled interrupts that have to be non-null */
 	call_default=CALLBACK_Allocate();
@@ -531,18 +568,21 @@
 	call_default2=CALLBACK_Allocate();
 	CALLBACK_Setup(call_default2,&default_handler,CB_IRET,"default");
    
-	/* Only setup default handler for first half of interrupt table */
-	for (i=0;i<0x40;i++) {
-		real_writed(0,i*4,CALLBACK_RealPointer(call_default));
+	/* Only setup default handler for first part of interrupt table */
+	for (Bit16u ct=0;ct<0x60;ct++) {
+		real_writed(0,ct*4,CALLBACK_RealPointer(call_default));
+	}
+	for (Bit16u ct=0x68;ct<0x70;ct++) {
+		real_writed(0,ct*4,CALLBACK_RealPointer(call_default));
 	}
 	/* Setup block of 0xCD 0xxx instructions */
-	PhysPt rint_base=(CB_SEG << 4)+CB_MAX*CB_SIZE;
+	PhysPt rint_base=CALLBACK_GetBase()+CB_MAX*CB_SIZE;
 	for (i=0;i<=0xff;i++) {
 		phys_writeb(rint_base,0xCD);
-		phys_writeb(rint_base+1,i);
+		phys_writeb(rint_base+1,(Bit8u)i);
 		phys_writeb(rint_base+2,0xFE);
 		phys_writeb(rint_base+3,0x38);
-		phys_writew(rint_base+4,call_stop);
+		phys_writew(rint_base+4,(Bit16u)call_stop);
 		rint_base+=6;
 
 	}
diff -urN dosbox-0.73/src/cpu/core_dynrec/.cvsignore dosboxcvs/src/cpu/core_dynrec/.cvsignore
--- dosbox-0.73/src/cpu/core_dynrec/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/cpu/core_dynrec/.cvsignore	2007-08-26 20:38:48.000000000 +0300
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/cpu/core_dynrec/decoder_opcodes.h dosboxcvs/src/cpu/core_dynrec/decoder_opcodes.h
--- dosbox-0.73/src/cpu/core_dynrec/decoder_opcodes.h	2009-05-25 21:44:44.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/decoder_opcodes.h	2009-06-25 22:31:43.000000000 +0300
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: decoder_opcodes.h,v 1.9 2009/06/25 19:31:43 c2woody Exp $ */
+
 
 /*
 	The functions in this file are called almost exclusively by	decoder.h,
@@ -544,8 +546,8 @@
 		MOV_REG_WORD_TO_HOST_REG(FC_OP1,decode.modrm.rm,decode.big_op);
 	}
 	MOV_REG_WORD_TO_HOST_REG(FC_OP2,decode.modrm.reg,decode.big_op);
-	if (immediate) gen_mov_byte_to_reg_low_imm(FC_RETOP,decode_fetchb());
-	else MOV_REG_BYTE_TO_HOST_REG_LOW(FC_RETOP,DRC_REG_ECX,0);
+	if (immediate) gen_mov_byte_to_reg_low_imm(FC_OP3,decode_fetchb());
+	else MOV_REG_BYTE_TO_HOST_REG_LOW(FC_OP3,DRC_REG_ECX,0);
 	if (decode.big_op) dyn_dpshift_dword_gencall(left);
 	else dyn_dpshift_word_gencall(left);
 
diff -urN dosbox-0.73/src/cpu/core_dynrec/Makefile.in dosboxcvs/src/cpu/core_dynrec/Makefile.in
--- dosbox-0.73/src/cpu/core_dynrec/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -53,6 +57,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -64,6 +70,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -74,8 +81,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -85,7 +93,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -103,12 +110,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -120,43 +130,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 noinst_HEADERS = cache.h decoder.h decoder_basic.h decoder_opcodes.h \
                  dyn_fpu.h operators.h risc_x64.h risc_x86.h risc_mipsel32.h \
                  risc_armv4le.h risc_armv4le-common.h \
@@ -195,14 +194,15 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -214,8 +214,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -225,12 +225,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -244,21 +245,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -317,20 +319,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -349,20 +343,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	ctags distclean distclean-generic distclean-tags distdir dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/cpu/core_dynrec/operators.h dosboxcvs/src/cpu/core_dynrec/operators.h
--- dosbox-0.73/src/cpu/core_dynrec/operators.h	2009-05-25 21:44:44.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/operators.h	2009-06-25 22:31:43.000000000 +0300
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: operators.h,v 1.8 2009/06/25 19:31:43 c2woody Exp $ */
+
 
 static Bit8u DRC_CALL_CONV dynrec_add_byte(Bit8u op1,Bit8u op2) DRC_FC;
 static Bit8u DRC_CALL_CONV dynrec_add_byte(Bit8u op1,Bit8u op2) {
@@ -1297,20 +1299,20 @@
 
 static void dyn_dpshift_word_gencall(bool left) {
 	if (left) {
-		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshl_word,FC_RETOP);
+		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshl_word,FC_OP3);
 		InvalidateFlagsPartially((void*)&dynrec_dshl_word_simple,proc_addr,t_DSHLw);
 	} else {
-		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshr_word,FC_RETOP);
+		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshr_word,FC_OP3);
 		InvalidateFlagsPartially((void*)&dynrec_dshr_word_simple,proc_addr,t_DSHRw);
 	}
 }
 
 static void dyn_dpshift_dword_gencall(bool left) {
 	if (left) {
-		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshl_dword,FC_RETOP);
+		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshl_dword,FC_OP3);
 		InvalidateFlagsPartially((void*)&dynrec_dshl_dword_simple,proc_addr,t_DSHLd);
 	} else {
-		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshr_dword,FC_RETOP);
+		DRC_PTR_SIZE_IM proc_addr=gen_call_function_R3((void*)&dynrec_dshr_dword,FC_OP3);
 		InvalidateFlagsPartially((void*)&dynrec_dshr_dword_simple,proc_addr,t_DSHRd);
 	}
 }
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-o3.h dosboxcvs/src/cpu/core_dynrec/risc_armv4le-o3.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-o3.h	2009-05-25 21:44:44.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_armv4le-o3.h	2009-06-27 15:51:10.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_armv4le-o3.h,v 1.4 2009/05/16 21:52:47 c2woody Exp $ */
+/* $Id: risc_armv4le-o3.h,v 1.6 2009/06/27 12:51:10 c2woody Exp $ */
 
 
 /* ARMv4 (little endian) backend by M-HT (size-tweaked arm version) */
@@ -24,11 +24,11 @@
 
 // temporary registers
 #define temp1 HOST_ip
-#define temp2 HOST_v5
+#define temp2 HOST_v3
 #define temp3 HOST_v4
 
 // register that holds function return values
-#define FC_RETOP HOST_v3
+#define FC_RETOP HOST_a1
 
 // register used for address calculations,
 #define FC_ADDR HOST_v1			// has to be saved across calls, see DRC_PROTECT_ADDR_REG
@@ -39,6 +39,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a2
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_v2
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_a1
 
@@ -624,7 +627,6 @@
 	cache_addd( ADD_IMM(HOST_lr, HOST_pc, 4, 0) );      // add lr, pc, #4
 	cache_addd( BX(temp1) );      // bx temp1
 	cache_addd((Bit32u)func);      // .int func
-	cache_addd( MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 0) );      // mov FC_RETOP, a1
 }
 
 // generate a call to a function with paramcount parameters
@@ -783,7 +785,7 @@
 
 static void gen_run_code(void) {
 	cache_addd(0xe92d4000);			// stmfd sp!, {lr}
-	cache_addd(0xe92d0df0);			// stmfd sp!, {v1-v5,v7,v8}
+	cache_addd(0xe92d0cf0);			// stmfd sp!, {v1-v4,v7,v8}
 
 	// adr: 8
 	cache_addd( LDR_IMM(FC_SEGS_ADDR, HOST_pc, 64 - (8 + 8)) );      // ldr FC_SEGS_ADDR, [pc, #(&Segs)]
@@ -794,7 +796,7 @@
 	cache_addd(0xe92d4000);			// stmfd sp!, {lr}
 	cache_addd( BX(HOST_r0) );			// bx r0	
 
-	cache_addd(0xe8bd0df0);			// ldmfd sp!, {v1-v5,v7,v8}
+	cache_addd(0xe8bd0cf0);			// ldmfd sp!, {v1-v4,v7,v8}
 
 	cache_addd(0xe8bd4000);			// ldmfd sp!, {lr}
 	cache_addd( BX(HOST_lr) );			// bx lr
@@ -815,7 +817,6 @@
 
 // return from a function
 static void gen_return_function(void) {
-	cache_addd( MOV_REG_LSL_IMM(HOST_a1, FC_RETOP, 0) );      // mov a1, FC_RETOP
 	cache_addd(0xe8bd4000);			// ldmfd sp!, {lr}
 	cache_addd( BX(HOST_lr) );			// bx lr
 }
@@ -832,31 +833,41 @@
 		case t_ADDw:
 		case t_ADDd:
 			*(Bit32u*)pos=ADD_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// add FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ORb:
 		case t_ORw:
 		case t_ORd:
 			*(Bit32u*)pos=ORR_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// orr FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ANDb:
 		case t_ANDw:
 		case t_ANDd:
 			*(Bit32u*)pos=AND_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// and FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SUBb:
 		case t_SUBw:
 		case t_SUBd:
 			*(Bit32u*)pos=SUB_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// sub FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_XORb:
 		case t_XORw:
 		case t_XORd:
 			*(Bit32u*)pos=EOR_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// eor FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_CMPb:
 		case t_CMPw:
@@ -864,106 +875,105 @@
 		case t_TESTb:
 		case t_TESTw:
 		case t_TESTd:
-			*(Bit32u*)pos=B_FWD(12);				// b (pc+3*4)
+			*(Bit32u*)pos=B_FWD(8);				// b (pc+2*4)
 			break;
 		case t_INCb:
 		case t_INCw:
 		case t_INCd:
 			*(Bit32u*)pos=ADD_IMM(FC_RETOP, HOST_a1, 1, 0);	// add FC_RETOP, a1, #1
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_DECb:
 		case t_DECw:
 		case t_DECd:
 			*(Bit32u*)pos=SUB_IMM(FC_RETOP, HOST_a1, 1, 0);	// sub FC_RETOP, a1, #1
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SHLb:
 		case t_SHLw:
 		case t_SHLd:
 			*(Bit32u*)pos=MOV_REG_LSL_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, lsl a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SHRb:
 			*(Bit32u*)pos=AND_IMM(FC_RETOP, HOST_a1, 0xff, 0);				// and FC_RETOP, a1, #0xff
 			*(Bit32u*)(pos+4)=MOV_REG_LSR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, lsr a2
 			*(Bit32u*)(pos+8)=NOP;				// nop
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SHRw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);			// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=MOV_REG_LSR_IMM(FC_RETOP, FC_RETOP, 16);		// mov FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+8)=MOV_REG_LSR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, lsr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SHRd:
 			*(Bit32u*)pos=MOV_REG_LSR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, lsr a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SARb:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);			// mov FC_RETOP, a1, lsl #24
 			*(Bit32u*)(pos+4)=MOV_REG_ASR_IMM(FC_RETOP, FC_RETOP, 24);		// mov FC_RETOP, FC_RETOP, asr #24
 			*(Bit32u*)(pos+8)=MOV_REG_ASR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, asr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SARw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);			// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=MOV_REG_ASR_IMM(FC_RETOP, FC_RETOP, 16);		// mov FC_RETOP, FC_RETOP, asr #16
 			*(Bit32u*)(pos+8)=MOV_REG_ASR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, asr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SARd:
 			*(Bit32u*)pos=MOV_REG_ASR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, asr a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_RORb:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);					// mov FC_RETOP, a1, lsl #24
 			*(Bit32u*)(pos+4)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 8);		// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #8
 			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+12)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_RORw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);					// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+8)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);			// mov FC_RETOP, FC_RETOP, ror a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_RORd:
 			*(Bit32u*)pos=MOV_REG_ROR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, ror a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
-			break;
-		case t_ROLb:
-			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);					// mov FC_RETOP, a1, lsl #24
-			*(Bit32u*)(pos+4)=RSB_IMM(HOST_a2, HOST_a2, 32, 0);						// rsb a2, a2, #32
-			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 8);		// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #8
-			*(Bit32u*)(pos+12)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
-			*(Bit32u*)(pos+16)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ROLw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);					// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=RSB_IMM(HOST_a2, HOST_a2, 32, 0);						// rsb a2, a2, #32
 			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+12)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_ROLd:
 			*(Bit32u*)pos=RSB_IMM(HOST_a2, HOST_a2, 32, 0);					// rsb a2, a2, #32
 			*(Bit32u*)(pos+4)=MOV_REG_ROR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, ror a2
 			*(Bit32u*)(pos+8)=NOP;				// nop
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_NEGb:
 		case t_NEGw:
 		case t_NEGd:
 			*(Bit32u*)pos=RSB_IMM(FC_RETOP, HOST_a1, 0, 0);	// rsb FC_RETOP, a1, #0
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		default:
 			*(Bit32u*)(pos+12)=(Bit32u)fct_ptr;		// simple_func
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-s3.h dosboxcvs/src/cpu/core_dynrec/risc_armv4le-s3.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-s3.h	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_armv4le-s3.h	2009-06-27 15:51:10.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_armv4le-s3.h,v 1.4 2009/05/16 21:52:47 c2woody Exp $ */
+/* $Id: risc_armv4le-s3.h,v 1.6 2009/06/27 12:51:10 c2woody Exp $ */
 
 
 /* ARMv4 (little endian) backend by M-HT (speed-tweaked arm version) */
@@ -24,11 +24,11 @@
 
 // temporary registers
 #define temp1 HOST_ip
-#define temp2 HOST_v5
+#define temp2 HOST_v3
 #define temp3 HOST_v4
 
 // register that holds function return values
-#define FC_RETOP HOST_v3
+#define FC_RETOP HOST_a1
 
 // register used for address calculations,
 #define FC_ADDR HOST_v1			// has to be saved across calls, see DRC_PROTECT_ADDR_REG
@@ -39,6 +39,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a2
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_v2
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_a1
 
@@ -472,7 +475,6 @@
 	cache_addd( ADD_IMM(HOST_lr, HOST_pc, 4, 0) );      // add lr, pc, #4
 	cache_addd( BX(temp1) );      // bx temp1
 	cache_addd((Bit32u)func);      // .int func
-	cache_addd( MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 0) );      // mov FC_RETOP, a1
 }
 
 // generate a call to a function with paramcount parameters
@@ -619,7 +621,7 @@
 
 static void gen_run_code(void) {
 	cache_addd(0xe92d4000);			// stmfd sp!, {lr}
-	cache_addd(0xe92d0df0);			// stmfd sp!, {v1-v5,v7,v8}
+	cache_addd(0xe92d0cf0);			// stmfd sp!, {v1-v4,v7,v8}
 
 	// adr: 8
 	cache_addd( LDR_IMM(FC_SEGS_ADDR, HOST_pc, 64 - (8 + 8)) );      // ldr FC_SEGS_ADDR, [pc, #(&Segs)]
@@ -630,7 +632,7 @@
 	cache_addd(0xe92d4000);			// stmfd sp!, {lr}
 	cache_addd( BX(HOST_r0) );			// bx r0	
 
-	cache_addd(0xe8bd0df0);			// ldmfd sp!, {v1-v5,v7,v8}
+	cache_addd(0xe8bd0cf0);			// ldmfd sp!, {v1-v4,v7,v8}
 
 	cache_addd(0xe8bd4000);			// ldmfd sp!, {lr}
 	cache_addd( BX(HOST_lr) );			// bx lr
@@ -651,7 +653,6 @@
 
 // return from a function
 static void gen_return_function(void) {
-	cache_addd( MOV_REG_LSL_IMM(HOST_a1, FC_RETOP, 0) );      // mov a1, FC_RETOP
 	cache_addd(0xe8bd4000);			// ldmfd sp!, {lr}
 	cache_addd( BX(HOST_lr) );			// bx lr
 }
@@ -668,31 +669,41 @@
 		case t_ADDw:
 		case t_ADDd:
 			*(Bit32u*)pos=ADD_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// add FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ORb:
 		case t_ORw:
 		case t_ORd:
 			*(Bit32u*)pos=ORR_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// orr FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ANDb:
 		case t_ANDw:
 		case t_ANDd:
 			*(Bit32u*)pos=AND_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// and FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SUBb:
 		case t_SUBw:
 		case t_SUBd:
 			*(Bit32u*)pos=SUB_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// sub FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_XORb:
 		case t_XORw:
 		case t_XORd:
 			*(Bit32u*)pos=EOR_REG_LSL_IMM(FC_RETOP, HOST_a1, HOST_a2, 0);	// eor FC_RETOP, a1, a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_CMPb:
 		case t_CMPw:
@@ -700,106 +711,105 @@
 		case t_TESTb:
 		case t_TESTw:
 		case t_TESTd:
-			*(Bit32u*)pos=B_FWD(12);				// b (pc+3*4)
+			*(Bit32u*)pos=B_FWD(8);				// b (pc+2*4)
 			break;
 		case t_INCb:
 		case t_INCw:
 		case t_INCd:
 			*(Bit32u*)pos=ADD_IMM(FC_RETOP, HOST_a1, 1, 0);	// add FC_RETOP, a1, #1
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_DECb:
 		case t_DECw:
 		case t_DECd:
 			*(Bit32u*)pos=SUB_IMM(FC_RETOP, HOST_a1, 1, 0);	// sub FC_RETOP, a1, #1
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SHLb:
 		case t_SHLw:
 		case t_SHLd:
 			*(Bit32u*)pos=MOV_REG_LSL_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, lsl a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SHRb:
 			*(Bit32u*)pos=AND_IMM(FC_RETOP, HOST_a1, 0xff, 0);				// and FC_RETOP, a1, #0xff
 			*(Bit32u*)(pos+4)=MOV_REG_LSR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, lsr a2
 			*(Bit32u*)(pos+8)=NOP;				// nop
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SHRw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);			// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=MOV_REG_LSR_IMM(FC_RETOP, FC_RETOP, 16);		// mov FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+8)=MOV_REG_LSR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, lsr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SHRd:
 			*(Bit32u*)pos=MOV_REG_LSR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, lsr a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_SARb:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);			// mov FC_RETOP, a1, lsl #24
 			*(Bit32u*)(pos+4)=MOV_REG_ASR_IMM(FC_RETOP, FC_RETOP, 24);		// mov FC_RETOP, FC_RETOP, asr #24
 			*(Bit32u*)(pos+8)=MOV_REG_ASR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, asr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SARw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);			// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=MOV_REG_ASR_IMM(FC_RETOP, FC_RETOP, 16);		// mov FC_RETOP, FC_RETOP, asr #16
 			*(Bit32u*)(pos+8)=MOV_REG_ASR_REG(FC_RETOP, FC_RETOP, HOST_a2);	// mov FC_RETOP, FC_RETOP, asr a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_SARd:
 			*(Bit32u*)pos=MOV_REG_ASR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, asr a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_RORb:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);					// mov FC_RETOP, a1, lsl #24
 			*(Bit32u*)(pos+4)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 8);		// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #8
 			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+12)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_RORw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);					// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+8)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);			// mov FC_RETOP, FC_RETOP, ror a2
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_RORd:
 			*(Bit32u*)pos=MOV_REG_ROR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, ror a2
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
-			break;
-		case t_ROLb:
-			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 24);					// mov FC_RETOP, a1, lsl #24
-			*(Bit32u*)(pos+4)=RSB_IMM(HOST_a2, HOST_a2, 32, 0);						// rsb a2, a2, #32
-			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 8);		// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #8
-			*(Bit32u*)(pos+12)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
-			*(Bit32u*)(pos+16)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		case t_ROLw:
 			*(Bit32u*)pos=MOV_REG_LSL_IMM(FC_RETOP, HOST_a1, 16);					// mov FC_RETOP, a1, lsl #16
 			*(Bit32u*)(pos+4)=RSB_IMM(HOST_a2, HOST_a2, 32, 0);						// rsb a2, a2, #32
 			*(Bit32u*)(pos+8)=ORR_REG_LSR_IMM(FC_RETOP, FC_RETOP, FC_RETOP, 16);	// orr FC_RETOP, FC_RETOP, FC_RETOP, lsr #16
 			*(Bit32u*)(pos+12)=MOV_REG_ROR_REG(FC_RETOP, FC_RETOP, HOST_a2);		// mov FC_RETOP, FC_RETOP, ror a2
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_ROLd:
 			*(Bit32u*)pos=RSB_IMM(HOST_a2, HOST_a2, 32, 0);					// rsb a2, a2, #32
 			*(Bit32u*)(pos+4)=MOV_REG_ROR_REG(FC_RETOP, HOST_a1, HOST_a2);	// mov FC_RETOP, a1, ror a2
 			*(Bit32u*)(pos+8)=NOP;				// nop
 			*(Bit32u*)(pos+12)=NOP;				// nop
-			*(Bit32u*)(pos+16)=NOP;				// nop
 			break;
 		case t_NEGb:
 		case t_NEGw:
 		case t_NEGd:
 			*(Bit32u*)pos=RSB_IMM(FC_RETOP, HOST_a1, 0, 0);	// rsb FC_RETOP, a1, #0
-			*(Bit32u*)(pos+4)=B_FWD(8);			// b (pc+2*4)
+			*(Bit32u*)(pos+4)=NOP;				// nop
+			*(Bit32u*)(pos+8)=NOP;				// nop
+			*(Bit32u*)(pos+12)=NOP;				// nop
 			break;
 		default:
 			*(Bit32u*)(pos+12)=(Bit32u)fct_ptr;		// simple_func
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb.h dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb.h	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb.h	2009-06-27 15:51:10.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_armv4le-thumb.h,v 1.4 2009/05/16 21:52:47 c2woody Exp $ */
+/* $Id: risc_armv4le-thumb.h,v 1.6 2009/06/27 12:51:10 c2woody Exp $ */
 
 
 /* ARMv4 (little endian) backend by M-HT (thumb version) */
@@ -25,15 +25,10 @@
 // temporary "lo" registers
 #define templo1 HOST_v3
 #define templo2 HOST_v4
-
-// temporary "lo" register - value must be preserved when using it
-#define templosav HOST_a3
-
-// temporary "hi" register
-#define temphi1 HOST_ip
+#define templo3 HOST_v2
 
 // register that holds function return values
-#define FC_RETOP HOST_v2
+#define FC_RETOP HOST_a1
 
 // register used for address calculations,
 #define FC_ADDR HOST_v1			// has to be saved across calls, see DRC_PROTECT_ADDR_REG
@@ -44,6 +39,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a2
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_a4
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_a1
 
@@ -83,8 +81,6 @@
 #define ADD_IMM8(dst, imm) (0x3000 + ((dst) << 8) + (imm) )
 // add dst, src1, src2
 #define ADD_REG(dst, src1, src2) (0x1800 + (dst) + ((src1) << 3) + ((src2) << 6) )
-// add dst, src
-#define ADD_LO_HI(dst, src) (0x4440 + (dst) + (((src) - HOST_r8) << 3) )
 // add dst, pc, #imm		@	0 <= imm < 1024	&	imm mod 4 = 0
 #define ADD_LO_PC_IMM(dst, imm) (0xa000 + ((dst) << 8) + ((imm) >> 2) )
 // sub dst, src1, src2
@@ -361,9 +357,8 @@
 
 // add a 32bit value from memory to a full register
 static void gen_add(HostReg reg,void* op) {
-	cache_addw( MOV_HI_LO(temphi1, reg) );      // mov temphi1, reg
-	gen_mov_word_to_reg(reg, op, 1);
-	cache_addw( ADD_LO_HI(reg, temphi1) );      // add reg, temphi1
+	gen_mov_word_to_reg(templo3, op, 1);
+	cache_addw( ADD_REG(reg, reg, templo3) );      // add reg, reg, templo3
 }
 
 // add a 32bit constant value to a full register
@@ -383,10 +378,8 @@
 
 // move a 32bit constant value into memory
 static void gen_mov_direct_dword(void* dest,Bit32u imm) {
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_dword_to_reg_imm(templosav, imm);
-	gen_mov_word_from_reg(templosav, dest, 1);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_dword_to_reg_imm(templo3, imm);
+	gen_mov_word_from_reg(templo3, dest, 1);
 }
 
 // move an address into memory
@@ -397,16 +390,14 @@
 // add an 8bit constant value to a dword memory value
 static void gen_add_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	if (imm >= 0) {
-		cache_addw( ADD_IMM8(templosav, (Bit32s)imm) );      // add templosav, #(imm)
+		cache_addw( ADD_IMM8(templo3, (Bit32s)imm) );      // add templo3, #(imm)
 	} else {
-		cache_addw( SUB_IMM8(templosav, -((Bit32s)imm)) );      // sub templosav, #(-imm)
+		cache_addw( SUB_IMM8(templo3, -((Bit32s)imm)) );      // sub templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // add a 32bit (dword==true) or 16bit (dword==false) constant value to a memory value
@@ -416,32 +407,28 @@
 		gen_add_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
-	cache_addw( ADD_REG(templosav, templosav, templo1) );      // add templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( ADD_REG(templo3, templo3, templo1) );      // add templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // subtract an 8bit constant value from a dword memory value
 static void gen_sub_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	if (imm >= 0) {
-		cache_addw( SUB_IMM8(templosav, (Bit32s)imm) );      // sub templosav, #(imm)
+		cache_addw( SUB_IMM8(templo3, (Bit32s)imm) );      // sub templo3, #(imm)
 	} else {
-		cache_addw( ADD_IMM8(templosav, -((Bit32s)imm)) );      // add templosav, #(-imm)
+		cache_addw( ADD_IMM8(templo3, -((Bit32s)imm)) );      // add templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // subtract a 32bit (dword==true) or 16bit (dword==false) constant value from a memory value
@@ -451,17 +438,15 @@
 		gen_sub_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
-	cache_addw( SUB_REG(templosav, templosav, templo1) );      // sub templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( SUB_REG(templo3, templo3, templo1) );      // sub templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // effective address calculation, destination is dest_reg
@@ -509,7 +494,6 @@
 	cache_addd(0xe12fff10 + (templo1));      // bx templo1
 	
 	// thumb state from now on
-	cache_addw( MOV_REG(FC_RETOP, HOST_a1) );      // mov FC_RETOP, a1
 }
 
 // generate a call to a function with paramcount parameters
@@ -520,8 +504,8 @@
 	gen_call_function_raw(func);
 	return proc_addr;
 	// if proc_addr is on word  boundary ((proc_addr & 0x03) == 0)
-	//   then length of generated code is 22 bytes
-	//   otherwise length of generated code is 24 bytes
+	//   then length of generated code is 20 bytes
+	//   otherwise length of generated code is 22 bytes
 }
 
 #if (1)
@@ -552,29 +536,28 @@
 
 // jump to an address pointed at by ptr, offset is in imm
 static void gen_jmp_ptr(void * ptr,Bits imm=0) {
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_word_to_reg(templosav, ptr, 1);
+	gen_mov_word_to_reg(templo3, ptr, 1);
 
 	if (imm) {
 		gen_mov_dword_to_reg_imm(templo2, imm);
-		cache_addw( ADD_REG(templosav, templosav, templo2) );      // add templosav, templosav, templo2
+		cache_addw( ADD_REG(templo3, templo3, templo2) );      // add templo3, templo3, templo2
 	}
 
 #if (1)
 // (*ptr) should be word aligned 
 	if ((imm & 0x03) == 0) {
-		cache_addw( LDR_IMM(templo2, templosav, 0) );      // ldr templo2, [templosav]
+		cache_addw( LDR_IMM(templo2, templo3, 0) );      // ldr templo2, [templo3]
 	} else
 #endif
 	{
-		cache_addw( LDRB_IMM(templo2, templosav, 0) );      // ldrb templo2, [templosav]
-		cache_addw( LDRB_IMM(templo1, templosav, 1) );      // ldrb templo1, [templosav, #1]
+		cache_addw( LDRB_IMM(templo2, templo3, 0) );      // ldrb templo2, [templo3]
+		cache_addw( LDRB_IMM(templo1, templo3, 1) );      // ldrb templo1, [templo3, #1]
 		cache_addw( LSL_IMM(templo1, templo1, 8) );      // lsl templo1, templo1, #8
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 2) );      // ldrb templo1, [templosav, #2]
+		cache_addw( LDRB_IMM(templo1, templo3, 2) );      // ldrb templo1, [templo3, #2]
 		cache_addw( LSL_IMM(templo1, templo1, 16) );      // lsl templo1, templo1, #16
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 3) );      // ldrb templo1, [templosav, #3]
+		cache_addw( LDRB_IMM(templo1, templo3, 3) );      // ldrb templo1, [templo3, #3]
 		cache_addw( LSL_IMM(templo1, templo1, 24) );      // lsl templo1, templo1, #24
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
 	}
@@ -582,8 +565,6 @@
 	// increase jmp address to keep thumb state
 	cache_addw( ADD_IMM3(templo2, templo2, 1) );      // add templo2, templo2, #1
 
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
-
 	cache_addw( BX(templo2) );      // bx templo2
 }
 
@@ -718,7 +699,6 @@
 
 // return from a function
 static void gen_return_function(void) {
-	cache_addw( MOV_REG(HOST_a1, FC_RETOP) );      // mov a1, FC_RETOP
 	cache_addw(0xbc08);      // pop {r3}
 	cache_addw( BX(HOST_r3) );      // bx r3
 }
@@ -736,35 +716,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -772,116 +749,110 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(18);							// b after_call (pc+18)
+				*(Bit16u*)pos=B_FWD(16);							// b after_call (pc+16)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_RORb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+6)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+12)=B_FWD(6);						// b after_call (pc+6)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+12)=B_FWD(4);						// b after_call (pc+4)
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+4)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+8)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+8)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			case t_ROLb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
 				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
+				*(Bit16u*)(pos+12)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
 				*(Bit16u*)(pos+14)=NOP;								// nop
-				*(Bit16u*)(pos+16)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+18)=NOP;								// nop
-				*(Bit16u*)(pos+20)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)(pos+16)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+18)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_ROLw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+12)=B_FWD(6);						// b after_call (pc+6)
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+12)=B_FWD(4);						// b after_call (pc+4)
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+8)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+4)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
 				break;
 			default:
 				*(Bit32u*)(pos+8)=(Bit32u)fct_ptr;		// simple_func
@@ -895,35 +866,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(18);						// b after_call (pc+18)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(18);						// b after_call (pc+18)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -931,114 +899,111 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(20);							// b after_call (pc+20)
+				*(Bit16u*)pos=B_FWD(18);							// b after_call (pc+18)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(18);						// b after_call (pc+18)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(18);						// b after_call (pc+18)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_RORb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+6)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+12)=B_FWD(8);						// b after_call (pc+8)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+12)=B_FWD(6);						// b after_call (pc+6)
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+4)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+8)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+8)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(16);						// b after_call (pc+16)
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			case t_ROLb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+10)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+12)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+14)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+16)=B_FWD(4);						// b after_call (pc+4)
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+12)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+14)=NOP;								// nop
+				*(Bit16u*)(pos+16)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+18)=NOP;								// nop
+				*(Bit16u*)(pos+20)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_ROLw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+12)=B_FWD(8);						// b after_call (pc+8)
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+12)=B_FWD(6);						// b after_call (pc+6)
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+8)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+4)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(18);						// b after_call (pc+18)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(16);						// b after_call (pc+16)
 				break;
 			default:
 				*(Bit32u*)(pos+10)=(Bit32u)fct_ptr;		// simple_func
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb-iw.h dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb-iw.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb-iw.h	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb-iw.h	2009-06-27 15:51:10.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_armv4le-thumb-iw.h,v 1.3 2009/05/16 21:52:47 c2woody Exp $ */
+/* $Id: risc_armv4le-thumb-iw.h,v 1.5 2009/06/27 12:51:10 c2woody Exp $ */
 
 
 /* ARMv4 (little endian) backend by M-HT (thumb version with data pool, requires -mthumb-interwork switch when compiling dosbox) */
@@ -25,15 +25,10 @@
 // temporary "lo" registers
 #define templo1 HOST_v3
 #define templo2 HOST_v4
-
-// temporary "lo" register - value must be preserved when using it
-#define templosav HOST_a3
-
-// temporary "hi" register
-#define temphi1 HOST_ip
+#define templo3 HOST_v2
 
 // register that holds function return values
-#define FC_RETOP HOST_v2
+#define FC_RETOP HOST_a1
 
 // register used for address calculations,
 #define FC_ADDR HOST_v1			// has to be saved across calls, see DRC_PROTECT_ADDR_REG
@@ -44,6 +39,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a2
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_a4
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_a1
 
@@ -83,8 +81,6 @@
 #define ADD_IMM8(dst, imm) (0x3000 + ((dst) << 8) + (imm) )
 // add dst, src1, src2
 #define ADD_REG(dst, src1, src2) (0x1800 + (dst) + ((src1) << 3) + ((src2) << 6) )
-// add dst, src
-#define ADD_LO_HI(dst, src) (0x4440 + (dst) + (((src) - HOST_r8) << 3) )
 // add dst, pc, #imm		@	0 <= imm < 1024	&	imm mod 4 = 0
 #define ADD_LO_PC_IMM(dst, imm) (0xa000 + ((dst) << 8) + ((imm) >> 2) )
 // sub dst, src1, src2
@@ -499,11 +495,9 @@
 
 // add a 32bit value from memory to a full register
 static void gen_add(HostReg reg,void* op) {
+	gen_mov_word_to_reg(templo3, op, 1);
 	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, reg) );      // mov temphi1, reg
-	gen_mov_word_to_reg(reg, op, 1);
-	cache_checkinstr(2);
-	cache_addw( ADD_LO_HI(reg, temphi1) );      // add reg, temphi1
+	cache_addw( ADD_REG(reg, reg, templo3) );      // add reg, reg, templo3
 }
 
 // add a 32bit constant value to a full register
@@ -525,12 +519,8 @@
 
 // move a 32bit constant value into memory
 static void gen_mov_direct_dword(void* dest,Bit32u imm) {
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_dword_to_reg_imm(templosav, imm);
-	gen_mov_word_from_reg(templosav, dest, 1);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_dword_to_reg_imm(templo3, imm);
+	gen_mov_word_from_reg(templo3, dest, 1);
 }
 
 // move an address into memory
@@ -541,19 +531,15 @@
 // add an 8bit constant value to a dword memory value
 static void gen_add_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	cache_checkinstr(2);
 	if (imm >= 0) {
-		cache_addw( ADD_IMM8(templosav, (Bit32s)imm) );      // add templosav, #(imm)
+		cache_addw( ADD_IMM8(templo3, (Bit32s)imm) );      // add templo3, #(imm)
 	} else {
-		cache_addw( SUB_IMM8(templosav, -((Bit32s)imm)) );      // sub templosav, #(-imm)
+		cache_addw( SUB_IMM8(templo3, -((Bit32s)imm)) );      // sub templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // add a 32bit (dword==true) or 16bit (dword==false) constant value to a memory value
@@ -563,38 +549,30 @@
 		gen_add_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
 	cache_checkinstr(2);
-	cache_addw( ADD_REG(templosav, templosav, templo1) );      // add templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( ADD_REG(templo3, templo3, templo1) );      // add templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // subtract an 8bit constant value from a dword memory value
 static void gen_sub_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	cache_checkinstr(2);
 	if (imm >= 0) {
-		cache_addw( SUB_IMM8(templosav, (Bit32s)imm) );      // sub templosav, #(imm)
+		cache_addw( SUB_IMM8(templo3, (Bit32s)imm) );      // sub templo3, #(imm)
 	} else {
-		cache_addw( ADD_IMM8(templosav, -((Bit32s)imm)) );      // add templosav, #(-imm)
+		cache_addw( ADD_IMM8(templo3, -((Bit32s)imm)) );      // add templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // subtract a 32bit (dword==true) or 16bit (dword==false) constant value from a memory value
@@ -604,20 +582,16 @@
 		gen_sub_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
 	cache_checkinstr(2);
-	cache_addw( SUB_REG(templosav, templosav, templo1) );      // sub templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( SUB_REG(templo3, templo3, templo1) );      // sub templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // effective address calculation, destination is dest_reg
@@ -670,12 +644,11 @@
 	// after_call:
 
 	// thumb state from now on
-	cache_addw( MOV_REG(FC_RETOP, HOST_a1) );      // mov FC_RETOP, a1
 }
 
 // generate a call to a parameterless function
 static void INLINE gen_call_function_raw(void * func) {
-	cache_checkinstr(14);
+	cache_checkinstr(12);
 	gen_call_function_helper(func);
 }
 
@@ -683,13 +656,13 @@
 // note: the parameters are loaded in the architecture specific way
 // using the gen_load_param_ functions below
 static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
-	cache_checkinstr(14);
+	cache_checkinstr(12);
 	Bit32u proc_addr = (Bit32u)cache.pos;
 	gen_call_function_helper(func);
 	return proc_addr;
 	// if proc_addr is on word  boundary ((proc_addr & 0x03) == 0)
-	//   then length of generated code is 14 bytes
-	//   otherwise length of generated code is 12 bytes
+	//   then length of generated code is 12 bytes
+	//   otherwise length of generated code is 10 bytes
 }
 
 #if (1)
@@ -720,33 +693,31 @@
 
 // jump to an address pointed at by ptr, offset is in imm
 static void gen_jmp_ptr(void * ptr,Bits imm=0) {
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_word_to_reg(templosav, ptr, 1);
+	gen_mov_word_to_reg(templo3, ptr, 1);
 
 	if (imm) {
 		gen_mov_dword_to_reg_imm(templo2, imm);
 		cache_checkinstr(2);
-		cache_addw( ADD_REG(templosav, templosav, templo2) );      // add templosav, templosav, templo2
+		cache_addw( ADD_REG(templo3, templo3, templo2) );      // add templo3, templo3, templo2
 	}
 
 #if (1)
 // (*ptr) should be word aligned 
 	if ((imm & 0x03) == 0) {
-		cache_checkinstr(8);
-		cache_addw( LDR_IMM(templo2, templosav, 0) );      // ldr templo2, [templosav]
+		cache_checkinstr(6);
+		cache_addw( LDR_IMM(templo2, templo3, 0) );      // ldr templo2, [templo3]
 	} else
 #endif
 	{
-		cache_checkinstr(26);
-		cache_addw( LDRB_IMM(templo2, templosav, 0) );      // ldrb templo2, [templosav]
-		cache_addw( LDRB_IMM(templo1, templosav, 1) );      // ldrb templo1, [templosav, #1]
+		cache_checkinstr(24);
+		cache_addw( LDRB_IMM(templo2, templo3, 0) );      // ldrb templo2, [templo3]
+		cache_addw( LDRB_IMM(templo1, templo3, 1) );      // ldrb templo1, [templo3, #1]
 		cache_addw( LSL_IMM(templo1, templo1, 8) );      // lsl templo1, templo1, #8
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 2) );      // ldrb templo1, [templosav, #2]
+		cache_addw( LDRB_IMM(templo1, templo3, 2) );      // ldrb templo1, [templo3, #2]
 		cache_addw( LSL_IMM(templo1, templo1, 16) );      // lsl templo1, templo1, #16
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 3) );      // ldrb templo1, [templosav, #3]
+		cache_addw( LDRB_IMM(templo1, templo3, 3) );      // ldrb templo1, [templo3, #3]
 		cache_addw( LSL_IMM(templo1, templo1, 24) );      // lsl templo1, templo1, #24
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
 	}
@@ -754,8 +725,6 @@
 	// increase jmp address to keep thumb state
 	cache_addw( ADD_IMM3(templo2, templo2, 1) );      // add templo2, templo2, #1
 
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
-
 	cache_addw( BX(templo2) );      // bx templo2
 }
 
@@ -895,8 +864,7 @@
 
 // return from a function
 static void gen_return_function(void) {
-	cache_checkinstr(6);
-	cache_addw( MOV_REG(HOST_a1, FC_RETOP) );      // mov a1, FC_RETOP
+	cache_checkinstr(4);
 	cache_addw(0xbc08);      // pop {r3}
 	cache_addw( BX(HOST_r3) );      // bx r3
 }
@@ -930,35 +898,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -966,117 +931,107 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(10);							// b after_call (pc+10)
+				*(Bit16u*)pos=B_FWD(8);								// b after_call (pc+8)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+10)=NOP;								// nop
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+10)=NOP;								// nop
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+10)=NOP;								// nop
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+10)=NOP;								// nop
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_RORb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+6)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NOP;								// nop
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+4)=NOP;								// nop
+				*(Bit16u*)(pos+6)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+8)=NOP;								// nop
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
-			/*case t_ROLb:
-				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+10)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+12)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+14)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				break;*/
 			case t_ROLw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=NOP;								// nop
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=NOP;								// nop
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+12)=NOP;								// nop
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+10)=NOP;								// nop
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			default:
 				*(Bit32u*)( ( ((Bit32u) (*pos)) << 2 ) + ((Bit32u)pos + 4) ) = (Bit32u)fct_ptr;		// simple_func
@@ -1090,35 +1045,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -1126,121 +1078,85 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(8);								// b after_call (pc+8)
+				*(Bit16u*)pos=B_FWD(6);								// b after_call (pc+6)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
 				*(Bit16u*)(pos+2)=NOP;								// nop
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
+				*(Bit16u*)(pos+4)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+8)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
 				*(Bit16u*)(pos+2)=NOP;								// nop
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
+				*(Bit16u*)(pos+4)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+8)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
 				*(Bit16u*)(pos+2)=NOP;								// nop
-				*(Bit16u*)(pos+4)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
+				*(Bit16u*)(pos+4)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
 				*(Bit16u*)(pos+2)=NOP;								// nop
-				*(Bit16u*)(pos+4)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
+				*(Bit16u*)(pos+4)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
-				break;
-			case t_RORb:
-				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+6)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
 				*(Bit16u*)(pos+4)=NOP;								// nop
-				*(Bit16u*)(pos+6)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+8)=NOP;								// nop
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
+				*(Bit16u*)(pos+6)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+8)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(4);							// b after_call (pc+4)
-				break;
-			/*case t_ROLb:
-				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+10)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+12)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+14)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				break;*/
-			case t_ROLw:
-				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=ADD_IMM8(templo1, 32);			// add templo1, #32
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=NOP;								// nop
+				*(Bit16u*)(pos+4)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+8)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			default:
 				*(Bit32u*)( ( ((Bit32u) (*pos)) << 2 ) + ((Bit32u)pos + 2) ) = (Bit32u)fct_ptr;		// simple_func
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb-niw.h dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb-niw.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_armv4le-thumb-niw.h	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_armv4le-thumb-niw.h	2009-06-27 15:51:10.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_armv4le-thumb-niw.h,v 1.3 2009/05/16 21:52:47 c2woody Exp $ */
+/* $Id: risc_armv4le-thumb-niw.h,v 1.5 2009/06/27 12:51:10 c2woody Exp $ */
 
 
 /* ARMv4 (little endian) backend by M-HT (thumb version with data pool) */
@@ -25,15 +25,10 @@
 // temporary "lo" registers
 #define templo1 HOST_v3
 #define templo2 HOST_v4
-
-// temporary "lo" register - value must be preserved when using it
-#define templosav HOST_a3
-
-// temporary "hi" register
-#define temphi1 HOST_ip
+#define templo3 HOST_v2
 
 // register that holds function return values
-#define FC_RETOP HOST_v2
+#define FC_RETOP HOST_a1
 
 // register used for address calculations,
 #define FC_ADDR HOST_v1			// has to be saved across calls, see DRC_PROTECT_ADDR_REG
@@ -44,6 +39,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a2
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_a4
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_a1
 
@@ -83,8 +81,6 @@
 #define ADD_IMM8(dst, imm) (0x3000 + ((dst) << 8) + (imm) )
 // add dst, src1, src2
 #define ADD_REG(dst, src1, src2) (0x1800 + (dst) + ((src1) << 3) + ((src2) << 6) )
-// add dst, src
-#define ADD_LO_HI(dst, src) (0x4440 + (dst) + (((src) - HOST_r8) << 3) )
 // add dst, pc, #imm		@	0 <= imm < 1024	&	imm mod 4 = 0
 #define ADD_LO_PC_IMM(dst, imm) (0xa000 + ((dst) << 8) + ((imm) >> 2) )
 // sub dst, src1, src2
@@ -499,11 +495,9 @@
 
 // add a 32bit value from memory to a full register
 static void gen_add(HostReg reg,void* op) {
+	gen_mov_word_to_reg(templo3, op, 1);
 	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, reg) );      // mov temphi1, reg
-	gen_mov_word_to_reg(reg, op, 1);
-	cache_checkinstr(2);
-	cache_addw( ADD_LO_HI(reg, temphi1) );      // add reg, temphi1
+	cache_addw( ADD_REG(reg, reg, templo3) );      // add reg, reg, templo3
 }
 
 // add a 32bit constant value to a full register
@@ -525,12 +519,8 @@
 
 // move a 32bit constant value into memory
 static void gen_mov_direct_dword(void* dest,Bit32u imm) {
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_dword_to_reg_imm(templosav, imm);
-	gen_mov_word_from_reg(templosav, dest, 1);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_dword_to_reg_imm(templo3, imm);
+	gen_mov_word_from_reg(templo3, dest, 1);
 }
 
 // move an address into memory
@@ -541,19 +531,15 @@
 // add an 8bit constant value to a dword memory value
 static void gen_add_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	cache_checkinstr(2);
 	if (imm >= 0) {
-		cache_addw( ADD_IMM8(templosav, (Bit32s)imm) );      // add templosav, #(imm)
+		cache_addw( ADD_IMM8(templo3, (Bit32s)imm) );      // add templo3, #(imm)
 	} else {
-		cache_addw( SUB_IMM8(templosav, -((Bit32s)imm)) );      // sub templosav, #(-imm)
+		cache_addw( SUB_IMM8(templo3, -((Bit32s)imm)) );      // sub templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // add a 32bit (dword==true) or 16bit (dword==false) constant value to a memory value
@@ -563,38 +549,30 @@
 		gen_add_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
 	cache_checkinstr(2);
-	cache_addw( ADD_REG(templosav, templosav, templo1) );      // add templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( ADD_REG(templo3, templo3, templo1) );      // add templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // subtract an 8bit constant value from a dword memory value
 static void gen_sub_direct_byte(void* dest,Bit8s imm) {
 	if(!imm) return;
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, 1, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, 1, templo2);
 	cache_checkinstr(2);
 	if (imm >= 0) {
-		cache_addw( SUB_IMM8(templosav, (Bit32s)imm) );      // sub templosav, #(imm)
+		cache_addw( SUB_IMM8(templo3, (Bit32s)imm) );      // sub templo3, #(imm)
 	} else {
-		cache_addw( ADD_IMM8(templosav, -((Bit32s)imm)) );      // add templosav, #(-imm)
+		cache_addw( ADD_IMM8(templo3, -((Bit32s)imm)) );      // add templo3, #(-imm)
 	}
-	gen_mov_word_from_reg_helper(templosav, dest, 1, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	gen_mov_word_from_reg_helper(templo3, dest, 1, templo2);
 }
 
 // subtract a 32bit (dword==true) or 16bit (dword==false) constant value from a memory value
@@ -604,20 +582,16 @@
 		gen_sub_direct_byte(dest,(Bit8s)imm);
 		return;
 	}
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
 	gen_mov_dword_to_reg_imm(templo2, (Bit32u)dest);
-	gen_mov_word_to_reg_helper(templosav, dest, dword, templo2);
+	gen_mov_word_to_reg_helper(templo3, dest, dword, templo2);
 	if (dword) {
 		gen_mov_dword_to_reg_imm(templo1, imm);
 	} else {
 		gen_mov_word_to_reg_imm(templo1, (Bit16u)imm);
 	}
 	cache_checkinstr(2);
-	cache_addw( SUB_REG(templosav, templosav, templo1) );      // sub templosav, templosav, templo1
-	gen_mov_word_from_reg_helper(templosav, dest, dword, templo2);
-	cache_checkinstr(2);
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
+	cache_addw( SUB_REG(templo3, templo3, templo1) );      // sub templo3, templo3, templo1
+	gen_mov_word_from_reg_helper(templo3, dest, dword, templo2);
 }
 
 // effective address calculation, destination is dest_reg
@@ -672,12 +646,11 @@
 	cache_addd(0xe12fff10 + (templo1));      // bx templo1
 
 	// thumb state from now on
-	cache_addw( MOV_REG(FC_RETOP, HOST_a1) );      // mov FC_RETOP, a1
 }
 
 // generate a call to a parameterless function
 static void INLINE gen_call_function_raw(void * func) {
-	cache_checkinstr(20);
+	cache_checkinstr(18);
 	gen_call_function_helper(func);
 }
 
@@ -685,13 +658,13 @@
 // note: the parameters are loaded in the architecture specific way
 // using the gen_load_param_ functions below
 static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
-	cache_checkinstr(20);
+	cache_checkinstr(18);
 	Bit32u proc_addr = (Bit32u)cache.pos;
 	gen_call_function_helper(func);
 	return proc_addr;
 	// if proc_addr is on word  boundary ((proc_addr & 0x03) == 0)
-	//   then length of generated code is 18 bytes
-	//   otherwise length of generated code is 20 bytes
+	//   then length of generated code is 16 bytes
+	//   otherwise length of generated code is 18 bytes
 }
 
 #if (1)
@@ -722,33 +695,31 @@
 
 // jump to an address pointed at by ptr, offset is in imm
 static void gen_jmp_ptr(void * ptr,Bits imm=0) {
-	cache_checkinstr(2);
-	cache_addw( MOV_HI_LO(temphi1, templosav) );      // mov temphi1, templosav
-	gen_mov_word_to_reg(templosav, ptr, 1);
+	gen_mov_word_to_reg(templo3, ptr, 1);
 
 	if (imm) {
 		gen_mov_dword_to_reg_imm(templo2, imm);
 		cache_checkinstr(2);
-		cache_addw( ADD_REG(templosav, templosav, templo2) );      // add templosav, templosav, templo2
+		cache_addw( ADD_REG(templo3, templo3, templo2) );      // add templo3, templo3, templo2
 	}
 
 #if (1)
 // (*ptr) should be word aligned 
 	if ((imm & 0x03) == 0) {
-		cache_checkinstr(8);
-		cache_addw( LDR_IMM(templo2, templosav, 0) );      // ldr templo2, [templosav]
+		cache_checkinstr(6);
+		cache_addw( LDR_IMM(templo2, templo3, 0) );      // ldr templo2, [templo3]
 	} else
 #endif
 	{
-		cache_checkinstr(26);
-		cache_addw( LDRB_IMM(templo2, templosav, 0) );      // ldrb templo2, [templosav]
-		cache_addw( LDRB_IMM(templo1, templosav, 1) );      // ldrb templo1, [templosav, #1]
+		cache_checkinstr(24);
+		cache_addw( LDRB_IMM(templo2, templo3, 0) );      // ldrb templo2, [templo3]
+		cache_addw( LDRB_IMM(templo1, templo3, 1) );      // ldrb templo1, [templo3, #1]
 		cache_addw( LSL_IMM(templo1, templo1, 8) );      // lsl templo1, templo1, #8
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 2) );      // ldrb templo1, [templosav, #2]
+		cache_addw( LDRB_IMM(templo1, templo3, 2) );      // ldrb templo1, [templo3, #2]
 		cache_addw( LSL_IMM(templo1, templo1, 16) );      // lsl templo1, templo1, #16
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
-		cache_addw( LDRB_IMM(templo1, templosav, 3) );      // ldrb templo1, [templosav, #3]
+		cache_addw( LDRB_IMM(templo1, templo3, 3) );      // ldrb templo1, [templo3, #3]
 		cache_addw( LSL_IMM(templo1, templo1, 24) );      // lsl templo1, templo1, #24
 		cache_addw( ORR(templo2, templo1) );      // orr templo2, templo1
 	}
@@ -756,8 +727,6 @@
 	// increase jmp address to keep thumb state
 	cache_addw( ADD_IMM3(templo2, templo2, 1) );      // add templo2, templo2, #1
 
-	cache_addw( MOV_LO_HI(templosav, temphi1) );      // mov templosav, temphi1
-
 	cache_addw( BX(templo2) );      // bx templo2
 }
 
@@ -897,8 +866,7 @@
 
 // return from a function
 static void gen_return_function(void) {
-	cache_checkinstr(6);
-	cache_addw( MOV_REG(HOST_a1, FC_RETOP) );      // mov a1, FC_RETOP
+	cache_checkinstr(4);
 	cache_addw(0xbc08);      // pop {r3}
 	cache_addw( BX(HOST_r3) );      // bx r3
 }
@@ -932,35 +900,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -968,118 +933,110 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(14);							// b after_call (pc+14)
+				*(Bit16u*)pos=B_FWD(12);							// b after_call (pc+12)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_RORb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
 				*(Bit16u*)(pos+6)=NOP;								// nop
-				*(Bit16u*)(pos+8)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
+				*(Bit16u*)(pos+8)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
 				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+14)=NOP;								// nop
-				*(Bit16u*)(pos+16)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
+				*(Bit16u*)(pos+12)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+14)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+4)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+8)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+8)=B_FWD(4);							// b after_call (pc+4)
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			case t_ROLb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+10)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+12)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+14)=NOP;								// nop
-				*(Bit16u*)(pos+16)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+12)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+14)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_ROLw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
 				*(Bit16u*)(pos+10)=NOP;								// nop
-				*(Bit16u*)(pos+12)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)(pos+12)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				*(Bit16u*)(pos+14)=NOP;								// nop
-				*(Bit16u*)(pos+16)=NOP;								// nop
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+8)=B_FWD(6);							// b after_call (pc+6)
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+4)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(10);						// b after_call (pc+10)
 				break;
 			default:
 				*(Bit32u*)( ( ((Bit32u) (*pos)) << 2 ) + ((Bit32u)pos + 4) ) = (Bit32u)fct_ptr;		// simple_func
@@ -1093,35 +1050,32 @@
 			case t_ADDb:
 			case t_ADDw:
 			case t_ADDd:
-				*(Bit16u*)pos=ADD_REG(FC_RETOP, HOST_a1, HOST_a2);	// add FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=ADD_REG(HOST_a1, HOST_a1, HOST_a2);	// add a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_ORb:
 			case t_ORw:
 			case t_ORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ORR(FC_RETOP, HOST_a2);			// orr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=ORR(HOST_a1, HOST_a2);				// orr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_ANDb:
 			case t_ANDw:
 			case t_ANDd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=AND(FC_RETOP, HOST_a2);			// and FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=AND(HOST_a1, HOST_a2);				// and a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SUBb:
 			case t_SUBw:
 			case t_SUBd:
-				*(Bit16u*)pos=SUB_REG(FC_RETOP, HOST_a1, HOST_a2);	// sub FC_RETOP, a1, a2
-				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=SUB_REG(HOST_a1, HOST_a1, HOST_a2);	// sub a1, a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_XORb:
 			case t_XORw:
 			case t_XORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=EOR(FC_RETOP, HOST_a2);			// eor FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=EOR(HOST_a1, HOST_a2);				// eor a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_CMPb:
 			case t_CMPw:
@@ -1129,115 +1083,113 @@
 			case t_TESTb:
 			case t_TESTw:
 			case t_TESTd:
-				*(Bit16u*)pos=B_FWD(16);							// b after_call (pc+16)
+				*(Bit16u*)pos=B_FWD(14);							// b after_call (pc+14)
 				break;
 			case t_INCb:
 			case t_INCw:
 			case t_INCd:
-				*(Bit16u*)pos=ADD_IMM3(FC_RETOP, HOST_a1, 1);		// add FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=ADD_IMM3(HOST_a1, HOST_a1, 1);		// add a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_DECb:
 			case t_DECw:
 			case t_DECd:
-				*(Bit16u*)pos=SUB_IMM3(FC_RETOP, HOST_a1, 1);		// sub FC_RETOP, a1, #1
-				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=SUB_IMM3(HOST_a1, HOST_a1, 1);		// sub a1, a1, #1
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SHLb:
 			case t_SHLw:
 			case t_SHLd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSL_REG(FC_RETOP, HOST_a2);		// lsl FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSL_REG(HOST_a1, HOST_a2);			// lsl a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SHRb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 24);	// lsr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 24);	// lsr a1, a1, #24
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_SHRw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, FC_RETOP, 16);	// lsr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=LSR_IMM(HOST_a1, HOST_a1, 16);	// lsr a1, a1, #16
+				*(Bit16u*)(pos+4)=LSR_REG(HOST_a1, HOST_a2);		// lsr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_SHRd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=LSR_REG(FC_RETOP, HOST_a2);		// lsr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=LSR_REG(HOST_a1, HOST_a2);			// lsr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_SARb:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 24);		// lsl FC_RETOP, a1, #24
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 24);	// asr FC_RETOP, FC_RETOP, #24
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 24);	// asr a1, a1, #24
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_SARw:
-				*(Bit16u*)pos=LSL_IMM(FC_RETOP, HOST_a1, 16);		// lsl FC_RETOP, a1, #16
-				*(Bit16u*)(pos+2)=ASR_IMM(FC_RETOP, FC_RETOP, 16);	// asr FC_RETOP, FC_RETOP, #16
-				*(Bit16u*)(pos+4)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+6)=B_FWD(10);						// b after_call (pc+10)
+				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
+				*(Bit16u*)(pos+2)=ASR_IMM(HOST_a1, HOST_a1, 16);	// asr a1, a1, #16
+				*(Bit16u*)(pos+4)=ASR_REG(HOST_a1, HOST_a2);		// asr a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_SARd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ASR_REG(FC_RETOP, HOST_a2);		// asr FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=ASR_REG(HOST_a1, HOST_a2);			// asr a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_RORb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+4)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+6)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+12)=B_FWD(4);						// b after_call (pc+4)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=NOP;								// nop
+				*(Bit16u*)(pos+8)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+12)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+14)=NOP;								// nop
+				*(Bit16u*)(pos+16)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_RORw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+4)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+8)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)(pos+2)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+4)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+6)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+8)=B_FWD(6);							// b after_call (pc+6)
 				break;
 			case t_RORd:
-				*(Bit16u*)pos=MOV_REG(FC_RETOP, HOST_a1);			// mov FC_RETOP, a1
-				*(Bit16u*)(pos+2)=ROR_REG(FC_RETOP, HOST_a2);		// ror FC_RETOP, a2
-				*(Bit16u*)(pos+4)=B_FWD(12);						// b after_call (pc+12)
+				*(Bit16u*)pos=ROR_REG(HOST_a1, HOST_a2);			// ror a1, a2
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			case t_ROLb:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 24);		// lsl a1, a1, #24
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 8);	// lsr FC_RETOP, a1, #8
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(HOST_a1, FC_RETOP);			// orr a1, FC_RETOP
-				*(Bit16u*)(pos+10)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+12)=NOP;								// nop
-				*(Bit16u*)(pos+14)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+16)=NOP;								// nop
-				*(Bit16u*)(pos+18)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 8);		// lsr templo1, a1, #8
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+12)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+14)=NOP;								// nop
+				*(Bit16u*)(pos+16)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
 				break;
 			case t_ROLw:
 				*(Bit16u*)pos=LSL_IMM(HOST_a1, HOST_a1, 16);		// lsl a1, a1, #16
-				*(Bit16u*)(pos+2)=NEG(templo1, HOST_a2);			// neg templo1, a2
-				*(Bit16u*)(pos+4)=LSR_IMM(FC_RETOP, HOST_a1, 16);	// lsr FC_RETOP, a1, #16
-				*(Bit16u*)(pos+6)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+8)=ORR(FC_RETOP, HOST_a1);			// orr FC_RETOP, a1
-				*(Bit16u*)(pos+10)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+12)=B_FWD(4);						// b after_call (pc+4)
+				*(Bit16u*)(pos+2)=NEG(HOST_a2, HOST_a2);			// neg a2, a2
+				*(Bit16u*)(pos+4)=LSR_IMM(templo1, HOST_a1, 16);	// lsr templo1, a1, #16
+				*(Bit16u*)(pos+6)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+8)=ORR(HOST_a1, templo1);			// orr a1, templo1
+				*(Bit16u*)(pos+10)=NOP;								// nop
+				*(Bit16u*)(pos+12)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+14)=NOP;								// nop
+				*(Bit16u*)(pos+16)=NOP;								// nop
 				break;
 			case t_ROLd:
-				*(Bit16u*)pos=NEG(templo1, HOST_a2);				// neg templo1, a2
-				*(Bit16u*)(pos+2)=MOV_REG(FC_RETOP, HOST_a1);		// mov FC_RETOP, a1
-				*(Bit16u*)(pos+4)=ADD_IMM8(templo1, 32);			// add templo1, #32
-				*(Bit16u*)(pos+6)=ROR_REG(FC_RETOP, templo1);		// ror FC_RETOP, templo1
-				*(Bit16u*)(pos+8)=B_FWD(8);							// b after_call (pc+8)
+				*(Bit16u*)pos=NEG(HOST_a2, HOST_a2);				// neg a2, a2
+				*(Bit16u*)(pos+2)=ADD_IMM8(HOST_a2, 32);			// add a2, #32
+				*(Bit16u*)(pos+4)=ROR_REG(HOST_a1, HOST_a2);		// ror a1, a2
+				*(Bit16u*)(pos+6)=B_FWD(8);							// b after_call (pc+8)
 				break;
 			case t_NEGb:
 			case t_NEGw:
 			case t_NEGd:
-				*(Bit16u*)pos=NEG(FC_RETOP, HOST_a1);				// neg FC_RETOP, a1
-				*(Bit16u*)(pos+2)=B_FWD(14);						// b after_call (pc+14)
+				*(Bit16u*)pos=NEG(HOST_a1, HOST_a1);				// neg a1, a1
+				*(Bit16u*)(pos+2)=B_FWD(12);						// b after_call (pc+12)
 				break;
 			default:
 				*(Bit32u*)( ( ((Bit32u) (*pos)) << 2 ) + ((Bit32u)pos + 2) ) = (Bit32u)fct_ptr;		// simple_func
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_mipsel32.h dosboxcvs/src/cpu/core_dynrec/risc_mipsel32.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_mipsel32.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_mipsel32.h	2009-06-25 22:31:43.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_mipsel32.h,v 1.5 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: risc_mipsel32.h,v 1.6 2009/06/25 19:31:43 c2woody Exp $ */
 
 
 /* MIPS32 (little endian) backend by crazyc */
@@ -74,6 +74,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_a1
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_???
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_t5
 
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_x64.h dosboxcvs/src/cpu/core_dynrec/risc_x64.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_x64.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_x64.h	2009-06-25 22:31:43.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_x64.h,v 1.12 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: risc_x64.h,v 1.13 2009/06/25 19:31:43 c2woody Exp $ */
 
 
 // some configuring defines that specify the capabilities of this architecture
@@ -63,6 +63,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_ESI
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_EAX
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_ECX
 
@@ -290,12 +293,11 @@
 		imm_size=4;	rm_base=0x80;			//Signed dword imm
 	}
 
-	// ea_reg := ea_reg+TEMP_REG_DRC*(2^scale)+imm
-	// ea_reg :=   op1 +   op2      *(2^scale)+imm
+	// ea_reg := ea_reg+scale_reg*(2^scale)+imm
 	cache_addb(0x48);
 	cache_addb(0x8d);			//LEA
 	cache_addb(0x04+(dest_reg << 3)+rm_base);	//The sib indicator
-	cache_addb(dest_reg+(TEMP_REG_DRC<<3)+(scale<<6));
+	cache_addb(dest_reg+(scale_reg<<3)+(scale<<6));
 
 	switch (imm_size) {
 	case 0:	break;
diff -urN dosbox-0.73/src/cpu/core_dynrec/risc_x86.h dosboxcvs/src/cpu/core_dynrec/risc_x86.h
--- dosbox-0.73/src/cpu/core_dynrec/risc_x86.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec/risc_x86.h	2009-06-25 22:31:43.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: risc_x86.h,v 1.9 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: risc_x86.h,v 1.10 2009/06/25 19:31:43 c2woody Exp $ */
 
 
 // some configuring defines that specify the capabilities of this architecture
@@ -70,6 +70,9 @@
 // register that holds the second parameter
 #define FC_OP2 HOST_EDX
 
+// special register that holds the third parameter for _R3 calls (byte accessible)
+#define FC_OP3 HOST_EAX
+
 // register that holds byte-accessible temporary values
 #define FC_TMP_BA1 HOST_ECX
 
@@ -267,11 +270,10 @@
 		imm_size=4;	rm_base=0x80;			//Signed dword imm
 	}
 
-	// ea_reg := ea_reg+TEMP_REG_DRC*(2^scale)+imm
-	// ea_reg :=   op1 +   op2      *(2^scale)+imm
+	// ea_reg := ea_reg+scale_reg*(2^scale)+imm
 	cache_addb(0x8d);			//LEA
 	cache_addb(0x04+(dest_reg << 3)+rm_base);	//The sib indicator
-	cache_addb(dest_reg+(TEMP_REG_DRC<<3)+(scale<<6));
+	cache_addb(dest_reg+(scale_reg<<3)+(scale<<6));
 
 	switch (imm_size) {
 	case 0:	break;
@@ -425,7 +427,9 @@
 static void gen_run_code(void) {
 	cache_addd(0x0424448b);		// mov eax,[esp+4]
 	cache_addb(0x53);			// push ebx
+	cache_addb(0x56);			// push esi
 	cache_addw(0xd0ff);			// call eax
+	cache_addb(0x5e);			// pop  esi
 	cache_addb(0x5b);			// pop  ebx
 }
 
diff -urN dosbox-0.73/src/cpu/core_dynrec.cpp dosboxcvs/src/cpu/core_dynrec.cpp
--- dosbox-0.73/src/cpu/core_dynrec.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_dynrec.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -224,9 +224,11 @@
 
 run_block:
 		cache.block.running=0;
+		Bitu CPU_CyclesOld = CPU_Cycles;
 		// now we're ready to run the dynamic code block
 //		BlockReturn ret=((BlockReturn (*)(void))(block->cache.start))();
 		BlockReturn ret=core_dynrec.runcode(block->cache.start);
+		cycle_count += CPU_CyclesOld - CPU_Cycles;
 
 		switch (ret) {
 		case BR_Iret:
diff -urN dosbox-0.73/src/cpu/core_dyn_x86/.cvsignore dosboxcvs/src/cpu/core_dyn_x86/.cvsignore
--- dosbox-0.73/src/cpu/core_dyn_x86/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/cpu/core_dyn_x86/.cvsignore	2004-01-01 14:33:03.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/cpu/core_dyn_x86/Makefile.in dosboxcvs/src/cpu/core_dyn_x86/Makefile.in
--- dosbox-0.73/src/cpu/core_dyn_x86/Makefile.in	2009-05-20 21:29:05.000000000 +0300
+++ dosboxcvs/src/cpu/core_dyn_x86/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -53,6 +57,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -64,6 +70,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -74,8 +81,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -85,7 +93,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -103,12 +110,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -120,43 +130,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 noinst_HEADERS = cache.h helpers.h decoder.h risc_x86.h string.h \
                  dyn_fpu.h dyn_fpu_dh.h
 
@@ -192,14 +191,15 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -211,8 +211,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -222,12 +222,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -241,21 +242,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -314,20 +316,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -346,20 +340,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	ctags distclean distclean-generic distclean-tags distdir dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/cpu/core_dyn_x86.cpp dosboxcvs/src/cpu/core_dyn_x86.cpp
--- dosbox-0.73/src/cpu/core_dyn_x86.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_dyn_x86.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -296,8 +296,10 @@
 		}
 	}
 run_block:
+	Bitu CPU_CyclesOld = CPU_Cycles;
 	cache.block.running=0;
 	BlockReturn ret=gen_runcode(block->cache.start);
+	cycle_count += CPU_CyclesOld - CPU_Cycles;
 	switch (ret) {
 	case BR_Iret:
 #if C_HEAVY_DEBUG
diff -urN dosbox-0.73/src/cpu/core_full/.cvsignore dosboxcvs/src/cpu/core_full/.cvsignore
--- dosbox-0.73/src/cpu/core_full/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/cpu/core_full/.cvsignore	2003-04-02 01:16:07.000000000 +0300
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/cpu/core_full/Makefile.in dosboxcvs/src/cpu/core_full/Makefile.in
--- dosbox-0.73/src/cpu/core_full/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/cpu/core_full/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -53,6 +57,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -64,6 +70,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -74,8 +81,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -85,7 +93,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -103,12 +110,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -120,43 +130,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 noinst_HEADERS = ea_lookup.h load.h loadwrite.h op.h optable.h save.h \
 		 string.h support.h
 
@@ -192,14 +191,15 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -211,8 +211,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -222,12 +222,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -241,21 +242,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -314,20 +316,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -346,20 +340,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	ctags distclean distclean-generic distclean-tags distdir dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/cpu/core_full.cpp dosboxcvs/src/cpu/core_full.cpp
--- dosbox-0.73/src/cpu/core_full.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_full.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -64,8 +64,8 @@
 Bits CPU_Core_Full_Run(void) {
 	FullData inst;	
 	while (CPU_Cycles-->0) {
-#if C_DEBUG
 		cycle_count++;
+#if C_DEBUG		
 #if C_HEAVY_DEBUG
 		if (DEBUG_HeavyIsBreakpoint()) {
 			FillFlags();
diff -urN dosbox-0.73/src/cpu/core_normal/.cvsignore dosboxcvs/src/cpu/core_normal/.cvsignore
--- dosbox-0.73/src/cpu/core_normal/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/cpu/core_normal/.cvsignore	2003-08-22 23:13:48.000000000 +0300
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/cpu/core_normal/Makefile.in dosboxcvs/src/cpu/core_normal/Makefile.in
--- dosbox-0.73/src/cpu/core_normal/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/cpu/core_normal/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -53,6 +57,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -64,6 +70,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -74,8 +81,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -85,7 +93,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -103,12 +110,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -120,43 +130,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 noinst_HEADERS = helpers.h prefix_none.h prefix_66.h prefix_0f.h support.h table_ea.h \
 		prefix_66_0f.h string.h
 
@@ -192,14 +191,15 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -211,8 +211,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -222,12 +222,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -241,21 +242,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -314,20 +316,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -346,20 +340,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	ctags distclean distclean-generic distclean-tags distdir dvi \
 	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-generic pdf \
-	pdf-am ps ps-am tags uninstall uninstall-am
+	pdf-am ps ps-am tags uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/cpu/core_normal.cpp dosboxcvs/src/cpu/core_normal.cpp
--- dosbox-0.73/src/cpu/core_normal.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_normal.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -49,7 +49,7 @@
 #define SaveMd(off,val)	mem_writed_inline(off,val)
 #endif
 
-extern Bitu cycle_count;
+Bitu cycle_count;
 
 #if C_FPU
 #define CPU_FPU	1						//Enable FPU escape instructions
@@ -152,8 +152,8 @@
 			return debugCallback;
 		};
 #endif
-		cycle_count++;
 #endif
+		cycle_count++;
 restart_opcode:
 		switch (core.opcode_index+Fetchb()) {
 		#include "core_normal/prefix_none.h"
diff -urN dosbox-0.73/src/cpu/core_prefetch.cpp dosboxcvs/src/cpu/core_prefetch.cpp
--- dosbox-0.73/src/cpu/core_prefetch.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/cpu/core_prefetch.cpp	2009-07-08 20:43:44.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: core_prefetch.cpp,v 1.2 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: core_prefetch.cpp,v 1.3 2009/06/26 16:43:30 c2woody Exp $ */
 
 #include <stdio.h>
 
@@ -274,7 +274,7 @@
 				if (len>16) len=16;
 				char tempcode[16*2+1];char * writecode=tempcode;
 				for (;len>0;len--) {
-					sprintf(writecode,"%X",mem_readb(core.cseip++));
+					sprintf(writecode,"%02X",mem_readb(core.cseip++));
 					writecode+=2;
 				}
 				LOG(LOG_CPU,LOG_NORMAL)("Illegal/Unhandled opcode %s",tempcode);
diff -urN dosbox-0.73/src/cpu/core_simple.cpp dosboxcvs/src/cpu/core_simple.cpp
--- dosbox-0.73/src/cpu/core_simple.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/core_simple.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -148,8 +148,8 @@
 			return debugCallback;
 		};
 #endif
-		cycle_count++;
 #endif
+		cycle_count++;
 restart_opcode:
 		switch (core.opcode_index+Fetchb()) {
 
diff -urN dosbox-0.73/src/cpu/cpu.cpp dosboxcvs/src/cpu/cpu.cpp
--- dosbox-0.73/src/cpu/cpu.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/cpu/cpu.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -30,6 +30,7 @@
 #include "paging.h"
 #include "lazyflags.h"
 #include "support.h"
+#include "control.h"
 
 Bitu DEBUG_EnableDebugger(void);
 extern void GFX_SetTitle(Bit32s cycles ,Bits frameskip,bool paused);
@@ -56,7 +57,10 @@
 Bit32s CPU_CycleLimit = -1;
 Bit32s CPU_CycleUp = 0;
 Bit32s CPU_CycleDown = 0;
+Bit32s CPU_CyclesSet = 3000;
+Bitu CPU_CyclesCur = 0;
 Bit64s CPU_IODelayRemoved = 0;
+char core_mode[16];
 CPU_Decoder * cpudecoder;
 bool CPU_CycleAutoAdjust = false;
 bool CPU_SkipCycleAutoAdjust = false;
@@ -1570,6 +1574,7 @@
 				if (CPU_AutoDetermineMode&CPU_AUTODETERMINE_CORE) {
 					CPU_Core_Dyn_X86_Cache_Init(true);
 					cpudecoder=&CPU_Core_Dyn_X86_Run;
+					strcpy(core_mode, "dynamic");
 				}
 #elif (C_DYNREC)
 				if (CPU_AutoDetermineMode&CPU_AUTODETERMINE_CORE) {
@@ -2108,7 +2113,12 @@
 	    
 		CPU_CycleLeft=0;CPU_Cycles=0;
 		if (CPU_CycleMax==old_cycles) CPU_CycleMax++;
-		LOG_MSG("CPU:%d cycles",CPU_CycleMax);
+		if (CPU_AutoDetermineMode&CPU_AUTODETERMINE_CYCLES) {
+		    LOG_MSG("CPU:%d cycles (auto)",CPU_CycleMax);
+		} else {
+		    CPU_CyclesSet=CPU_CycleMax;
+		    LOG_MSG("CPU:%d cycles",CPU_CycleMax);
+		}
 		GFX_SetTitle(CPU_CycleMax,-1,false);
 	}
 }
@@ -2128,11 +2138,87 @@
 		}
 		CPU_CycleLeft=0;CPU_Cycles=0;
 		if (CPU_CycleMax <= 0) CPU_CycleMax=1;
-		LOG_MSG("CPU:%d cycles",CPU_CycleMax);
+		if (CPU_AutoDetermineMode&CPU_AUTODETERMINE_CYCLES) {
+		    LOG_MSG("CPU:%d cycles (auto)",CPU_CycleMax);
+		} else {
+		    CPU_CyclesSet=CPU_CycleMax;
+		    LOG_MSG("CPU:%d cycles",CPU_CycleMax);
+		}
 		GFX_SetTitle(CPU_CycleMax,-1,false);
 	}
 }
 
+static void CPU_ToggleAutoCycles(bool pressed) {
+    if (!pressed)
+	return;
+    Section* sec=control->GetSection("cpu");
+    if(sec) {
+	std::string tmp("cycles=");
+	sec->ExecuteDestroy(false);
+	if(CPU_CycleAutoAdjust) {
+	    std::ostringstream str;
+	    str << "fixed " << CPU_CyclesSet;
+	    tmp.append(str.str());
+	} else if(CPU_AutoDetermineMode&CPU_AUTODETERMINE_CYCLES) {
+	    tmp.append("max");
+	} else {
+	    tmp.append("auto");
+	}
+	sec->HandleInputline(tmp);
+	sec->ExecuteInit(false);
+    }
+}
+
+static void CPU_ToggleFullCore(bool pressed) {
+    if (!pressed)
+	return;
+    Section* sec=control->GetSection("cpu");
+    if(sec) {
+	std::string tmp="core=full";
+	sec->ExecuteDestroy(false);
+	sec->HandleInputline(tmp);
+	sec->ExecuteInit(false);
+    }
+}
+
+static void CPU_ToggleNormalCore(bool pressed) {
+    if (!pressed)
+	return;
+    Section* sec=control->GetSection("cpu");
+    if(sec) {
+	std::string tmp="core=normal";
+	sec->ExecuteDestroy(false);
+	sec->HandleInputline(tmp);
+	sec->ExecuteInit(false);
+    }
+}
+
+#if ((C_DYNAMIC_X86) || (C_DYNREC))
+static void CPU_ToggleDynamicCore(bool pressed) {
+    if (!pressed)
+	return;
+    Section* sec=control->GetSection("cpu");
+    if(sec) {
+	std::string tmp="core=dynamic";
+	sec->ExecuteDestroy(false);
+	sec->HandleInputline(tmp);
+	sec->ExecuteInit(false);
+    }
+}
+#endif
+
+static void CPU_ToggleSimpleCore(bool pressed) {
+    if (!pressed)
+	return;
+    Section* sec=control->GetSection("cpu");
+    std::string tmp="core=simple";
+    if(sec) {
+	sec->ExecuteDestroy(false);
+	sec->HandleInputline(tmp);
+	sec->ExecuteInit(false);
+    }
+}
+
 void CPU_Enable_SkipAutoAdjust(void) {
 	if (CPU_CycleAutoAdjust) {
 		CPU_CycleMax /= 2;
@@ -2216,6 +2302,13 @@
 #endif
 		MAPPER_AddHandler(CPU_CycleDecrease,MK_f11,MMOD1,"cycledown","Dec Cycles");
 		MAPPER_AddHandler(CPU_CycleIncrease,MK_f12,MMOD1,"cycleup"  ,"Inc Cycles");
+		MAPPER_AddHandler(CPU_ToggleAutoCycles,MK_equals,MMOD1,"cycauto","Tog. Cycles Auto");
+		MAPPER_AddHandler(CPU_ToggleNormalCore,MK_1,MMOD1,"normal"  ,"Tog. Normal Core");
+		MAPPER_AddHandler(CPU_ToggleFullCore,MK_2,MMOD1,"full","Tog. Full Core");
+#if ((C_DYNAMIC_X86) || (C_DYNREC))
+		MAPPER_AddHandler(CPU_ToggleDynamicCore,MK_3,MMOD1,"dynamic","Tog. Dynamic Core");
+#endif
+		MAPPER_AddHandler(CPU_ToggleSimpleCore,MK_4,MMOD1,"simple","Tog. Simple Core");
 		Change_Config(configuration);	
 		CPU_JMP(false,0,0,0);					//Setup the first cpu core
 	}
@@ -2293,11 +2386,15 @@
 				std::istringstream stream(str);
 				stream >> rmdval;
 				CPU_CycleMax=(Bit32s)rmdval;
+				CPU_CyclesSet=(Bit32s)rmdval;
 			} else {
 				std::istringstream stream(type);
 				int rmdval=0;
 				stream >> rmdval;
-				if(rmdval) CPU_CycleMax=(Bit32s)rmdval;
+				if(rmdval) {
+					CPU_CycleMax=(Bit32s)rmdval;
+					CPU_CyclesSet=(Bit32s)rmdval;
+				}
 			}
 			CPU_CycleAutoAdjust=false;
 		}
@@ -2306,6 +2403,8 @@
 		CPU_CycleDown=section->Get_int("cycledown");
 		std::string core(section->Get_string("core"));
 		cpudecoder=&CPU_Core_Normal_Run;
+		strncpy(core_mode,core.c_str(),15);
+		core_mode[15] = '\0';
 		if (core == "normal") {
 			cpudecoder=&CPU_Core_Normal_Run;
 		} else if (core =="simple") {
@@ -2331,7 +2430,11 @@
 #else
 
 #endif
+		} else {
+			strcpy(core_mode,"normal");
+			LOG_MSG("CPU:Unknown core type %s, switching back to normal.",core.c_str());
 		}
+  
 
 #if (C_DYNAMIC_X86)
 		CPU_Core_Dyn_X86_Cache_Init((core == "dynamic") || (core == "dynamic_nodhfpu"));
diff -urN dosbox-0.73/src/cpu/.cvsignore dosboxcvs/src/cpu/.cvsignore
--- dosbox-0.73/src/cpu/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/cpu/.cvsignore	2003-03-06 14:03:40.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/cpu/Makefile.in dosboxcvs/src/cpu/Makefile.in
--- dosbox-0.73/src/cpu/Makefile.in	2009-05-20 21:29:05.000000000 +0300
+++ dosboxcvs/src/cpu/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -54,7 +58,7 @@
 	core_prefetch.$(OBJEXT) core_dyn_x86.$(OBJEXT) \
 	core_dynrec.$(OBJEXT)
 libcpu_a_OBJECTS = $(am_libcpu_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -70,13 +74,10 @@
 DIST_SOURCES = $(libcpu_a_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -84,6 +85,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -95,6 +98,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -105,8 +109,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -116,7 +121,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -134,12 +138,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -151,43 +158,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 SUBDIRS = core_full core_normal core_dyn_x86 core_dynrec
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libcpu.a
@@ -255,18 +251,19 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/paging.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -299,7 +296,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -343,8 +341,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -369,8 +367,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -380,12 +378,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -399,21 +398,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -427,7 +427,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -435,8 +435,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -492,20 +490,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am:
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -525,24 +515,22 @@
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES ctags ctags-recursive distclean \
-	distclean-compile distclean-generic distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-noinstLIBRARIES clean-recursive \
+	ctags ctags-recursive distclean distclean-compile \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs installdirs-am \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags tags-recursive uninstall uninstall-am
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/.cvsignore dosboxcvs/src/.cvsignore
--- dosbox-0.73/src/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/.cvsignore	2003-03-06 14:03:39.000000000 +0200
@@ -0,0 +1,4 @@
+.deps
+dosbox
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/debug/.cvsignore dosboxcvs/src/debug/.cvsignore
--- dosbox-0.73/src/debug/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/debug/.cvsignore	2003-03-06 14:03:40.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/debug/debug.cpp dosboxcvs/src/debug/debug.cpp
--- dosbox-0.73/src/debug/debug.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/debug/debug.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -123,7 +123,7 @@
 static Bitu oldflags,oldcpucpl;
 DBGBlock dbg;
 static Bitu input_count;
-Bitu cycle_count;
+extern Bitu cycle_count;
 static bool debugging;
 
 
diff -urN dosbox-0.73/src/debug/Makefile.in dosboxcvs/src/debug/Makefile.in
--- dosbox-0.73/src/debug/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/debug/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -51,7 +55,7 @@
 am_libdebug_a_OBJECTS = debug.$(OBJEXT) debug_gui.$(OBJEXT) \
 	debug_disasm.$(OBJEXT) debug_win32.$(OBJEXT)
 libdebug_a_OBJECTS = $(am_libdebug_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -71,6 +75,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -82,6 +88,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -92,8 +99,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -103,7 +111,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -121,12 +128,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -138,43 +148,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libdebug.a
 libdebug_a_SOURCES = debug.cpp debug_gui.cpp debug_disasm.cpp debug_inc.h disasm_tables.h debug_win32.cpp
@@ -231,26 +230,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/debug_win32.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -262,8 +262,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -273,12 +273,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -292,21 +293,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -367,20 +369,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -400,22 +394,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/dos/.cvsignore dosboxcvs/src/dos/.cvsignore
--- dosbox-0.73/src/dos/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/dos/.cvsignore	2003-03-06 14:03:40.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/dos/dos.cpp dosboxcvs/src/dos/dos.cpp
--- dosbox-0.73/src/dos/dos.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/dos/dos.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -21,7 +21,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
-#include <time.h>
 #include "dosbox.h"
 #include "bios.h"
 #include "mem.h"
@@ -30,6 +29,7 @@
 #include "dos_inc.h"
 #include "setup.h"
 #include "support.h"
+#include "parport.h"
 #include "serialport.h"
 
 DOS_Block dos;
@@ -42,6 +42,11 @@
 	dos.errorcode=code;
 }
 
+static void DOS_AddDays(Bitu days);
+const Bit8u DOS_DATE_months[] = {
+	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
+};
+
 #define DATA_TRANSFERS_TAKE_CYCLES 1
 #ifdef DATA_TRANSFERS_TAKE_CYCLES
 #include "cpu.h"
@@ -109,8 +114,16 @@
 		}
 		break;
 	case 0x05:		/* Write Character to PRINTER */
-		E_Exit("DOS:Unhandled call %02X",reg_ah);
+	{
+		for(int i = 0; i < 3; i++) {
+			// look up a parallel port
+			if(parallelPortObjects[i] != NULL) {
+				parallelPortObjects[i]->Putchar(reg_dl);
+				break;
+			}
+		}
 		break;
+	}
 	case 0x06:		/* Direct Console Output / Input */
 		switch (reg_dl) {
 		case 0xFF:	/* Input */
@@ -333,6 +346,9 @@
 		break;
 	case 0x2a:		/* Get System Date */
 		{
+			reg_ax=0; // get time
+			CALLBACK_RunRealInt(0x1a);
+			if(reg_al) DOS_AddDays(reg_al);
 			int a = (14 - dos.date.month)/12;
 			int y = dos.date.year - a;
 			int m = dos.date.month + 12*a - 2;
@@ -345,7 +361,11 @@
 	case 0x2b:		/* Set System Date */
 		if (reg_cx<1980) { reg_al=0xff;break;}
 		if ((reg_dh>12) || (reg_dh==0))	{ reg_al=0xff;break;}
-		if ((reg_dl>31) || (reg_dl==0))	{ reg_al=0xff;break;}
+		if (reg_dl==0) { reg_al=0xff;break;}
+ 		if (reg_dl>DOS_DATE_months[reg_dh]) {
+			if(!((reg_dh==2)&&(reg_cx%4 == 0)&&(reg_dl==29))) // february pass
+			{ reg_al=0xff;break; }
+		}
 		dos.date.year=reg_cx;
 		dos.date.month=reg_dh;
 		dos.date.day=reg_dl;
@@ -355,13 +375,22 @@
 //TODO Get time through bios calls date is fixed
 		{
 /*	Calculate how many miliseconds have passed */
-			Bitu ticks=5*mem_readd(BIOS_TIMER);
-			ticks = ((ticks / 59659u) << 16) + ((ticks % 59659u) << 16) / 59659u;
-			Bitu seconds=(ticks/100);
-			reg_ch=(Bit8u)(seconds/3600);
-			reg_cl=(Bit8u)((seconds % 3600)/60);
-			reg_dh=(Bit8u)(seconds % 60);
-			reg_dl=(Bit8u)(ticks % 100);
+			//TODO Get time through bios calls date is fixed
+			reg_ax=0; // get time
+			CALLBACK_RunRealInt(0x1a);
+			if(reg_al) DOS_AddDays(reg_al);
+
+			Bitu time=((Bitu)reg_cx<<16)|reg_dx;
+			Bitu ticks=(Bitu)(5.49254945 * (double)time);
+				//* mem_readd(BIOS_TIMER));
+			
+			reg_dl=(Bit8u)((Bitu)ticks % 100); // 1/100 seconds
+			ticks/=100; 
+			reg_dh=(Bit8u)((Bitu)ticks % 60); // seconds
+			ticks/=60;
+			reg_cl=(Bit8u)((Bitu)ticks % 60); // minutes
+			ticks/=60;
+			reg_ch=(Bit8u)((Bitu)ticks % 24); // hours
 		}
 		break;
 	case 0x2d:		/* Set System Time */
@@ -1043,6 +1072,29 @@
 	return CBRET_NONE;
 }
 
+static void DOS_AddDays(Bitu days) {
+	dos.date.day += days;
+	Bit8u monthlimit = DOS_DATE_months[dos.date.month];
+
+	if(dos.date.day > monthlimit) {
+		if((dos.date.year %4 == 0) && (dos.date.month==2)) {
+			// leap year
+			if(dos.date.day > 29) {
+				dos.date.month++;
+				dos.date.day -= 29;
+			}
+		} else {
+			//not leap year
+			dos.date.month++;
+			dos.date.day -= monthlimit;
+		}
+		if(dos.date.month > 12) {
+			// year over
+			dos.date.month = 1; 
+			dos.date.year++;
+		}
+	}
+}
 
 static Bitu DOS_20Handler(void) {
 	reg_ax=0x4c00;
@@ -1131,16 +1183,6 @@
 	
 		dos.version.major=5;
 		dos.version.minor=0;
-	
-		/* Setup time and date */
-		time_t curtime;struct tm *loctime;
-		curtime = time (NULL);loctime = localtime (&curtime);
-	
-		dos.date.day=(Bit8u)loctime->tm_mday;
-		dos.date.month=(Bit8u)loctime->tm_mon+1;
-		dos.date.year=(Bit16u)loctime->tm_year+1900;
-		Bit32u ticks=(Bit32u)((loctime->tm_hour*3600+loctime->tm_min*60+loctime->tm_sec)*(float)PIT_TICK_RATE/65536.0);
-		mem_writed(BIOS_TIMER,ticks);
 	}
 	~DOS(){
 		for (Bit16u i=0;i<DOS_DRIVES;i++) delete Drives[i];
diff -urN dosbox-0.73/src/dos/dos_devices.cpp dosboxcvs/src/dos/dos_devices.cpp
--- dosbox-0.73/src/dos/dos_devices.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/dos/dos_devices.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -26,6 +26,7 @@
 #include "bios.h"
 #include "dos_inc.h"
 #include "support.h"
+#include "parport.h"
 #include "drives.h" //Wildcmp
 /* Include all the devices */
 
@@ -57,10 +58,39 @@
 	virtual bool WriteToControlChannel(PhysPt bufptr,Bit16u size,Bit16u * retcode){return false;}
 };
 
-class device_LPT1 : public device_NUL {
+class device_PRN : public DOS_Device {
 public:
-   	device_LPT1() { SetName("LPT1");}
-	Bit16u GetInformation(void) { return 0x80A0; }
+	device_PRN() {
+		SetName("PRN");
+	}
+	bool Read(Bit8u * data,Bit16u * size) {
+		*size=0;
+		LOG(LOG_DOSMISC,LOG_NORMAL)("PRNDEVICE:Read called");
+		return true;
+	}
+	bool Write(Bit8u * data,Bit16u * size) {
+		for(int i = 0; i < 3; i++) {
+			// look up a parallel port
+			if(parallelPortObjects[i] != NULL) {
+				// send the data
+				for (Bit16u j=0; j<*size; j++) {
+					if(!parallelPortObjects[i]->Putchar(data[j])) return false;
+				}
+				return true;
+			}
+		}
+		return false;
+	}
+	bool Seek(Bit32u * pos,Bit32u type) {
+		*pos = 0;
+		return true;
+	}
+	Bit16u GetInformation(void) {
+		return 0x80A0;
+	}
+	bool Close() {
+		return false;
+	}
 };
 
 bool DOS_Device::Read(Bit8u * data,Bit16u * size) {
@@ -142,7 +172,6 @@
 	// A bit of a hack. (but less then before).
 	// no need for casecmp as makename returns uppercase
 	if (strcmp(name_part, "AUX") == 0) name_part = com;
-	if (strcmp(name_part, "PRN") == 0) name_part = lpt;
 
 	/* loop through devices */
 	for(Bit8u index = 0;index < DOS_DEVICES;index++) {
@@ -187,6 +216,6 @@
 	newdev2=new device_NUL();
 	DOS_AddDevice(newdev2);
 	DOS_Device * newdev3;
-	newdev3=new device_LPT1();
+	newdev3=new device_PRN();
 	DOS_AddDevice(newdev3);
 }
diff -urN dosbox-0.73/src/dos/dos_files.cpp dosboxcvs/src/dos/dos_files.cpp
--- dosbox-0.73/src/dos/dos_files.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/dos/dos_files.cpp	2009-06-18 21:17:54.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: dos_files.cpp,v 1.110 2009/04/26 19:13:32 harekiet Exp $ */
+/* $Id: dos_files.cpp,v 1.111 2009/06/18 18:17:54 c2woody Exp $ */
 
 #include <string.h>
 #include <stdlib.h>
@@ -356,9 +356,8 @@
 		DOS_SetError(DOSERR_INVALID_HANDLE);
 		return false;
 	};
-//TODO maybe another code :)
 /*
-	if (!(Files[handle]->flags & OPEN_READ)) {
+	if ((Files[handle]->flags & 0x0f) == OPEN_WRITE)) {
 		DOS_SetError(DOSERR_INVALID_HANDLE);
 		return false;
 	}
@@ -379,9 +378,8 @@
 		DOS_SetError(DOSERR_INVALID_HANDLE);
 		return false;
 	};
-//TODO maybe another code :)
 /*
-	if (!(Files[handle]->flags & OPEN_WRITE)) {
+	if ((Files[handle]->flags & 0x0f) == OPEN_READ)) {
 		DOS_SetError(DOSERR_INVALID_HANDLE);
 		return false;
 	}
@@ -1059,7 +1057,9 @@
  */
 
 	DOS_FCB fcb(seg,offset);
-	Bit32u random;Bit16u old_block;Bit8u old_rec;
+	Bit32u random;
+	Bit16u old_block=0;
+	Bit8u old_rec=0;
 	Bit8u error=0;
 
 	/* Set the correct record from the random data */
@@ -1082,7 +1082,9 @@
 Bit8u DOS_FCBRandomWrite(Bit16u seg,Bit16u offset,Bit16u numRec,bool restore) {
 /* see FCB_RandomRead */
 	DOS_FCB fcb(seg,offset);
-	Bit32u random;Bit16u old_block;Bit8u old_rec;
+	Bit32u random;
+	Bit16u old_block=0;
+	Bit8u old_rec=0;
 	Bit8u error=0;
 
 	/* Set the correct record from the random data */
diff -urN dosbox-0.73/src/dos/dos_ioctl.cpp dosboxcvs/src/dos/dos_ioctl.cpp
--- dosbox-0.73/src/dos/dos_ioctl.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/dos/dos_ioctl.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -150,6 +150,12 @@
 			return false;
 		}
 		return true;
+
+	case 0x0A:		/* Is Device of Handle Remote? */
+		reg_dx=0x8000;
+		LOG(LOG_IOCTL,LOG_NORMAL)("0A:Faked output: device of handle %d is remote",handle);
+		return true;
+
 	case 0x0D:		/* Generic block device request */
 		{
 			if (Drives[drive]->isRemovable()) {
diff -urN dosbox-0.73/src/dos/dos_memory.cpp dosboxcvs/src/dos/dos_memory.cpp
--- dosbox-0.73/src/dos/dos_memory.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/dos/dos_memory.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: dos_memory.cpp,v 1.44 2009/06/08 17:20:02 c2woody Exp $ */
+
 #include "dosbox.h"
 #include "mem.h"
 #include "dos_inc.h"
@@ -29,8 +31,11 @@
 	Bit16u mcb_segment=dos.firstMCB;
 	DOS_MCB mcb(mcb_segment);
 	DOS_MCB mcb_next(0);
+	Bitu counter=0;
 
-	while (mcb.GetType()!=0x5a) {
+	while (mcb.GetType()!='Z') {
+		if(counter > 10000000) E_Exit("DOS MCB list corrupted.");
+		counter++;
 		mcb_next.SetPt((Bit16u)(mcb_segment+mcb.GetSize()+1));
 		if ((mcb.GetPSPSeg()==0) && (mcb_next.GetPSPSeg()==0)) {
 			mcb.SetSize(mcb.GetSize()+mcb_next.GetSize()+1);
@@ -45,7 +50,7 @@
 void DOS_FreeProcessMemory(Bit16u pspseg) {
 	Bit16u mcb_segment=dos.firstMCB;
 	DOS_MCB mcb(mcb_segment);
-	while (true) {
+	for (;;) {
 		if (mcb.GetPSPSeg()==pspseg) {
 			mcb.SetPSPSeg(MCB_FREE);
 		}
@@ -64,7 +69,7 @@
 	Bit16u umb_start=dos_infoblock.GetStartOfUMBChain();
 	if (umb_start==UMB_START_SEG) {
 		DOS_MCB umb_mcb(umb_start);
-		while (true) {
+		for (;;) {
 			if (umb_mcb.GetPSPSeg()==pspseg) {
 				umb_mcb.SetPSPSeg(MCB_FREE);
 			}
@@ -394,8 +399,8 @@
 	 * buggy games, which compare against the interrupt table. (probably a 
 	 * broken linked list implementation) */
 	callbackhandler.Allocate(&DOS_default_handler,"DOS default int");
-	Bitu ihseg = 0x70;
-	Bitu ihofs = 0x08;
+	Bit16u ihseg = 0x70;
+	Bit16u ihofs = 0x08;
 	real_writeb(ihseg,ihofs+0x00,(Bit8u)0xFE);	//GRP 4
 	real_writeb(ihseg,ihofs+0x01,(Bit8u)0x38);	//Extra Callback instruction
 	real_writew(ihseg,ihofs+0x02,callbackhandler.Get_callback());  //The immediate word
@@ -434,12 +439,12 @@
 	if (machine==MCH_TANDY) {
 		/* memory up to 608k available, the rest (to 640k) is used by
 			the tandy graphics system's variable mapping of 0xb800 */
-		mcb.SetSize(0x97FE - DOS_MEM_START - mcb_sizes);
+		mcb.SetSize(0x97FF - DOS_MEM_START - mcb_sizes);
 	} else if (machine==MCH_PCJR) {
 		/* memory from 128k to 640k is available */
 		mcb_devicedummy.SetPt((Bit16u)0x2000);
 		mcb_devicedummy.SetPSPSeg(MCB_FREE);
-		mcb_devicedummy.SetSize(0x9FFE - 0x2000);
+		mcb_devicedummy.SetSize(0x9FFF - 0x2000);
 		mcb_devicedummy.SetType(0x5a);
 
 		/* exclude PCJr graphics region */
@@ -453,6 +458,7 @@
 		mcb.SetType(0x4d);
 	} else {
 		/* complete memory up to 640k available */
+		/* last paragraph used to add UMB chain to low-memory MCB chain */
 		mcb.SetSize(0x9FFE - DOS_MEM_START - mcb_sizes);
 	}
 
diff -urN dosbox-0.73/src/dos/dos_programs.cpp dosboxcvs/src/dos/dos_programs.cpp
--- dosbox-0.73/src/dos/dos_programs.cpp	2009-05-25 21:44:45.000000000 +0300
+++ dosboxcvs/src/dos/dos_programs.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: dos_programs.cpp,v 1.93 2009/04/16 12:28:30 qbix79 Exp $ */
+/* $Id: dos_programs.cpp,v 1.94 2009/06/12 20:10:09 c2woody Exp $ */
 
 #include "dosbox.h"
 #include <stdlib.h>
@@ -171,6 +171,7 @@
 
 			if (!cmd->FindCommand(2,temp_line)) goto showusage;
 			if (!temp_line.size()) goto showusage;
+			bool is_physfs = temp_line.find(':',((temp_line[0]|0x20) >= 'a' && (temp_line[0]|0x20) <= 'z')?2:0) != std::string::npos;
 			struct stat test;
 			//Win32 : strip tailing backslashes
 			//os2: some special drive check
@@ -179,7 +180,7 @@
 #if defined (WIN32) || defined(OS2)
 			/* Removing trailing backslash if not root dir so stat will succeed */
 			if(temp_line.size() > 3 && temp_line[temp_line.size()-1]=='\\') temp_line.erase(temp_line.size()-1,1);
-			if (stat(temp_line.c_str(),&test)) {
+			if (!is_physfs && stat(temp_line.c_str(),&test)) {
 #endif
 #if defined(WIN32)
 // Nothing to do here.
@@ -203,7 +204,7 @@
 			}
 			if (failed) {
 #else
-			if (stat(temp_line.c_str(),&test)) {
+			if (!is_physfs && stat(temp_line.c_str(),&test)) {
 				failed = true;
 				Cross::ResolveHomedir(temp_line);
 				//Try again after resolving ~
@@ -215,7 +216,7 @@
 				return;
 			}
 			/* Not a switch so a normal directory/file */
-			if (!(test.st_mode & S_IFDIR)) {
+			if (!is_physfs && !(test.st_mode & S_IFDIR)) {
 #ifdef OS2
 				HFILE cdrom_fd = 0;
 				ULONG ulAction = 0;
@@ -224,13 +225,26 @@
 					OPEN_FLAGS_DASD | OPEN_SHARE_DENYNONE | OPEN_ACCESS_READONLY, 0L);
 				DosClose(cdrom_fd);
 				if (rc != NO_ERROR && rc != ERROR_NOT_READY) {
+#if C_HAVE_PHYSFS
+				// Make it a physfs then...
+				is_physfs = true;
+				temp_line.insert(0, 1, ':');
+#else
 				WriteOut(MSG_Get("PROGRAM_MOUNT_ERROR_2"),temp_line.c_str());
 				return;
+#endif
 			}
 #else
+#if C_HAVE_PHYSFS
+				// Make it a physfs then...
+				is_physfs = true;
+				temp_line.insert(0, 1, ':');
+#else
 				WriteOut(MSG_Get("PROGRAM_MOUNT_ERROR_2"),temp_line.c_str());
 				return;
 #endif
+#endif
+
 			}
 
 			if (temp_line[temp_line.size()-1]!=CROSS_FILESPLIT) temp_line+=CROSS_FILESPLIT;
@@ -238,7 +252,7 @@
 			if (type=="cdrom") {
 				int num = -1;
 				cmd->FindInt("-usecd",num,true);
-				int error;
+				int error = 0;
 				if (cmd->FindExist("-aspi",false)) {
 					MSCDEX_SetCDInterface(CDROM_USE_ASPI, num);
 				} else if (cmd->FindExist("-ioctl_dio",false)) {
@@ -267,7 +281,15 @@
 					MSCDEX_SetCDInterface(CDROM_USE_IOCTL_DIO, num);
 #endif
 				}
-				newdrive  = new cdromDrive(drive,temp_line.c_str(),sizes[0],bit8size,sizes[2],0,mediaid,error);
+				if (is_physfs) {
+#if C_HAVE_PHYSFS
+					newdrive  = new physfscdromDrive(drive,temp_line.c_str(),sizes[0],bit8size,sizes[2],0,mediaid,error);
+#else
+					LOG_MSG("ERROR:This build does not support physfs");
+#endif
+				} else {
+					newdrive  = new cdromDrive(drive,temp_line.c_str(),sizes[0],bit8size,sizes[2],0,mediaid,error);
+				}
 				// Check Mscdex, if it worked out...
 				switch (error) {
 					case 0  :	WriteOut(MSG_Get("MSCDEX_SUCCESS"));				break;
@@ -291,7 +313,15 @@
 #else
 				if(temp_line == "/") WriteOut(MSG_Get("PROGRAM_MOUNT_WARNING_OTHER"));
 #endif
-				newdrive=new localDrive(temp_line.c_str(),sizes[0],bit8size,sizes[2],sizes[3],mediaid);
+				if (is_physfs) {
+#if C_HAVE_PHYSFS
+					newdrive=new physfsDrive(temp_line.c_str(),sizes[0],bit8size,sizes[2],sizes[3],mediaid);
+#else
+					LOG_MSG("ERROR:This build does not support physfs");
+#endif
+				} else {
+					newdrive=new localDrive(temp_line.c_str(),sizes[0],bit8size,sizes[2],sizes[3],mediaid);
+				}
 			}
 		} else {
 			WriteOut(MSG_Get("PROGRAM_MOUNT_ILL_TYPE"),type.c_str());
@@ -308,16 +338,16 @@
 		mem_writeb(Real2Phys(dos.tables.mediaid)+(drive-'A')*2,newdrive->GetMediaByte());
 		WriteOut(MSG_Get("PROGRAM_MOUNT_STATUS_2"),drive,newdrive->GetInfo());
 		/* check if volume label is given and don't allow it to updated in the future */
-		if (cmd->FindString("-label",label,true)) newdrive->dirCache.SetLabel(label.c_str(),iscdrom,false);
+		if (cmd->FindString("-label",label,true)) newdrive->SetLabel(label.c_str(),iscdrom,false);
 		/* For hard drives set the label to DRIVELETTER_Drive.
 		 * For floppy drives set the label to DRIVELETTER_Floppy.
 		 * This way every drive except cdroms should get a label.*/
 		else if(type == "dir") { 
 			label = drive; label += "_DRIVE";
-			newdrive->dirCache.SetLabel(label.c_str(),iscdrom,true);
+			newdrive->SetLabel(label.c_str(),iscdrom,true);
 		} else if(type == "floppy") {
 			label = drive; label += "_FLOPPY";
-			newdrive->dirCache.SetLabel(label.c_str(),iscdrom,true);
+			newdrive->SetLabel(label.c_str(),iscdrom,true);
 		}
 		return;
 showusage:
@@ -742,6 +772,11 @@
 				}
 			}
 		} else {
+			// No sane BIOS boots if the signature is missing
+			if((bootarea.rawdata[510]!=0x55) || (bootarea.rawdata[511]!=0xAA)) {
+				WriteOut_NoParsing("PROGRAM_BOOT_UNABLE");
+				return;
+			}
 			disable_umb_ems_xms();
 			void RemoveEMSPageFrame(void);
 			RemoveEMSPageFrame();
@@ -758,7 +793,7 @@
 			SegSet16(es, 0);
 			/* set up stack at a safe place */
 			SegSet16(ss, 0x7000);
-			reg_esp = 0x400;
+			reg_esp = 0x100;
 			reg_esi = 0;
 			reg_ecx = 1;
 			reg_ebp = 0;
@@ -774,7 +809,7 @@
 }
 
 
-#if C_DEBUG
+//#if C_DEBUG
 class LDGFXROM : public Program {
 public:
 	void Run(void) {
@@ -827,8 +862,544 @@
 static void LDGFXROM_ProgramStart(Program * * make) {
 	*make=new LDGFXROM;
 }
+//#endif
+
+const Bit8u freedos_mbr[] = {
+	0x33,0xC0,0x8E,0xC0,0x8E,0xD8,0x8E,0xD0,0xBC,0x00,0x7C,0xFC,0x8B,0xF4,0xBF,0x00, 
+	0x06,0xB9,0x00,0x01,0xF2,0xA5,0xEA,0x67,0x06,0x00,0x00,0x8B,0xD5,0x58,0xA2,0x4F, // 10h
+	0x07,0x3C,0x35,0x74,0x23,0xB4,0x10,0xF6,0xE4,0x05,0xAE,0x04,0x8B,0xF0,0x80,0x7C, // 20h
+	0x04,0x00,0x74,0x44,0x80,0x7C,0x04,0x05,0x74,0x3E,0xC6,0x04,0x80,0xE8,0xDA,0x00, 
+	0x8A,0x74,0x01,0x8B,0x4C,0x02,0xEB,0x08,0xE8,0xCF,0x00,0xB9,0x01,0x00,0x32,0xD1, // 40h
+	0xBB,0x00,0x7C,0xB8,0x01,0x02,0xCD,0x13,0x72,0x1E,0x81,0xBF,0xFE,0x01,0x55,0xAA, 
+	0x75,0x16,0xEA,0x00,0x7C,0x00,0x00,0x80,0xFA,0x81,0x74,0x02,0xB2,0x80,0x8B,0xEA, 
+	0x42,0x80,0xF2,0xB3,0x88,0x16,0x41,0x07,0xBF,0xBE,0x07,0xB9,0x04,0x00,0xC6,0x06, 
+	0x34,0x07,0x31,0x32,0xF6,0x88,0x2D,0x8A,0x45,0x04,0x3C,0x00,0x74,0x23,0x3C,0x05, // 80h
+	0x74,0x1F,0xFE,0xC6,0xBE,0x31,0x07,0xE8,0x71,0x00,0xBE,0x4F,0x07,0x46,0x46,0x8B, 
+	0x1C,0x0A,0xFF,0x74,0x05,0x32,0x7D,0x04,0x75,0xF3,0x8D,0xB7,0x7B,0x07,0xE8,0x5A, 
+	0x00,0x83,0xC7,0x10,0xFE,0x06,0x34,0x07,0xE2,0xCB,0x80,0x3E,0x75,0x04,0x02,0x74, 
+	0x0B,0xBE,0x42,0x07,0x0A,0xF6,0x75,0x0A,0xCD,0x18,0xEB,0xAC,0xBE,0x31,0x07,0xE8, 
+	0x39,0x00,0xE8,0x36,0x00,0x32,0xE4,0xCD,0x1A,0x8B,0xDA,0x83,0xC3,0x60,0xB4,0x01, 
+	0xCD,0x16,0xB4,0x00,0x75,0x0B,0xCD,0x1A,0x3B,0xD3,0x72,0xF2,0xA0,0x4F,0x07,0xEB, 
+	0x0A,0xCD,0x16,0x8A,0xC4,0x3C,0x1C,0x74,0xF3,0x04,0xF6,0x3C,0x31,0x72,0xD6,0x3C, 
+	0x35,0x77,0xD2,0x50,0xBE,0x2F,0x07,0xBB,0x1B,0x06,0x53,0xFC,0xAC,0x50,0x24,0x7F, //100h
+	0xB4,0x0E,0xCD,0x10,0x58,0xA8,0x80,0x74,0xF2,0xC3,0x56,0xB8,0x01,0x03,0xBB,0x00, //110h
+	0x06,0xB9,0x01,0x00,0x32,0xF6,0xCD,0x13,0x5E,0xC6,0x06,0x4F,0x07,0x3F,0xC3,0x0D, //120h
+	0x8A,0x0D,0x0A,0x46,0x35,0x20,0x2E,0x20,0x2E,0x20,0x2E,0xA0,0x64,0x69,0x73,0x6B, 
+	0x20,0x32,0x0D,0x0A,0x0A,0x44,0x65,0x66,0x61,0x75,0x6C,0x74,0x3A,0x20,0x46,0x31, //140h
+	0xA0,0x00,0x01,0x00,0x04,0x00,0x06,0x03,0x07,0x07,0x0A,0x0A,0x63,0x0E,0x64,0x0E, 
+	0x65,0x14,0x80,0x19,0x81,0x19,0x82,0x19,0x83,0x1E,0x93,0x24,0xA5,0x2B,0x9F,0x2F, 
+	0x75,0x33,0x52,0x33,0xDB,0x36,0x40,0x3B,0xF2,0x41,0x00,0x44,0x6F,0xF3,0x48,0x70, 
+	0x66,0xF3,0x4F,0x73,0xB2,0x55,0x6E,0x69,0xF8,0x4E,0x6F,0x76,0x65,0x6C,0xEC,0x4D, //180h
+	0x69,0x6E,0x69,0xF8,0x4C,0x69,0x6E,0x75,0xF8,0x41,0x6D,0x6F,0x65,0x62,0xE1,0x46, 
+	0x72,0x65,0x65,0x42,0x53,0xC4,0x42,0x53,0x44,0xE9,0x50,0x63,0x69,0xF8,0x43,0x70, 
+	0xED,0x56,0x65,0x6E,0x69,0xF8,0x44,0x6F,0x73,0x73,0x65,0xE3,0x3F,0xBF,0x00,0x00, //1B0h
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, 
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x55,0xAA
+	};
+#ifdef WIN32
+#include <winioctl.h>
 #endif
 
+class IMGMAKE : public Program {
+public:
+#ifdef WIN32
+	bool OpenDisk(HANDLE* f, OVERLAPPED* o, Bit8u* name) {
+		o->hEvent = INVALID_HANDLE_VALUE;
+		*f = CreateFile( (LPCSTR)name, GENERIC_READ | GENERIC_WRITE,
+			0,    // exclusive access 
+			NULL, // default security attributes 
+			OPEN_EXISTING,
+			FILE_FLAG_OVERLAPPED,
+			NULL );
+
+		if (*f == INVALID_HANDLE_VALUE) return false;
+
+		// init OVERLAPPED 
+		o->Internal = 0;
+		o->InternalHigh = 0;
+		o->Offset = 0;
+		o->OffsetHigh = 0;
+		o->hEvent = CreateEvent(
+			NULL,   // default security attributes 
+			TRUE,   // manual-reset event 
+			FALSE,  // not signaled 
+			NULL    // no name
+			);
+		return true;
+	}
+
+	void CloseDisk(HANDLE f, OVERLAPPED* o) {
+		if(f != INVALID_HANDLE_VALUE) CloseHandle(f);
+		if(o->hEvent != INVALID_HANDLE_VALUE) CloseHandle(o->hEvent);
+	}
+
+	bool StartReadDisk(HANDLE f, OVERLAPPED* o, Bit8u* buffer, Bitu offset, Bitu size) { 
+		o->Offset = offset;
+		if (!ReadFile(f, buffer, size, NULL, o) && 
+			(GetLastError()==ERROR_IO_PENDING)) return true;
+		return false;
+	}
+
+	// 0=still waiting, 1=catastrophic faliure, 2=success, 3=sector not found, 4=crc error 
+	Bitu CheckDiskReadComplete(HANDLE f, OVERLAPPED* o) {
+		DWORD numret;
+		BOOL b = GetOverlappedResult( f, o, &numret,false); 
+		if(b) return 2;
+		else {
+			int error = GetLastError();
+			if(error==ERROR_IO_INCOMPLETE)			return 0;
+			if(error==ERROR_FLOPPY_UNKNOWN_ERROR)	return 5;
+			if(error==ERROR_CRC)					return 4;
+			if(error==ERROR_SECTOR_NOT_FOUND)		return 3;
+			return 1;	
+		}
+	}
+
+	Bitu ReadDisk(FILE* f, Bit8u driveletter, Bitu retries_max) {
+		unsigned char data[36*2*512];
+		HANDLE hFloppy;
+		DWORD numret;
+		OVERLAPPED o;
+		DISK_GEOMETRY geom;
+
+		Bit8u drivestring[] = "\\\\.\\x:"; drivestring[4]=driveletter;
+		if(!OpenDisk(&hFloppy, &o, drivestring)) return false;
+
+		// get drive geom
+		DeviceIoControl( hFloppy, IOCTL_DISK_GET_DRIVE_GEOMETRY,NULL,0,
+		&geom,sizeof(DISK_GEOMETRY),&numret,NULL);
+
+		switch(geom.MediaType) {
+			case F5_1Pt2_512: case F3_1Pt44_512: case F3_2Pt88_512:	case F3_720_512:
+			case F5_360_512: case F5_320_512: case F5_180_512: case F5_160_512:
+				break;
+			default:
+				CloseDisk(hFloppy,&o);
+				return false;
+		}
+		Bitu total_sect_per_cyl = geom.SectorsPerTrack * geom.TracksPerCylinder;
+		Bitu cyln_size = 512 * total_sect_per_cyl;
+		
+		WriteOut(MSG_Get("PROGRAM_IMGMAKE_FLREAD"),
+			geom.Cylinders.LowPart,geom.TracksPerCylinder,
+			geom.SectorsPerTrack,(cyln_size*geom.Cylinders.LowPart)/1024);
+		WriteOut(MSG_Get("PROGRAM_IMGMAKE_FLREAD2"));
+			
+		for(Bitu i = 0; i < geom.Cylinders.LowPart; i++) {
+			Bitu result;
+			// for each cylinder
+			WriteOut("%2u",i);
+
+			if(!StartReadDisk(hFloppy, &o, &data[0], cyln_size*i, cyln_size)){
+				CloseDisk(hFloppy,&o);
+				return false;
+			}
+			do {
+				result = CheckDiskReadComplete(hFloppy, &o);
+				CALLBACK_Idle();
+			}
+			while (result==0);
+
+			switch(result) {
+			case 1:
+				CloseDisk(hFloppy,&o);
+				return false;
+			case 2: // success
+				for(Bitu m=0; m < cyln_size/512; m++) WriteOut("\xdb");
+				break;
+			case 3:
+			case 4: // data errors
+			case 5:
+				for(Bitu k=0; k < total_sect_per_cyl; k++) {
+					Bitu retries=retries_max;
+restart_int:
+					StartReadDisk(hFloppy, &o, &data[512*k], cyln_size*i + 512*k, 512);
+					do {
+						result = CheckDiskReadComplete(hFloppy, &o);
+						CALLBACK_Idle();
+					}
+					while (result==0);
+										
+					switch(result) {
+					case 1: // bad error
+						CloseDisk(hFloppy,&o);
+						return false;
+					case 2: // success
+						if(retries==retries_max) WriteOut("\xdb");
+						else WriteOut("\b\b\b\xb1");
+						break;
+					case 3:
+					case 4: // read errors
+					case 5:
+						if(retries!=retries_max) WriteOut("\b\b\b");
+						retries--;
+						switch(result) {
+							case 3: WriteOut("x");
+							case 4: WriteOut("!");
+							case 5: WriteOut("?");
+						}
+						WriteOut("%2d",retries);
+
+						if(retries)	goto restart_int;
+						const Bit8u badfood[]="IMGMAKE BAD FLOPPY SECTOR \xBA\xAD\xF0\x0D";
+						for(Bitu z = 0; z < 512/32; z++)
+							memcpy(&data[512*k+z*32],badfood,32);
+						WriteOut("\b\b");
+						break;
+					}
+				}
+				break;
+			}
+			fwrite(data, 512, total_sect_per_cyl, f);
+			WriteOut("%2x%2x\n", data[0], data[1]);
+		}
+		// seek to 0
+		StartReadDisk(hFloppy, &o, &data[0], 0, 512);
+		CloseDisk(hFloppy,&o);
+		return true;
+	}
+#endif
+
+	void Run(void) {
+		std::string disktype;
+		std::string src;
+		std::string filename;
+		std::string path = "";
+		std::string dpath;
+
+		Bitu c, h, s, sectors; 
+		Bit64u size = 0;
+
+		if(cmd->FindExist("-?")) {
+			printHelp();
+			return;
+		}
+
+		// temp_line is the filename
+		if (!(cmd->FindCommand(1, temp_line))) {
+			printHelp();
+			return;
+		}
+/*
+		this stuff is too frustrating
+
+		// when only a filename is passed try to create the file on the current DOS path
+		// if directory+filename are passed first see if directory is a host path, if not
+		// maybe it is a DOSBox path.
+		
+		// split filename and path
+		Bitu spos = temp_line.rfind('\\');
+		if(spos==std::string::npos) {
+			temp_line.rfind('/');
+		}
+
+		if(spos==std::string::npos) {
+			// no path separator
+			filename=temp_line;
+		} else {
+			path=temp_line.substr(0,spos);
+			filename=temp_line.substr(spos+1,std::string::npos);
+		}
+		if(filename=="") 
+
+		char tbuffer[DOS_PATHLENGTH]= { 0 };
+		if(path=="") {
+			if(!DOS_GetCurrentDir(DOS_GetDefaultDrive()+1,tbuffer)){
+				printHelp();
+				return;
+			}
+			dpath=(std::string)tbuffer;
+		}		
+		WriteOut("path %s, filename %s, dpath %s",
+			path.c_str(),filename.c_str(),dpath.c_str());
+		return;
+*/
+			
+		// don't trash user's files
+		FILE* f = fopen(temp_line.c_str(),"r");
+		if(f) {
+			fclose(f);
+			WriteOut(MSG_Get("PROGRAM_IMGMAKE_FILE_EXISTS"),temp_line.c_str());
+			return;
+		}
+#ifdef WIN32
+		// read from real floppy?
+		if(cmd->FindString("-source",src)) {
+			Bits retries = 10;
+			cmd->FindInt("-retries",retries);
+			if((retries < 1)||(retries > 99))  {
+				printHelp();
+				return;
+			}
+			if((src.length()!=1) || !isalpha(src.c_str()[0])) {
+				// only one letter allowed
+				printHelp();
+				return;
+			}
+			f = fopen(temp_line.c_str(),"wb+");
+			if (!f) {
+				WriteOut(MSG_Get("PROGRAM_IMGMAKE_CANNOT_WRITE"),temp_line.c_str());
+				return;
+			}
+			// maybe delete f if it failed?
+			if(!ReadDisk(f, src.c_str()[0],retries))
+				WriteOut(MSG_Get("PROGRAM_IMGMAKE_CANT_READ_FLOPPY"));
+            fclose(f);
+			return;
+		}
+#endif
+		// disk type
+		if (!(cmd->FindString("-t",disktype))) {
+			printHelp();
+			return;
+		}
+
+		Bit8u mediadesc = 0xF8; // media descriptor byte; also used to differ fd and hd
+		Bitu root_ent = 512; // FAT root directory entries: 512 is for harddisks
+		if(disktype=="fd_160") {
+			c = 40; h = 1; s = 8; mediadesc = 0xFE; root_ent = 56; // root_ent?
+		} else if(disktype=="fd_180") {
+			c = 40; h = 1; s = 9; mediadesc = 0xFC; root_ent = 56; // root_ent?
+		} else if(disktype=="fd_200") {
+			c = 40; h = 1; s = 10; mediadesc = 0xFC; root_ent = 56; // root_ent?
+		} else if(disktype=="fd_320") {
+			c = 40; h = 2; s = 8; mediadesc = 0xFF; root_ent = 112; // root_ent?
+		} else if(disktype=="fd_360") {
+			c = 40; h = 2; s = 9; mediadesc = 0xFD; root_ent = 112;
+		} else if(disktype=="fd_400") {
+			c = 40; h = 2; s = 10; mediadesc = 0xFD; root_ent = 112; // root_ent?
+		} else if(disktype=="fd_720") {
+			c = 80; h = 2; s = 9; mediadesc = 0xF9; root_ent = 112;
+		} else if(disktype=="fd_1200") {
+			c = 80; h = 2; s = 15; mediadesc = 0xF9; root_ent = 224;
+		} else if(disktype=="fd_1440") {
+			c = 80; h = 2; s = 18; mediadesc = 0xF0; root_ent = 224;
+		} else if(disktype=="fd_2880") {
+			c = 80; h = 2; s = 36; mediadesc = 0xF0; root_ent = 512; // root_ent?
+		} else if(disktype=="hd_520") {
+			c = 1023; h = 16; s = 63;
+		} else if(disktype=="hd_2gig") {
+			c = 1023; h = 64; s = 63;
+		//} else if(disktype=="hd_4gig") { // fseek only supports 2gig
+		//	c = 1023; h = 130; s = 63;
+		} else if(disktype=="hd_st251") { // old 40meg drive
+			c = 820; h = 6; s = 17;
+		} else if(disktype=="hd_st225") { // even older 20meg drive
+			c = 615; h = 4; s = 17;
+		} else if(disktype=="hd") { 
+			// get size from parameter
+			std::string isize;
+			if (!(cmd->FindString("-size",isize))) {
+				// maybe -chs?
+				if (!(cmd->FindString("-chs",isize))){
+						// user forgot -size and -chs
+						printHelp();
+						return;
+					}
+				else {
+					// got chs data: -chs 1023,16,63
+					if(sscanf(isize.c_str(),"%u,%u,%u",&c,&h,&s) != 3) {
+						printHelp();
+						return;
+					}
+					// sanity-check chs values
+					if((h>256)||(c>1023)||(s>63)) {
+						printHelp();
+						return;
+					}
+					size = c*h*s*512;
+					if((size < 3*1024*1024) || (size > 0x7FFFFFFF)) {
+						// user picked geometry resulting in wrong size
+						printHelp();
+						return;
+					}
+				}
+			} else {
+				// got -size
+				std::istringstream stream(isize);
+				stream >> size;
+				size *= 1024*1024; // size in megabytes
+				// low limit: 3 megs, high limit: 2 gigs
+				// Int13 limit would be 8 gigs
+				if((size < 3*1024*1024) || (size > 0x7FFFFFFF)) {
+					// wrong size
+					printHelp();
+					return;
+				}
+				sectors = (Bitu)(size / 512);
+
+				// Now that we finally have the proper size, figure out good CHS values
+				h=2;
+				while(h*1023*63 < sectors) h <<= 1;
+				if(h==256) h=130;
+				s=8;
+				while(h*s*1023 < sectors) s *= 2;
+				if(s==64) s=63;
+				c=sectors/(h*s);
+			}
+		} else {
+			// user passed a wrong -t argument
+			printHelp();
+			return;
+		}
+
+		WriteOut(MSG_Get("PROGRAM_IMGMAKE_PRINT_CHS"),c,h,s);
+		WriteOut("%s\r\n",temp_line.c_str());
+		// do it again for fixed chs values
+		size = c*h*s*512;
+		sectors = (Bitu)(size / 512);
+
+		// create the image file
+		f = fopen(temp_line.c_str(),"wb+");
+		if (!f) {
+			WriteOut(MSG_Get("PROGRAM_IMGMAKE_CANNOT_WRITE"),temp_line.c_str());
+			return;
+		}
+		if(fseek(f,(Bitu)size-1,SEEK_SET)) {
+			WriteOut(MSG_Get("PROGRAM_IMGMAKE_NOT_ENOUGH_SPACE"),size);
+			return;
+		}
+		Bit8u bufferbyte=0;
+		if(fwrite(&bufferbyte,1,1,f)!=1) {
+			WriteOut(MSG_Get("PROGRAM_IMGMAKE_NOT_ENOUGH_SPACE"),size);
+			return;
+		}
+		
+		// Format the image if not unrequested
+		Bitu bootsect_pos = 0; // offset of the boot sector in clusters
+		if(!cmd->FindExist("-nofs")) {
+			Bit8u sbuf[512];
+			if(mediadesc == 0xF8) {
+				// is a harddisk: write MBR
+				memcpy(sbuf,freedos_mbr,512);
+				// active partition
+				sbuf[0x1be]=0x80;
+				// start head - head 0 has the partition table, head 1 first partition
+				sbuf[0x1bf]=1;
+				// start sector with bits 8-9 of start cylinder in bits 6-7
+				sbuf[0x1c0]=1;
+				// start cylinder bits 0-7
+				sbuf[0x1c1]=0;
+				// OS indicator: DOS what else ;)
+				sbuf[0x1c2]=0x06;
+				// end head (0-based)
+				sbuf[0x1c3]= h-1;
+				// end sector with bits 8-9 of end cylinder in bits 6-7
+				sbuf[0x1c4]=s|((c&0x300)>>2);
+				// start cylinder bits 0-7
+				sbuf[0x1c5]=c&0xFF;
+				// sectors preceding partition1 (one head)
+				host_writed(&sbuf[0x1c6],s);
+				// length of partition1
+				host_writed(&sbuf[0x1ca],sectors-s);
+				
+				// write partition table
+				fseek(f,0,SEEK_SET);
+				fwrite(&sbuf,512,1,f);
+				bootsect_pos = s;
+			}
+
+			// set boot sector values
+			memset(sbuf,0,512);
+			// TODO boot code jump
+			sbuf[0]=0xEB; sbuf[1]=0x3c; sbuf[2]=0x90;
+			// OEM
+			sprintf((char*)&sbuf[0x03],"MSDOS5.0");
+			// bytes per sector: always 512
+			host_writew(&sbuf[0x0b],512);
+			// sectors per cluster: 1,2,4,8,16,...
+			if(mediadesc == 0xF8) {
+				Bitu cval = 1;
+				while((sectors/cval) >= 65525) cval <<= 1;
+				sbuf[0x0d]=cval;
+			} else sbuf[0x0d]=sectors/0x1000 + 1; // FAT12 can hold 0x1000 entries TODO
+			// TODO small floppys have 2 sectors per cluster?
+			// reserverd sectors: 1 ( the boot sector)
+			host_writew(&sbuf[0x0e],1);
+			// Number of FATs - always 2
+			sbuf[0x10] = 2;
+			// Root entries - how are these made up? - TODO
+			host_writew(&sbuf[0x11],root_ent);
+			// sectors (under 32MB) - will OSes be sore if all HD's use large size?
+			if(mediadesc != 0xF8) host_writew(&sbuf[0x13],c*h*s);
+			// media descriptor
+			sbuf[0x15]=mediadesc;
+			// sectors per FAT
+			// needed entries: (sectors per cluster)
+			Bitu sect_per_fat=0;
+			Bitu clusters = (sectors-1)/sbuf[0x0d]; // TODO subtract root dir too maybe
+			if(mediadesc == 0xF8) sect_per_fat = (clusters*2)/512+1;
+			else sect_per_fat = ((clusters*3)/2)/512+1;
+			host_writew(&sbuf[0x16],sect_per_fat);
+			// sectors per track
+			host_writew(&sbuf[0x18],s);
+			// heads
+			host_writew(&sbuf[0x1a],h);
+			// hidden sectors
+			host_writed(&sbuf[0x1c],bootsect_pos);
+			// sectors (large disk) - this is the same as partition length in MBR
+			if(mediadesc == 0xF8) host_writed(&sbuf[0x20],sectors-s);
+			// BIOS drive
+			if(mediadesc == 0xF8) sbuf[0x24]=0x80;
+			else sbuf[0x24]=0x00;
+			// ext. boot signature
+			sbuf[0x26]=0x29;
+			// volume serial number
+			// let's use the BIOS time (cheap, huh?)
+			host_writed(&sbuf[0x27],mem_readd(BIOS_TIMER));
+			// Volume label
+			sprintf((char*)&sbuf[0x2b],"NO NAME    ");
+			// file system type
+			if(mediadesc == 0xF8) sprintf((char*)&sbuf[0x36],"FAT16   ");
+			else sprintf((char*)&sbuf[0x36],"FAT12   ");
+			// boot sector signature
+			host_writew(&sbuf[0x1fe],0xAA55);
+
+			// write the boot sector
+			fseek(f,bootsect_pos*512,SEEK_SET);
+			fwrite(&sbuf,512,1,f);
+			// write FATs
+			memset(sbuf,0,512);
+			if(mediadesc == 0xF8) host_writed(&sbuf[0],0xFFFFFFF8);
+			else host_writed(&sbuf[0],0xFFFFF0);
+			// 1st FAT
+			fseek(f,(bootsect_pos+1)*512,SEEK_SET);
+			fwrite(&sbuf,512,1,f);
+			// 2nd FAT
+			fseek(f,(bootsect_pos+1+sect_per_fat)*512,SEEK_SET);
+			fwrite(&sbuf,512,1,f);
+		}
+		fclose(f);
+		// create the batch file
+		if(cmd->FindExist("-bat")) {
+			std::string t2;
+			if(temp_line.length() > 3) {
+				t2 = temp_line.substr(0,temp_line.length()-4);
+				t2 = t2.append(".bat");
+			} else {
+				t2 = temp_line.append(".bat");
+			}
+			WriteOut("%s\n",t2.c_str());
+			f = fopen(t2.c_str(),"wb+");
+			if (!f) {
+				WriteOut(MSG_Get("PROGRAM_IMGMAKE_CANNOT_WRITE"),t2.c_str());
+				return;
+			}
+			fprintf(f,"imgmount c %s -size 512,%u,%u,%u\r\n",temp_line.c_str(),s,h,c);
+			fclose(f);
+		}
+		return;
+	}
+	void printHelp() { // maybe hint parameter?
+		WriteOut(MSG_Get("PROGRAM_IMGMOUNT_SYNTAX"));
+	}
+};
+
+static void IMGMAKE_ProgramStart(Program * * make) {
+	*make=new IMGMAKE;
+}
 
 // LOADFIX
 
@@ -1005,8 +1576,16 @@
 			return;
 		}
 
-
 		std::string type="hdd";
+		// default to floppy for drive letters A and B and numbers 0 and 1
+		if (!cmd->FindCommand(1,temp_line) || (temp_line.size() > 2) ||
+			((temp_line.size()>1) && (temp_line[1]!=':'))) {
+			// drive not valid
+		} else {
+			Bit8u tdr = toupper(temp_line[0]);
+			if(tdr=='A'||tdr=='B'||tdr=='0'||tdr=='1') type="floppy";
+		}
+
 		std::string fstype="fat";
 		cmd->FindString("-t",type,true);
 		cmd->FindString("-fs",fstype,true);
@@ -1127,6 +1706,7 @@
 
 			if(fstype=="fat") {
 				if (imgsizedetect) {
+					bool yet_detected = false;
 					FILE * diskfile = fopen(temp_line.c_str(), "rb+");
 					if(!diskfile) {
 						WriteOut(MSG_Get("PROGRAM_IMGMOUNT_INVALID_IMAGE"));
@@ -1142,17 +1722,65 @@
 						return;
 					}
 					fclose(diskfile);
+					// check MBR signature
 					if ((buf[510]!=0x55) || (buf[511]!=0xaa)) {
 						WriteOut(MSG_Get("PROGRAM_IMGMOUNT_INVALID_GEOMETRY"));
 						return;
 					}
-					Bitu sectors=(Bitu)(fcsize/(16*63));
-					if (sectors*16*63!=fcsize) {
+					// check MBR partition entry 1
+					Bitu starthead = buf[0x1bf];
+					Bitu startsect = buf[0x1c0]&0x3f-1;
+					Bitu startcyl = buf[0x1c1]|((buf[0x1c0]&0xc0)<<2);
+					Bitu endcyl = buf[0x1c5]|((buf[0x1c4]&0xc0)<<2);
+					
+					Bitu heads = buf[0x1c3]+1;
+					Bitu sectors = buf[0x1c4]&0x3f;
+
+					Bitu pe1_size = host_readd(&buf[0x1ca]);
+					if(pe1_size!=0) {
+						Bitu part_start = startsect + sectors*starthead +
+							startcyl*sectors*heads;
+						Bitu part_end = heads*sectors*endcyl;
+						Bits part_len = part_end - part_start;
+						// partition start/end sanity check
+						// partition length should not exceed file length
+						// real partition size can be a few cylinders less than pe1_size
+						// if more than 1023 cylinders see if first partition fits
+						// into 1023, else bail.
+						if((part_len<0)||((Bitu)part_len > pe1_size)||(pe1_size > fcsize)||
+							((pe1_size-part_len)/(sectors*heads)>2)||
+							((pe1_size/(heads*sectors))>1023)) {
+							//LOG_MSG("start(c,h,s) %u,%u,%u",startcyl,starthead,startsect);
+							//LOG_MSG("endcyl %u heads %u sectors %u",endcyl,heads,sectors);
+							//LOG_MSG("psize %u start %u end %u",pe1_size,part_start,part_end);
+						} else {
+							sizes[0]=512; sizes[1]=sectors;
+							sizes[2]=heads; sizes[3]=(Bit16u)(fcsize/(heads*sectors));
+							if(sizes[3]>1023) sizes[3]=1023;
+							yet_detected = true;
+						}
+					}
+					if(!yet_detected) {
+						// Try bximage disk geometry
+						Bitu cylinders=(Bitu)(fcsize/(16*63));
+						// Int13 only supports up to 1023 cylinders
+						// For mounting unknown images we could go up with the heads to 255
+						if ((cylinders*16*63==fcsize)&&(cylinders<1024)) {
+							yet_detected=true;
+							sizes[0]=512; sizes[1]=63; sizes[2]=16; sizes[3]=cylinders;
+						}
+					}
+
+					if(yet_detected)
+						WriteOut(MSG_Get("PROGRAM_IMGMOUNT_AUTODET_VALUES"),sizes[0],sizes[1],sizes[2],sizes[3]);
+						
+						
+						//"Image geometry auto detection: -size %u,%u,%u,%u\r\n",
+							//sizes[0],sizes[1],sizes[2],sizes[3]);
+					else {
 						WriteOut(MSG_Get("PROGRAM_IMGMOUNT_INVALID_GEOMETRY"));
 						return;
 					}
-					sizes[0]=512;	sizes[1]=63;	sizes[2]=16;	sizes[3]=sectors;
-					LOG_MSG("autosized image file: %d:%d:%d:%d",sizes[0],sizes[1],sizes[2],sizes[3]);
 				}
 
 				newdrive=new fatDrive(temp_line.c_str(),sizes[0],sizes[1],sizes[2],sizes[3],0);
@@ -1503,6 +2131,7 @@
 		"Check that the path is correct and the image is accessible.\n");
 	MSG_Add("PROGRAM_IMGMOUNT_INVALID_GEOMETRY","Could not extract drive geometry from image.\n"
 		"Use parameter -size bps,spc,hpc,cyl to specify the geometry.\n");
+	MSG_Add("PROGRAM_IMGMOUNT_AUTODET_VALUES","Image geometry auto detection: -size %u,%u,%u,%u\n");
 	MSG_Add("PROGRAM_IMGMOUNT_TYPE_UNSUPPORTED","Type \"%s\" is unsupported. Specify \"hdd\" or \"floppy\" or\"iso\".\n");
 	MSG_Add("PROGRAM_IMGMOUNT_FORMAT_UNSUPPORTED","Format \"%s\" is unsupported. Specify \"fat\" or \"iso\" or \"none\".\n");
 	MSG_Add("PROGRAM_IMGMOUNT_SPECIFY_FILE","Must specify file-image to mount.\n");
@@ -1513,6 +2142,47 @@
 	MSG_Add("PROGRAM_IMGMOUNT_MOUNT_NUMBER","Drive number %d mounted as %s\n");
 	MSG_Add("PROGRAM_IMGMOUNT_NON_LOCAL_DRIVE", "The image must be on a host or local drive.\n");
 	MSG_Add("PROGRAM_IMGMOUNT_MULTIPLE_NON_CUEISO_FILES", "Using multiple files is only supported for cue/iso images.\n");
+		
+	MSG_Add("PROGRAM_IMGMOUNT_SYNTAX",
+		"Creates floppy or harddisk images.\n"
+		"Syntax: IMGMAKE file [-t type] [[-size size] | [-chs geometry]] [-nofs]\n"
+		"  [-source source] [-r retries]\n"
+		"  file: The image file that is to be created - !path on the host!\n"
+		"  -type: Type of image.\n"
+		"    Floppy templates (names resolve to floppy sizes in kilobytes):\n"
+		"     fd_160 fd_180 fd_200 fd_320 fd_360 fd_400 fd_720 fd_1200 fd_1440 fd_2880\n"
+		"    Harddisk templates:\n"
+		"     hd_520: 520MB image, hd_2gig: 2GB image (maximum size)\n"
+		"     hd_st251: 40MB image, hd_st251: 20MB image (geometry from old drives)\n"
+		"    Custom harddisk images:\n"
+		"     hd (requires -size or -chs)\n"
+		"  size: size of a custom harddisk image in MB.\n"
+		"  geometry: disk geometry in cylinders(1-1023),heads(1-255),sectors(1-63).\n"
+		"  -nofs: add this parameter if a blank image should be created.\n"
+		"  -bat: creates a .bat file with the IMGMOUNT command required for this image.\n"
+#ifdef WIN32
+		"  source: drive letter - if specified the image is read from a floppy disk.\n"
+		"  retries: how often to retry when attempting to read a bad floppy disk(1-99).\n"
+#endif
+		" Examples:\n"
+		"    imgmake c:\\image.img -t fd_1440          - create a 1.44MB floppy image\n"
+		"    imgmake c:\\image.img -t hd -size 100     - create a 100MB hdd image\n"
+		"    imgmake c:\\image.img -t hd -chs 130,2,17 - create a special hd image"
+#ifdef WIN32
+		"    \nimgmake c:\\image.img -source a           - read image from physical drive A"
+#endif
+		);
+#ifdef WIN32
+	MSG_Add("PROGRAM_IMGMAKE_FLREAD",
+		"Disk geometry: %d Cylinders, %d Heads, %d Sectors, %d Kilobytes\n\n");
+	MSG_Add("PROGRAM_IMGMAKE_FLREAD2",
+		"\xdb =good, \xb1 =good after retries, ! =CRC error, x =sector not found, ? =unknown\n\n");
+#endif
+	MSG_Add("PROGRAM_IMGMAKE_FILE_EXISTS","The file \"%s\" already exists.\n");
+	MSG_Add("PROGRAM_IMGMAKE_CANNOT_WRITE","The file \"%s\" cannot be opened for writing.\n");
+	MSG_Add("PROGRAM_IMGMAKE_NOT_ENOUGH_SPACE","Not enough space availible for the image file. Need %u bytes.\n");
+	MSG_Add("PROGRAM_IMGMAKE_PRINT_CHS","Creating an image file with %u cylinders, %u heads and %u sectors\n");
+	MSG_Add("PROGRAM_IMGMAKE_CANT_READ_FLOPPY","\n\nUnable to read floppy.");
 
 	MSG_Add("PROGRAM_KEYB_INFO","Codepage %i has been loaded\n");
 	MSG_Add("PROGRAM_KEYB_INFO_LAYOUT","Codepage %i has been loaded for layout %s\n");
@@ -1536,9 +2206,10 @@
 	PROGRAMS_MakeFile("RESCAN.COM",RESCAN_ProgramStart);
 	PROGRAMS_MakeFile("INTRO.COM",INTRO_ProgramStart);
 	PROGRAMS_MakeFile("BOOT.COM",BOOT_ProgramStart);
-#if C_DEBUG
+//#if C_DEBUG
 	PROGRAMS_MakeFile("LDGFXROM.COM", LDGFXROM_ProgramStart);
-#endif
+//#endif
+	PROGRAMS_MakeFile("IMGMAKE.COM", IMGMAKE_ProgramStart);
 	PROGRAMS_MakeFile("IMGMOUNT.COM", IMGMOUNT_ProgramStart);
 	PROGRAMS_MakeFile("KEYB.COM", KEYB_ProgramStart);
 }
diff -urN dosbox-0.73/src/dos/drive_cache.cpp dosboxcvs/src/dos/drive_cache.cpp
--- dosbox-0.73/src/dos/drive_cache.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/dos/drive_cache.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -72,7 +72,7 @@
 	updatelabel = true;
 }
 
-DOS_Drive_Cache::DOS_Drive_Cache(const char* path) {
+DOS_Drive_Cache::DOS_Drive_Cache(const char* path, DOS_Drive *drive) {
 	dirBase			= new CFileInfo;
 	save_dir		= 0;
 	srchNr			= 0;
@@ -80,7 +80,7 @@
 	nextFreeFindFirst	= 0;
 	for (Bit32u i=0; i<MAX_OPENDIRS; i++) { dirSearch[i] = 0; free[i] = true; dirFindFirst[i] = 0; };
 	SetDirSort(DIRALPHABETICAL);
-	SetBaseDir(path);
+	SetBaseDir(path,drive);
 	updatelabel = true;
 }
 
@@ -102,7 +102,7 @@
 	save_dir	= 0;
 	srchNr		= 0;
 	for (Bit32u i=0; i<MAX_OPENDIRS; i++) free[i] = true; 
-	SetBaseDir(basePath);
+	SetBaseDir(basePath,drive);
 }
 
 void DOS_Drive_Cache::SetLabel(const char* vname,bool cdrom,bool allowupdate) {
@@ -122,9 +122,10 @@
 	return 0;
 }
 
-void DOS_Drive_Cache::SetBaseDir(const char* baseDir) {
+void DOS_Drive_Cache::SetBaseDir(const char* baseDir, DOS_Drive *drive) {
 	Bit16u id;
 	strcpy(basePath,baseDir);
+	this->drive = drive;
 	if (OpenDir(baseDir,id)) {
 		char* result = 0;
 		ReadDir(id,result);
@@ -133,11 +134,11 @@
 #if defined (WIN32) || defined (OS2)
 	bool cdrom = false;
 	char labellocal[256]={ 0 };
-	char drive[4] = "C:\\";
-	drive[0] = basePath[0];
+	char drives[4] = "C:\\";
+	drives[0] = basePath[0];
 #if defined (WIN32)
-	if (GetVolumeInformation(drive,labellocal,256,NULL,NULL,NULL,NULL,0)) {
-	UINT test = GetDriveType(drive);
+	if (GetVolumeInformation(drives,labellocal,256,NULL,NULL,NULL,NULL,0)) {
+	UINT test = GetDriveType(drives);
 	if(test == DRIVE_CDROM) cdrom = true;
 #else // OS2
 	//TODO determine wether cdrom or not!
@@ -593,10 +594,10 @@
 	// open dir
 	if (dirSearch[id]) {
 		// open dir
-		dir_information* dirp = open_directory(expandcopy);
+		void* dirp = drive->opendir(expandcopy);
 		if (dirp) { 
 			// Reset it..
-			close_directory(dirp);
+			drive->closedir(dirp);
 			strcpy(dirPath,expandcopy);
 			free[id] = false;
 			return true;
@@ -657,7 +658,7 @@
 
 	if (!IsCachedIn(dirSearch[id])) {
 		// Try to open directory
-		dir_information* dirp = open_directory(dirPath);
+		void* dirp = drive->opendir(dirPath);
 		if (!dirp) {
 			free[id] = true;
 			return false;
@@ -665,15 +666,15 @@
 		// Read complete directory
 		char dir_name[CROSS_LEN];
 		bool is_directory;
-		if (read_directory_first(dirp, dir_name, is_directory)) {
+		if (drive->read_directory_first(dirp, dir_name, is_directory)) {
 			CreateEntry(dirSearch[id], dir_name, is_directory);
-			while (read_directory_next(dirp, dir_name, is_directory)) {
+			while (drive->read_directory_next(dirp, dir_name, is_directory)) {
 				CreateEntry(dirSearch[id], dir_name, is_directory);
 			}
 		}
 
 		// close dir
-		close_directory(dirp);
+		drive->closedir(dirp);
 
 		// Info
 /*		if (!dirp) {
diff -urN dosbox-0.73/src/dos/drive_fat.cpp dosboxcvs/src/dos/drive_fat.cpp
--- dosbox-0.73/src/dos/drive_fat.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/dos/drive_fat.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: drive_fat.cpp,v 1.27 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: drive_fat.cpp,v 1.28 2009/06/19 18:28:10 c2woody Exp $ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -70,7 +70,7 @@
 
 /* IN - char * filename: Name in regular filename format, e.g. bob.txt */
 /* OUT - char * filearray: Name in DOS directory format, eleven char, e.g. bob     txt */
-static void convToDirFile(char *filename, char *filearray) {
+static void convToDirFile(const char *filename, char *filearray) {
 	Bit32u charidx = 0;
 	Bit32u flen,i;
 	flen = (Bit32u)strlen(filename);
@@ -105,6 +105,10 @@
 }
 
 bool fatFile::Read(Bit8u * data, Bit16u *size) {
+	if ((this->flags & 0xf) == OPEN_WRITE) {	// check if file opened in write-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
 	Bit16u sizedec, sizecount;
 	if(seekpos >= filelength) {
 		*size = 0;
@@ -156,6 +160,11 @@
 bool fatFile::Write(Bit8u * data, Bit16u *size) {
 	/* TODO: Check for read-only bit */
 
+	if ((this->flags & 0xf) == OPEN_READ) {	// check if file opened in read-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+
 	direntry tmpentry;
 	Bit16u sizedec, sizecount;
 	sizedec = *size;
@@ -385,7 +394,7 @@
 	}
 }
 
-bool fatDrive::getEntryName(char *fullname, char *entname) {
+bool fatDrive::getEntryName(const char *fullname, char *entname) {
 	char dirtoken[DOS_PATHLENGTH];
 
 	char * findDir;
@@ -453,7 +462,7 @@
 	return true;
 }
 
-bool fatDrive::getDirClustNum(char *dir, Bit32u *clustNum, bool parDir) {
+bool fatDrive::getDirClustNum(const char *dir, Bit32u *clustNum, bool parDir) {
 	Bit32u len = (Bit32u)strlen(dir);
 	char dirtoken[DOS_PATHLENGTH];
 	Bit32u currentClust = 0;
@@ -761,13 +770,13 @@
 
 Bit8u fatDrive::GetMediaByte(void) { return loadedDisk->GetBiosType(); }
 
-bool fatDrive::FileCreate(DOS_File **file, char *name, Bit16u attributes) {
+bool fatDrive::FileCreate(DOS_File **file, const char *name, Bit16u attributes) {
 	direntry fileEntry;
 	Bit32u dirClust, subEntry;
 	char dirName[DOS_NAMELENGTH_ASCII];
 	char pathName[11];
 
-	Bitu save_errorcode=dos.errorcode;
+	Bit16u save_errorcode=dos.errorcode;
 
 	/* Check if file already exists */
 	if(getFileDirEntry(name, &fileEntry, &dirClust, &subEntry)) {
@@ -793,6 +802,7 @@
 	/* Empty file created, now lets open it */
 	/* TODO: check for read-only flag and requested write access */
 	*file = new fatFile(name, fileEntry.loFirstClust, fileEntry.entrysize, this);
+	(*file)->flags=OPEN_READWRITE;
 	((fatFile *)(*file))->dirCluster = dirClust;
 	((fatFile *)(*file))->dirIndex = subEntry;
 	/* Maybe modTime and date should be used ? (crt matches findnext) */
@@ -810,12 +820,13 @@
 	return true;
 }
 
-bool fatDrive::FileOpen(DOS_File **file, char *name, Bit32u /*flags*/) {
+bool fatDrive::FileOpen(DOS_File **file, const char *name, Bit32u flags) {
 	direntry fileEntry;
 	Bit32u dirClust, subEntry;
 	if(!getFileDirEntry(name, &fileEntry, &dirClust, &subEntry)) return false;
 	/* TODO: check for read-only flag and requested write access */
 	*file = new fatFile(name, fileEntry.loFirstClust, fileEntry.entrysize, this);
+	(*file)->flags = flags;
 	((fatFile *)(*file))->dirCluster = dirClust;
 	((fatFile *)(*file))->dirIndex = subEntry;
 	/* Maybe modTime and date should be used ? (crt matches findnext) */
@@ -829,7 +840,7 @@
 	return false;
 }
 
-bool fatDrive::FileUnlink(char * name) {
+bool fatDrive::FileUnlink(const char * name) {
 	direntry fileEntry;
 	Bit32u dirClust, subEntry;
 
@@ -843,7 +854,7 @@
 	return true;
 }
 
-bool fatDrive::FindFirst(char *_dir, DOS_DTA &dta,bool /*fcb_findfirst*/) {
+bool fatDrive::FindFirst(const char *_dir, DOS_DTA &dta,bool /*fcb_findfirst*/) {
 	direntry dummyClust;
 	Bit8u attr;char pattern[DOS_NAMELENGTH_ASCII];
 	dta.GetSearchParams(attr,pattern);
@@ -955,7 +966,7 @@
 	return FindNextInternal(dta.GetDirIDCluster(), dta, &dummyClust);
 }
 
-bool fatDrive::GetFileAttr(char *name, Bit16u *attr) {
+bool fatDrive::GetFileAttr(const char *name, Bit16u *attr) {
 	direntry fileEntry;
 	Bit32u dirClust, subEntry;
 	if(!getFileDirEntry(name, &fileEntry, &dirClust, &subEntry)) {
@@ -1109,7 +1120,7 @@
 	}
 }
 
-bool fatDrive::MakeDir(char *dir) {
+bool fatDrive::MakeDir(const char *dir) {
 	Bit32u dummyClust, dirClust;
 	direntry tmpentry;
 	char dirName[DOS_NAMELENGTH_ASCII];
@@ -1161,7 +1172,7 @@
 	return true;
 }
 
-bool fatDrive::RemoveDir(char *dir) {
+bool fatDrive::RemoveDir(const char *dir) {
 	Bit32u dummyClust, dirClust;
 	direntry tmpentry;
 	char dirName[DOS_NAMELENGTH_ASCII];
@@ -1214,7 +1225,7 @@
 	return true;
 }
 
-bool fatDrive::Rename(char * oldname, char * newname) {
+bool fatDrive::Rename(const char * oldname, const char * newname) {
 	direntry fileEntry1;
 	Bit32u dirClust1, subEntry1;
 	if(!getFileDirEntry(oldname, &fileEntry1, &dirClust1, &subEntry1)) return false;
@@ -1253,7 +1264,7 @@
 	return false;
 }
 
-bool fatDrive::TestDir(char *dir) {
+bool fatDrive::TestDir(const char *dir) {
 	Bit32u dummyClust;
 	return getDirClustNum(dir, &dummyClust, false);
 }
diff -urN dosbox-0.73/src/dos/drive_iso.cpp dosboxcvs/src/dos/drive_iso.cpp
--- dosbox-0.73/src/dos/drive_iso.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/dos/drive_iso.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: drive_iso.cpp,v 1.25 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: drive_iso.cpp,v 1.26 2009/06/19 18:28:10 c2woody Exp $ */
 
 #include <cctype>
 #include <cstring>
@@ -46,8 +46,7 @@
 	Bit16u info;
 };
 
-isoFile::isoFile(isoDrive *drive, const char *name, FileStat_Block *stat, Bit32u offset)
-{
+isoFile::isoFile(isoDrive *drive, const char *name, FileStat_Block *stat, Bit32u offset) {
 	this->drive = drive;
 	time = stat->time;
 	date = stat->date;
@@ -61,8 +60,7 @@
 	SetName(name);
 }
 
-bool isoFile::Read(Bit8u *data, Bit16u *size)
-{
+bool isoFile::Read(Bit8u *data, Bit16u *size) {
 	if (filePos + *size > fileEnd)
 		*size = (Bit16u)(fileEnd - filePos);
 	
@@ -99,13 +97,11 @@
 	return true;
 }
 
-bool isoFile::Write(Bit8u *data, Bit16u *size)
-{
+bool isoFile::Write(Bit8u* /*data*/, Bit16u* /*size*/) {
 	return false;
 }
 
-bool isoFile::Seek(Bit32u *pos, Bit32u type)
-{
+bool isoFile::Seek(Bit32u *pos, Bit32u type) {
 	switch (type) {
 		case DOS_SEEK_SET:
 			filePos = fileBegin + *pos;
@@ -126,14 +122,12 @@
 	return true;
 }
 
-bool isoFile::Close()
-{
+bool isoFile::Close() {
 	if (refCtr == 1) open = false;
 	return true;
 }
 
-Bit16u isoFile::GetInformation(void)
-{
+Bit16u isoFile::GetInformation(void) {
 	return 0x40;		// read-only drive
 }
 
@@ -143,8 +137,7 @@
 bool MSCDEX_HasDrive(char driveLetter);
 bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name);
 
-isoDrive::isoDrive(char driveLetter, const char *fileName, Bit8u mediaid, int &error)
-{
+isoDrive::isoDrive(char driveLetter, const char *fileName, Bit8u mediaid, int &error) {
 	nextFreeDirIterator = 0;
 	memset(dirIterators, 0, sizeof(dirIterators));
 	memset(sectorHashEntries, 0, sizeof(sectorHashEntries));
@@ -199,9 +192,8 @@
 	UpdateMscdex(driveLetter, fileName, subUnit);
 }
 
-bool isoDrive::FileOpen(DOS_File **file, char *name, Bit32u flags)
-{
-	if (flags == OPEN_WRITE) {
+bool isoDrive::FileOpen(DOS_File **file, const char *name, Bit32u flags) {
+	if ((flags & 0x0f) == OPEN_WRITE) {
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
@@ -221,38 +213,32 @@
 	return success;
 }
 
-bool isoDrive::FileCreate(DOS_File **file, char *name, Bit16u attributes)
-{
+bool isoDrive::FileCreate(DOS_File** /*file*/, const char* /*name*/, Bit16u /*attributes*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool isoDrive::FileUnlink(char *name)
-{
+bool isoDrive::FileUnlink(const char* /*name*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool isoDrive::RemoveDir(char *dir)
-{
+bool isoDrive::RemoveDir(const char* /*dir*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool isoDrive::MakeDir(char *dir)
-{
+bool isoDrive::MakeDir(const char* /*dir*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool isoDrive::TestDir(char *dir)
-{
+bool isoDrive::TestDir(const char *dir) {
 	isoDirEntry de;	
 	return (lookup(&de, dir) && IS_DIR(de.fileFlags));
 }
 
-bool isoDrive::FindFirst(char *dir, DOS_DTA &dta, bool fcb_findfirst)
-{
+bool isoDrive::FindFirst(const char *dir, DOS_DTA &dta, bool fcb_findfirst) {
 	isoDirEntry de;
 	if (!lookup(&de, dir)) {
 		DOS_SetError(DOSERR_PATH_NOT_FOUND);
@@ -285,8 +271,7 @@
 	return FindNext(dta);
 }
 
-bool isoDrive::FindNext(DOS_DTA &dta)
-{
+bool isoDrive::FindNext(DOS_DTA &dta) {
 	Bit8u attr;
 	char pattern[DOS_NAMELENGTH_ASCII];
 	dta.GetSearchParams(attr, pattern);
@@ -324,14 +309,12 @@
 	return false;
 }
 
-bool isoDrive::Rename(char *oldname, char *newname)
-{
+bool isoDrive::Rename(const char* /*oldname*/, const char* /*newname*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool isoDrive::GetFileAttr(char *name, Bit16u *attr)
-{
+bool isoDrive::GetFileAttr(const char *name, Bit16u *attr) {
 	*attr = 0;
 	isoDirEntry de;
 	bool success = lookup(&de, name);
@@ -343,8 +326,7 @@
 	return success;
 }
 
-bool isoDrive::AllocationInfo(Bit16u *bytes_sector, Bit8u *sectors_cluster, Bit16u *total_clusters, Bit16u *free_clusters)
-{
+bool isoDrive::AllocationInfo(Bit16u *bytes_sector, Bit8u *sectors_cluster, Bit16u *total_clusters, Bit16u *free_clusters) {
 	*bytes_sector = 2048;
 	*sectors_cluster = 1; // cluster size for cdroms ?
 	*total_clusters = 60000;
@@ -352,14 +334,12 @@
 	return true;
 }
 
-bool isoDrive::FileExists(const char *name)
-{
+bool isoDrive::FileExists(const char *name) {
 	isoDirEntry de;
 	return (lookup(&de, name) && !IS_DIR(de.fileFlags));
 }
 
-bool isoDrive::FileStat(const char *name, FileStat_Block *const stat_block)
-{
+bool isoDrive::FileStat(const char *name, FileStat_Block *const stat_block) {
 	isoDirEntry de;
 	bool success = lookup(&de, name);
 	
@@ -374,18 +354,15 @@
 	return success;
 }
 
-Bit8u isoDrive::GetMediaByte(void)
-{
+Bit8u isoDrive::GetMediaByte(void) {
 	return mediaid;
 }
 
-bool isoDrive::isRemote(void)
-{
+bool isoDrive::isRemote(void) {
 	return true;
 }
 
-bool isoDrive::isRemovable(void)
-{
+bool isoDrive::isRemovable(void) {
 	return true;
 }
 
@@ -397,8 +374,7 @@
 	return 2;
 }
 
-int isoDrive::GetDirIterator(const isoDirEntry* de)
-{
+int isoDrive::GetDirIterator(const isoDirEntry* de) {
 	int dirIterator = nextFreeDirIterator;
 	
 	// get start and end sector of the directory entry (pad end sector if necessary)
@@ -418,8 +394,7 @@
 	return dirIterator;
 }
 
-bool isoDrive::GetNextDirEntry(const int dirIteratorHandle, isoDirEntry* de)
-{
+bool isoDrive::GetNextDirEntry(const int dirIteratorHandle, isoDirEntry* de) {
 	bool result = false;
 	Bit8u* buffer = NULL;
 	DirIterator& dirIterator = dirIterators[dirIteratorHandle];
@@ -450,8 +425,7 @@
 	return result;
 }
 
-void isoDrive::FreeDirIterator(const int dirIterator)
-{
+void isoDrive::FreeDirIterator(const int dirIterator) {
 	dirIterators[dirIterator].valid = false;
 	
 	// if this was the last aquired iterator decrement nextFreeIterator
@@ -460,8 +434,7 @@
 	}
 }
 
-bool isoDrive::ReadCachedSector(Bit8u** buffer, const Bit32u sector)
-{
+bool isoDrive::ReadCachedSector(Bit8u** buffer, const Bit32u sector) {
 	// get hash table entry
 	int pos = sector % ISO_MAX_HASH_TABLE_SIZE;
 	SectorHashEntry& he = sectorHashEntries[pos];
@@ -479,13 +452,11 @@
 	return true;
 }
 
-inline bool isoDrive :: readSector(Bit8u *buffer, Bit32u sector)
-{
+inline bool isoDrive :: readSector(Bit8u *buffer, Bit32u sector) {
 	return CDROM_Interface_Image::images[subUnit]->ReadSector(buffer, false, sector);
 }
 
-int isoDrive :: readDirEntry(isoDirEntry *de, Bit8u *data)
-{	
+int isoDrive :: readDirEntry(isoDirEntry *de, Bit8u *data) {	
 	// copy data into isoDirEntry struct, data[0] = length of DirEntry
 //	if (data[0] > sizeof(isoDirEntry)) return -1;//check disabled as isoDirentry is currently 258 bytes large. So it always fits
 	memcpy(de, data, data[0]);//Perharps care about a zero at the end.
@@ -525,8 +496,7 @@
 	return de->length;
 }
 
-bool isoDrive :: loadImage()
-{
+bool isoDrive :: loadImage() {
 	isoPVD pvd;
 	dataCD = false;
 	readSector((Bit8u*)(&pvd), ISO_FIRST_VD);
@@ -538,8 +508,7 @@
 	return false;
 }
 
-bool isoDrive :: lookup(isoDirEntry *de, const char *path)
-{
+bool isoDrive :: lookup(isoDirEntry *de, const char *path) {
 	if (!dataCD) return false;
 	*de = this->rootEntry;
 	if (!strcmp(path, "")) return true;
diff -urN dosbox-0.73/src/dos/drive_local.cpp dosboxcvs/src/dos/drive_local.cpp
--- dosbox-0.73/src/dos/drive_local.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/dos/drive_local.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: drive_local.cpp,v 1.79 2009/04/26 18:24:36 qbix79 Exp $ */
+/* $Id: drive_local.cpp,v 1.81 2009/06/18 18:17:54 c2woody Exp $ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -48,7 +48,7 @@
 };
 
 
-bool localDrive::FileCreate(DOS_File * * file,char * name,Bit16u attributes) {
+bool localDrive::FileCreate(DOS_File * * file,const char * name,Bit16u /*attributes*/) {
 //TODO Maybe care for attributes but not likely
 	char newname[CROSS_LEN];
 	strcpy(newname,basedir);
@@ -71,25 +71,30 @@
 		return false;
 	}
    
-	if(!existing_file) dirCache.AddEntry(newname, true);
+	if(!existing_file) {
+		strcpy(newname,basedir);
+		strcat(newname,name);
+		CROSS_FILENAME(newname);
+		dirCache.AddEntry(newname, true);
+	}
+
 	/* Make the 16 bit device information */
 	*file=new localFile(name,hand);
+	(*file)->flags=OPEN_READWRITE;
 
 	return true;
 }
 
-bool localDrive::FileOpen(DOS_File * * file,char * name,Bit32u flags) {
+bool localDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 	const char* type;
-	switch (flags &3) {
+	switch (flags&0xf) {
 	case OPEN_READ:type="rb"; break;
-	case OPEN_WRITE:type="rb+"; break;
+	case OPEN_WRITE:type="wb"; break;
 	case OPEN_READWRITE:type="rb+"; break;
 	default:
-//TODO FIX IT
-		type="rb+";
-//		return false;
-
-	};
+		DOS_SetError(DOSERR_ACCESS_CODE_INVALID);
+		return false;
+	}
 	char newname[CROSS_LEN];
 	strcpy(newname,basedir);
 	strcat(newname,name);
@@ -99,7 +104,7 @@
 	FILE * hand=fopen(newname,type);
 //	Bit32u err=errno;
 	if (!hand) { 
-		if((flags&3) != OPEN_READ) {
+		if((flags&0xf) != OPEN_READ) {
 			FILE * hmm=fopen(newname,"rb");
 			if (hmm) {
 				fclose(hmm);
@@ -135,8 +140,7 @@
 	return true;
 }
 
-bool localDrive::FileUnlink(char * name) {
-
+bool localDrive::FileUnlink(const char * name) {
 	char newname[CROSS_LEN];
 	strcpy(newname,basedir);
 	strcat(newname,name);
@@ -175,11 +179,9 @@
 		dirCache.DeleteEntry(newname);
 		return true;
 	}
-	return false;
 }
 
-bool localDrive::FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
-
+bool localDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
 	char tempDir[CROSS_LEN];
 	strcpy(tempDir,basedir);
 	strcat(tempDir,_dir);
@@ -193,8 +195,7 @@
 	if (tempDir[strlen(tempDir)-1]!=CROSS_FILESPLIT) strcat(tempDir,end);
 	
 	Bitu id;
-	if (!dirCache.FindFirst(tempDir,id))
-	{
+	if (!dirCache.FindFirst(tempDir,id)) {
 		DOS_SetError(DOSERR_PATH_NOT_FOUND);
 		return false;
 	}
@@ -279,8 +280,8 @@
 	find_size=(Bit32u) stat_block.st_size;
 	struct tm *time;
 	if((time=localtime(&stat_block.st_mtime))!=0){
-		find_date=DOS_PackDate(time->tm_year+1900,time->tm_mon+1,time->tm_mday);
-		find_time=DOS_PackTime(time->tm_hour,time->tm_min,time->tm_sec);
+		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 	} else {
 		find_time=6; 
 		find_date=4;
@@ -289,7 +290,7 @@
 	return true;
 }
 
-bool localDrive::GetFileAttr(char * name,Bit16u * attr) {
+bool localDrive::GetFileAttr(const char * name,Bit16u * attr) {
 	char newname[CROSS_LEN];
 	strcpy(newname,basedir);
 	strcat(newname,name);
@@ -306,7 +307,7 @@
 	return false; 
 }
 
-bool localDrive::MakeDir(char * dir) {
+bool localDrive::MakeDir(const char * dir) {
 	char newdir[CROSS_LEN];
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
@@ -321,7 +322,7 @@
 	return (temp==0);// || ((temp!=0) && (errno==EEXIST));
 }
 
-bool localDrive::RemoveDir(char * dir) {
+bool localDrive::RemoveDir(const char * dir) {
 	char newdir[CROSS_LEN];
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
@@ -331,7 +332,7 @@
 	return (temp==0);
 }
 
-bool localDrive::TestDir(char * dir) {
+bool localDrive::TestDir(const char * dir) {
 	char newdir[CROSS_LEN];
 	strcpy(newdir,basedir);
 	strcat(newdir,dir);
@@ -349,7 +350,7 @@
 	return (temp==0);
 }
 
-bool localDrive::Rename(char * oldname,char * newname) {
+bool localDrive::Rename(const char * oldname,const char * newname) {
 	char newold[CROSS_LEN];
 	strcpy(newold,basedir);
 	strcat(newold,oldname);
@@ -399,8 +400,8 @@
 	/* Convert the stat to a FileStat */
 	struct tm *time;
 	if((time=localtime(&temp_stat.st_mtime))!=0) {
-		stat_block->time=DOS_PackTime(time->tm_hour,time->tm_min,time->tm_sec);
-		stat_block->date=DOS_PackDate(time->tm_year+1900,time->tm_mon+1,time->tm_mday);
+		stat_block->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
+		stat_block->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 	} else {
 
 	}
@@ -426,6 +427,23 @@
 	return 0; 
 }
 
+/* helper functions for drive cache */
+void *localDrive::opendir(const char *name) {
+	return open_directory(name);
+}
+
+void localDrive::closedir(void *handle) {
+	close_directory((dir_information*)handle);
+}
+
+bool localDrive::read_directory_first(void *handle, char* entry_name, bool& is_directory) {
+	return ::read_directory_first((dir_information*)handle, entry_name, is_directory);
+}
+
+bool localDrive::read_directory_next(void *handle, char* entry_name, bool& is_directory) {
+	return ::read_directory_next((dir_information*)handle, entry_name, is_directory);
+}
+
 localDrive::localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid) {
 	strcpy(basedir,startdir);
 	sprintf(info,"local directory %s",startdir);
@@ -435,12 +453,16 @@
 	allocation.free_clusters=_free_clusters;
 	allocation.mediaid=_mediaid;
 
-	dirCache.SetBaseDir(basedir);
+	dirCache.SetBaseDir(basedir,this);
 }
 
 
 //TODO Maybe use fflush, but that seemed to fuck up in visual c
 bool localFile::Read(Bit8u * data,Bit16u * size) {
+	if ((this->flags & 0xf) == OPEN_WRITE) {	// check if file opened in write-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
 	if (last_action==WRITE) fseek(fhandle,ftell(fhandle),SEEK_SET);
 	last_action=READ;
 	*size=(Bit16u)fread(data,1,*size,fhandle);
@@ -453,6 +475,10 @@
 }
 
 bool localFile::Write(Bit8u * data,Bit16u * size) {
+	if ((this->flags & 0xf) == OPEN_READ) {	// check if file opened in read-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
 	if (last_action==READ) fseek(fhandle,ftell(fhandle),SEEK_SET);
 	last_action=WRITE;
 	if(*size==0){  
@@ -509,20 +535,13 @@
 
 localFile::localFile(const char* _name, FILE * handle) {
 	fhandle=handle;
-	struct stat temp_stat;
-	fstat(fileno(handle),&temp_stat);
-	struct tm * ltime;
-	if((ltime=localtime(&temp_stat.st_mtime))!=0) {
-		time=DOS_PackTime(ltime->tm_hour,ltime->tm_min,ltime->tm_sec);
-		date=DOS_PackDate(ltime->tm_year+1900,ltime->tm_mon+1,ltime->tm_mday);
-	} else {
-		time=1;date=1;
-	}
+	open=true;
+	UpdateDateTimeFromHost();
+
 	attr=DOS_ATTR_ARCHIVE;
 	last_action=NONE;
 	read_only_medium=false;
 
-	open=true;
 	name=0;
 	SetName(_name);
 }
@@ -537,8 +556,8 @@
 	fstat(fileno(fhandle),&temp_stat);
 	struct tm * ltime;
 	if((ltime=localtime(&temp_stat.st_mtime))!=0) {
-		time=DOS_PackTime(ltime->tm_hour,ltime->tm_min,ltime->tm_sec);
-		date=DOS_PackDate(ltime->tm_year+1900,ltime->tm_mon+1,ltime->tm_mday);
+		time=DOS_PackTime((Bit16u)ltime->tm_hour,(Bit16u)ltime->tm_min,(Bit16u)ltime->tm_sec);
+		date=DOS_PackDate((Bit16u)(ltime->tm_year+1900),(Bit16u)(ltime->tm_mon+1),(Bit16u)ltime->tm_mday);
 	} else {
 		time=1;date=1;
 	}
@@ -568,10 +587,10 @@
 	if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
 }
 
-bool cdromDrive::FileOpen(DOS_File * * file,char * name,Bit32u flags) {
-	if ((flags&3)==OPEN_READWRITE) {
+bool cdromDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
+	if ((flags&0xf)==OPEN_READWRITE) {
 		flags &= ~OPEN_READWRITE;
-	} else if ((flags&3)==OPEN_WRITE) {
+	} else if ((flags&0xf)==OPEN_WRITE) {
 		DOS_SetError(DOSERR_ACCESS_DENIED);
 		return false;
 	}
@@ -580,38 +599,38 @@
 	return retcode;
 }
 
-bool cdromDrive::FileCreate(DOS_File * * file,char * name,Bit16u attributes) {
+bool cdromDrive::FileCreate(DOS_File * * /*file*/,const char * /*name*/,Bit16u /*attributes*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool cdromDrive::FileUnlink(char * name) {
+bool cdromDrive::FileUnlink(const char * /*name*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool cdromDrive::RemoveDir(char * dir) {
+bool cdromDrive::RemoveDir(const char * /*dir*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool cdromDrive::MakeDir(char * dir) {
+bool cdromDrive::MakeDir(const char * /*dir*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool cdromDrive::Rename(char * oldname,char * newname) {
+bool cdromDrive::Rename(const char * /*oldname*/,const char * /*newname*/) {
 	DOS_SetError(DOSERR_ACCESS_DENIED);
 	return false;
 }
 
-bool cdromDrive::GetFileAttr(char * name,Bit16u * attr) {
+bool cdromDrive::GetFileAttr(const char * name,Bit16u * attr) {
 	bool result = localDrive::GetFileAttr(name,attr);
 	if (result) *attr |= DOS_ATTR_READ_ONLY;
 	return result;
 }
 
-bool cdromDrive::FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
+bool cdromDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool /*fcb_findfirst*/) {
 	// If media has changed, reInit drivecache.
 	if (MSCDEX_HasMediaChanged(subUnit)) {
 		dirCache.EmptyCache();
diff -urN dosbox-0.73/src/dos/drive_physfs.cpp dosboxcvs/src/dos/drive_physfs.cpp
--- dosbox-0.73/src/dos/drive_physfs.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/dos/drive_physfs.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -0,0 +1,841 @@
+/*
+ *  Copyright (C) 2002-2005  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* $Id$ */
+
+#include "dosbox.h"
+
+#if C_HAVE_PHYSFS
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <physfs.h>
+#include "dos_inc.h"
+#include "drives.h"
+#include "support.h"
+#include "cross.h"
+
+/* yuck. Hopefully, later physfs versions improve things */
+/* The hackishness level is quite low, but to get perfect, here is my personal wishlist for PHYSFS:
+ - mounting zip files at arbitrary locations (already in CVS, I think)
+ - rename support
+ - a better API for stat() infos
+ - more stdio-like API for seek, open and truncate
+ - perhaps a ramdisk as write dir?
+*/
+PHYSFS_sint64 PHYSFS_fileLength(const char *name) {
+	PHYSFS_file *f = PHYSFS_openRead(name);
+	if (f == NULL) return 0;
+	PHYSFS_sint64 size = PHYSFS_fileLength(f);
+	PHYSFS_close(f);
+	return size;
+}
+
+class physfsFile : public DOS_File {
+public:
+	physfsFile(const char* name, PHYSFS_file * handle,Bit16u devinfo, const char* physname, bool write);
+	bool Read(Bit8u * data,Bit16u * size);
+	bool Write(Bit8u * data,Bit16u * size);
+	bool Seek(Bit32u * pos,Bit32u type);
+	bool prepareRead();
+	bool prepareWrite();
+	bool Close();
+	Bit16u GetInformation(void);
+	bool UpdateDateTimeFromHost(void);   
+private:
+	PHYSFS_file * fhandle;
+	enum { READ,WRITE } last_action;
+	Bit16u info;
+	char pname[CROSS_LEN];
+};
+
+/* Need to strip "/.." components and transform '\\' to '/' for physfs */
+static char *normalize(char * name, const char *basedir) {
+	int last = strlen(name)-1;
+	strreplace(name,'\\','/');
+	while (last >= 0 && name[last] == '/') name[last--] = 0;
+	if (last > 0 && name[last] == '.' && name[last-1] == '/') name[last-1] = 0;
+	if (last > 1 && name[last] == '.' && name[last-1] == '.' && name[last-2] == '/') {
+		name[last-2] = 0;
+		char *slash = strrchr(name,'/');
+		if (slash) *slash = 0;
+	}
+	if (strlen(basedir) > strlen(name)) { strcpy(name,basedir); strreplace(name,'\\','/'); }
+	last = strlen(name)-1;
+	while (last >= 0 && name[last] == '/') name[last--] = 0;
+	if (name[0] == 0) name[0] = '/';
+	//LOG_MSG("File access: %s",name);
+	return name;
+}
+
+bool physfsDrive::FileCreate(DOS_File * * file,const char * name,Bit16u attributes) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+
+	/* Test if file exists, don't add to dirCache then */
+	bool existing_file=PHYSFS_exists(newname);
+	
+	char *slash = strrchr(newname,'/');
+	if (slash && slash != newname) {
+		char file[CROSS_LEN];
+		*slash = 0;
+		if (!PHYSFS_isDirectory(newname)) return false;
+		PHYSFS_mkdir(newname);
+		*slash = '/';
+	}
+
+	PHYSFS_file * hand=PHYSFS_openWrite(newname);
+	if (!hand){
+		LOG_MSG("Warning: file creation failed: %s (%s)",newname,PHYSFS_getLastError());
+		return false;
+	}
+
+	/* Make the 16 bit device information */
+	*file=new physfsFile(name,hand,0x202,newname,true);
+	(*file)->flags=OPEN_READWRITE;
+	if(!existing_file) {
+		strcpy(newname,basedir);
+		strcat(newname,name);
+		CROSS_FILENAME(newname);
+		dirCache.AddEntry(newname, true);
+	}
+	return true;
+}
+
+bool physfsDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+
+	PHYSFS_file * hand;
+	
+	if (!PHYSFS_exists(newname)) return false;
+	if ((flags&0xf) == OPEN_READ) {
+		hand = PHYSFS_openRead(newname);
+	} else {
+
+		/* open for reading, deal with writing later */
+		hand = PHYSFS_openRead(newname);
+	}
+
+	if (!hand) { 
+		if((flags&0xf) != OPEN_READ) {
+			PHYSFS_file *hmm = PHYSFS_openRead(newname);
+			if (hmm) {
+				PHYSFS_close(hmm);
+				LOG_MSG("Warning: file %s exists and failed to open in write mode.\nPlease mount a write directory (see docs).",newname);
+			}
+		}
+		return false;
+	}
+   
+	*file=new physfsFile(name,hand,0x202,newname,false);
+	(*file)->flags=flags;  //for the inheritance flag and maybe check for others.
+	return true;
+}
+
+bool physfsDrive::FileUnlink(const char * name) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+	if (PHYSFS_delete(newname)) {
+		CROSS_FILENAME(newname);
+		dirCache.DeleteEntry(newname);
+		return true;
+	};
+	return false;
+}
+
+
+bool physfsDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
+
+	char tempDir[CROSS_LEN];
+	strcpy(tempDir,basedir);
+	strcat(tempDir,_dir);
+	CROSS_FILENAME(tempDir);
+
+	char end[2]={CROSS_FILESPLIT,0};
+	if (tempDir[strlen(tempDir)-1]!=CROSS_FILESPLIT) strcat(tempDir,end);
+	
+	Bitu id;
+	if (!dirCache.FindFirst(tempDir,id))
+	{
+		DOS_SetError(DOSERR_PATH_NOT_FOUND);
+		return false;
+	}
+	strcpy(srchInfo[id].srch_dir,tempDir);
+	dta.SetDirID(id);
+	
+	Bit8u sAttr;
+	dta.GetSearchParams(sAttr,tempDir);
+
+	if (sAttr == DOS_ATTR_VOLUME) {
+		if ( strcmp(dirCache.GetLabel(), "") == 0 ) {
+			LOG(LOG_DOSMISC,LOG_ERROR)("DRIVELABEL REQUESTED: none present, returned  NOLABEL");
+			dta.SetResult("NO_LABEL",0,0,0,DOS_ATTR_VOLUME);
+			return true;
+		}
+		dta.SetResult(dirCache.GetLabel(),0,0,0,DOS_ATTR_VOLUME);
+		return true;
+	} else if ((sAttr & DOS_ATTR_VOLUME)  && (*_dir == 0) && !fcb_findfirst) { 
+	//should check for a valid leading directory instead of 0
+	//exists==true if the volume label matches the searchmask and the path is valid
+		if ( strcmp(dirCache.GetLabel(), "") == 0 ) {
+			LOG(LOG_DOSMISC,LOG_ERROR)("DRIVELABEL REQUESTED: none present, returned  NOLABEL");
+			dta.SetResult("NO_LABEL",0,0,0,DOS_ATTR_VOLUME);
+			return true;
+		}
+		if (WildFileCmp(dirCache.GetLabel(),tempDir)) {
+			dta.SetResult(dirCache.GetLabel(),0,0,0,DOS_ATTR_VOLUME);
+			return true;
+		}
+	}
+	return FindNext(dta);
+}
+
+bool physfsDrive::FindNext(DOS_DTA & dta) {
+
+	char * dir_ent;
+	char full_name[CROSS_LEN];
+
+	Bit8u srch_attr;char srch_pattern[DOS_NAMELENGTH_ASCII];
+	Bit8u find_attr;
+
+	dta.GetSearchParams(srch_attr,srch_pattern);
+	
+	Bitu id = dta.GetDirID();
+
+again:
+	if (!dirCache.FindNext(id,dir_ent)) {
+		DOS_SetError(DOSERR_NO_MORE_FILES);
+		return false;
+	}
+	if(!WildFileCmp(dir_ent,srch_pattern)) goto again;
+
+	char find_name[DOS_NAMELENGTH_ASCII];Bit16u find_date,find_time;Bit32u find_size;
+	if(strlen(dir_ent)<DOS_NAMELENGTH_ASCII){
+		strcpy(find_name,dir_ent);
+		upcase(find_name);
+	} 
+
+	strcpy(full_name,srchInfo[id].srch_dir);
+	strcat(full_name,dir_ent);
+	dirCache.ExpandName(full_name);
+	normalize(full_name,basedir);
+	
+	if (PHYSFS_isDirectory(full_name)) find_attr=DOS_ATTR_DIRECTORY|DOS_ATTR_ARCHIVE;
+	else find_attr=DOS_ATTR_ARCHIVE;
+ 	if (~srch_attr & find_attr & (DOS_ATTR_DIRECTORY | DOS_ATTR_HIDDEN | DOS_ATTR_SYSTEM)) goto again;
+	
+	/*file is okay, setup everything to be copied in DTA Block */
+	find_size=(Bit32u)PHYSFS_fileLength(full_name);
+	time_t mytime = PHYSFS_getLastModTime(full_name);
+	struct tm *time;
+	if((time=localtime(&mytime))!=0){
+		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
+	} else {
+		find_time=6; 
+		find_date=4;
+	}
+	dta.SetResult(find_name,find_size,find_date,find_time,find_attr);
+	return true;
+}
+
+bool physfsDrive::GetFileAttr(const char * name,Bit16u * attr) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+	char *last = strrchr(newname,'/');
+	if (last == NULL) last = newname-1;
+
+	*attr = 0;
+	if (!PHYSFS_exists(newname)) return false;
+	*attr=DOS_ATTR_ARCHIVE;
+	if (PHYSFS_isDirectory(newname)) *attr|=DOS_ATTR_DIRECTORY;
+	return true;
+}
+
+bool physfsDrive::MakeDir(const char * dir) {
+	char newdir[CROSS_LEN];
+	strcpy(newdir,basedir);
+	strcat(newdir,dir);
+	CROSS_FILENAME(newdir);
+	dirCache.ExpandName(newdir);
+	normalize(newdir,basedir);
+	if (PHYSFS_mkdir(newdir)) {
+		CROSS_FILENAME(newdir);
+		dirCache.CacheOut(newdir,true);
+		return true;
+	}
+	return false;
+}
+
+bool physfsDrive::RemoveDir(const char * dir) {
+	char newdir[CROSS_LEN];
+	strcpy(newdir,basedir);
+	strcat(newdir,dir);
+	CROSS_FILENAME(newdir);
+	dirCache.ExpandName(newdir);
+	normalize(newdir,basedir);
+	if (PHYSFS_isDirectory(newdir) && PHYSFS_delete(newdir)) {
+		CROSS_FILENAME(newdir);
+		dirCache.DeleteEntry(newdir,true);
+		return true;
+	}
+	return false;
+}
+
+bool physfsDrive::TestDir(const char * dir) {
+	char newdir[CROSS_LEN];
+	strcpy(newdir,basedir);
+	strcat(newdir,dir);
+	CROSS_FILENAME(newdir);
+	dirCache.ExpandName(newdir);
+	normalize(newdir,basedir);
+	return (PHYSFS_isDirectory(newdir));
+}
+
+bool physfsDrive::Rename(const char * oldname,const char * newname) {
+	char newold[CROSS_LEN];
+	strcpy(newold,basedir);
+	strcat(newold,oldname);
+	CROSS_FILENAME(newold);
+	dirCache.ExpandName(newold);
+	normalize(newold,basedir);
+	
+	char newnew[CROSS_LEN];
+	strcpy(newnew,basedir);
+	strcat(newnew,newname);
+	CROSS_FILENAME(newnew);
+	dirCache.ExpandName(newnew);
+	normalize(newnew,basedir);
+	/* yuck. physfs doesn't have "rename". */
+	LOG_MSG("PHYSFS TODO: rename not yet implemented (%s -> %s)",newold,newnew);
+	return false;
+
+}
+
+bool physfsDrive::AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters) {
+	/* Always report 100 mb free should be enough */
+	/* Total size is always 1 gb */
+	*_bytes_sector=allocation.bytes_sector;
+	*_sectors_cluster=allocation.sectors_cluster;
+	*_total_clusters=allocation.total_clusters;
+	*_free_clusters=allocation.free_clusters;
+	return true;
+}
+
+bool physfsDrive::FileExists(const char* name) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+	return PHYSFS_exists(newname) && !PHYSFS_isDirectory(newname);
+}
+
+bool physfsDrive::FileStat(const char* name, FileStat_Block * const stat_block) {
+	char newname[CROSS_LEN];
+	strcpy(newname,basedir);
+	strcat(newname,name);
+	CROSS_FILENAME(newname);
+	dirCache.ExpandName(newname);
+	normalize(newname,basedir);
+	time_t mytime = PHYSFS_getLastModTime(newname);
+	/* Convert the stat to a FileStat */
+	struct tm *time;
+	if((time=localtime(&mytime))!=0) {
+		stat_block->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
+		stat_block->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+	} else {
+		stat_block->time=DOS_PackTime(0,0,0);
+		stat_block->date=DOS_PackDate(1980,1,1);
+	}
+	stat_block->size=(Bit32u)PHYSFS_fileLength(newname);
+	return true;
+}
+
+
+Bit8u physfsDrive::GetMediaByte(void) {
+	return allocation.mediaid;
+}
+
+bool physfsDrive::isRemote(void) {
+	return false;
+}
+
+bool physfsDrive::isRemovable(void) {
+	return false;
+}
+
+struct opendirinfo {
+	char **files;
+	int pos;
+};
+/* helper functions for drive cache */
+bool physfsDrive::isdir(const char *name) {
+	char myname[CROSS_LEN];
+	strcpy(myname,name);
+	normalize(myname,basedir);
+	return PHYSFS_isDirectory(myname);
+}
+
+void *physfsDrive::opendir(const char *name) {
+	char myname[CROSS_LEN];
+	strcpy(myname,name);
+	normalize(myname,basedir);
+	if (!PHYSFS_isDirectory(myname)) return false;
+
+	struct opendirinfo *oinfo = (struct opendirinfo *)malloc(sizeof(struct opendirinfo));
+	oinfo->files = PHYSFS_enumerateFiles(myname);
+	if (oinfo->files == NULL) {
+		LOG_MSG("PHYSFS: nothing found for %s (%s)",myname,PHYSFS_getLastError());
+		free(oinfo);
+		return NULL;
+	}
+
+	oinfo->pos = (myname[1] == 0?0:-2);
+	return (void *)oinfo;
+}
+
+void physfsDrive::closedir(void *handle) {
+	struct opendirinfo *oinfo = (struct opendirinfo *)handle;
+	if (handle == NULL) return;
+	if (oinfo->files != NULL) PHYSFS_freeList(oinfo->files);
+	free(oinfo);
+}
+
+bool physfsDrive::read_directory_first(void* dirp, char* entry_name, bool& is_directory) {
+	return read_directory_next(dirp, entry_name, is_directory);
+}
+
+bool physfsDrive::read_directory_next(void* dirp, char* entry_name, bool& is_directory) {
+	struct opendirinfo *oinfo = (struct opendirinfo *)dirp;
+	if (!oinfo) return false;
+	if (oinfo->pos == -2) {
+		oinfo->pos++;
+		safe_strncpy(entry_name,".",CROSS_LEN);
+		is_directory = true;
+		return true;
+	}
+	if (oinfo->pos == -1) {
+		oinfo->pos++;
+		safe_strncpy(entry_name,"..",CROSS_LEN);
+		is_directory = true;
+		return true;
+	}
+	if (!oinfo->files || !oinfo->files[oinfo->pos]) return false;
+	safe_strncpy(entry_name,oinfo->files[oinfo->pos++],CROSS_LEN);
+	is_directory = isdir(entry_name);
+	return true;
+}
+
+extern std::string capturedir;
+static Bit8u physfs_used = 0;
+physfsDrive::physfsDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid)
+		   :localDrive(startdir,_bytes_sector,_sectors_cluster,_total_clusters,_free_clusters,_mediaid) {
+
+	char newname[CROSS_LEN+1];
+
+	/* No writedir given, use capture directory */
+	if(startdir[0] == ':') {
+		strcpy(newname,capturedir.c_str());
+		strcat(newname,startdir);
+	} else {
+		strcpy(newname,startdir);
+	}
+
+	CROSS_FILENAME(newname);	
+	if (!physfs_used) {
+		PHYSFS_init("");
+		PHYSFS_permitSymbolicLinks(1);
+	}
+
+	physfs_used++;
+	char *lastdir = newname;
+	char *dir = strchr(lastdir+(((lastdir[0]|0x20) >= 'a' && (lastdir[0]|0x20) <= 'z')?2:0),':');
+	while (dir) {
+		*dir++ = 0;
+		if((lastdir == newname) && !strchr(dir+(((dir[0]|0x20) >= 'a' && (dir[0]|0x20) <= 'z')?2:0),':')) {
+			// If the first parameter is a directory, the next one has to be the archive file,
+			// do not confuse it with basedir if trailing : is not there!
+			int tmp = strlen(dir)-1;
+			dir[tmp++] = ':';
+			dir[tmp++] = CROSS_FILESPLIT;
+			dir[tmp] = '\0';
+		}
+		if (*lastdir && PHYSFS_addToSearchPath(lastdir,true) == 0) {
+			LOG_MSG("PHYSFS couldn't add '%s': %s",lastdir,PHYSFS_getLastError());
+		}
+		lastdir = dir;
+		dir = strchr(lastdir+(((lastdir[0]|0x20) >= 'a' && (lastdir[0]|0x20) <= 'z')?2:0),':');
+	}
+	const char *oldwrite = PHYSFS_getWriteDir();
+	if (oldwrite) oldwrite = strdup(oldwrite);
+	if (!PHYSFS_setWriteDir(newname)) {
+		if (!oldwrite)
+			LOG_MSG("PHYSFS can't use '%s' for writing, you might encounter problems",newname);
+		else
+			PHYSFS_setWriteDir(oldwrite);
+	}
+	if (oldwrite) free((char *)oldwrite);
+	
+	strcpy(basedir,lastdir);
+
+	allocation.bytes_sector=_bytes_sector;
+	allocation.sectors_cluster=_sectors_cluster;
+	allocation.total_clusters=_total_clusters;
+	allocation.free_clusters=_free_clusters;
+	allocation.mediaid=_mediaid;
+
+	dirCache.SetBaseDir(basedir, this);
+}
+
+physfsDrive::~physfsDrive(void) {
+	if(!physfs_used) {
+		LOG_MSG("PHYSFS invalid reference count!");
+		return;
+	}
+	physfs_used--;
+	if(!physfs_used) {
+		LOG_MSG("PHYSFS calling PHYSFS_deinit()");
+		PHYSFS_deinit();
+	}
+}
+
+const char *physfsDrive::GetInfo() {
+	char **files = PHYSFS_getSearchPath(), **list = files;
+	sprintf(info,"PHYSFS directory %s in ",basedir);
+	while (*files != NULL) {
+		strcat(info,*files++);
+		strcat(info,", ");
+	}
+	if (PHYSFS_getWriteDir() != NULL) {
+		strcat(info,"writing to ");
+		strcat(info,PHYSFS_getWriteDir());
+	} else {
+		strcat(info,"read-only");
+	}
+	PHYSFS_freeList(list);
+	return info;
+}
+
+
+bool physfsFile::Read(Bit8u * data,Bit16u * size) {
+	if ((this->flags & 0xf) == OPEN_WRITE) {        // check if file opened in write-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	if (last_action==WRITE) prepareRead();
+	last_action=READ;
+	PHYSFS_sint64 mysize = PHYSFS_read(fhandle,data,1,(PHYSFS_uint64)*size);
+	//LOG_MSG("Read %i bytes (wanted %i) at %i of %s (%s)",(int)mysize,(int)*size,(int)PHYSFS_tell(fhandle),name,PHYSFS_getLastError());
+	*size = (Bit16u)mysize;
+	return true;
+}
+
+bool physfsFile::Write(Bit8u * data,Bit16u * size) {
+	if ((this->flags & 0xf) == OPEN_READ) { // check if file opened in read-only mode
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	if (last_action==READ) prepareWrite();
+	last_action=WRITE;
+	if (*size==0) {
+		if (PHYSFS_tell(fhandle) == 0) {
+			PHYSFS_close(PHYSFS_openWrite(pname));
+			//LOG_MSG("Truncate %s (%s)",name,PHYSFS_getLastError());
+		} else {
+			LOG_MSG("PHYSFS TODO: truncate not yet implemented (%s at %i)",pname,PHYSFS_tell(fhandle));
+			return false;
+		}
+	} else {
+		PHYSFS_sint64 mysize = PHYSFS_write(fhandle,data,1,(PHYSFS_uint64)*size);
+		//LOG_MSG("Wrote %i bytes (wanted %i) at %i of %s (%s)",(int)mysize,(int)*size,(int)PHYSFS_tell(fhandle),name,PHYSFS_getLastError());
+		*size = (Bit16u)mysize;
+		return true;
+	}
+}
+bool physfsFile::Seek(Bit32u * pos,Bit32u type) {
+	PHYSFS_sint64 mypos = (Bit32s)*pos;
+	switch (type) {
+	case DOS_SEEK_SET:break;
+	case DOS_SEEK_CUR:mypos += PHYSFS_tell(fhandle); break;
+	case DOS_SEEK_END:mypos += PHYSFS_fileLength(fhandle);-mypos; break;
+	default:
+	//TODO Give some doserrorcode;
+		return false;//ERROR
+	}
+
+	if (!PHYSFS_seek(fhandle,mypos)) {
+		// Out of file range, pretend everythings ok 
+		// and move file pointer top end of file... ?! (Black Thorne)
+		PHYSFS_seek(fhandle,PHYSFS_fileLength(fhandle));
+	};
+	//LOG_MSG("Seek to %i (%i at %x) of %s (%s)",(int)mypos,(int)*pos,type,name,PHYSFS_getLastError());
+
+	*pos=(Bit32u)PHYSFS_tell(fhandle);
+	return true;
+}
+
+bool physfsFile::prepareRead() {
+	PHYSFS_uint64 pos = PHYSFS_tell(fhandle);
+	PHYSFS_close(fhandle);
+	fhandle = PHYSFS_openRead(pname);
+	PHYSFS_seek(fhandle, pos);
+	//LOG_MSG("Goto read (%s at %i)",pname,PHYSFS_tell(fhandle));
+}
+
+#ifndef WIN32
+#include <fcntl.h>
+#include <errno.h>
+#endif
+
+bool physfsFile::prepareWrite() {
+	const char *wdir = PHYSFS_getWriteDir();
+	if (wdir == NULL) {
+		LOG_MSG("PHYSFS could not fulfill write request: no write directory set.");
+		return false;
+	}
+	//LOG_MSG("Goto write (%s at %i)",pname,PHYSFS_tell(fhandle));
+	const char *fdir = PHYSFS_getRealDir(pname);
+	PHYSFS_uint64 pos = PHYSFS_tell(fhandle);
+	char *slash = strrchr(pname,'/');
+	if (slash && slash != pname) {
+		*slash = 0;
+		PHYSFS_mkdir(pname);
+		*slash = '/';
+	}
+	if (strcmp(fdir,wdir)) { /* we need COW */
+		//LOG_MSG("COW",pname,PHYSFS_tell(fhandle));
+		PHYSFS_file *whandle = PHYSFS_openWrite(pname);
+		if (whandle == NULL) {
+			LOG_MSG("PHYSFS copy-on-write failed: %s.",PHYSFS_getLastError());
+			return false;
+		}
+		char buffer[65536];
+		PHYSFS_sint64 size;
+		PHYSFS_seek(fhandle, 0);
+		while ((size = PHYSFS_read(fhandle,buffer,1,65536)) > 0) {
+			if (PHYSFS_write(whandle,buffer,1,size) != size) {
+				LOG_MSG("PHYSFS copy-on-write failed: %s.",PHYSFS_getLastError());
+				PHYSFS_close(whandle);
+				return false;
+			}
+		}
+		PHYSFS_seek(whandle, pos);
+		PHYSFS_close(fhandle);
+		fhandle = whandle;
+	} else { // megayuck - physfs on posix platforms uses O_APPEND. We illegally access the fd directly and clear that flag.
+		//LOG_MSG("noCOW",pname,PHYSFS_tell(fhandle));
+		PHYSFS_close(fhandle);
+		fhandle = PHYSFS_openAppend(pname);
+#ifndef WIN32
+		int rc = fcntl(**(int**)fhandle->opaque,F_SETFL,0);
+#endif
+		PHYSFS_seek(fhandle, pos);
+	}
+	return true;
+}
+
+bool physfsFile::Close() {
+	// only close if one reference left
+	if (refCtr==1) {
+		PHYSFS_close(fhandle);
+		fhandle = 0;
+		open = false;
+	};
+	return true;
+}
+
+Bit16u physfsFile::GetInformation(void) {
+	return info;
+}
+	
+
+physfsFile::physfsFile(const char* _name, PHYSFS_file * handle,Bit16u devinfo, const char* physname, bool write) {
+	fhandle=handle;
+	info=devinfo;
+	strcpy(pname,physname);
+	time_t mytime = PHYSFS_getLastModTime(pname);
+	/* Convert the stat to a FileStat */
+	struct tm *time;
+	if((time=localtime(&mytime))!=0) {
+		this->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
+		this->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+	} else {
+		this->time=DOS_PackTime(0,0,0);
+		this->date=DOS_PackDate(1980,1,1);
+	}
+
+	attr=DOS_ATTR_ARCHIVE;
+	last_action=(write?WRITE:READ);
+
+	open=true;
+	name=0;
+	SetName(_name);
+}
+
+bool physfsFile::UpdateDateTimeFromHost(void) {
+	if(!open) return false;
+	time_t mytime = PHYSFS_getLastModTime(pname);
+	/* Convert the stat to a FileStat */
+	struct tm *time;
+	if((time=localtime(&mytime))!=0) {
+		this->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
+		this->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
+	} else {
+		this->time=DOS_PackTime(0,0,0);
+		this->date=DOS_PackDate(1980,1,1);
+	}
+	return true;
+}
+
+
+// ********************************************
+// CDROM DRIVE
+// ********************************************
+
+int  MSCDEX_AddDrive(char driveLetter, const char* physicalPath, Bit8u& subUnit);
+bool MSCDEX_HasMediaChanged(Bit8u subUnit);
+bool MSCDEX_GetVolumeName(Bit8u subUnit, char* name);
+
+
+physfscdromDrive::physfscdromDrive(const char driveLetter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error)
+		   :physfsDrive(startdir,_bytes_sector,_sectors_cluster,_total_clusters,_free_clusters,_mediaid)
+{
+	// Init mscdex
+	error = MSCDEX_AddDrive(driveLetter,startdir,subUnit);
+	// Get Volume Label
+	char name[32];
+	if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
+};
+
+const char *physfscdromDrive::GetInfo() {
+	char **files = PHYSFS_getSearchPath(), **list = files;
+	sprintf(info,"PHYSFS directory %s in ",basedir);
+	while (*files != NULL) {
+		strcat(info,*files++);
+		strcat(info,", ");
+	}
+	strcat(info,"CD-ROM mode (read-only)");
+	PHYSFS_freeList(list);
+	return info;
+}
+
+bool physfscdromDrive::FileOpen(DOS_File * * file,const char * name,Bit32u flags)
+{
+	if ((flags&0xf)==OPEN_READWRITE) {
+		flags &= ~OPEN_READWRITE;
+	} else if ((flags&0xf)==OPEN_WRITE) {
+		DOS_SetError(DOSERR_ACCESS_DENIED);
+		return false;
+	}
+	return physfsDrive::FileOpen(file,name,flags);
+};
+
+bool physfscdromDrive::FileCreate(DOS_File * * file,const char * name,Bit16u attributes)
+{
+	DOS_SetError(DOSERR_ACCESS_DENIED);
+	return false;
+};
+
+bool physfscdromDrive::FileUnlink(const char * name)
+{
+	DOS_SetError(DOSERR_ACCESS_DENIED);
+	return false;
+};
+
+bool physfscdromDrive::RemoveDir(const char * dir)
+{
+	DOS_SetError(DOSERR_ACCESS_DENIED);
+	return false;
+};
+
+bool physfscdromDrive::MakeDir(const char * dir)
+{
+	DOS_SetError(DOSERR_ACCESS_DENIED);
+	return false;
+};
+
+bool physfscdromDrive::Rename(const char * oldname,const char * newname)
+{
+	DOS_SetError(DOSERR_ACCESS_DENIED);
+	return false;
+};
+
+bool physfscdromDrive::GetFileAttr(const char * name,Bit16u * attr)
+{
+	bool result = physfsDrive::GetFileAttr(name,attr);
+	if (result) *attr |= DOS_ATTR_READ_ONLY;
+	return result;
+};
+
+bool physfscdromDrive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst)
+{
+	// If media has changed, reInit drivecache.
+	if (MSCDEX_HasMediaChanged(subUnit)) {
+		dirCache.EmptyCache();
+		// Get Volume Label
+		char name[32];
+		if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
+	}
+	return physfsDrive::FindFirst(_dir,dta);
+};
+
+void physfscdromDrive::SetDir(const char* path)
+{
+	// If media has changed, reInit drivecache.
+	if (MSCDEX_HasMediaChanged(subUnit)) {
+		dirCache.EmptyCache();
+		// Get Volume Label
+		char name[32];
+		if (MSCDEX_GetVolumeName(subUnit,name)) dirCache.SetLabel(name,true,true);
+	}
+	physfsDrive::SetDir(path);
+};
+
+bool physfscdromDrive::isRemote(void) {
+	return true;
+}
+
+bool physfscdromDrive::isRemovable(void) {
+	return true;
+}
+
+Bits physfscdromDrive::UnMount(void) {
+	return true;
+}
+
+#endif // C_HAVE_PHYSFS
diff -urN dosbox-0.73/src/dos/drives.cpp dosboxcvs/src/dos/drives.cpp
--- dosbox-0.73/src/dos/drives.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/dos/drives.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -114,7 +114,7 @@
 	info[0]=0;
 }
 
-char * DOS_Drive::GetInfo(void) {
+const char * DOS_Drive::GetInfo(void) {
 	return info;
 }
 
diff -urN dosbox-0.73/src/dos/drives.h dosboxcvs/src/dos/drives.h
--- dosbox-0.73/src/dos/drives.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/dos/drives.h	2009-07-08 20:43:48.000000000 +0300
@@ -52,18 +52,18 @@
 class localDrive : public DOS_Drive {
 public:
 	localDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid);
-	virtual bool FileOpen(DOS_File * * file,char * name,Bit32u flags);
-	virtual FILE *GetSystemFilePtr(char const * const name, char const * const type);
-	virtual bool GetSystemFilename(char* sysName, char const * const dosName);
-	virtual bool FileCreate(DOS_File * * file,char * name,Bit16u attributes);
-	virtual bool FileUnlink(char * name);
-	virtual bool RemoveDir(char * dir);
-	virtual bool MakeDir(char * dir);
-	virtual bool TestDir(char * dir);
-	virtual bool FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	virtual FILE *GetSystemFilePtr(char const * const name, char const * const type); 
+	virtual bool GetSystemFilename(char* sysName, char const * const dosName); 
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	virtual bool FileUnlink(const char * name);
+	virtual bool RemoveDir(const char * dir);
+	virtual bool MakeDir(const char * dir);
+	virtual bool TestDir(const char * dir);
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
 	virtual bool FindNext(DOS_DTA & dta);
-	virtual bool GetFileAttr(char * name,Bit16u * attr);
-	virtual bool Rename(char * oldname,char * newname);
+	virtual bool GetFileAttr(const char * name,Bit16u * attr);
+	virtual bool Rename(const char * oldname,const char * newname);
 	virtual bool AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters);
 	virtual bool FileExists(const char* name);
 	virtual bool FileStat(const char* name, FileStat_Block * const stat_block);
@@ -71,7 +71,17 @@
 	virtual bool isRemote(void);
 	virtual bool isRemovable(void);
 	virtual Bits UnMount(void);
-private:
+	virtual char const * GetLabel(){return dirCache.GetLabel();};
+	virtual void SetLabel(const char *label, bool iscdrom, bool updatable) { dirCache.SetLabel(label,iscdrom,updatable); };
+	virtual void *opendir(const char *dir);
+	virtual void closedir(void *handle);
+	virtual bool read_directory_first(void *handle, char* entry_name, bool& is_directory);
+	virtual bool read_directory_next(void *handle, char* entry_name, bool& is_directory);
+
+	virtual void EmptyCache(void) { dirCache.EmptyCache(); };
+
+protected:
+	DOS_Drive_Cache dirCache;
 	char basedir[CROSS_LEN];
 	friend void DOS_Shell::CMD_SUBST(char* args); 	
 	struct {
@@ -87,6 +97,36 @@
 	} allocation;
 };
 
+class physfsDrive : public localDrive {
+private:
+	bool isdir(const char *dir);
+
+public:
+	physfsDrive(const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid);
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	virtual bool FileUnlink(const char * name);
+	virtual bool RemoveDir(const char * dir);
+	virtual bool MakeDir(const char * dir);
+	virtual bool TestDir(const char * dir);
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
+	virtual bool FindNext(DOS_DTA & dta);
+	virtual bool GetFileAttr(const char * name,Bit16u * attr);
+	virtual bool Rename(const char * oldname,const char * newname);
+	virtual bool AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters);
+	virtual bool FileExists(const char* name);
+	virtual bool FileStat(const char* name, FileStat_Block * const stat_block);
+	virtual Bit8u GetMediaByte(void);
+	virtual bool isRemote(void);
+	virtual bool isRemovable(void);
+	virtual void *opendir(const char *dir);
+	virtual void closedir(void *handle);
+	virtual bool read_directory_first(void *handle, char* entry_name, bool& is_directory);
+	virtual bool read_directory_next(void *handle, char* entry_name, bool& is_directory);
+	virtual const char *GetInfo(void);
+	virtual ~physfsDrive(void);
+};
+
 #ifdef _MSC_VER
 #pragma pack (1)
 #endif
@@ -147,16 +187,16 @@
 class fatDrive : public DOS_Drive {
 public:
 	fatDrive(const char * sysFilename, Bit32u bytesector, Bit32u cylsector, Bit32u headscyl, Bit32u cylinders, Bit32u startSector);
-	virtual bool FileOpen(DOS_File * * file,char * name,Bit32u flags);
-	virtual bool FileCreate(DOS_File * * file,char * name,Bit16u attributes);
-	virtual bool FileUnlink(char * name);
-	virtual bool RemoveDir(char * dir);
-	virtual bool MakeDir(char * dir);
-	virtual bool TestDir(char * dir);
-	virtual bool FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	virtual bool FileUnlink(const char * name);
+	virtual bool RemoveDir(const char * dir);
+	virtual bool MakeDir(const char * dir);
+	virtual bool TestDir(const char * dir);
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
 	virtual bool FindNext(DOS_DTA & dta);
-	virtual bool GetFileAttr(char * name,Bit16u * attr);
-	virtual bool Rename(char * oldname,char * newname);
+	virtual bool GetFileAttr(const char * name,Bit16u * attr);
+	virtual bool Rename(const char * oldname,const char * newname);
 	virtual bool AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters);
 	virtual bool FileExists(const char* name);
 	virtual bool FileStat(const char* name, FileStat_Block * const stat_block);
@@ -181,11 +221,11 @@
 	void setClusterValue(Bit32u clustNum, Bit32u clustValue);
 	Bit32u getClustFirstSect(Bit32u clustNum);
 	bool FindNextInternal(Bit32u dirClustNumber, DOS_DTA & dta, direntry *foundEntry);
-	bool getDirClustNum(char * dir, Bit32u * clustNum, bool parDir);
+	bool getDirClustNum(const char * dir, Bit32u * clustNum, bool parDir);
 	bool getFileDirEntry(char const * const filename, direntry * useEntry, Bit32u * dirClust, Bit32u * subEntry);
 	bool addDirectoryEntry(Bit32u dirClustNumber, direntry useEntry);
 	void zeroOutCluster(Bit32u clustNumber);
-	bool getEntryName(char *fullname, char *entname);
+	bool getEntryName(const char *fullname, char *entname);
 	friend void DOS_Shell::CMD_SUBST(char* args); 	
 	struct {
 		char srch_dir[CROSS_LEN];
@@ -215,18 +255,38 @@
 {
 public:
 	cdromDrive(const char driveLetter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error);
-	virtual bool FileOpen(DOS_File * * file,char * name,Bit32u flags);
-	virtual bool FileCreate(DOS_File * * file,char * name,Bit16u attributes);
-	virtual bool FileUnlink(char * name);
-	virtual bool RemoveDir(char * dir);
-	virtual bool MakeDir(char * dir);
-	virtual bool Rename(char * oldname,char * newname);
-	virtual bool GetFileAttr(char * name,Bit16u * attr);
-	virtual bool FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	virtual bool FileUnlink(const char * name);
+	virtual bool RemoveDir(const char * dir);
+	virtual bool MakeDir(const char * dir);
+	virtual bool Rename(const char * oldname,const char * newname);
+	virtual bool GetFileAttr(const char * name,Bit16u * attr);
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
+	virtual void SetDir(const char* path);
+	virtual bool isRemote(void);
+	virtual bool isRemovable(void);virtual Bits UnMount(void);
+private:
+	Bit8u subUnit;	char driveLetter;
+};
+
+class physfscdromDrive : public physfsDrive
+{
+public:
+	physfscdromDrive(const char driveLetter, const char * startdir,Bit16u _bytes_sector,Bit8u _sectors_cluster,Bit16u _total_clusters,Bit16u _free_clusters,Bit8u _mediaid, int& error);
+	virtual bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	virtual bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	virtual bool FileUnlink(const char * name);
+	virtual bool RemoveDir(const char * dir);
+	virtual bool MakeDir(const char * dir);
+	virtual bool Rename(const char * oldname,const char * newname);
+	virtual bool GetFileAttr(const char * name,Bit16u * attr);
+	virtual bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst=false);
 	virtual void SetDir(const char* path);
 	virtual bool isRemote(void);
 	virtual bool isRemovable(void);
 	virtual Bits UnMount(void);
+	virtual const char *GetInfo(void);
 private:
 	Bit8u subUnit;
 	char driveLetter;
@@ -311,16 +371,16 @@
 public:
 	isoDrive(char driveLetter, const char* device_name, Bit8u mediaid, int &error);
 	~isoDrive();
-	virtual bool FileOpen(DOS_File **file, char *name, Bit32u flags);
-	virtual bool FileCreate(DOS_File **file, char *name, Bit16u attributes);
-	virtual bool FileUnlink(char *name);
-	virtual bool RemoveDir(char *dir);
-	virtual bool MakeDir(char *dir);
-	virtual bool TestDir(char *dir);
-	virtual bool FindFirst(char *_dir, DOS_DTA &dta, bool fcb_findfirst);
+	virtual bool FileOpen(DOS_File **file, const char *name, Bit32u flags);
+	virtual bool FileCreate(DOS_File **file, const char *name, Bit16u attributes);
+	virtual bool FileUnlink(const char *name);
+	virtual bool RemoveDir(const char *dir);
+	virtual bool MakeDir(const char *dir);
+	virtual bool TestDir(const char *dir);
+	virtual bool FindFirst(const char *_dir, DOS_DTA &dta, bool fcb_findfirst);
 	virtual bool FindNext(DOS_DTA &dta);
-	virtual bool GetFileAttr(char *name, Bit16u *attr);
-	virtual bool Rename(char * oldname,char * newname);
+	virtual bool GetFileAttr(const char *name, Bit16u *attr);
+	virtual bool Rename(const char * oldname,const char * newname);
 	virtual bool AllocationInfo(Bit16u *bytes_sector, Bit8u *sectors_cluster, Bit16u *total_clusters, Bit16u *free_clusters);
 	virtual bool FileExists(const char *name);
    	virtual bool FileStat(const char *name, FileStat_Block *const stat_block);
@@ -372,16 +432,16 @@
 class Virtual_Drive: public DOS_Drive {
 public:
 	Virtual_Drive();
-	bool FileOpen(DOS_File * * file,char * name,Bit32u flags);
-	bool FileCreate(DOS_File * * file,char * name,Bit16u attributes);
-	bool FileUnlink(char * name);
-	bool RemoveDir(char * dir);
-	bool MakeDir(char * dir);
-	bool TestDir(char * dir);
-	bool FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst);
+	bool FileOpen(DOS_File * * file,const char * name,Bit32u flags);
+	bool FileCreate(DOS_File * * file,const char * name,Bit16u attributes);
+	bool FileUnlink(const char * name);
+	bool RemoveDir(const char * dir);
+	bool MakeDir(const char * dir);
+	bool TestDir(const char * dir);
+	bool FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst);
 	bool FindNext(DOS_DTA & dta);
-	bool GetFileAttr(char * name,Bit16u * attr);
-	bool Rename(char * oldname,char * newname);
+	bool GetFileAttr(const char * name,Bit16u * attr);
+	bool Rename(const char * oldname,const char * newname);
 	bool AllocationInfo(Bit16u * _bytes_sector,Bit8u * _sectors_cluster,Bit16u * _total_clusters,Bit16u * _free_clusters);
 	bool FileExists(const char* name);
 	bool FileStat(const char* name, FileStat_Block* const stat_block);
diff -urN dosbox-0.73/src/dos/drive_virtual.cpp dosboxcvs/src/dos/drive_virtual.cpp
--- dosbox-0.73/src/dos/drive_virtual.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/dos/drive_virtual.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -140,7 +140,7 @@
 }
 
 
-bool Virtual_Drive::FileOpen(DOS_File * * file,char * name,Bit32u flags) {
+bool Virtual_Drive::FileOpen(DOS_File * * file,const char * name,Bit32u flags) {
 /* Scan through the internal list of files */
 	VFILE_Block * cur_file=first_file;
 	while (cur_file) {
@@ -155,23 +155,23 @@
 	return false;
 }
 
-bool Virtual_Drive::FileCreate(DOS_File * * file,char * name,Bit16u attributes) {
+bool Virtual_Drive::FileCreate(DOS_File * * file,const char * name,Bit16u attributes) {
 	return false;
 }
 
-bool Virtual_Drive::FileUnlink(char * name) {
+bool Virtual_Drive::FileUnlink(const char * name) {
 	return false;
 }
 
-bool Virtual_Drive::RemoveDir(char * dir) {
+bool Virtual_Drive::RemoveDir(const char * dir) {
 	return false;
 }
 
-bool Virtual_Drive::MakeDir(char * dir) {
+bool Virtual_Drive::MakeDir(const char * dir) {
 	return false;
 }
 
-bool Virtual_Drive::TestDir(char * dir) {
+bool Virtual_Drive::TestDir(const char * dir) {
 	if (!dir[0]) return true;		//only valid dir is the empty dir
 	return false;
 }
@@ -200,7 +200,7 @@
 	return false;
 }
 
-bool Virtual_Drive::FindFirst(char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
+bool Virtual_Drive::FindFirst(const char * _dir,DOS_DTA & dta,bool fcb_findfirst) {
 	search_file=first_file;
 	Bit8u attr;char pattern[DOS_NAMELENGTH_ASCII];
 	dta.GetSearchParams(attr,pattern);
@@ -231,7 +231,7 @@
 	return false;
 }
 
-bool Virtual_Drive::GetFileAttr(char * name,Bit16u * attr) {
+bool Virtual_Drive::GetFileAttr(const char * name,Bit16u * attr) {
 	VFILE_Block * cur_file=first_file;
 	while (cur_file) {
 		if (strcasecmp(name,cur_file->name)==0) { 
@@ -243,7 +243,7 @@
 	return false;
 }
 
-bool Virtual_Drive::Rename(char * oldname,char * newname) {
+bool Virtual_Drive::Rename(const char * oldname,const char * newname) {
 	return false;
 }
 
diff -urN dosbox-0.73/src/dos/Makefile.am dosboxcvs/src/dos/Makefile.am
--- dosbox-0.73/src/dos/Makefile.am	2006-10-27 16:37:13.000000000 +0300
+++ dosboxcvs/src/dos/Makefile.am	2009-07-08 20:43:48.000000000 +0300
@@ -7,4 +7,4 @@
 		   drives.cpp drives.h drive_virtual.cpp drive_local.cpp drive_cache.cpp drive_fat.cpp \
 		   drive_iso.cpp dev_con.h dos_mscdex.cpp dos_keyboard_layout.cpp \
 		   cdrom.h cdrom.cpp cdrom_ioctl_win32.cpp cdrom_aspi_win32.cpp cdrom_ioctl_linux.cpp cdrom_image.cpp \
-		   cdrom_ioctl_os2.cpp
+		   cdrom_ioctl_os2.cpp drive_physfs.cpp
diff -urN dosbox-0.73/src/dos/Makefile.in dosboxcvs/src/dos/Makefile.in
--- dosbox-0.73/src/dos/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/dos/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -57,9 +61,10 @@
 	dos_mscdex.$(OBJEXT) dos_keyboard_layout.$(OBJEXT) \
 	cdrom.$(OBJEXT) cdrom_ioctl_win32.$(OBJEXT) \
 	cdrom_aspi_win32.$(OBJEXT) cdrom_ioctl_linux.$(OBJEXT) \
-	cdrom_image.$(OBJEXT) cdrom_ioctl_os2.$(OBJEXT)
+	cdrom_image.$(OBJEXT) cdrom_ioctl_os2.$(OBJEXT) \
+	drive_physfs.$(OBJEXT)
 libdos_a_OBJECTS = $(am_libdos_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -79,6 +84,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -90,6 +97,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -100,8 +108,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -111,7 +120,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -129,12 +137,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -146,43 +157,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libdos.a
 EXTRA_DIST = scsidefs.h wnaspi32.h dos_codepages.h dos_keyboard_layout_data.h
@@ -191,7 +191,7 @@
 		   drives.cpp drives.h drive_virtual.cpp drive_local.cpp drive_cache.cpp drive_fat.cpp \
 		   drive_iso.cpp dev_con.h dos_mscdex.cpp dos_keyboard_layout.cpp \
 		   cdrom.h cdrom.cpp cdrom_ioctl_win32.cpp cdrom_aspi_win32.cpp cdrom_ioctl_linux.cpp cdrom_image.cpp \
-		   cdrom_ioctl_os2.cpp
+		   cdrom_ioctl_os2.cpp drive_physfs.cpp
 
 all: all-am
 
@@ -262,30 +262,32 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drive_fat.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drive_iso.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drive_local.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drive_physfs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drive_virtual.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/drives.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -297,8 +299,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -308,12 +310,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -327,21 +330,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -402,20 +406,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -435,22 +431,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/dosbox.cpp dosboxcvs/src/dosbox.cpp
--- dosbox-0.73/src/dosbox.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/dosbox.cpp	2010-10-29 14:12:37.125646126 +0300
@@ -42,6 +42,12 @@
 #include "mapper.h"
 #include "ints/int10.h"
 #include "render.h"
+#include "parport.h"
+
+#ifdef C_NE2000
+//#include "ne2000.h"
+void NE2K_Init(Section* sec);
+#endif
 
 Config * control;
 MachineType machine;
@@ -86,6 +92,9 @@
 void DISNEY_Init(Section*);
 void SERIAL_Init(Section*); 
 
+#if C_PRINTER
+void PRINTER_Init(Section*);
+#endif
 
 #if C_IPX
 void IPX_Init(Section*);
@@ -374,7 +383,8 @@
 
 	Pmulti = secprop->Add_multi("scaler",Property::Changeable::Always," ");
 	Pmulti->SetValue("normal2x");
-	Pmulti->Set_help("Scaler used to enlarge/enhance low resolution modes. If 'forced' is appended,the scaler will be used even if the result might not be desired.");
+	Pmulti->Set_help("Scaler used to enlarge/enhance low resolution modes. If 'forced' is appended,the scaler will be used even if the result might not be desired.\n"
+			 "Hardware modes (all except surface) also support hardware2x or hardware3x, use for hardware scaling.");
 	Pstring = Pmulti->GetSection()->Add_string("type",Property::Changeable::Always,"normal2x");
 
 	const char *scalers[] = { 
@@ -385,7 +395,7 @@
 #if RENDER_USE_ADVANCED_SCALERS>0
 		"tv2x", "tv3x", "rgb2x", "rgb3x", "scan2x", "scan3x",
 #endif
-		0 };
+		"hardware2x", "hardware3x", 0 };
 	Pstring->Set_values(scalers);
 
 	const char* force[] = { "", "forced", 0 };
@@ -397,7 +407,7 @@
 #if (C_DYNAMIC_X86) || (C_DYNREC)
 		"dynamic",
 #endif
-		"normal", "simple",0 };
+		"normal", "full", "simple", 0 };
 	Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"auto");
 	Pstring->Set_values(cores);
 	Pstring->Set_help("CPU Core used in emulation. auto will switch to dynamic if available and appropriate.");
@@ -462,7 +472,7 @@
 	
 	const char* mputypes[] = { "intelligent", "uart", "none",0};
 	// FIXME: add some way to offer the actually available choices.
-	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi","none", 0};
+	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi", "mt32", "none", 0};
 	Pstring = secprop->Add_string("mpu401",Property::Changeable::WhenIdle,"intelligent");
 	Pstring->Set_values(mputypes);
 	Pstring->Set_help("Type of MPU-401 to emulate.");
@@ -504,7 +514,7 @@
 	Pbool = secprop->Add_bool("sbmixer",Property::Changeable::WhenIdle,true);
 	Pbool->Set_help("Allow the soundblaster mixer to modify the DOSBox mixer.");
 
-	const char* oplmodes[]={ "auto", "cms", "opl2", "dualopl2", "opl3", "none", 0};
+	const char* oplmodes[]={ "auto", "cms", "opl2", "dualopl2", "opl3", "none", "hardware", 0 };
 	Pstring = secprop->Add_string("oplmode",Property::Changeable::WhenIdle,"auto");
 	Pstring->Set_values(oplmodes);
 	Pstring->Set_help("Type of OPL emulation. On 'auto' the mode is determined by sblaster type. All OPL modes are Adlib-compatible, except for 'cms'.");
@@ -518,6 +528,9 @@
 	Pint->Set_values(oplrates);
 	Pint->Set_help("Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).");
 
+	Phex = secprop->Add_hex("hardwarebase",Property::Changeable::WhenIdle,0x220);
+	Phex->Set_help("base address of the real hardware soundblaster:\n"\
+		"210,220,230,240,250,260,280");
 
 	secprop=control->AddSection_prop("gus",&GUS_Init,true); //done
 	Pbool = secprop->Add_bool("gus",Property::Changeable::WhenIdle,false); 	
@@ -566,7 +579,7 @@
 
 	secprop->AddInitFunction(&DISNEY_Init,true);//done
 	
-	Pbool = secprop->Add_bool("disney",Property::Changeable::WhenIdle,true);
+	Pbool = secprop->Add_bool("disney",Property::Changeable::WhenIdle,false);
 	Pbool->Set_help("Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).");
 
 	secprop=control->AddSection_prop("joystick",&BIOS_Init,false);//done
@@ -639,6 +652,70 @@
 	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
 	Pmulti_remain->Set_help("see serial1");
 
+#if C_PRINTER
+	secprop=control->AddSection_prop("printer",&PRINTER_Init); 
+	Pbool = secprop->Add_bool("printer",Property::Changeable::WhenIdle,true);
+	Pbool->Set_help("Enable printer emulation.");
+	//secprop->Add_string("fontpath","%%windir%%\\fonts");
+	Pint = secprop->Add_int("dpi",Property::Changeable::WhenIdle,360); 
+	Pint->Set_help("Resolution of printer (default 360).");
+	Pint = secprop->Add_int("width",Property::Changeable::WhenIdle,85);
+	Pint->Set_help("Width of paper in 1/10 inch (default 85 = 8.5'').");
+	Pint = secprop->Add_int("height",Property::Changeable::WhenIdle,110);
+	Pint->Set_help("Height of paper in 1/10 inch (default 110 = 11.0'').");
+#ifdef C_LIBPNG
+	Pstring = secprop->Add_string("printoutput",Property::Changeable::WhenIdle, "png");
+#else
+	Pstring = secprop->Add_string("printoutput",Property::Changeable::WhenIdle, "ps");
+#endif
+	Pstring->Set_help("Output method for finished pages: \n"
+#ifdef C_LIBPNG
+		"  png     : Creates PNG images (default)\n"
+#endif
+		"  ps      : Creates Postscript\n"
+		"  bmp     : Creates BMP images (very huge files, not recommend)\n"
+#if defined (WIN32)
+		"  printer : Send to an actual printer (Print dialog will appear)"
+#endif
+		);
+
+	Pbool = secprop->Add_bool("multipage",Property::Changeable::WhenIdle, false);
+	Pbool->Set_help("Adds all pages to one Postscript file or printer job until CTRL-F2 is pressed.");
+
+	Pstring = secprop->Add_string("docpath",Property::Changeable::WhenIdle,".");
+	Pstring->Set_help("The path where the output files are stored.");
+
+	Pint = secprop->Add_int("timeout",Property::Changeable::WhenIdle,0);
+	Pint->Set_help("(in milliseconds) if nonzero: the time the page will\n"
+					"be ejected automatically after when no more data\n"
+					"arrives at the printer.");
+#endif
+
+	// parallel ports
+	secprop=control->AddSection_prop("parallel",&PARALLEL_Init,true);
+	Pstring = secprop->Add_string("parallel1",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help(
+	        "parallel1-3 -- set type of device connected to lpt port.\n"
+			"Can be:\n"
+			"	reallpt (direct parallel port passthrough using Porttalk),\n"
+			"	printer (virtual dot-matrix printer, see [printer] section)\n"
+	        "Additional parameters must be in the same line in the form of\n"
+	        "parameter:value.\n"
+	        "  for reallpt:\n"
+	        "    Windows: realbase (the base address of your real parallel port).\n"
+			"      Standard ports are 378, 278 and 3BC. The first two can be ECP ports.\n"
+			"      PCI add-on cards may use nonstandard ports, look them up in the device manager.\n"
+			"      Default: 378\n"
+			"      You have to install the PortTalk driver from\n"
+			"      http://www.beyondlogic.org/porttalk/porttalk.htm first.\n"
+			"    Linux: realport (the parallel port device i.e. /dev/parport0).\n"
+			"  for printer:\n"
+			"    printer still has it's own configuration section above."
+	);
+	Pstring = secprop->Add_string("parallel2",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help("see parallel1");
+	Pstring = secprop->Add_string("parallel3",Property::Changeable::WhenIdle,"disabled");
+	Pstring->Set_help("see parallel1");
 
 	/* All the DOS Related stuff, which will eventually start up in the shell */
 	secprop=control->AddSection_prop("dos",&DOS_Init,false);//done
@@ -666,6 +743,45 @@
 	Pbool = secprop->Add_bool("ipx",Property::Changeable::WhenIdle, false);
 	Pbool->Set_help("Enable ipx over UDP/IP emulation.");
 #endif
+
+#ifdef C_NE2000
+	secprop=control->AddSection_prop("ne2000",&NE2K_Init,true);
+	MSG_Add("NE2000_CONFIGFILE_HELP",
+		"macaddr -- The physical address the emulator will use on your network.\n"
+		"           If you have multiple DOSBoxes running on your network,\n"
+		"           this has to be changed. Modify the last three number blocks.\n"
+		"           I.e. AC:DE:48:88:99:AB.\n"
+		"realnic -- Specifies which of your network interfaces is used.\n"
+		"           Write \'list\' here to see the list of devices in the\n"
+		"           Status Window. Then make your choice and put either the\n"
+		"           interface number (2 or something) or a part of your adapters\n"
+		"           name, e.g. VIA here.\n"
+
+	);
+
+	Pbool = secprop->Add_bool("ne2000", Property::Changeable::WhenIdle, true);
+	Pbool->Set_help("Enable Ethernet passthrough. Requires [Win]Pcap.");
+
+	Phex = secprop->Add_hex("nicbase", Property::Changeable::WhenIdle, 0x300);
+	Phex->Set_help("The base address of the NE2000 board.");
+
+	Pint = secprop->Add_int("nicirq", Property::Changeable::WhenIdle, 3);
+	Pint->Set_help("The interrupt it uses. Note serial2 uses IRQ3 as default.");
+
+	Pstring = secprop->Add_string("macaddr", Property::Changeable::WhenIdle,"AC:DE:48:88:99:AA");
+	Pstring->Set_help("The physical address the emulator will use on your network.\n"
+		"If you have multiple DOSBoxes running on your network,\n"
+		"this has to be changed for each. AC:DE:48 is an address range reserved for\n"
+		"private use, so modify the last three number blocks.\n"
+		"I.e. AC:DE:48:88:99:AB.");
+	
+	Pstring = secprop->Add_string("realnic", Property::Changeable::WhenIdle,"list");
+	Pstring->Set_help("Specifies which of your network interfaces is used.\n"
+		"Write \'list\' here to see the list of devices in the\n"
+		"Status Window. Then make your choice and put either the\n"
+		"interface number (2 or something) or a part of your adapters\n"
+		"name, e.g. VIA here.");
+#endif // C_NE2000
 //	secprop->AddInitFunction(&CREDITS_Init);
 
 	//TODO ?
diff -urN dosbox-0.73/src/fpu/.cvsignore dosboxcvs/src/fpu/.cvsignore
--- dosbox-0.73/src/fpu/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/fpu/.cvsignore	2003-03-06 14:03:40.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/fpu/Makefile.in dosboxcvs/src/fpu/Makefile.in
--- dosbox-0.73/src/fpu/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/fpu/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -50,7 +54,7 @@
 libfpu_a_LIBADD =
 am_libfpu_a_OBJECTS = fpu.$(OBJEXT)
 libfpu_a_OBJECTS = $(am_libfpu_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -70,6 +74,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -81,6 +87,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -91,8 +98,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -102,7 +110,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -120,12 +127,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -137,43 +147,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libfpu.a
 libfpu_a_SOURCES = fpu.cpp fpu_instructions.h \
@@ -229,26 +228,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fpu.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -260,8 +260,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -271,12 +271,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -290,21 +291,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -365,20 +367,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -398,22 +392,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/gui/allpass.cpp dosboxcvs/src/gui/allpass.cpp
--- dosbox-0.73/src/gui/allpass.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/allpass.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,34 @@
+// Allpass filter implementation
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#include "freeverb/allpass.h"
+
+allpass::allpass()
+{
+	bufidx = 0;
+}
+
+void allpass::setbuffer(float *buf, int size)
+{
+	buffer = buf;
+	bufsize = size;
+}
+
+void allpass::mute()
+{
+	for (int i=0; i<bufsize; i++)
+		buffer[i]=0;
+}
+
+void allpass::setfeedback(float val)
+{
+	feedback = val;
+}
+
+float allpass::getfeedback()
+{
+	return feedback;
+}
diff -urN dosbox-0.73/src/gui/blit/Blit.cpp dosboxcvs/src/gui/blit/Blit.cpp
--- dosbox-0.73/src/gui/blit/Blit.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Blit.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,105 @@
+/***************************************************/
+/*! \class Blit
+    \brief STK band-limited impulse train class.
+
+    This class generates a band-limited impulse train using a
+    closed-form algorithm reported by Stilson and Smith in "Alias-Free
+    Digital Synthesis of Classic Analog Waveforms", 1996.  The user
+    can specify both the fundamental frequency of the impulse train
+    and the number of harmonics contained in the resulting signal.
+
+    The signal is normalized so that the peak value is +/-1.0.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Original code by Robin Davies, 2005.
+    Revisions by Gary Scavone for STK, 2005.
+*/
+/***************************************************/
+
+#include "Blit.h"
+#include <cmath>
+#include <limits>
+ 
+Blit:: Blit( StkFloat frequency )
+{
+  nHarmonics_ = 0;
+  this->setFrequency( frequency );
+  this->reset();
+}
+
+Blit :: ~Blit()
+{
+}
+
+void Blit :: reset()
+{
+  phase_ = 0.0;
+  lastOutput_ = 0;
+}
+
+void Blit :: setFrequency( StkFloat frequency )
+{
+#if defined(_STK_DEBUG_)
+  errorString_ << "Blit::setFrequency: frequency = " << frequency << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+
+  p_ = Stk::sampleRate() / frequency;
+  rate_ = PI / p_;
+  this->updateHarmonics();
+}
+
+void Blit :: setHarmonics( unsigned int nHarmonics )
+{
+  nHarmonics_ = nHarmonics;
+  this->updateHarmonics();
+}
+
+void Blit :: updateHarmonics( void )
+{
+  if ( nHarmonics_ <= 0 ) {
+    unsigned int maxHarmonics = (unsigned int) floor( 0.5 * p_ );
+    m_ = 2 * maxHarmonics + 1;
+  }
+  else
+    m_ = 2 * nHarmonics_ + 1;
+
+#if defined(_STK_DEBUG_)
+  errorString_ << "Blit::updateHarmonics: nHarmonics_ = " << nHarmonics_ << ", m_ = " << m_ << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+}
+
+StkFloat Blit :: computeSample( void )
+{
+  // The code below implements the SincM algorithm of Stilson and
+  // Smith with an additional scale factor of P / M applied to
+  // normalize the output.
+
+  // A fully optimized version of this code would replace the two sin
+  // calls with a pair of fast sin oscillators, for which stable fast
+  // two-multiply algorithms are well known. In the spirit of STK,
+  // which favors clarity over performance, the optimization has not
+  // been made here.
+
+  // Avoid a divide by zero at the sinc peak, which has a limiting
+  // value of 1.0.
+  StkFloat denominator = sin( phase_ );
+  if ( denominator <= std::numeric_limits<StkFloat>::epsilon() ) {
+    lastOutput_ = 1.0;
+  } else {
+    lastOutput_ =  sin( m_ * phase_ );
+    lastOutput_ /= m_ * denominator;
+  }
+
+  phase_ += rate_;
+  if ( phase_ >= PI ) phase_ -= PI;
+    
+	return lastOutput_;
+}
+
diff -urN dosbox-0.73/src/gui/blit/Blit.h dosboxcvs/src/gui/blit/Blit.h
--- dosbox-0.73/src/gui/blit/Blit.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Blit.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,87 @@
+/***************************************************/
+/*! \class Blit
+    \brief STK band-limited impulse train class.
+
+    This class generates a band-limited impulse train using a
+    closed-form algorithm reported by Stilson and Smith in "Alias-Free
+    Digital Synthesis of Classic Analog Waveforms", 1996.  The user
+    can specify both the fundamental frequency of the impulse train
+    and the number of harmonics contained in the resulting signal.
+
+    The signal is normalized so that the peak value is +/-1.0.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Original code by Robin Davies, 2005.
+    Revisions by Gary Scavone for STK, 2005.
+*/
+/***************************************************/
+
+#ifndef STK_BLIT_H
+#define STK_BLIT_H
+
+#include "Generator.h"
+
+class Blit: public Generator
+{
+ public:
+  //! Default constructor that initializes BLIT frequency to 220 Hz.
+  Blit( StkFloat frequency = 220.0 );
+
+  //! Class destructor.
+  ~Blit();
+
+  //! Resets the oscillator state and phase to 0.
+  void reset();
+
+  //! Set the phase of the signal.
+  /*!
+    Set the phase of the signal, in the range 0 to 1.
+  */
+  void setPhase( StkFloat phase ) { phase_ = PI * phase; };
+
+  //! Get the current phase of the signal.
+  /*!
+    Get the phase of the signal, in the range [0 to 1.0).
+  */
+  StkFloat getPhase() const { return phase_ / PI; };
+
+  //! Set the impulse train rate in terms of a frequency in Hz.
+  void setFrequency( StkFloat frequency );
+
+  StkFloat getFrequency () { return curfreq_; };
+
+  //! Set the number of harmonics generated in the signal.
+  /*!
+    This function sets the number of harmonics contained in the
+    resulting signal.  It is equivalent to (2 * M) + 1 in the BLIT
+    algorithm.  The default value of 0 sets the algorithm for maximum
+    harmonic content (harmonics up to half the sample rate).  This
+    parameter is not checked against the current sample rate and
+    fundamental frequency.  Thus, aliasing can result if one or more
+    harmonics for a given fundamental frequency exceeds fs / 2.  This
+    behavior was chosen over the potentially more problematic solution
+    of automatically modifying the M parameter, which can produce
+    audible clicks in the signal.
+  */
+  void setHarmonics( unsigned int nHarmonics = 0 );
+
+ protected:
+
+  void updateHarmonics( void );
+  StkFloat computeSample( void );
+
+  unsigned int nHarmonics_;
+  unsigned int m_;
+  StkFloat rate_;
+  StkFloat phase_;
+  StkFloat p_;
+  StkFloat curfreq_;
+
+};
+
+#endif
diff -urN dosbox-0.73/src/gui/blit/BlitSaw.cpp dosboxcvs/src/gui/blit/BlitSaw.cpp
--- dosbox-0.73/src/gui/blit/BlitSaw.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/BlitSaw.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,132 @@
+/***************************************************/
+/*! \class BlitSaw
+    \brief STK band-limited sawtooth wave class.
+
+    This class generates a band-limited sawtooth waveform using a
+    closed-form algorithm reported by Stilson and Smith in "Alias-Free
+    Digital Synthesis of Classic Analog Waveforms", 1996.  The user
+    can specify both the fundamental frequency of the sawtooth and the
+    number of harmonics contained in the resulting signal.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Based on initial code of Robin Davies, 2005.
+    Modified algorithm code by Gary Scavone, 2005.
+*/
+/***************************************************/
+
+#include "BlitSaw.h"
+#include <cmath>
+#include <limits>
+
+BlitSaw:: BlitSaw( StkFloat frequency, StkFloat phase )
+{
+	reset(frequency, phase);
+}
+
+
+BlitSaw :: ~BlitSaw()
+{
+}
+
+void BlitSaw :: reset(StkFloat frequency, StkFloat phase) {
+	nHarmonics_ = 0; // FIXME: Possibly should outcomment this for testing
+	startphase_ = phase;
+	startfreq_ = frequency;
+	reset();
+}
+
+void BlitSaw :: reset()
+{
+  phase_ = startphase_ * PI;
+  state_ = 0.0;
+  lastOutput_ = 0;
+  this->setFrequency(startfreq_);
+}
+
+void BlitSaw :: setFrequency( StkFloat frequency )
+{
+#if defined(_STK_DEBUG_)
+  errorString_ << "BlitSaw::setFrequency: frequency = " << frequency << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+
+  p_ = Stk::sampleRate() / frequency;
+  C2_ = 1 / p_;
+  rate_ = PI * C2_;
+  this->updateHarmonics();
+}
+
+void BlitSaw :: setHarmonics( unsigned int nHarmonics )
+{
+  nHarmonics_ = nHarmonics;
+  this->updateHarmonics();
+
+  // I found that the initial DC offset could be minimized with an
+  // initial state setting as given below.  This initialization should
+  // only happen before starting the oscillator for the first time
+  // (but after setting the frequency and number of harmonics).  I
+  // struggled a bit to decide where best to put this and finally
+  // settled on here.  In general, the user shouldn't be messing with
+  // the number of harmonics once the oscillator is running because
+  // this is automatically taken care of in the setFrequency()
+  // function.  (GPS - 1 October 2005)
+  state_ = -0.5 * a_;
+}
+
+void BlitSaw :: updateHarmonics( void )
+{
+  if ( nHarmonics_ <= 0 ) {
+    unsigned int maxHarmonics = (unsigned int) floor( 0.5 * p_ );
+    m_ = 2 * maxHarmonics + 1;
+  }
+  else
+    m_ = 2 * nHarmonics_ + 1;
+
+  a_ = m_ / p_;
+
+#if defined(_STK_DEBUG_)
+  errorString_ << "BlitSaw::updateHarmonics: nHarmonics_ = " << nHarmonics_ << ", m_ = " << m_ << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+}
+
+StkFloat BlitSaw :: computeSample( void )
+{
+  // The code below implements the BLIT algorithm of Stilson and
+  // Smith, followed by a summation and filtering operation to produce
+  // a sawtooth waveform.  After experimenting with various approaches
+  // to calculate the average value of the BLIT over one period, I
+  // found that an estimate of C2_ = 1.0 / period (in samples) worked
+  // most consistently.  A "leaky integrator" is then applied to the
+  // difference of the BLIT output and C2_. (GPS - 1 October 2005)
+
+  // A fully  optimized version of this code would replace the two sin
+  // calls with a pair of fast sin oscillators, for which stable fast
+  // two-multiply algorithms are well known. In the spirit of STK,
+  // which favors clarity over performance, the optimization has
+  // not been made here.
+
+  // Avoid a divide by zero, or use of a denormalized divisor
+  // at the sinc peak, which has a limiting value of m_ / p_.
+  StkFloat denominator = sin( phase_ );
+  if ( fabs(denominator) <= std::numeric_limits<StkFloat>::epsilon() )
+    lastOutput_ = a_;
+  else {
+    lastOutput_ =  sin( m_ * phase_ );
+    lastOutput_ /= p_ * denominator;
+  }
+
+  lastOutput_ += state_ - C2_;
+  state_ = lastOutput_ * 0.995;
+
+  phase_ += rate_;
+  if ( phase_ >= PI ) phase_ -= PI;
+
+	return lastOutput_;
+}
+
diff -urN dosbox-0.73/src/gui/blit/BlitSaw.h dosboxcvs/src/gui/blit/BlitSaw.h
--- dosbox-0.73/src/gui/blit/BlitSaw.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/BlitSaw.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,88 @@
+/***************************************************/
+/*! \class BlitSaw
+    \brief STK band-limited sawtooth wave class.
+
+    This class generates a band-limited sawtooth waveform using a
+    closed-form algorithm reported by Stilson and Smith in "Alias-Free
+    Digital Synthesis of Classic Analog Waveforms", 1996.  The user
+    can specify both the fundamental frequency of the sawtooth and the
+    number of harmonics contained in the resulting signal.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Based on initial code of Robin Davies, 2005.
+    Modified algorithm code by Gary Scavone, 2005.
+*/
+/***************************************************/
+
+#ifndef STK_BLITSAW_H
+#define STK_BLITSAW_H
+
+#include "Generator.h"
+
+class BlitSaw: public Generator
+{
+ public:
+  //! Class constructor.
+  BlitSaw( StkFloat frequency = 220.0, StkFloat phase = 0.0f );
+
+  //! Class destructor.
+  ~BlitSaw();
+
+  void reinit(StkFloat frequency = 220.0, StkFloat phase = 0.0f);
+  //! Resets the oscillator state and phase to 0.
+  //NOTE:KG: Not entirely true - phase is set back to whatever phase the BlitSaw was constructed with
+  void reset();
+
+  void reset(StkFloat frequency, StkFloat phase);
+
+  //! Set the sawtooth oscillator rate in terms of a frequency in Hz.
+  void setFrequency( StkFloat frequency );
+
+  StkFloat getStartFreq() const { return startfreq_; };
+
+  //! Set the number of harmonics generated in the signal.
+  /*!
+    This function sets the number of harmonics contained in the
+    resulting signal.  It is equivalent to (2 * M) + 1 in the BLIT
+    algorithm.  The default value of 0 sets the algorithm for maximum
+    harmonic content (harmonics up to half the sample rate).  This
+    parameter is not checked against the current sample rate and
+    fundamental frequency.  Thus, aliasing can result if one or more
+    harmonics for a given fundamental frequency exceeds fs / 2.  This
+    behavior was chosen over the potentially more problematic solution
+    of automatically modifying the M parameter, which can produce
+    audible clicks in the signal.
+  */
+  void setHarmonics( unsigned int nHarmonics = 0 );
+
+  //CC: Used to get the phase so we can have our sine wave modulator
+  //for sawtooth generation work in tandem with the square wave 
+  //generator
+  float getPhase() {
+	  return (float)phase_;
+  }
+
+ protected:
+
+  void updateHarmonics( void );
+  StkFloat computeSample( void );
+
+  unsigned int nHarmonics_;
+  unsigned int m_;
+  StkFloat rate_;
+  StkFloat phase_;
+  StkFloat p_;
+  StkFloat C2_;
+  StkFloat a_;
+  StkFloat state_;
+  StkFloat startphase_;
+  StkFloat startfreq_;
+
+};
+
+#endif
diff -urN dosbox-0.73/src/gui/blit/BlitSquare.cpp dosboxcvs/src/gui/blit/BlitSquare.cpp
--- dosbox-0.73/src/gui/blit/BlitSquare.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/BlitSquare.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,122 @@
+/***************************************************/
+/*! \class BlitSquare
+    \brief STK band-limited square wave class.
+
+    This class generates a band-limited square wave signal.  It is
+    derived in part from the approach reported by Stilson and Smith in
+    "Alias-Free Digital Synthesis of Classic Analog Waveforms", 1996.
+    The algorithm implemented in this class uses a SincM function with
+    an even M value to achieve a bipolar bandlimited impulse train.
+    This signal is then integrated to achieve a square waveform.  The
+    integration process has an associated DC offset but that is
+    subtracted off the output signal.
+
+    The user can specify both the fundamental frequency of the
+    waveform and the number of harmonics contained in the resulting
+    signal.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Based on initial code of Robin Davies, 2005.
+    Modified algorithm code by Gary Scavone, 2005.
+*/
+/***************************************************/
+
+#include "BlitSquare.h"
+#include <cmath>
+#include <limits>
+ 
+BlitSquare:: BlitSquare( StkFloat frequency )
+{
+  nHarmonics_ = 0;
+  this->setFrequency( frequency );
+  this->reset();
+}
+
+BlitSquare :: ~BlitSquare()
+{
+}
+
+void BlitSquare :: reset()
+{
+  phase_ = 0.0;
+  lastOutput_ = 0;
+}
+
+void BlitSquare :: setFrequency( StkFloat frequency )
+{
+#if defined(_STK_DEBUG_)
+  errorString_ << "BlitSquare::setFrequency: frequency = " << frequency << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+
+  // By using an even value of the parameter M, we get a bipolar blit
+  // waveform at half the blit frequency.  Thus, we need to scale the
+  // frequency value here by 2.0. (GPS, 2005).
+  p_ = 2.0 * Stk::sampleRate() / frequency;
+  rate_ = PI / p_;
+  this->updateHarmonics();
+}
+
+void BlitSquare :: setHarmonics( unsigned int nHarmonics )
+{
+  nHarmonics_ = nHarmonics;
+  this->updateHarmonics();
+}
+
+void BlitSquare :: updateHarmonics( void )
+{
+  // Make sure we end up with an even value of the parameter M here.
+  if ( nHarmonics_ <= 0 ) {
+    unsigned int maxHarmonics = (unsigned int) floor( 0.5 * p_ );
+    m_ = 2 * maxHarmonics;
+  }
+  else
+    m_ = 2 * nHarmonics_;
+
+  // This offset value was derived empirically. (GPS, 2005)
+  offset_ = 1.0 - 0.5 * m_ / p_;
+
+#if defined(_STK_DEBUG_)
+  errorString_ << "BlitSquare::updateHarmonics: nHarmonics_ = " << nHarmonics_ << ", m_ = " << m_ << '.';
+  handleError( StkError::DEBUG_WARNING );
+#endif
+}
+
+StkFloat BlitSquare :: computeSample( void )
+{
+  StkFloat temp = lastOutput_;
+
+  // A fully  optimized version of this would replace the two sin calls
+  // with a pair of fast sin oscillators, for which stable fast 
+  // two-multiply algorithms are well known. In the spirit of STK,
+  // which favors clarity over performance, the optimization has 
+  // not been made here.
+
+  // Avoid a divide by zero, or use of a denomralized divisor
+  // at the sinc peak, which has a limiting value of 1.0.
+  StkFloat denominator = sin( phase_ );
+  if ( fabs( denominator )  < std::numeric_limits<StkFloat>::epsilon() ) {
+    // Inexact comparison safely distinguishes betwen *close to zero*, and *close to PI*.
+    if ( phase_ < 0.1f || phase_ > TWO_PI - 0.1f )
+      lastOutput_ = 1.0;
+    else
+      lastOutput_ = -1.0;
+  }
+  else {
+    lastOutput_ =  sin( m_ * phase_ );
+    lastOutput_ /= p_ * denominator;
+  }
+
+  lastOutput_ += temp;
+
+  phase_ += rate_;
+  if ( phase_ >= TWO_PI ) phase_ -= TWO_PI;
+    
+	return lastOutput_ - offset_;
+}
+
diff -urN dosbox-0.73/src/gui/blit/BlitSquare.h dosboxcvs/src/gui/blit/BlitSquare.h
--- dosbox-0.73/src/gui/blit/BlitSquare.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/BlitSquare.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,89 @@
+/***************************************************/
+/*! \class BlitSquare
+    \brief STK band-limited square wave class.
+
+    This class generates a band-limited square wave signal.  It is
+    derived in part from the approach reported by Stilson and Smith in
+    "Alias-Free Digital Synthesis of Classic Analog Waveforms", 1996.
+    The algorithm implemented in this class uses a SincM function with
+    an even M value to achieve a bipolar bandlimited impulse train.
+    This signal is then integrated to achieve a square waveform.  The
+    integration process has an associated DC offset but that is
+    subtracted off the output signal.
+
+    The user can specify both the fundamental frequency of the
+    waveform and the number of harmonics contained in the resulting
+    signal.
+
+    If nHarmonics is 0, then the signal will contain all harmonics up
+    to half the sample rate.  Note, however, that this setting may
+    produce aliasing in the signal when the frequency is changing (no
+    automatic modification of the number of harmonics is performed by
+    the setFrequency() function).
+
+    Based on initial code of Robin Davies, 2005.
+    Modified algorithm code by Gary Scavone, 2005.
+*/
+/***************************************************/
+
+#ifndef STK_BLITSQUARE_H
+#define STK_BLITSQUARE_H
+
+#include "Generator.h"
+
+class BlitSquare: public Generator
+{
+ public:
+  //! Default constructor that initializes BLIT frequency to 220 Hz.
+  BlitSquare( StkFloat frequency = 220.0 );
+
+  //! Class destructor.
+  ~BlitSquare();
+
+  //! Resets the oscillator state and phase to 0.
+  void reset();
+
+  //! Set the phase of the signal.
+  /*!
+    Set the phase of the signal, in the range 0 to 1.
+  */
+  void setPhase( StkFloat phase ) { phase_ = PI * phase; };
+
+  //! Get the current phase of the signal.
+  /*!
+    Get the phase of the signal, in the range [0 to 1.0).
+  */
+  StkFloat getPhase() const { return phase_ / PI; };
+
+  //! Set the impulse train rate in terms of a frequency in Hz.
+  void setFrequency( StkFloat frequency );
+
+  //! Set the number of harmonics generated in the signal.
+  /*!
+    This function sets the number of harmonics contained in the
+    resulting signal.  It is equivalent to (2 * M) + 1 in the BLIT
+    algorithm.  The default value of 0 sets the algorithm for maximum
+    harmonic content (harmonics up to half the sample rate).  This
+    parameter is not checked against the current sample rate and
+    fundamental frequency.  Thus, aliasing can result if one or more
+    harmonics for a given fundamental frequency exceeds fs / 2.  This
+    behavior was chosen over the potentially more problematic solution
+    of automatically modifying the M parameter, which can produce
+    audible clicks in the signal.
+  */
+  void setHarmonics( unsigned int nHarmonics = 0 );
+
+ protected:
+
+  void updateHarmonics( void );
+  StkFloat computeSample( void );
+
+  unsigned int nHarmonics_;
+  unsigned int m_;
+  StkFloat rate_;
+  StkFloat phase_;
+  StkFloat p_;
+  StkFloat offset_;
+};
+
+#endif
diff -urN dosbox-0.73/src/gui/blit/Generator.cpp dosboxcvs/src/gui/blit/Generator.cpp
--- dosbox-0.73/src/gui/blit/Generator.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Generator.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,54 @@
+/***************************************************/
+/*! \class Generator
+    \brief STK abstract unit generator parent class.
+
+    This class provides common functionality for
+    STK unit generator sample-source subclasses.
+
+    by Perry R. Cook and Gary P. Scavone, 1995 - 2005.
+*/
+/***************************************************/
+
+#include "Generator.h"
+
+Generator :: Generator() : Stk()
+{
+  lastOutput_ = 0.0;
+}
+
+Generator :: ~Generator()
+{
+}
+
+StkFloat Generator :: tick( void )
+{
+  return computeSample();
+}
+
+StkFrames& Generator :: tick( StkFrames& frames, unsigned int channel )
+{
+  if ( channel >= frames.channels() ) {
+    errorString_ << "Generator::tick(): channel and StkFrames arguments are incompatible!";
+    handleError( StkError::FUNCTION_ARGUMENT );
+  }
+
+  if ( frames.channels() == 1 ) {
+    for ( unsigned int i=0; i<frames.frames(); i++ )
+      frames[i] = computeSample();
+  }
+  else if ( frames.interleaved() ) {
+    unsigned int hop = frames.channels();
+    unsigned int index = channel;
+    for ( unsigned int i=0; i<frames.frames(); i++ ) {
+      frames[index] = computeSample();
+      index += hop;
+    }
+  }
+  else {
+    unsigned int iStart = channel * frames.frames();
+    for ( unsigned int i=0; i<frames.frames(); i++, iStart++ )
+      frames[iStart] = computeSample();
+  }
+
+  return frames;
+}
diff -urN dosbox-0.73/src/gui/blit/Generator.h dosboxcvs/src/gui/blit/Generator.h
--- dosbox-0.73/src/gui/blit/Generator.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Generator.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,53 @@
+/***************************************************/
+/*! \class Generator
+    \brief STK abstract unit generator parent class.
+
+    This class provides common functionality for
+    STK unit generator sample-source subclasses.
+
+    by Perry R. Cook and Gary P. Scavone, 1995 - 2005.
+*/
+/***************************************************/
+
+#ifndef STK_GENERATOR_H
+#define STK_GENERATOR_H
+
+#include "Stk.h"
+
+class Generator : public Stk
+{
+ public:
+  //! Class constructor.
+  Generator( void );
+
+  //! Class destructor.
+  virtual ~Generator( void );
+
+  //! Return the last output value.
+  virtual StkFloat lastOut( void ) const { return lastOutput_; };
+
+  //! Compute one sample and output.
+  StkFloat tick( void );
+
+  //! Fill a channel of the StkFrames object with computed outputs.
+  /*!
+    The \c channel argument should be zero or greater (the first
+    channel is specified by 0).  An StkError will be thrown if the \c
+    channel argument is equal to or greater than the number of
+    channels in the StkFrames object.
+  */
+  StkFrames& tick( StkFrames& frames, unsigned int channel = 0 );
+
+ protected:
+
+  // This abstract function must be implemented in all subclasses.
+  // It is used to get around a C++ problem with overloaded virtual
+  // functions.
+  virtual StkFloat computeSample( void ) = 0;
+
+  StkFloat lastOutput_;
+
+};
+
+#endif
+
diff -urN dosbox-0.73/src/gui/blit/Stk.cpp dosboxcvs/src/gui/blit/Stk.cpp
--- dosbox-0.73/src/gui/blit/Stk.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Stk.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,312 @@
+/***************************************************/
+/*! \class Stk
+    \brief STK base class
+
+    Nearly all STK classes inherit from this class.
+    The global sample rate can be queried and
+    modified via Stk.  In addition, this class
+    provides error handling and byte-swapping
+    functions.
+
+    by Perry R. Cook and Gary P. Scavone, 1995 - 2005.
+*/
+/***************************************************/
+
+#include <stdlib.h>
+#include "Stk.h"
+
+StkFloat Stk :: srate_ = (StkFloat) SRATE;
+std::string Stk :: rawwavepath_ = RAWWAVE_PATH;
+const Stk::StkFormat Stk :: STK_SINT8   = 0x1;
+const Stk::StkFormat Stk :: STK_SINT16  = 0x2;
+const Stk::StkFormat Stk :: STK_SINT24  = 0x4;
+const Stk::StkFormat Stk :: STK_SINT32  = 0x8;
+const Stk::StkFormat Stk :: STK_FLOAT32 = 0x10;
+const Stk::StkFormat Stk :: STK_FLOAT64 = 0x20;
+bool Stk :: showWarnings_ = false;
+bool Stk :: printErrors_ = true;
+
+Stk :: Stk(void)
+{
+}
+
+Stk :: ~Stk(void)
+{
+}
+
+void Stk :: setRawwavePath( std::string path )
+{
+  if ( !path.empty() )
+    rawwavepath_ = path;
+
+  // Make sure the path includes a "/"
+  if ( rawwavepath_[rawwavepath_.length()-1] != '/' )
+    rawwavepath_ += "/";
+}
+
+void Stk :: swap16(unsigned char *ptr)
+{
+  register unsigned char val;
+
+  // Swap 1st and 2nd bytes
+  val = *(ptr);
+  *(ptr) = *(ptr+1);
+  *(ptr+1) = val;
+}
+
+void Stk :: swap32(unsigned char *ptr)
+{
+  register unsigned char val;
+
+  // Swap 1st and 4th bytes
+  val = *(ptr);
+  *(ptr) = *(ptr+3);
+  *(ptr+3) = val;
+
+  //Swap 2nd and 3rd bytes
+  ptr += 1;
+  val = *(ptr);
+  *(ptr) = *(ptr+1);
+  *(ptr+1) = val;
+}
+
+void Stk :: swap64(unsigned char *ptr)
+{
+  register unsigned char val;
+
+  // Swap 1st and 8th bytes
+  val = *(ptr);
+  *(ptr) = *(ptr+7);
+  *(ptr+7) = val;
+
+  // Swap 2nd and 7th bytes
+  ptr += 1;
+  val = *(ptr);
+  *(ptr) = *(ptr+5);
+  *(ptr+5) = val;
+
+  // Swap 3rd and 6th bytes
+  ptr += 1;
+  val = *(ptr);
+  *(ptr) = *(ptr+3);
+  *(ptr+3) = val;
+
+  // Swap 4th and 5th bytes
+  ptr += 1;
+  val = *(ptr);
+  *(ptr) = *(ptr+1);
+  *(ptr+1) = val;
+}
+
+#if (defined(__OS_IRIX__) || defined(__OS_LINUX__) || defined(__OS_MACOSX__))
+  #include <unistd.h>
+#elif defined(__OS_WINDOWS__)
+  #include <windows.h>
+#endif
+
+void Stk :: sleep(unsigned long milliseconds)
+{
+#if defined(__OS_WINDOWS__)
+  Sleep((DWORD) milliseconds);
+#elif (defined(__OS_IRIX__) || defined(__OS_LINUX__) || defined(__OS_MACOSX__))
+  usleep( (unsigned long) (milliseconds * 1000.0) );
+#endif
+}
+
+void Stk :: handleError( StkError::Type type )
+{
+  handleError( errorString_.str(), type );
+  errorString_.str( std::string() ); // reset the ostringstream buffer
+}
+
+void Stk :: handleError( const char *message, StkError::Type type )
+{
+  std::string msg( message );
+  handleError( msg, type );
+}
+
+void Stk :: handleError( std::string message, StkError::Type type )
+{
+  if ( type == StkError::WARNING || type == StkError::STATUS ) {
+    if ( !showWarnings_ ) return;
+    std::cerr << '\n' << message << '\n' << std::endl;
+  }
+  else if (type == StkError::DEBUG_WARNING) {
+#if defined(_STK_DEBUG_)
+    std::cerr << '\n' << message << '\n' << std::endl;
+#endif
+  }
+  else {
+    if ( printErrors_ ) {
+      // Print error message before throwing.
+      std::cerr << '\n' << message << '\n' << std::endl;
+    }
+    throw StkError(message, type);
+  }
+}
+
+//
+// StkFrames definitions
+//
+
+StkFrames :: StkFrames( unsigned int nFrames, unsigned int nChannels, bool interleaved )
+  : nFrames_( nFrames ), nChannels_( nChannels ), interleaved_( interleaved )
+{
+  size_ = nFrames_ * nChannels_;
+  bufferSize_ = size_;
+
+  if ( size_ > 0 ) {
+    data_ = (StkFloat *) calloc( size_, sizeof( StkFloat ) );
+#if defined(_STK_DEBUG_)
+    if ( data_ == NULL ) {
+      std::string error = "StkFrames: memory allocation error in constructor!";
+      Stk::handleError( error, StkError::MEMORY_ALLOCATION );
+    }
+#endif
+  }
+  else data_ = 0;
+
+  dataRate_ = Stk::sampleRate();
+}
+
+StkFrames :: StkFrames( const StkFloat& value, unsigned int nFrames, unsigned int nChannels, bool interleaved )
+  : nFrames_( nFrames ), nChannels_( nChannels ), interleaved_( interleaved )
+{
+  size_ = nFrames_ * nChannels_;
+  bufferSize_ = size_;
+  if ( size_ > 0 ) {
+    data_ = (StkFloat *) malloc( size_ * sizeof( StkFloat ) );
+#if defined(_STK_DEBUG_)
+    if ( data_ == NULL ) {
+      std::string error = "StkFrames: memory allocation error in constructor!";
+      Stk::handleError( error, StkError::MEMORY_ALLOCATION );
+    }
+#endif
+    for ( long i=0; i<(long)size_; i++ ) data_[i] = value;
+  }
+  else data_ = 0;
+
+  dataRate_ = Stk::sampleRate();
+}
+
+StkFrames :: ~StkFrames()
+{
+  if ( data_ ) free( data_ );
+}
+
+bool StkFrames :: empty() const
+{
+  if ( size_ > 0 ) return false;
+  else return true;
+}
+
+void StkFrames :: resize( size_t nFrames, unsigned int nChannels )
+{
+  nFrames_ = nFrames;
+  nChannels_ = nChannels;
+
+  size_ = nFrames_ * nChannels_;
+  if ( size_ > bufferSize_ ) {
+    if ( data_ ) free( data_ );
+    data_ = (StkFloat *) malloc( size_ * sizeof( StkFloat ) );
+#if defined(_STK_DEBUG_)
+    if ( data_ == NULL ) {
+      std::string error = "StkFrames::resize: memory allocation error!";
+      Stk::handleError( error, StkError::MEMORY_ALLOCATION );
+    }
+#endif
+    bufferSize_ = size_;
+  }
+}
+
+void StkFrames :: resize( size_t nFrames, unsigned int nChannels, StkFloat value )
+{
+  this->resize( nFrames, nChannels );
+
+  for ( size_t i=0; i<size_; i++ ) data_[i] = value;
+}
+
+StkFloat& StkFrames :: operator[] ( size_t n )
+{
+#if defined(_STK_DEBUG_)
+    if ( n >= size_ ) {
+      std::ostringstream error;
+      error << "StkFrames::operator[]: invalid index (" << n << ") value!";
+      Stk::handleError( error.str(), StkError::MEMORY_ACCESS );
+    }
+#endif
+
+  return data_[n];
+}
+
+StkFloat StkFrames :: operator[] ( size_t n ) const
+{
+#if defined(_STK_DEBUG_)
+    if ( n >= size_ ) {
+      std::ostringstream error;
+      error << "StkFrames::operator[]: invalid index (" << n << ") value!";
+      Stk::handleError( error.str(), StkError::MEMORY_ACCESS );
+    }
+#endif
+
+  return data_[n];
+}
+
+StkFloat& StkFrames :: operator() ( size_t frame, unsigned int channel )
+{
+#if defined(_STK_DEBUG_)
+    if ( frame >= nFrames_ || channel >= nChannels_ ) {
+      std::ostringstream error;
+      error << "StkFrames::operator(): invalid frame (" << frame << ") or channel (" << channel << ") value!";
+      Stk::handleError( error.str(), StkError::MEMORY_ACCESS );
+    }
+#endif
+
+  if ( interleaved_ )
+    return data_[ frame * nChannels_ + channel ];
+  else
+    return data_[ channel * nFrames_ + frame ];
+}
+
+StkFloat StkFrames :: operator() ( size_t frame, unsigned int channel ) const
+{
+#if defined(_STK_DEBUG_)
+    if ( frame >= nFrames_ || channel >= nChannels_ ) {
+      std::ostringstream error;
+      error << "StkFrames::operator(): invalid frame (" << frame << ") or channel (" << channel << ") value!";
+      Stk::handleError( error.str(), StkError::MEMORY_ACCESS );
+    }
+#endif
+
+  if ( interleaved_ )
+    return data_[ frame * nChannels_ + channel ];
+  else
+    return data_[ channel * nFrames_ + frame ];
+}
+
+StkFloat StkFrames :: interpolate( StkFloat frame, unsigned int channel ) const
+{
+#if defined(_STK_DEBUG_)
+    if ( frame >= (StkFloat) nFrames_ || channel >= nChannels_ ) {
+      std::ostringstream error;
+      error << "StkFrames::interpolate: invalid frame (" << frame << ") or channel (" << channel << ") value!";
+      Stk::handleError( error.str(), StkError::MEMORY_ACCESS );
+    }
+#endif
+
+  size_t iIndex = ( size_t ) frame;                    // integer part of index
+  StkFloat output, alpha = frame - (StkFloat) iIndex;  // fractional part of index
+
+  if ( interleaved_ ) {
+    iIndex = iIndex * nChannels_ + channel;
+    output = data_[ iIndex ];
+    output += ( alpha * ( data_[ iIndex + nChannels_ ] - output ) );
+  }
+  else {
+    iIndex += channel * nFrames_;
+    output = data_[ iIndex ];
+    output += ( alpha * ( data_[ iIndex++ ] - output ) );
+  }
+
+  return output;
+}
diff -urN dosbox-0.73/src/gui/blit/Stk.h dosboxcvs/src/gui/blit/Stk.h
--- dosbox-0.73/src/gui/blit/Stk.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/blit/Stk.h	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,364 @@
+/***************************************************/
+/*! \class Stk
+    \brief STK base class
+
+    Nearly all STK classes inherit from this class.
+    The global sample rate and rawwave path variables
+    can be queried and modified via Stk.  In addition,
+    this class provides error handling and
+    byte-swapping functions.
+
+    by Perry R. Cook and Gary P. Scavone, 1995 - 2005.
+*/
+/***************************************************/
+
+#ifndef STK_STK_H
+#define STK_STK_H
+
+#include <string>
+#include <iostream>
+#include <sstream>
+
+// Most data in STK is passed and calculated with the
+// following user-definable floating-point type.  You
+// can change this to "float" if you prefer or perhaps
+// a "long double" in the future.
+typedef float StkFloat;
+
+// The "MY_FLOAT" type was deprecated in STK
+// versions higher than 4.1.3 and replaced with the variable
+// "StkFloat".  
+#if defined(__WINDOWS_DS__) || defined(__WINDOWS_ASIO__)
+  typedef StkFloat MY_FLOAT;
+  #pragma deprecated(MY_FLOAT)
+#elif defined(__GXX__) 
+  typedef StkFloat MY_FLOAT __attribute__ ((deprecated));
+#else
+  typedef StkFloat MY_FLOAT; // temporary
+#endif
+
+
+//! STK error handling class.
+/*!
+  This is a fairly abstract exception handling class.  There could
+  be sub-classes to take care of more specific error conditions ... or
+  not.
+*/
+class StkError
+{
+public:
+  enum Type {
+    STATUS,
+    WARNING,
+    DEBUG_WARNING,
+    MEMORY_ALLOCATION,
+    MEMORY_ACCESS,
+    FUNCTION_ARGUMENT,
+    FILE_NOT_FOUND,
+    FILE_UNKNOWN_FORMAT,
+    FILE_ERROR,
+    PROCESS_THREAD,
+    PROCESS_SOCKET,
+    PROCESS_SOCKET_IPADDR,
+    AUDIO_SYSTEM,
+    MIDI_SYSTEM,
+    UNSPECIFIED
+  };
+
+protected:
+  std::string message_;
+  Type type_;
+
+public:
+  //! The constructor.
+  StkError(const std::string& message, Type type = StkError::UNSPECIFIED)
+    : message_(message), type_(type) {}
+
+  //! The destructor.
+  virtual ~StkError(void) {};
+
+  //! Prints thrown error message to stderr.
+  virtual void printMessage(void) { std::cerr << '\n' << message_ << "\n\n"; }
+
+  //! Returns the thrown error message type.
+  virtual const Type& getType(void) { return type_; }
+
+  //! Returns the thrown error message string.
+  virtual const std::string& getMessage(void) { return message_; }
+
+  //! Returns the thrown error message as a C string.
+  virtual const char *getMessageCString(void) { return message_.c_str(); }
+};
+
+
+class Stk
+{
+public:
+
+  typedef unsigned long StkFormat;
+  static const StkFormat STK_SINT8;   /*!< -128 to +127 */
+  static const StkFormat STK_SINT16;  /*!< -32768 to +32767 */
+  static const StkFormat STK_SINT24;  /*!< Upper 3 bytes of 32-bit signed integer. */
+  static const StkFormat STK_SINT32;  /*!< -2147483648 to +2147483647. */
+  static const StkFormat STK_FLOAT32; /*!< Normalized between plus/minus 1.0. */
+  static const StkFormat STK_FLOAT64; /*!< Normalized between plus/minus 1.0. */
+
+  //! Static method which returns the current STK sample rate.
+  static StkFloat sampleRate(void) { return srate_; }
+
+  //! Static method which sets the STK sample rate.
+  /*!
+    The sample rate set using this method is queried by all STK
+    classes which depend on its value.  It is initialized to the
+    default SRATE set in Stk.h.  Many STK classes use the sample rate
+    during instantiation.  Therefore, if you wish to use a rate which
+    is different from the default rate, it is imperative that it be
+    set \e BEFORE STK objects are instantiated.
+  */
+  static void setSampleRate(StkFloat rate) { if (rate > 0.0) srate_ = rate; }
+
+  //! Static method which returns the current rawwave path.
+  static std::string rawwavePath(void) { return rawwavepath_; }
+
+  //! Static method which sets the STK rawwave path.
+  static void setRawwavePath(std::string path);
+
+  //! Static method which byte-swaps a 16-bit data type.
+  static void swap16(unsigned char *ptr);
+
+  //! Static method which byte-swaps a 32-bit data type.
+  static void swap32(unsigned char *ptr);
+
+  //! Static method which byte-swaps a 64-bit data type.
+  static void swap64(unsigned char *ptr);
+
+  //! Static cross-platform method to sleep for a number of milliseconds.
+  static void sleep(unsigned long milliseconds);
+
+  //! Static function for error reporting and handling using c-strings.
+  static void handleError( const char *message, StkError::Type type );
+
+  //! Static function for error reporting and handling using c++ strings.
+  static void handleError( std::string message, StkError::Type type );
+
+  //! Toggle display of WARNING and STATUS messages.
+  static void showWarnings( bool status ) { showWarnings_ = status; }
+
+  //! Toggle display of error messages before throwing exceptions.
+  static void printErrors( bool status ) { printErrors_ = status; }
+
+private:
+  static StkFloat srate_;
+  static std::string rawwavepath_;
+  static bool showWarnings_;
+  static bool printErrors_;
+
+protected:
+
+  std::ostringstream errorString_;
+
+  //! Default constructor.
+  Stk(void);
+
+  //! Class destructor.
+  virtual ~Stk(void);
+
+  //! Internal function for error reporting which assumes message in \c errorString_ variable.
+  void handleError( StkError::Type type );
+};
+
+
+/***************************************************/
+/*! \class StkFrames
+    \brief An STK class to handle vectorized audio data.
+
+    This class can hold single- or multi-channel audio data in either
+    interleaved or non-interleaved formats.  The data type is always
+    StkFloat.  In an effort to maintain efficiency, no out-of-bounds
+    checks are performed in this class.
+
+    Possible future improvements in this class could include functions
+    to inter- or de-interleave the data and to convert to and return
+    other data types.
+
+    by Perry R. Cook and Gary P. Scavone, 1995 - 2005.
+*/
+/***************************************************/
+
+class StkFrames
+{
+public:
+
+  //! The default constructor initializes the frame data structure to size zero.
+  StkFrames( unsigned int nFrames = 0, unsigned int nChannels = 0, bool interleaved = true );
+
+  //! Overloaded constructor that initializes the frame data to the specified size with \c value.
+  StkFrames( const StkFloat& value, unsigned int nFrames, unsigned int nChannels, bool interleaved = true );
+
+  //! The destructor.
+  ~StkFrames();
+
+  //! Subscript operator which returns a reference to element \c n of self.
+  /*!
+    The result can be used as an lvalue . This reference is valid
+    until the resize function is called or the array is destroyed. The
+    index \c n must be between 0 and size less one.  No range checking
+    is performed unless _STK_DEBUG_ is defined.
+  */
+  StkFloat& operator[] ( size_t n );
+
+  //! Subscript operator that returns the value at element \c n of self.
+  /*!
+    The index \c n must be between 0 and size less one.  No range
+    checking is performed unless _STK_DEBUG_ is defined.
+  */
+  StkFloat operator[] ( size_t n ) const;
+
+  //! Channel / frame subscript operator that returns a reference.
+  /*!
+    The result can be used as an lvalue. This reference is valid
+    until the resize function is called or the array is destroyed. The
+    \c frame index must be between 0 and frames() - 1.  The \c channel
+    index must be between 0 and channels() - 1.  No range checking is
+    performed unless _STK_DEBUG_ is defined.
+  */
+  StkFloat& operator() ( size_t frame, unsigned int channel );
+
+  //! Channel / frame subscript operator that returns a value.
+  /*!
+    The \c frame index must be between 0 and frames() - 1.  The \c
+    channel index must be between 0 and channels() - 1.  No range checking
+    is performed unless _STK_DEBUG_ is defined.
+  */
+  StkFloat operator() ( size_t frame, unsigned int channel ) const;
+
+  //! Return an interpolated value at the fractional frame index and channel.
+  /*!
+    This function performs linear interpolation.  The \c frame
+    index must be between 0.0 and frames() - 1.  The \c channel index
+    must be between 0 and channels() - 1.  No range checking is
+    performed unless _STK_DEBUG_ is defined.
+  */
+  StkFloat interpolate( StkFloat frame, unsigned int channel = 0 ) const;
+
+  //! Returns the total number of audio samples represented by the object.
+  size_t size() const { return size_; }; 
+
+  //! Returns \e true if the object size is zero and \e false otherwise.
+  bool empty() const;
+
+  //! Resize self to represent the specified number of channels and frames.
+  /*!
+    Changes the size of self based on the number of frames and
+    channels.  No element assignment is performed.  No memory
+    deallocation occurs if the new size is smaller than the previous
+    size.  Further, no new memory is allocated when the new size is
+    smaller or equal to a previously allocated size.
+  */
+  void resize( size_t nFrames, unsigned int nChannels = 1 );
+
+  //! Resize self to represent the specified number of channels and frames and perform element initialization.
+  /*!
+    Changes the size of self based on the number of frames and
+    channels, and assigns \c value to every element.  No memory
+    deallocation occurs if the new size is smaller than the previous
+    size.  Further, no new memory is allocated when the new size is
+    smaller or equal to a previously allocated size.
+  */
+  void resize( size_t nFrames, unsigned int nChannels, StkFloat value );
+
+  //! Return the number of channels represented by the data.
+  unsigned int channels( void ) const { return nChannels_; };
+
+  //! Return the number of sample frames represented by the data.
+  unsigned int frames( void ) const { return nFrames_; };
+
+  //! Set the sample rate associated with the StkFrames data.
+  /*!
+    By default, this value is set equal to the current STK sample
+    rate at the time of instantiation.
+   */
+  void setDataRate( StkFloat rate ) { dataRate_ = rate; };
+
+  //! Return the sample rate associated with the StkFrames data.
+  /*!
+    By default, this value is set equal to the current STK sample
+    rate at the time of instantiation.
+   */
+  StkFloat dataRate( void ) const { return dataRate_; };
+
+  //! Returns \c true if the data is in interleaved format, \c false if the data is non-interleaved.
+  bool interleaved( void ) const { return interleaved_; };
+
+  //! Set the flag to indicate whether the internal data is in interleaved (\c true) or non-interleaved (\c false) format.
+  /*!
+    Note that this function does not modify the internal data order
+    with respect to the argument value.  It simply changes the
+    indicator flag value.
+   */
+  void setInterleaved( bool isInterleaved ) { interleaved_ = isInterleaved; };
+
+private:
+
+  StkFloat *data_;
+  StkFloat dataRate_;
+  size_t nFrames_;
+  unsigned int nChannels_;
+  size_t size_;
+  size_t bufferSize_;
+  bool interleaved_;
+
+};
+
+
+// Here are a few other useful typedefs.
+typedef unsigned short UINT16;
+typedef unsigned int UINT32;
+typedef signed short SINT16;
+typedef signed int SINT32;
+typedef float FLOAT32;
+typedef double FLOAT64;
+
+// The default sampling rate.
+const StkFloat SRATE = 44100.0;
+
+// The default real-time audio input and output buffer size.  If
+// clicks are occuring in the input and/or output sound stream, a
+// larger buffer size may help.  Larger buffer sizes, however, produce
+// more latency.
+const unsigned int RT_BUFFER_SIZE = 512;
+
+// The default rawwave path value is set with the preprocessor
+// definition RAWWAVE_PATH.  This can be specified as an argument to
+// the configure script, in an integrated development environment, or
+// below.  The global STK rawwave path variable can be dynamically set
+// with the Stk::setRawwavePath() function.  This value is
+// concatenated to the beginning of all references to rawwave files in
+// the various STK core classes (ex. Clarinet.cpp).  If you wish to
+// move the rawwaves directory to a different location in your file
+// system, you will need to set this path definition appropriately.
+#if !defined(RAWWAVE_PATH)
+  #define RAWWAVE_PATH "../../rawwaves/"
+#endif
+
+const StkFloat PI           = 3.14159265358979;
+const StkFloat TWO_PI       = 2 * PI;
+const StkFloat ONE_OVER_128 = 0.0078125;
+
+#if defined(__WINDOWS_DS__) || defined(__WINDOWS_ASIO__) || defined(__WINDOWS_MM__)
+  #define __OS_WINDOWS__
+  #define __STK_REALTIME__
+#elif defined(__LINUX_OSS__) || defined(__LINUX_ALSA__) || defined(__LINUX_JACK__)
+  #define __OS_LINUX__
+  #define __STK_REALTIME__
+#elif defined(__IRIX_AL__)
+  #define __OS_IRIX__
+  #define __STK_REALTIME__
+#elif defined(__MACOSX_CORE__)
+  #define __OS_MACOSX__
+  #define __STK_REALTIME__
+#endif
+
+//#define _STK_DEBUG_
+
+#endif
diff -urN dosbox-0.73/src/gui/comb.cpp dosboxcvs/src/gui/comb.cpp
--- dosbox-0.73/src/gui/comb.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/comb.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,46 @@
+// Comb filter implementation
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#include "freeverb/comb.h"
+
+comb::comb()
+{
+	filterstore = 0;
+	bufidx = 0;
+}
+
+void comb::setbuffer(float *buf, int size)
+{
+	buffer = buf;
+	bufsize = size;
+}
+
+void comb::mute()
+{
+	for (int i=0; i<bufsize; i++)
+		buffer[i]=0;
+}
+
+void comb::setdamp(float val)
+{
+	damp1 = val;
+	damp2 = 1-val;
+}
+
+float comb::getdamp()
+{
+	return damp1;
+}
+
+void comb::setfeedback(float val)
+{
+	feedback = val;
+}
+
+float comb::getfeedback()
+{
+	return feedback;
+}
diff -urN dosbox-0.73/src/gui/.cvsignore dosboxcvs/src/gui/.cvsignore
--- dosbox-0.73/src/gui/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/gui/delayReverb.cpp dosboxcvs/src/gui/delayReverb.cpp
--- dosbox-0.73/src/gui/delayReverb.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/delayReverb.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,122 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+
+#include "mt32emu.h"
+
+#include "delayReverb.h"
+
+using namespace MT32Emu;
+
+// All in seconds
+const float RAMP_TIME = 1.0f / 88.0f; // Time taken to ramp up from 0 to desired reverb/feedback levels after parameter change
+const float BASE_DELAY = 0.0006875;
+const float LEFT_DELAY_COEF = 0.056;
+const float RIGHT_DELAY_COEF = 0.028;
+
+DelayReverb::DelayReverb() {
+	sampleRate = 0;
+	buf = NULL;
+	bufSize = 0;
+	leftDelaySeconds = 0;
+	rightDelaySeconds = 0;
+	targetReverbLevel = 0;
+	targetFeedbackLevel = 0;
+}
+
+DelayReverb::~DelayReverb() {
+	delete[] buf;
+}
+
+void DelayReverb::setSampleRate(unsigned int sampleRate) {
+	if(sampleRate != this->sampleRate) {
+		this->sampleRate = sampleRate;
+		delete[] buf;
+		// FIXME: Always 2 second buffer - we could reduce this to what we actually need after we've tweaked the parameters
+		bufSize = 2 * sampleRate;
+		buf = new float[bufSize];
+		this->rampTarget = (unsigned int)(RAMP_TIME * sampleRate);
+		reset();
+	}
+}
+
+void DelayReverb::setParameters(Bit8u mode, Bit8u time, Bit8u level) {
+	float oldLeftDelaySeconds = leftDelaySeconds;
+	float oldRightDelaySeconds = rightDelaySeconds;
+	float oldTargetReverbLevel = targetReverbLevel;
+	float oldTargetFeedbackLevel = targetFeedbackLevel;
+
+	leftDelaySeconds = BASE_DELAY + time * LEFT_DELAY_COEF;
+	rightDelaySeconds = BASE_DELAY + time * RIGHT_DELAY_COEF;
+	targetReverbLevel = level * 6.0f / 127.0f;
+	targetFeedbackLevel = 30.0f / 128.0f;
+
+	if (leftDelaySeconds != oldLeftDelaySeconds || rightDelaySeconds != oldRightDelaySeconds || targetReverbLevel != oldTargetReverbLevel || targetFeedbackLevel != oldTargetFeedbackLevel) {
+		resetParameters();
+	}
+}
+
+void DelayReverb::process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, long numSamples) {
+	for (unsigned int sampleIx = 0; sampleIx < numSamples; sampleIx++) {
+		float leftSample = inLeft[sampleIx];
+		float rightSample = inRight[sampleIx];
+
+		bufIx = (bufSize + bufIx - 1) % bufSize;
+		float reverbLeft = buf[(bufIx + leftDelay) % bufSize];
+		float reverbRight = buf[(bufIx + rightDelay) % bufSize];
+
+		outLeft[sampleIx] = (reverbLeft * reverbLevel) + leftSample;
+		outRight[sampleIx] = (reverbRight * reverbLevel) + rightSample;
+
+		buf[bufIx] = (reverbLeft * feedbackLevel) + (leftSample + rightSample) / 2.0f;
+
+		if (rampCount < rampTarget) {
+			// Linearly ramp up reverb/feedback levels over RAMP_TIME (after parameter change)
+			rampCount++;
+			if (rampCount == rampTarget) {
+				reverbLevel = targetReverbLevel;
+				feedbackLevel = targetFeedbackLevel;
+			} else {
+				reverbLevel += reverbLevelRampInc;
+				feedbackLevel += feedbackLevelRampInc;
+			}
+		}
+	}
+}
+
+void DelayReverb::reset() {
+	resetBuffer();
+	resetParameters();
+}
+
+void DelayReverb::resetBuffer() {
+	bufIx = 0;
+	if (buf != NULL) {
+		memset(buf, 0, bufSize * sizeof(float));
+	}
+}
+
+void DelayReverb::resetParameters() {
+	leftDelay = leftDelaySeconds * sampleRate;
+	rightDelay = rightDelaySeconds * sampleRate;
+
+	rampCount = 0;
+	reverbLevel = 0;
+	feedbackLevel = 0;
+	feedbackLevelRampInc = targetFeedbackLevel / rampTarget;
+	reverbLevelRampInc = targetReverbLevel / rampTarget;
+}
diff -urN dosbox-0.73/src/gui/direct3d.cpp dosboxcvs/src/gui/direct3d.cpp
--- dosbox-0.73/src/gui/direct3d.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/direct3d.cpp	2009-07-08 20:59:20.000000000 +0300
@@ -0,0 +1,1421 @@
+/*
+ *  Direct3D rendering code by gulikoza
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "dosbox.h"
+
+#if (HAVE_D3D9_H) && defined(WIN32)
+
+#include "direct3d.h"
+
+#if LOG_D3D
+#define EnterCriticalSection(x) EnterLOGCriticalSection(x, __LINE__)
+
+void CDirect3D::EnterLOGCriticalSection(LPCRITICAL_SECTION lpCriticalSection, int line)
+{
+    Bitu i = 0;
+    static int oldline = -1;
+    while(!TryEnterCriticalSection(lpCriticalSection)) {
+	i++; Sleep(0);
+	if(!(i&0xFFF)) {
+	    LOG_MSG("Possible deadlock in %u (line: %d, oldline: %d, active command: %d)", SDL_ThreadID(), line, oldline, thread_command);
+	}
+    }
+    if(i) LOG_MSG("D3D:Thread %u waited %u to enter critical section (line: %d, oldline: %d, active command: %d)", SDL_ThreadID(), i, line, oldline, thread_command);
+    oldline = line;
+}
+#endif
+
+HRESULT CDirect3D::InitializeDX(HWND wnd, bool triplebuf)
+{
+#if LOG_D3D
+    LOG_MSG("D3D:Starting Direct3D");
+#endif
+
+    // Check for display window
+    if(!wnd) {
+	MessageBox(wnd, "No display window set!", "Error", MB_OK | MB_ICONERROR);
+	return E_FAIL;
+    }
+
+    hwnd = wnd;
+
+    mhmodDX9 = LoadLibrary("d3d9.dll");
+    if(!mhmodDX9)
+	return E_FAIL;
+
+    // Set the presentation parameters
+    ZeroMemory(&d3dpp, sizeof(d3dpp));
+    d3dpp.BackBufferWidth = dwWidth;
+    d3dpp.BackBufferHeight = dwHeight;
+    d3dpp.BackBufferCount = 1;
+    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
+    d3dpp.Windowed = true;
+    d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
+    d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE; // */D3DPRESENT_INTERVAL_DEFAULT; //VSync();
+
+    if(triplebuf) {
+	LOG_MSG("D3D:Using triple buffering");
+	d3dpp.BackBufferCount = 2;
+    }
+
+    // Init Direct3D
+#ifdef D3D_THREAD
+    thread_run = true;
+    thread_command = D3D_LOADPS;
+#if LOG_D3D
+    LOG_MSG("D3D:Starting worker thread from thread: %u", SDL_ThreadID());
+#endif
+    thread = SDL_CreateThread(EntryPoint, this);
+
+    if(FAILED(Wait(true))) {
+#else
+    if(FAILED(InitD3D())) {
+#endif
+	DestroyD3D();
+	MessageBox(hwnd, "Unable to initialize DirectX9!", "Error", MB_OK | MB_ICONERROR);
+	return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+#ifdef D3D_THREAD
+// Wait for D3D to finish processing and return the result
+HRESULT CDirect3D::Wait(bool unlock) {
+    HRESULT res;
+
+    EnterCriticalSection(&cs);
+    while(thread_command != D3D_IDLE) {
+	wait = true;
+	LeaveCriticalSection(&cs);
+#if LOG_D3D
+	LOG_MSG("Waiting for D3D thread to finish processing...(command: %d)", thread_command);
+#endif
+	SDL_SemWait(thread_ack);
+	EnterCriticalSection(&cs);
+	wait = false;
+    }
+
+#if LOG_D3D
+    if(SDL_SemValue(thread_ack)) LOG_MSG("Semaphore has value: %d!", SDL_SemValue(thread_ack));
+#endif
+
+    res = thread_hr;
+    if(unlock) LeaveCriticalSection(&cs);
+    return res;
+}
+#endif
+
+#ifdef D3D_THREAD
+int CDirect3D::Start(void)
+{
+#if LOG_D3D
+    LOG_MSG("D3D:Thread %u starting, initializing D3D...", SDL_ThreadID());
+#endif
+
+    EnterCriticalSection(&cs);
+    thread_hr = InitD3D();
+    thread_command = D3D_IDLE;
+    LeaveCriticalSection(&cs);
+
+    SDL_SemPost(thread_ack);
+
+    EnterCriticalSection(&cs);
+    while(thread_run) {
+
+	HRESULT hr;
+	D3D_state tmp = thread_command;
+	LeaveCriticalSection(&cs);
+
+	if(tmp == D3D_IDLE) {
+	    SDL_SemWait(thread_sem);
+	    EnterCriticalSection(&cs);
+	    continue;
+	}
+
+	switch(tmp) {
+	    case D3D_LOADPS: hr = LoadPixelShader(); break;
+	    case D3D_RESIZE: hr = Resize3DEnvironment(); break;
+	    case D3D_LOCK: hr = LockTexture(); break;
+	    case D3D_UNLOCK: (UnlockTexture() ? hr = S_OK : hr = E_FAIL); break;
+	    case D3D_DESTROY: DestroyD3D(); // fall through
+	    default: hr = S_OK; break;
+	}
+
+	EnterCriticalSection(&cs);
+	thread_hr = hr;
+	thread_command = D3D_IDLE;
+	if(wait) {
+		LeaveCriticalSection(&cs);
+		SDL_SemPost(thread_ack);
+		EnterCriticalSection(&cs);
+	}
+    }
+
+#if LOG_D3D
+    LOG_MSG("D3D:Thread %u is finishing...", SDL_ThreadID());
+#endif
+    LeaveCriticalSection(&cs);
+
+    return 0;
+}
+#endif
+
+bool CDirect3D::LockTexture(Bit8u * & pixels,Bitu & pitch)
+{
+#ifdef D3D_THREAD
+    Wait(false);
+
+    // Locks take a bit, waiting for our thread to do it will most certainly
+    // take us waiting in the kernel mode...try to lock the texture directly...
+    if(FAILED(LockTexture())) {
+
+	// OK, let the thread do it...
+	thread_command = D3D_LOCK;
+	LeaveCriticalSection(&cs);
+	SDL_SemPost(thread_sem);
+
+	if(FAILED(Wait(false))) {
+	    LeaveCriticalSection(&cs);
+	    LOG_MSG("D3D:No texture to draw to!?");
+	    return false;
+	}
+    }
+    LeaveCriticalSection(&cs);
+#else
+    if(FAILED(LockTexture())) {
+	LOG_MSG("D3D:No texture to draw to!?");
+	return false;
+    }
+#endif
+
+    pixels=(Bit8u *)d3dlr.pBits;
+    pitch=d3dlr.Pitch;
+    return true;
+}
+
+HRESULT CDirect3D::LockTexture(void)
+{
+    // Lock the surface and write the pixels
+    static DWORD d3dflags = D3DLOCK_NO_DIRTY_UPDATE;
+lock_texture:
+    if(GCC_UNLIKELY(!lpTexture || deviceLost)) {
+	// Try to reset the device, but only when running in the worker thread
+	if((SDL_ThreadID() == SDL_GetThreadID(thread))) Resize3DEnvironment();
+	if(GCC_UNLIKELY(!lpTexture || deviceLost)) {
+	    LOG_MSG("D3D:Device is lost, locktexture() failed...");
+	    return E_FAIL;
+	}
+	// Success, continue as planned...
+    }
+    if(GCC_UNLIKELY(lpTexture->LockRect(0, &d3dlr, NULL, d3dflags) != D3D_OK)) {
+        if(d3dflags) {
+            d3dflags = 0;
+            LOG_MSG("D3D:Cannot lock texture, fallback to compatible mode");
+            goto lock_texture;
+        } else {
+            LOG_MSG("D3D:Failed to lock texture!");
+	}
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+bool CDirect3D::UnlockTexture(const Bit16u *changed)
+{
+	changedLines = changed;
+#ifdef D3D_THREAD
+	Wait(false);
+	thread_command = D3D_UNLOCK;
+	LeaveCriticalSection(&cs);
+
+	SDL_SemPost(thread_sem);
+	return true;
+#else
+	return UnlockTexture();
+#endif
+}
+
+bool CDirect3D::UnlockTexture(void)
+{
+    if(GCC_UNLIKELY(deviceLost)) return false;
+    lpTexture->UnlockRect(0);
+    RECT rect;
+    rect.left = 0;
+    rect.right = dwWidth;
+    if(!dynamic && changedLines) {
+        Bitu y = 0, index = 0;
+        while(y < dwHeight) {
+            if(!(index & 1)) {
+                y += changedLines[index];
+            } else {
+                rect.top = y;
+                rect.bottom = y + changedLines[index];
+                lpTexture->AddDirtyRect(&rect);
+                y += changedLines[index];
+            }
+            index++;
+        }
+    } else {
+        rect.top = 0; rect.bottom = dwHeight;
+        lpTexture->AddDirtyRect(&rect);
+    }
+
+    return D3DSwapBuffers();
+}
+
+HRESULT CDirect3D::InitD3D(void)
+{
+    IDirect3D9 *(APIENTRY *pDirect3DCreate9)(UINT) = (IDirect3D9 *(APIENTRY *)(UINT))GetProcAddress(mhmodDX9, "Direct3DCreate9");
+    if(!pDirect3DCreate9)
+	return E_FAIL;
+
+    // create the IDirect3D9 object
+    pD3D9 = pDirect3DCreate9(D3D_SDK_VERSION);
+    if(pD3D9 == NULL)
+	return E_FAIL;
+
+    D3DCAPS9 d3dCaps;
+    // get device capabilities
+    ZeroMemory(&d3dCaps, sizeof(d3dCaps));
+    if(FAILED(pD3D9->GetDeviceCaps(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &d3dCaps)))
+	return E_FAIL;
+
+    // get the display mode
+    D3DDISPLAYMODE d3ddm;
+    pD3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &d3ddm);
+    d3dpp.BackBufferFormat = d3ddm.Format;
+
+    HRESULT hr;
+
+    // Check if hardware vertex processing is available
+    if(d3dCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) {
+        // Create device with hardware vertex processing
+        hr = pD3D9->CreateDevice(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, hwnd,
+            D3DCREATE_HARDWARE_VERTEXPROCESSING|0x00000800L|D3DCREATE_FPU_PRESERVE, &d3dpp, &pD3DDevice9);
+    } else {
+        // Create device with software vertex processing
+        hr = pD3D9->CreateDevice(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, hwnd,
+    	    D3DCREATE_SOFTWARE_VERTEXPROCESSING|0x00000800L|D3DCREATE_FPU_PRESERVE, &d3dpp, &pD3DDevice9);
+    }
+
+    // Make sure device was created
+    if(FAILED(hr)) {
+	LOG_MSG("D3D:Unable to create D3D device!");
+	return E_FAIL;
+    }
+
+    if(FAILED(pD3D9->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3ddm.Format,
+			    0, D3DRTYPE_TEXTURE, D3DFMT_X8R8G8B8))) {
+	if(FAILED(pD3D9->CheckDeviceFormat(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, d3ddm.Format,
+			    0, D3DRTYPE_TEXTURE, D3DFMT_R5G6B5))) {
+	    DestroyD3D();
+	    MessageBox(hwnd, "Cannot find a working texture color format!", "Error", MB_OK | MB_ICONERROR);
+	    return E_FAIL;
+	}
+
+	bpp16 = true;
+	LOG_MSG("D3D:Running in 16-bit color mode");
+    }
+
+    if(d3dCaps.TextureCaps & D3DPTEXTURECAPS_SQUAREONLY) {
+#if LOG_D3D
+	LOG_MSG("D3D:Square-only textures");
+#endif
+	square = true;
+    } else {
+#if LOG_D3D
+	LOG_MSG("D3D:Non-square textures");
+#endif
+	square = false;
+    }
+
+    if(d3dCaps.TextureCaps & D3DPTEXTURECAPS_POW2) {
+        if(d3dCaps.TextureCaps & D3DPTEXTURECAPS_NONPOW2CONDITIONAL) {
+#if LOG_D3D
+	    LOG_MSG("D3D:Conditional non-pow2 texture size support");
+#endif
+	    pow2 = false;
+        } else {
+#if LOG_D3D
+	    LOG_MSG("D3D:Textures must be a power of 2 in size");
+#endif
+	    pow2 = true;
+	}
+    } else {
+#if LOG_D3D
+       LOG_MSG("D3D:Textures do not need to be a power of 2 in size");
+#endif
+       pow2 = false;
+    }
+
+    if(d3dCaps.Caps2 & D3DCAPS2_DYNAMICTEXTURES) {
+#if LOG_D3D
+	LOG_MSG("D3D:Dynamic textures supported");
+#endif
+	dynamic = true;
+    } else {
+	LOG_MSG("D3D:Dynamic textures NOT supported. Performance will suffer!");
+	dynamic = false;
+    }
+
+#if LOG_D3D
+    LOG_MSG("D3D:Max texture width: %d", d3dCaps.MaxTextureWidth);
+    LOG_MSG("D3D:Max texture height: %d", d3dCaps.MaxTextureHeight);
+#endif
+
+    if((d3dCaps.MaxTextureWidth < 1024) || (d3dCaps.MaxTextureHeight < 1024)) {
+	DestroyD3D();
+	MessageBox(hwnd, "Your card does not support large textures!", "Error", MB_OK | MB_ICONERROR);
+	return E_FAIL;
+    }
+
+#if C_D3DSHADERS
+    // allow scale2x_ps14.fx with 1.4 shaders, everything else requires 2.0
+    if(d3dCaps.PixelShaderVersion >= D3DPS_VERSION(1,4)) {
+#if LOG_D3D
+	LOG_MSG("D3D:Hardware PS version %d.%d", D3DSHADER_VERSION_MAJOR(d3dCaps.PixelShaderVersion),
+						    D3DSHADER_VERSION_MINOR(d3dCaps.PixelShaderVersion));
+#endif
+	if(d3dCaps.PixelShaderVersion == D3DPS_VERSION(1,4))
+	    LOG_MSG("D3D:Hardware PS version 1.4 detected. Most shaders probably won't work...");
+	if((d3dCaps.DevCaps & D3DDEVCAPS_HWTRANSFORMANDLIGHT) && (dynamic)) {
+	    psEnabled = true;
+	    square = true;
+	    pow2 = true;			// pow2 texture size has to be enabled as well
+	} else {
+	    LOG_MSG("D3D:Error when initializing pixel shader support. Disabling shaders.");
+	    psEnabled = false;
+	}
+    }
+    else {
+	LOG_MSG("D3D:Hardware PS version too low. Disabling support for shaders.");
+	psEnabled = false;
+    }
+#endif
+
+    DWORD		dwNumAdapterModes;
+    D3DDISPLAYMODE	DisplayMode;
+    DWORD		m;
+
+    dwNumModes = 0;
+
+    if(bpp16)
+	dwNumAdapterModes = pD3D9->GetAdapterModeCount(D3DADAPTER_DEFAULT, D3DFMT_R5G6B5);
+    else
+	dwNumAdapterModes = pD3D9->GetAdapterModeCount(D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8);
+
+    if(dwNumAdapterModes == 0) {
+	LOG_MSG("D3D:No display modes found");
+	return E_FAIL;
+    }
+
+#if LOG_D3D
+    LOG_MSG("D3D:Found %d display modes", dwNumAdapterModes);
+#endif
+    modes = (D3DDISPLAYMODE*)malloc(sizeof(D3DDISPLAYMODE)*dwNumAdapterModes);
+
+    if(!modes) {
+	LOG_MSG("D3D:Error allocating memory!");
+	DestroyD3D();
+	return E_FAIL;
+    }
+
+    for(iMode=0;iMode<dwNumAdapterModes;iMode++) {
+	// Get the display mode attributes
+	if(bpp16)
+	    pD3D9->EnumAdapterModes(D3DADAPTER_DEFAULT, D3DFMT_R5G6B5, iMode, &DisplayMode);
+	else
+	    pD3D9->EnumAdapterModes(D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8, iMode, &DisplayMode);
+
+	// Check if the mode already exists
+	for(m=0;m<dwNumModes;m++) {
+	    if((modes[m].Width == DisplayMode.Width) && (modes[m].Height == DisplayMode.Height) &&
+		(modes[m].Format == DisplayMode.Format))
+		break;
+	}
+
+	// If we found a new mode, add it to the list of modes
+	if(m==dwNumModes) {
+#if LOG_D3D
+	    LOG_MSG("D3D:Display mode: %dx%dx%d", DisplayMode.Width, DisplayMode.Height, DisplayMode.Format);
+#endif
+	    // Try to sort resolutions
+	    if(dwNumModes>0) {
+		if(((modes[m - 1].Width == DisplayMode.Width) && (modes[m - 1].Height > DisplayMode.Height)) ||
+		   (modes[m - 1].Width  > DisplayMode.Width)) {
+		    modes[m].Width  = modes[m - 1].Width;
+		    modes[m].Height = modes[m - 1].Height;
+		    modes[m].Format = modes[m - 1].Format;
+		    m--;
+		}
+	    }
+
+	    modes[m].Width       = DisplayMode.Width;
+	    modes[m].Height      = DisplayMode.Height;
+	    modes[m].Format      = DisplayMode.Format;
+	    modes[m].RefreshRate = 0;
+	    ++dwNumModes;
+	}
+    }
+
+    // Free some unused memory
+    modes = (D3DDISPLAYMODE*)realloc(modes, sizeof(D3DDISPLAYMODE)*dwNumModes);
+
+    if(!modes) {
+	LOG_MSG("D3D:Error allocating memory!");
+	DestroyD3D();
+	return E_FAIL;
+    }
+
+    dwTexHeight = 0;
+    dwTexWidth = 0;
+
+    return S_OK;
+}
+
+void CDirect3D::DestroyD3D(void)
+{
+#ifdef D3D_THREAD
+    // If running in main thread, call d3d thread to clean up...
+    if(thread == NULL) return;
+
+    if((SDL_ThreadID() != SDL_GetThreadID(thread))) {
+	Wait(false);
+	thread_command = D3D_DESTROY;
+	LeaveCriticalSection(&cs);
+	SDL_SemPost(thread_sem);
+	Wait(true);
+	return;
+    }
+#endif
+
+    InvalidateDeviceObjects();
+
+    // Delete D3D device
+    SAFE_RELEASE(pD3DDevice9);
+    SAFE_RELEASE(pD3D9);
+
+    if(modes) {
+	free(modes);
+	modes = NULL;
+    }
+}
+
+// Draw a textured quad on the back-buffer
+bool CDirect3D::D3DSwapBuffers(void)
+{
+    HRESULT hr;
+    UINT uPasses;
+
+    // begin rendering
+    pD3DDevice9->BeginScene();
+
+#if C_D3DSHADERS
+    /* PS 2.0 path */
+    if(psActive) {
+
+	// Set textures
+	if(FAILED(psEffect->SetTextures(lpTexture, lpWorkTexture1, lpWorkTexture2, lpHq2xLookupTexture))) {
+	    LOG_MSG("D3D:Failed to set PS textures");
+	    return false;
+	}
+
+	if(preProcess) {
+
+	    // Set preprocess matrices
+	    if(FAILED(psEffect->SetMatrices(m_matPreProj, m_matPreView, m_matPreWorld))) {
+		LOG_MSG("D3D:Set matrices failed.");
+		return false;
+	    }
+
+	    // Save render target
+	    LPDIRECT3DSURFACE9 lpRenderTarget;
+	    pD3DDevice9->GetRenderTarget(0, &lpRenderTarget);
+	    LPDIRECT3DTEXTURE9 lpWorkTexture = lpWorkTexture1;
+pass2:
+	    // Change the render target
+	    LPDIRECT3DSURFACE9 lpNewRenderTarget;
+	    lpWorkTexture->GetSurfaceLevel(0, &lpNewRenderTarget);
+
+	    if(FAILED(pD3DDevice9->SetRenderTarget(0, lpNewRenderTarget))) {
+		LOG_MSG("D3D:Failed to set render target");
+		return false;
+	    }
+
+	    SAFE_RELEASE(lpNewRenderTarget);
+
+	    uPasses = 0;
+	    if(FAILED(psEffect->Begin((lpWorkTexture==lpWorkTexture1) ?
+		    (ScalingEffect::Preprocess1):(ScalingEffect::Preprocess2), &uPasses))) {
+		LOG_MSG("D3D:Failed to begin PS");
+		return false;
+	    }
+
+    	    for(UINT uPass=0;uPass<uPasses;uPass++) {
+		hr=psEffect->BeginPass(uPass);
+		if(FAILED(hr)) {
+		    LOG_MSG("D3D:Failed to begin pass %d", uPass);
+		    return false;
+		}
+
+		// Render the vertex buffer contents
+		pD3DDevice9->DrawPrimitive(D3DPT_TRIANGLESTRIP, 4, 2);
+		psEffect->EndPass();
+	    }
+
+	    if(FAILED(psEffect->End())) {
+		LOG_MSG("D3D:Failed to end effect");
+		return false;
+	    }
+
+#if DEBUG_PS
+	    // Save rendertarget data
+	    LPDIRECT3DSURFACE9 lpTexRenderTarget;
+	    lpWorkTexture->GetSurfaceLevel(0, &lpTexRenderTarget);
+	    lpDebugTexture->GetSurfaceLevel(0, &lpNewRenderTarget);
+	    if(FAILED(hr=pD3DDevice9->GetRenderTargetData(lpTexRenderTarget, lpNewRenderTarget))) {
+		LOG_MSG("D3D:Unable to get render target data: 0x%x", hr);
+		SAFE_RELEASE(lpTexRenderTarget);
+		SAFE_RELEASE(lpNewRenderTarget);
+	    } else {
+		D3DLOCKED_RECT d3dlr;
+		SAFE_RELEASE(lpTexRenderTarget);
+		SAFE_RELEASE(lpNewRenderTarget);
+		LOG_MSG("D3D:Got render target data, writing debug file (%dx%d)", dwTexWidth, dwTexHeight);
+		lpDebugTexture->LockRect(0, &d3dlr, NULL, D3DLOCK_READONLY);
+		FILE * debug = fopen(((lpWorkTexture==lpWorkTexture1)?"pass1.raw":"pass2.raw"), "wb");
+		if(debug == NULL) {
+		    LOG_MSG("D3D:Unable to create file!");
+		} else {
+		    for(int i = 0; i < dwTexHeight; i++) {
+			Bit8u * ptr = (Bit8u*)d3dlr.pBits;
+			for(int j = 0; j < dwTexWidth; j++) {
+			    fwrite(ptr, 3, sizeof(char), debug);
+			    ptr += 4;
+			}
+			d3dlr.pBits = (Bit8u*)d3dlr.pBits + d3dlr.Pitch;
+		    }
+		    fclose(debug);
+		}
+		lpDebugTexture->UnlockRect(0);
+	    }
+#endif
+
+	    if((psEffect->hasPreprocess2()) && (lpWorkTexture == lpWorkTexture1)) {
+		lpWorkTexture = lpWorkTexture2;
+		goto pass2;
+	    }
+
+	    // Reset the rendertarget
+	    pD3DDevice9->SetRenderTarget(0, lpRenderTarget);
+	    SAFE_RELEASE(lpRenderTarget);
+
+	    // Set matrices for final pass
+	    if(FAILED(psEffect->SetMatrices(m_matProj, m_matView, m_matWorld))) {
+		LOG_MSG("D3D:Set matrices failed.");
+		return false;
+	    }
+	}
+
+	uPasses = 0;
+
+	if(FAILED(psEffect->Begin(ScalingEffect::Combine, &uPasses))) {
+	    LOG_MSG("D3D:Failed to begin PS");
+	    return false;
+	}
+
+	for(UINT uPass=0;uPass<uPasses;uPass++) {
+	    hr=psEffect->BeginPass(uPass);
+	    if(FAILED(hr)) {
+		LOG_MSG("D3D:Failed to begin pass %d", uPass);
+		return false;
+	    }
+
+	    // Render the vertex buffer contents
+	    pD3DDevice9->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
+	    psEffect->EndPass();
+	}
+
+	if(FAILED(psEffect->End())) {
+	    LOG_MSG("D3D:Failed to end effect");
+	    return false;
+	}
+
+    } else
+#endif
+    {
+	// Normal path
+	pD3DDevice9->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
+    }
+
+    // end rendering
+    pD3DDevice9->EndScene();
+
+    if(GCC_UNLIKELY(hr=pD3DDevice9->Present(NULL, NULL, NULL, NULL)) != D3D_OK) {
+	switch(hr) {
+	    case D3DERR_DEVICELOST:
+		// This will be handled when SDL catches alt-tab and resets GFX
+		return true;
+		break;
+	    case D3DERR_DRIVERINTERNALERROR:
+		LOG_MSG("D3D:Driver internal error");
+		return false;
+		break;
+	    case D3DERR_INVALIDCALL:
+	    default:
+		LOG_MSG("D3D:Invalid call");
+		return false;
+		break;
+	}
+    }
+
+    return true;
+}
+
+HRESULT CDirect3D::InvalidateDeviceObjects(void)
+{
+    SAFE_RELEASE(lpTexture);
+#if C_D3DSHADERS
+    SAFE_RELEASE(lpWorkTexture1);
+    SAFE_RELEASE(lpWorkTexture2);
+    SAFE_RELEASE(lpHq2xLookupTexture);
+#if LOG_D3D
+    SAFE_RELEASE(lpDebugTexture);
+#endif
+
+    // Delete pixel shader
+    if(psEffect) {
+	delete psEffect;
+	psEffect = NULL;
+    }
+#endif
+
+    // clear stream source
+    if(pD3DDevice9)
+	pD3DDevice9->SetStreamSource(0, NULL, 0, 0);
+
+    SAFE_RELEASE(vertexBuffer);
+
+    return S_OK;
+}
+
+HRESULT CDirect3D::RestoreDeviceObjects(void)
+{
+    unsigned int vertexbuffersize = sizeof(TLVERTEX) * 4;
+    preProcess = false;
+
+#if C_D3DSHADERS
+    if(psActive) {
+	// Set up pixel shaders
+	psEffect = new ScalingEffect(pD3DDevice9);
+
+#if LOG_D3D
+	LOG_MSG("D3D:Loading pixel shader from %s", pshader);
+#endif
+
+	if(FAILED(psEffect->LoadEffect(pshader)) || FAILED(psEffect->Validate())) {
+	    LOG_MSG("D3D:Pixel shader error:\n%s", psEffect->getErrors());
+	    LOG_MSG("D3D:Pixel shader output disabled");
+	    delete psEffect;
+	    psEffect = NULL;
+	    psActive = false;
+	    pshader[8] = '\0';
+	} else if(psEffect->hasPreprocess()) {
+#if LOG_D3D
+	    LOG_MSG("D3D:Pixel shader preprocess active");
+#endif
+	    preProcess = true;
+	    vertexbuffersize = sizeof(TLVERTEX) * 8;
+	}
+    }
+#endif
+    // Initialize vertex
+    pD3DDevice9->SetFVF(D3DFVF_TLVERTEX);
+
+    // Create vertex buffer
+    if(FAILED(pD3DDevice9->CreateVertexBuffer(vertexbuffersize, D3DUSAGE_WRITEONLY,
+    	D3DFVF_TLVERTEX, D3DPOOL_MANAGED, &vertexBuffer, NULL))) {
+	LOG_MSG("D3D:Failed to create Vertex Buffer");
+	return E_FAIL;
+    }
+
+    // Lock vertex buffer and set vertices
+    CreateVertex();
+
+    pD3DDevice9->SetStreamSource(0, vertexBuffer, 0, sizeof(TLVERTEX));
+
+    // Turn off culling
+    pD3DDevice9->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
+
+    // Turn off D3D lighting
+    pD3DDevice9->SetRenderState(D3DRS_LIGHTING, false);
+
+    // Turn off the zbuffer
+    pD3DDevice9->SetRenderState(D3DRS_ZENABLE, false);
+
+    CreateDisplayTexture();
+    SetupSceneScaled();
+
+    if(!psActive) {
+	pD3DDevice9->SetTexture(0, lpTexture);
+
+	// Disable Shaders
+	pD3DDevice9->SetVertexShader(0);
+	pD3DDevice9->SetPixelShader(0);
+
+	pD3DDevice9->SetTransform(D3DTS_PROJECTION, &m_matProj);
+	pD3DDevice9->SetTransform(D3DTS_VIEW, &m_matView);
+	pD3DDevice9->SetTransform(D3DTS_WORLD, &m_matWorld);
+    }
+#if C_D3DSHADERS
+    else {
+	if(preProcess) {
+    	    // Projection is (0,0,0) -> (1,1,1)
+	    D3DXMatrixOrthoOffCenterLH(&m_matPreProj, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f);
+
+	    // Align texels with pixels
+	    D3DXMatrixTranslation(&m_matPreView, -0.5f/dwTexWidth, 0.5f/dwTexHeight, 0.0f);
+
+	    // Identity for world
+	    D3DXMatrixIdentity(&m_matPreWorld);
+
+	} else if(FAILED(psEffect->SetMatrices(m_matProj, m_matView, m_matWorld))) {
+	    LOG_MSG("D3D:Set matrices failed.");
+	    InvalidateDeviceObjects();
+	    return E_FAIL;
+	}
+    }
+#endif
+
+    return S_OK;
+}
+
+HRESULT CDirect3D::LoadPixelShader(const char * shader, double scalex, double scaley)
+{
+    if(!psEnabled) {
+	psActive = false;
+	return E_FAIL;
+    }
+
+#if C_D3DSHADERS
+    // See if the shader is already running
+    if((!psEffect) || (strcmp(pshader+8, shader))) {
+
+	strncpy(pshader+8, shader, 22); pshader[29] = '\0';
+#ifdef D3D_THREAD
+	Wait(false);
+	thread_command = D3D_LOADPS;
+	LeaveCriticalSection(&cs);
+	SDL_SemPost(thread_sem);
+
+	if(FAILED(Wait(true))) return E_FAIL;
+#else
+	if(FAILED(LoadPixelShader())) return E_FAIL;
+#endif
+
+    }
+#if LOG_D3D
+    else {
+	LOG_MSG("D3D:Shader %s is already loaded", shader);
+    }
+#endif
+
+#if LOG_D3D
+    LOG_MSG("D3D:Shader scale: %.2f", psEffect->getScale());
+#endif
+    // Compare optimal scaling factor
+    bool dblgfx=((scalex < scaley ? scalex : scaley) >= psEffect->getScale());
+
+    if(dblgfx) {
+	LOG_MSG("D3D:Pixel shader %s active", shader);
+	psActive = true;
+	return S_OK;
+    } else {
+	LOG_MSG("D3D:Pixel shader not needed");
+	psActive = false;
+	return E_FAIL;
+    }
+
+#endif // C_D3DSHADERS
+
+    return S_OK;
+}
+
+HRESULT CDirect3D::LoadPixelShader(void)
+{
+#if C_D3DSHADERS
+    // Load new shader
+    if(psEffect) {
+	delete psEffect;
+	psEffect = NULL;
+    }
+
+    if(!strcmp(pshader+8, "none")) {
+	psActive = false;
+	return E_FAIL;
+    }
+
+    psEffect = new ScalingEffect(pD3DDevice9);
+
+#if LOG_D3D
+    LOG_MSG("D3D:Loading pixel shader from %s", pshader);
+#endif
+
+    if(FAILED(psEffect->LoadEffect(pshader)) || FAILED(psEffect->Validate())) {
+	LOG_MSG("D3D:Error in pixel shader %s", psEffect->getErrors());
+	LOG_MSG("D3D:Pixel shader output disabled");
+	delete psEffect;
+	psEffect = NULL;
+	psActive = false;
+	pshader[8] = '\0';
+	return E_FAIL;
+    }
+
+#endif // C_D3DSHADERS
+
+    return S_OK;
+}
+
+HRESULT CDirect3D::Resize3DEnvironment(Bitu width, Bitu height, Bitu rwidth, Bitu rheight, bool fullscreen)
+{
+#if LOG_D3D
+    LOG_MSG("D3D:Resizing D3D screen...");
+#endif
+
+#ifdef D3D_THREAD
+    Wait(true);
+#endif
+
+    // set the presentation parameters
+    d3dpp.BackBufferWidth = width;
+    d3dpp.BackBufferHeight = height;
+
+    if(fullscreen) {
+	// Find correct display mode
+	bool fullscreen_ok = false;
+
+	for(iMode=0;iMode<dwNumModes;iMode++) {
+	    if((modes[iMode].Width >= width) && (modes[iMode].Height >= height)) {
+		d3dpp.BackBufferWidth = modes[iMode].Width;
+		d3dpp.BackBufferHeight = modes[iMode].Height;
+		fullscreen_ok = true;
+
+		// Some cards no longer support 320xXXX resolutions,
+		// even if they list them as supported. In this case
+		// the card will silently switch to 640xXXX, leaving black
+		// borders around displayed picture. Using hardware scaling
+		// to 640xXXX doesn't cost anything in this case and should
+		// look exactly the same as 320xXXX.
+		if(d3dpp.BackBufferWidth < 512) {
+			d3dpp.BackBufferWidth *= 2;
+			d3dpp.BackBufferHeight *= 2;
+			width *= 2; height *= 2;
+		}
+		break;
+	    }
+	}
+
+	if(!fullscreen_ok) {
+	    LOG_MSG("D3D:No suitable fullscreen mode found!");
+	    //d3dpp.Windowed = !d3dpp.Windowed;
+	}
+    }
+
+    dwScaledWidth = width;
+    dwScaledHeight = height;
+
+    dwWidth = rwidth;
+    dwHeight = rheight;
+
+#if LOG_D3D
+    LOG_MSG("D3D:Resolution set to %dx%d%s", d3dpp.BackBufferWidth, d3dpp.BackBufferHeight, fullscreen ? ", fullscreen" : "");
+#endif
+
+#ifdef D3D_THREAD
+    EnterCriticalSection(&cs);
+    thread_command = D3D_RESIZE;
+    LeaveCriticalSection(&cs);
+    SDL_SemPost(thread_sem);
+
+    return Wait(true);
+#else
+    return Resize3DEnvironment();
+#endif
+}
+
+HRESULT CDirect3D::Resize3DEnvironment(void)
+{
+    // Release all vidmem objects
+    HRESULT hr;
+
+#if LOG_D3D
+    LOG_MSG("D3D:Resize3DEnvironment() called");
+#endif
+
+    if(FAILED(hr=InvalidateDeviceObjects())) {
+	LOG_MSG("D3D:Failed to invalidate objects");
+	return hr;
+    }
+
+    // Reset the device
+reset_device:
+    Bitu i = 20;
+    // Don't bother too much, when device is already lost
+    if(deviceLost) i = 5;
+    deviceLost = false;
+
+    if(FAILED(hr=pD3DDevice9->Reset(&d3dpp))) {
+	if(hr==D3DERR_DEVICELOST) {
+	    while((hr=pD3DDevice9->TestCooperativeLevel()) != D3DERR_DEVICENOTRESET) {
+		if(hr==D3DERR_DRIVERINTERNALERROR) {
+		    LOG_MSG("D3D:Driver internal error when resetting device!");
+		    return hr;
+		}
+#if LOG_D3D
+		LOG_MSG("D3D:Wait for D3D device to become available...");
+#endif
+		Sleep(50); i--;
+		if(i == 0) {
+		    deviceLost = true;
+#if LOG_D3D
+		    LOG_MSG("D3D:Giving up on D3D wait...");
+#endif
+		    // Return ok or dosbox will quit, we'll try to reset the device later
+		    return S_OK;
+		}
+	    }
+#if LOG_D3D
+	    LOG_MSG("D3D:Performing another reset...");
+#endif
+	    goto reset_device;
+	} else {
+	    LOG_MSG("D3D:Failed to reset device!");
+	    return hr;
+	}
+    }
+
+    // Clear all backbuffers
+    pD3DDevice9->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
+
+    pD3DDevice9->Present(NULL, NULL, NULL, NULL);
+    pD3DDevice9->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
+
+    if(d3dpp.BackBufferCount == 2) {
+	pD3DDevice9->Present(NULL, NULL, NULL, NULL);
+	pD3DDevice9->Clear(0, NULL, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 0, 0), 1.0f, 0);
+    }
+
+#if LOG_D3D
+    LOG_MSG("D3D:Mode: %dx%d (x %.2fx%.2f) --> scaled size: %dx%d", dwWidth, dwHeight,
+		    (float)dwScaledWidth/dwWidth, (float)dwScaledHeight/dwHeight, dwScaledWidth, dwScaledHeight);
+#endif
+
+    return RestoreDeviceObjects();
+}
+
+HRESULT CDirect3D::CreateDisplayTexture(void)
+{
+    SAFE_RELEASE(lpTexture);
+
+    if((dwTexWidth == 0) || (dwTexHeight == 0))
+	return S_OK;
+
+#if LOG_D3D
+    LOG_MSG("D3D:Creating Textures: %dx%d", dwTexWidth, dwTexHeight);
+#endif
+
+    HRESULT hr;
+
+    D3DFORMAT d3dtexformat;
+
+    if(bpp16)
+	d3dtexformat = D3DFMT_R5G6B5;
+    else
+	d3dtexformat = D3DFMT_X8R8G8B8;
+
+    if(!dynamic) {
+	if(FAILED(hr=pD3DDevice9->CreateTexture(dwTexWidth, dwTexHeight, 1, 0, d3dtexformat,
+                                D3DPOOL_MANAGED, &lpTexture, NULL))) {
+	    LOG_MSG("D3D:Failed to create texture: 0x%x", hr);
+
+	    switch(hr) {
+	    case D3DERR_INVALIDCALL:
+		LOG_MSG("D3D:Invalid call");
+		break;
+	    case D3DERR_OUTOFVIDEOMEMORY:
+		LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+		break;
+	    case E_OUTOFMEMORY:
+		LOG_MSG("D3D:E_OUTOFMEMORY");
+		break;
+	    default:
+		LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+	return S_OK;
+    }
+
+    if(FAILED(hr=pD3DDevice9->CreateTexture(dwTexWidth, dwTexHeight, 1, D3DUSAGE_DYNAMIC, d3dtexformat,
+			    D3DPOOL_DEFAULT, &lpTexture, NULL))) {
+	LOG_MSG("D3D:Failed to create dynamic texture: 0x%x", hr);
+
+	switch(hr) {
+	case D3DERR_INVALIDCALL:
+	    LOG_MSG("D3D:Invalid call");
+	    break;
+	case D3DERR_OUTOFVIDEOMEMORY:
+	    LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+	    break;
+	case E_OUTOFMEMORY:
+	    LOG_MSG("D3D:E_OUTOFMEMORY");
+	    break;
+	default:
+	    LOG_MSG("D3D:E_UNKNOWN");
+	}
+	return E_FAIL;
+    }
+
+#if C_D3DSHADERS
+    if(psActive) {
+	// Working textures for pixel shader
+	if(FAILED(hr=pD3DDevice9->CreateTexture(dwTexWidth, dwTexHeight, 1, D3DUSAGE_RENDERTARGET,
+			    D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &lpWorkTexture1, NULL))) {
+	    LOG_MSG("D3D:Failed to create working texture: 0x%x", hr);
+
+	    switch(hr) {
+	    case D3DERR_INVALIDCALL:
+	        LOG_MSG("D3D:Invalid call");
+		break;
+    	    case D3DERR_OUTOFVIDEOMEMORY:
+		LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+		break;
+	    case E_OUTOFMEMORY:
+		LOG_MSG("D3D:E_OUTOFMEMORY");
+		break;
+	    default:
+		LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+	if(FAILED(hr=pD3DDevice9->CreateTexture(dwTexWidth, dwTexHeight, 1, D3DUSAGE_RENDERTARGET,
+			    D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &lpWorkTexture2, NULL))) {
+	    LOG_MSG("D3D:Failed to create working texture: 0x%x", hr);
+
+	    switch(hr) {
+	    case D3DERR_INVALIDCALL:
+	        LOG_MSG("D3D:Invalid call");
+		break;
+    	    case D3DERR_OUTOFVIDEOMEMORY:
+		LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+		break;
+	    case E_OUTOFMEMORY:
+		LOG_MSG("D3D:E_OUTOFMEMORY");
+		break;
+	    default:
+		LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+	if(FAILED(hr=pD3DDevice9->CreateVolumeTexture(256, 16, 256, 1, 0, D3DFMT_A8R8G8B8,
+			    D3DPOOL_MANAGED, &lpHq2xLookupTexture, NULL))) {
+	    LOG_MSG("D3D:Failed to create volume texture: 0x%x", hr);
+
+	    switch(hr) {
+	    case D3DERR_INVALIDCALL:
+	        LOG_MSG("D3D:Invalid call");
+		break;
+    	    case D3DERR_OUTOFVIDEOMEMORY:
+		LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+		break;
+	    case E_OUTOFMEMORY:
+		LOG_MSG("D3D:E_OUTOFMEMORY");
+		break;
+	    default:
+		LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+	// build lookup table
+	D3DLOCKED_BOX lockedBox;
+
+	if(FAILED(hr = lpHq2xLookupTexture->LockBox(0, &lockedBox, NULL, 0))) {
+	    LOG_MSG("D3D:Failed to lock box of volume texture: 0x%x", hr);
+
+	    switch(hr) {
+		case D3DERR_INVALIDCALL:
+		    LOG_MSG("D3D:Invalid call");
+		    break;
+		default:
+		    LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+	BuildHq2xLookupTexture(dwScaledWidth, dwScaledHeight, dwWidth, dwHeight, (Bit8u *)lockedBox.pBits);
+
+#if LOG_D3D
+	// Debug: Write look-up texture to file
+	int fd = _open("hq2xLookupTexture.pam",_O_WRONLY|_O_CREAT|_O_TRUNC|_O_BINARY,0666);
+	unsigned char table[4096] = HQ2X_D3D_TABLE_DATA;
+	sprintf((char *)table,"P7\nWIDTH %i\nHEIGHT %i\nMAXVAL 255\nDEPTH 4\nTUPLTYPE RGB_ALPHA\nENDHDR\n",16*HQ2X_RESOLUTION,4096/16*HQ2X_RESOLUTION);
+	write(fd,table,strlen((char *)table));
+	write(fd, lockedBox.pBits, HQ2X_RESOLUTION * HQ2X_RESOLUTION * 4096 * 4);
+	_close(fd);
+#endif
+
+	if(FAILED(hr = lpHq2xLookupTexture->UnlockBox(0))) {
+	    LOG_MSG("D3D:Failed to unlock box of volume texture: 0x%x", hr);
+
+	    switch(hr) {
+		case D3DERR_INVALIDCALL:
+		    LOG_MSG("D3D:Invalid call");
+		    break;
+		default:
+		    LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+
+#if LOG_D3D
+	// Debug texture for pixel shader
+	if(FAILED(hr=pD3DDevice9->CreateTexture(dwTexWidth, dwTexHeight, 1, 0, D3DFMT_A8R8G8B8,
+			    D3DPOOL_SYSTEMMEM, &lpDebugTexture, NULL))) {
+	    LOG_MSG("D3D:Failed to create debug texture: 0x%x", hr);
+
+	    switch(hr) {
+	    case D3DERR_INVALIDCALL:
+	        LOG_MSG("D3D:Invalid call");
+		break;
+    	    case D3DERR_OUTOFVIDEOMEMORY:
+		LOG_MSG("D3D:D3DERR_OUTOFVIDEOMEMORY");
+		break;
+	    case E_OUTOFMEMORY:
+		LOG_MSG("D3D:E_OUTOFMEMORY");
+		break;
+	    default:
+		LOG_MSG("D3D:E_UNKNOWN");
+	    }
+	    return E_FAIL;
+	}
+#endif	// LOG_D3D
+
+    }
+#endif	// C_D3DSHADERS
+
+    return S_OK;
+}
+
+HRESULT CDirect3D::CreateVertex(void)
+{
+    TLVERTEX* vertices;
+
+    // Texture coordinates
+    float sizex=1.0f, sizey=1.0f;
+
+    // If texture is larger than DOSBox FB
+    if(dwTexWidth != dwWidth)
+	sizex = (float)dwWidth/dwTexWidth;
+    if(dwTexHeight != dwHeight)
+	sizey = (float)dwHeight/dwTexHeight;
+
+#if LOG_D3D
+    LOG_MSG("D3D:Quad size: %dx%d, tex. coord.: 0,0-->%.2f,%.2f", dwWidth, dwHeight, sizex, sizey);
+#endif
+
+    // Lock the vertex buffer
+    vertexBuffer->Lock(0, 0, (void**)&vertices, 0);
+
+    //Setup vertices
+    vertices[0].position = D3DXVECTOR3(-0.5f, -0.5f, 0.0f);
+    vertices[0].diffuse  = 0xFFFFFFFF;
+    vertices[0].texcoord = D3DXVECTOR2( 0.0f,  sizey);
+    vertices[1].position = D3DXVECTOR3(-0.5f,  0.5f, 0.0f);
+    vertices[1].diffuse  = 0xFFFFFFFF;
+    vertices[1].texcoord = D3DXVECTOR2( 0.0f,  0.0f);
+    vertices[2].position = D3DXVECTOR3( 0.5f, -0.5f, 0.0f);
+    vertices[2].diffuse  = 0xFFFFFFFF;
+    vertices[2].texcoord = D3DXVECTOR2( sizex, sizey);
+    vertices[3].position = D3DXVECTOR3( 0.5f,  0.5f, 0.0f);
+    vertices[3].diffuse  = 0xFFFFFFFF;
+    vertices[3].texcoord = D3DXVECTOR2( sizex, 0.0f);
+
+    // Additional vertices required for some PS effects
+    if(preProcess) {
+	vertices[4].position = D3DXVECTOR3( 0.0f, 0.0f, 0.0f);
+	vertices[4].diffuse  = 0xFFFFFF00;
+	vertices[4].texcoord = D3DXVECTOR2( 0.0f, 1.0f);
+	vertices[5].position = D3DXVECTOR3( 0.0f, 1.0f, 0.0f);
+	vertices[5].diffuse  = 0xFFFFFF00;
+	vertices[5].texcoord = D3DXVECTOR2( 0.0f, 0.0f);
+	vertices[6].position = D3DXVECTOR3( 1.0f, 0.0f, 0.0f);
+	vertices[6].diffuse  = 0xFFFFFF00;
+	vertices[6].texcoord = D3DXVECTOR2( 1.0f, 1.0f);
+	vertices[7].position = D3DXVECTOR3( 1.0f, 1.0f, 0.0f);
+	vertices[7].diffuse  = 0xFFFFFF00;
+	vertices[7].texcoord = D3DXVECTOR2( 1.0f, 0.0f);
+    }
+
+    // Unlock the vertex buffer
+    vertexBuffer->Unlock();
+
+    return S_OK;
+}
+
+void CDirect3D::SetupSceneScaled(void)
+{
+    unsigned char x=1, y=1;
+    double sizex,sizey,ratio;
+
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE);
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE);
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
+    pD3DDevice9->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
+    pD3DDevice9->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_POINT);
+    pD3DDevice9->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_POINT);
+    pD3DDevice9->SetSamplerState(0, D3DSAMP_MIPFILTER, D3DTEXF_NONE);
+
+    D3DVIEWPORT9 Viewport;
+    pD3DDevice9->GetViewport(&Viewport);
+
+    // Projection is screenspace coords
+    D3DXMatrixOrthoOffCenterLH(&m_matProj, 0.0f, (float)Viewport.Width, 0.0f, (float)Viewport.Height, 0.0f, 1.0f);
+
+    // View matrix does offset
+    // A -0.5f modifier is applied to vertex coordinates to match texture
+    // and screen coords. Some drivers may compensate for this
+    // automatically, but on others texture alignment errors are introduced
+    // More information on this can be found in the Direct3D 9 documentation
+    D3DXMatrixTranslation(&m_matView, (float)Viewport.Width/2-0.5f, (float)Viewport.Height/2+0.5f, 0.0f);
+
+    // World View does scaling
+    sizex = dwScaledWidth;
+    sizey = dwScaledHeight;
+
+    // aspect = -1 when in window mode
+    if((aspect > -1) && (dwWidth > 0) && (dwHeight > 0)) {
+	if(aspect == 0) {
+
+	    // Do only integer scaling to avoid blurring
+	    x = (Bitu)dwScaledWidth/dwWidth;
+	    y = (Bitu)dwScaledHeight/dwHeight;
+
+	    ratio = (double)(dwWidth*x)/(dwHeight*y);
+#if LOG_D3D
+	    LOG_MSG("D3D:Image aspect ratio is: %f (%dx%d)", ratio, x, y);
+#endif
+
+	    // Ajdust width
+	    sizey = 4.0/3.0;
+	    while(x > 1) {
+		sizex = (double)(dwWidth*(x-1))/(dwHeight*y);
+		if(fabs(sizex - sizey) > fabs(ratio - sizey)) {
+		    break;
+		} else {
+		    x--;
+		    ratio = sizex;
+		}
+#if LOG_D3D
+		LOG_MSG("D3D:X adjust, new aspect ratio is: %f (%dx%d)", ratio, x, y);
+#endif
+	    }
+
+	    // Adjust height
+	    while(y > 1) {
+		sizex = (double)(dwWidth*x)/(dwHeight*(y-1));
+		if(fabs(sizex - sizey) > fabs(ratio - sizey)) {
+		    break;
+		} else {
+		    y--;
+		    ratio = sizex;
+		}
+#if LOG_D3D
+		LOG_MSG("D3D:Y adjust, new aspect ratio is: %f (%dx%d)", ratio, x, y);
+#endif
+	    }
+
+	    sizex = dwWidth*x;
+	    sizey = dwHeight*y;
+
+	} else if(aspect == 1) {
+
+	    // We'll try to make the image as close as possible to 4:3
+	    // (square pixels assumed (as in lcd not crt))
+#if LOG_D3D
+	    LOG_MSG("D3D:Scaling image to 4:3");
+#endif
+	    ratio = 4.0/3.0;
+
+	    if(sizex*3 > sizey*4)
+		sizex = sizey*ratio;
+	    else if(sizex*3 < sizey*4)
+		sizey = sizex/ratio;
+
+	}
+    }
+
+#if LOG_D3D
+    LOG_MSG("D3D:Scaled resolution: %.1fx%.1f, factor: %dx%d", sizex, sizey, x, y);
+#endif
+
+    D3DXMatrixScaling(&m_matWorld, sizex, sizey, 1.0f);
+}
+
+#if !(C_D3DSHADERS)
+
+D3DXMATRIX* CDirect3D::MatrixOrthoOffCenterLH(D3DXMATRIX *pOut, float l, float r, float b, float t, float zn, float zf)
+{
+    pOut->_11=2.0f/r; pOut->_12=0.0f;   pOut->_13=0.0f;  pOut->_14=0.0f;
+    pOut->_21=0.0f;   pOut->_22=2.0f/t; pOut->_23=0.0f;  pOut->_24=0.0f;
+    pOut->_31=0.0f;   pOut->_32=0.0f;   pOut->_33=1.0f;  pOut->_34=0.0f;
+    pOut->_41=-1.0f;  pOut->_42=-1.0f;  pOut->_43=0.0f;  pOut->_44=1.0f;
+
+    return pOut;
+}
+
+D3DXMATRIX* CDirect3D::MatrixScaling(D3DXMATRIX *pOut, float sx, float sy, float sz)
+{
+    pOut->_11=sx;     pOut->_12=0.0f;   pOut->_13=0.0f;  pOut->_14=0.0f;
+    pOut->_21=0.0f;   pOut->_22=sy;     pOut->_23=0.0f;  pOut->_24=0.0f;
+    pOut->_31=0.0f;   pOut->_32=0.0f;   pOut->_33=sz;    pOut->_34=0.0f;
+    pOut->_41=0.0f;   pOut->_42=0.0f;   pOut->_43=0.0f;  pOut->_44=1.0f;
+
+    return pOut;
+}
+
+D3DXMATRIX* CDirect3D::MatrixTranslation(D3DXMATRIX *pOut, float tx, float ty, float tz)
+{
+    pOut->_11=1.0f;   pOut->_12=0.0f;   pOut->_13=0.0f;  pOut->_14=0.0f;
+    pOut->_21=0.0f;   pOut->_22=1.0f;   pOut->_23=0.0f;  pOut->_24=0.0f;
+    pOut->_31=0.0f;   pOut->_32=0.0f;   pOut->_33=1.0f;  pOut->_34=0.0f;
+    pOut->_41=tx;     pOut->_42=ty;     pOut->_43=tz;    pOut->_44=1.0f;
+
+    return pOut;
+}
+
+#endif  // !(C_D3DSHADERS)
+
+#endif 	// (HAVE_D3D9_H)
diff -urN dosbox-0.73/src/gui/direct3d.h dosboxcvs/src/gui/direct3d.h
--- dosbox-0.73/src/gui/direct3d.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/direct3d.h	2009-07-08 20:43:21.000000000 +0300
@@ -0,0 +1,257 @@
+/*
+ *  Direct3D rendering code by gulikoza
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __DIRECT3D_H_
+#define __DIRECT3D_H_
+
+#include <d3d9.h>
+#include "dosbox.h"
+#include "hq2x_d3d.h"
+
+#define LOG_D3D 0		// Set this to 1 to enable D3D debug messages
+#define D3D_THREAD		// Define this to thread Direct3D
+
+#if LOG_D3D
+#include <io.h>
+#include <fcntl.h>
+#include <stdio.h>
+#endif
+
+#ifdef D3D_THREAD
+#include "SDL_thread.h"
+#endif
+
+#define SAFE_RELEASE(p)		{ if(p) { (p)->Release(); (p)=NULL; } }
+
+#if defined (_MSC_VER)						/* MS Visual C++ */
+#define	strcasecmp(a,b) stricmp(a,b)
+#endif
+
+// Vertex format
+#define D3DFVF_TLVERTEX D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1
+
+#if C_D3DSHADERS
+#include "ScalingEffect.h"
+#else
+#define D3DXMATRIX D3DMATRIX
+#define D3DXVECTOR3 vec3f
+#define D3DXVECTOR2 vec2f
+#define D3DXMatrixOrthoOffCenterLH MatrixOrthoOffCenterLH
+#define D3DXMatrixTranslation MatrixTranslation
+#define D3DXMatrixScaling MatrixScaling
+
+struct vec3f {
+    float x, y, z;
+    vec3f() { }
+    vec3f(float vx, float vy, float vz)
+    : x(vx), y(vy), z(vz) { }
+};
+
+struct vec2f {
+    float x, y;
+    vec2f() { }
+    vec2f(float vx, float vy)
+    : x(vx), y(vy) { }
+};
+
+#endif
+
+class CDirect3D {
+private:
+
+    // globals
+    HMODULE			mhmodDX9;
+    IDirect3D9*			pD3D9;
+    IDirect3DDevice9*		pD3DDevice9;
+
+    D3DPRESENT_PARAMETERS 	d3dpp;			// Present parameters
+    D3DLOCKED_RECT		d3dlr;			// Texture lock rectangle
+
+    HWND hwnd;						// DOSBow window
+    DWORD dwWidth, dwHeight;                            // DOSBox framebuffer size
+    DWORD dwScaledWidth, dwScaledHeight;                // D3D backbuffer size
+    const Bit16u* changedLines;
+
+    // display modes
+    D3DDISPLAYMODE*		modes;
+    unsigned int		iMode;
+    DWORD			dwNumModes;
+
+    bool			deviceLost;
+
+    // vertex stuff
+    IDirect3DVertexBuffer9*	vertexBuffer;		// VertexBuffer
+
+    // Custom vertex
+    struct TLVERTEX {
+	D3DXVECTOR3 position;       // vertex position
+	D3DCOLOR    diffuse;
+        D3DXVECTOR2 texcoord;       // texture coords
+    };
+
+    // Projection matrices
+    D3DXMATRIX			m_matProj;
+    D3DXMATRIX			m_matWorld;
+    D3DXMATRIX			m_matView;
+
+#if C_D3DSHADERS
+    D3DXMATRIX			m_matPreProj;
+    D3DXMATRIX			m_matPreView;
+    D3DXMATRIX			m_matPreWorld;
+
+    // Pixel shader
+    char			pshader[30];
+    ScalingEffect*		psEffect;
+    LPDIRECT3DTEXTURE9		lpWorkTexture1;
+    LPDIRECT3DTEXTURE9		lpWorkTexture2;
+    LPDIRECT3DVOLUMETEXTURE9	lpHq2xLookupTexture;
+#if LOG_D3D
+    LPDIRECT3DTEXTURE9		lpDebugTexture;
+#endif
+#endif
+    LPDIRECT3DTEXTURE9		lpTexture;		// D3D texture
+    bool 			psEnabled;
+    bool			preProcess;
+
+    // function declarations
+    HRESULT InitD3D(void);
+
+    HRESULT RestoreDeviceObjects(void);
+    HRESULT InvalidateDeviceObjects(void);
+    HRESULT CreateDisplayTexture(void);
+    HRESULT CreateVertex(void);
+#if !(C_D3DSHADERS)
+    D3DXMATRIX* MatrixOrthoOffCenterLH(D3DXMATRIX*, float, float, float, float, float, float);
+    D3DXMATRIX* MatrixScaling(D3DXMATRIX*, float, float, float);
+    D3DXMATRIX* MatrixTranslation(D3DXMATRIX*, float, float, float);
+#endif
+
+    void SetupSceneScaled(void);
+    bool D3DSwapBuffers(void);
+
+#ifdef D3D_THREAD
+    // Thread entry point must be static
+    static int EntryPoint(void * pthis) { CDirect3D * pt = (CDirect3D *)pthis; return pt->Start(); }
+    HRESULT Wait(bool unlock = true);
+    int Start(void);
+
+    SDL_Thread *thread;
+    CRITICAL_SECTION cs;
+    SDL_semaphore *thread_sem, *thread_ack;
+
+    volatile enum D3D_state { D3D_IDLE = 0, D3D_LOADPS, D3D_RESIZE, D3D_LOCK, D3D_UNLOCK, D3D_DESTROY } thread_command;
+    volatile bool thread_run, wait;
+    volatile HRESULT thread_hr;
+#if LOG_D3D
+    void EnterLOGCriticalSection(LPCRITICAL_SECTION lpCriticalSection, int);
+#endif
+#endif
+
+    HRESULT LoadPixelShader(void);
+    HRESULT Resize3DEnvironment(void);
+    HRESULT LockTexture(void);
+    bool UnlockTexture(void);
+    void DestroyD3D(void);
+
+public:
+
+    // texture stuff
+    DWORD	dwTexHeight, dwTexWidth;
+
+    bool 	square, pow2, dynamic, bpp16;		// Texture limitations
+    Bit8s 	aspect;
+
+    // Pixel shader status
+    bool 	psActive;
+
+    // function declarations
+    HRESULT InitializeDX(HWND, bool);
+    HRESULT LoadPixelShader(const char*, double, double);
+    HRESULT Resize3DEnvironment(Bitu, Bitu, Bitu, Bitu, bool fullscreen=false);
+    bool LockTexture(Bit8u * & pixels,Bitu & pitch);
+    bool UnlockTexture(const Bit16u *changed);
+
+    CDirect3D(Bitu width = 640, Bitu height = 400):dwWidth(width),dwHeight(height) {
+	mhmodDX9 = NULL;
+	pD3D9 = NULL;
+	pD3DDevice9 = NULL;
+	modes = NULL;
+	vertexBuffer = NULL;
+
+	deviceLost = false;
+
+	bpp16 = false;
+	aspect = 0;
+	lpTexture = NULL;
+
+	psEnabled = false;
+	psActive = false;
+	preProcess = false;
+
+#if C_D3DSHADERS
+	lpWorkTexture1 = NULL;
+	lpWorkTexture2 = NULL;
+	lpHq2xLookupTexture = NULL;
+#if LOG_D3D
+	lpDebugTexture = NULL;
+#endif
+	strcpy(pshader, "shaders\\");
+	psEffect = NULL;
+#endif
+
+#ifdef D3D_THREAD
+	thread = NULL;
+	wait = false;
+	thread_run = false;
+	thread_command = D3D_IDLE;
+
+	InitializeCriticalSection(&cs);
+	thread_sem = SDL_CreateSemaphore(0);
+	thread_ack = SDL_CreateSemaphore(0);
+#endif
+
+    }
+
+    ~CDirect3D() {
+#if LOG_D3D
+	LOG_MSG("D3D:Shutting down Direct3D");
+#endif
+	DestroyD3D();
+
+#ifdef D3D_THREAD
+	// Kill child thread
+	thread_run = false;
+	thread_command = D3D_IDLE;
+	SDL_SemPost(thread_sem);
+	SDL_WaitThread(thread, NULL);
+	thread = NULL;
+
+	DeleteCriticalSection(&cs);
+	SDL_DestroySemaphore(thread_sem);
+	SDL_DestroySemaphore(thread_ack);
+#endif
+
+	// Unload d3d9.dll
+	if (mhmodDX9) {
+	    FreeLibrary(mhmodDX9);
+	    mhmodDX9 = NULL;
+	}
+    }
+};
+
+#endif // __DIRECT3D_H_
diff -urN dosbox-0.73/src/gui/externalInterface.cpp dosboxcvs/src/gui/externalInterface.cpp
--- dosbox-0.73/src/gui/externalInterface.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/externalInterface.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,237 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+
+#include "mt32emu.h"
+
+#if MT32EMU_USE_EXTINT == 1
+
+#include "externalInterface.h"
+
+namespace MT32Emu {
+
+bool ExternalInterface::start() {
+	this->ipxServerIp.host = 0x0100007f;
+	this->ipxServerIp.port = 0xc307;
+
+	if (!SDLNet_ResolveHost(&ipxServerIp, NULL, 0xc307)) {
+		ipxServerSocket = SDLNet_UDP_Open(1987);
+		if (ipxServerSocket == NULL)
+			return false;
+		regPacket = SDLNet_AllocPacket(4096);
+		if (regPacket == NULL)
+			return false;
+
+		this->openedPort = true;
+		return true;
+	} else {
+        return false;
+	}
+}
+
+void ExternalInterface::doControlPanelComm(Synth *synth, int sndBufLength) {
+	int reqType;
+	int i;
+	bool sentBasicPacket = false;
+	Bit16u length = 0;
+	Bit8u buffer[4096];
+	while (getStatusRequest(&reqType, (char *)buffer)) {
+		switch (reqType) {
+			case 1:
+				if (!sentBasicPacket) {
+					// Only send one basic packet per loop.
+					sentBasicPacket = true;
+					Bit16u *bufptr;
+					bufptr = (Bit16u *)(&buffer[0]);
+					*bufptr++ = (Bit16u)reqType;
+					*bufptr++ = (Bit16u)MT32EMU_MAX_PARTIALS;
+					for (i=0;i<MT32EMU_MAX_PARTIALS;i++) {
+						if (!synth->getPartial(i)->play) {
+							*bufptr++ = 0;
+							*bufptr++ = 0;
+							*bufptr++ = 0;
+
+							*bufptr++ = 0;
+							*bufptr++ = 0;
+							*bufptr++ = 0;
+						} else {
+							if (synth->getPartial(i)->envs[EnvelopeType_amp].decaying) {
+								*bufptr++ = 3;
+							} else {
+								if (synth->getPartial(i)->envs[EnvelopeType_amp].envstat == 4) {
+									*bufptr++ = 2;
+								} else {
+									*bufptr++ = 1;
+								}
+							}
+
+							*bufptr++ = (Bit16u)synth->getPartial(i)->getOwnerPart();
+							*bufptr++ = (Bit16u)synth->getPartial(i)->getKey();
+
+							// Age uniquely identifies note instance
+							*(Bit32u *)bufptr = synth->getPartial(i)->age;
+							bufptr++;
+							bufptr++;
+							if (synth->getPartial(i)->getPoly() != NULL) {
+								*bufptr++ = (Bit16u)synth->getPartial(i)->getPoly()->vel;
+							} else {
+								*bufptr++ = 0;
+							}
+						}
+					}
+					// 8 channel names with description
+					*bufptr++ = 8;
+					for (i=0;i<8;i++) {
+						memcpy(bufptr, synth->getPart(i)->getCurrentInstr(), 10);
+						bufptr++;
+						bufptr++;
+						bufptr++;
+						bufptr++;
+						bufptr++;
+					}
+					for (i=0;i<9;i++) {
+						*bufptr++ = (Bit16u)synth->getPart(i)->getVolume();
+					}
+					*(int *)bufptr = sndBufLength;
+
+					sendResponse(reqType, (char *)&buffer[0], 492);
+					//sendResponse(reqType, (char *)&buffer[0], 300);
+				}
+				break;
+			case 2:
+				// Literal sysex from control panel
+				// Format:
+				// 2 bytes = length of raw sysex
+				// [length] bytes = raw sysex without Open/Close Exclusive bytes or machine identifiers
+				length = *(Bit16u *)&buffer[0];
+				synth->writeSysex(0x10, buffer + 2, length);
+				break;
+			case 3:
+				// Reserved for raw sysex reads
+				break;
+			case 4:
+				// Message data from control panel.  Specified with part and not channel mappings
+				// Format:
+				// 1 byte = part (0 - 8)
+				// 1 byte = code
+				// 1 byte = note
+				// 1 byte = velocity
+				synth->playMsgOnPart(buffer[0], buffer[1], buffer[2], buffer[3]);
+				break;
+			case 5:
+				// Raw memory address reads
+				// Format:
+				// 4 bytes = memory address
+				// 2 bytes = length (Probably not a good idea to request more than 4094 bytes!
+				Bit32u addr = *(Bit32u *)&buffer[0];
+				Bit16u len = *(Bit16u *)&buffer[4];
+
+				*(Bit16u *)&buffer[0] = 5;
+				*(Bit32u *)&buffer[2] = addr;
+				*(Bit16u *)&buffer[6] = len;
+
+				synth->readMemory(MT32EMU_MEMADDR(addr), len, &buffer[8]);
+
+				sendResponse(5, (char *)&buffer[0], len + 8);
+
+				break;
+		}
+
+	}
+}
+
+bool ExternalInterface::getStatusRequest(int *requestType, char * buffer) {
+	int result;
+	UDPpacket inPacket;
+
+	inPacket.channel = -1;
+	inPacket.data = &inBuffer[0];
+	inPacket.maxlen = 4096;
+	result = SDLNet_UDP_Recv(ipxServerSocket, &inPacket);
+	if (result != 0) {
+		this->ipxClientIp = inPacket.address;
+		this->knownClient = true;
+		*requestType = (int)*(Bit16u *)(&inBuffer[0]);
+		if (buffer != NULL) {
+			if (inPacket.len > 1) {
+				memcpy(buffer, &inBuffer[2], inPacket.len - 2);
+			}
+		}
+		return true;
+	} else {
+        return false;
+	}
+}
+
+bool ExternalInterface::sendResponse(int /*requestType*/, char *requestBuf, int requestLen) {
+
+	memcpy(regPacket->data, requestBuf, requestLen);
+	regPacket->len = requestLen;
+	//regPacket->address.host = 0xffffffff;
+	//regPacket->address.port = 0x641e;
+	regPacket->address = this->ipxClientIp;
+	SDLNet_UDP_Send(ipxServerSocket,-1,regPacket);
+
+	if ((this->knownClient) && (this->textToDisplay)) {
+
+		memcpy(regPacket->data, txtBuffer, requestLen);
+		regPacket->len = 22;
+		regPacket->address = this->ipxClientIp;
+		//regPacket->address.host = 0xffffffff;
+		//regPacket->address.port = 0x641e;
+		SDLNet_UDP_Send(ipxServerSocket,-1,regPacket);
+		this->textToDisplay = false;
+	}
+
+	return true;
+}
+
+bool ExternalInterface::sendDisplayText(char *requestBuf, int requestLen) {
+	if (!this->knownClient) {
+        memcpy(&txtBuffer[0], requestBuf, requestLen);
+		this->textToDisplay = true;
+	} else {
+		this->sendResponse(2, requestBuf, requestLen);
+	}
+	return true;
+}
+
+bool ExternalInterface::stop() {
+	if (this->openedPort) {
+		if (ipxServerSocket != NULL) {
+		SDLNet_UDP_Close(ipxServerSocket);
+		}
+		this->openedPort = false;
+	}
+	return true;
+}
+
+void ExternalInterface::handleReport(Synth * /*synth*/, ReportType type, const void *reportData) {
+	switch (type) {
+		case ReportType_lcdMessage:
+		{
+			char buf[514]; //FIXME: Messy...
+			*(Bit16u *)(&buf[0]) = 2;
+			strcpy(&buf[2], (const char *)reportData);
+			sendResponse(2, &buf[0], (int)strlen((const char *)reportData) + 3);
+		}
+	}
+}
+
+}
+
+#endif
diff -urN dosbox-0.73/src/gui/file.cpp dosboxcvs/src/gui/file.cpp
--- dosbox-0.73/src/gui/file.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/file.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,107 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+
+#include "mt32emu.h"
+
+namespace MT32Emu {
+
+	bool ANSIFile::open(const char *filename, OpenMode mode) {
+		const char *fmode;
+		if (mode == OpenMode_read) {
+			fmode = "rb";
+		} else {
+			fmode = "wb";
+		}
+		fp = fopen(filename, fmode);
+		return (fp != NULL);
+	}
+
+	void ANSIFile::close() {
+		fclose(fp);
+	}
+
+	size_t ANSIFile::read(void *in, size_t size) {
+		return fread(in, 1, size, fp);
+	}
+
+	bool ANSIFile::readLine(char *in, size_t size) {
+		return fgets(in, (int)size, fp) != NULL;
+	}
+
+	bool ANSIFile::readBit8u(Bit8u *in) {
+		int c = fgetc(fp);
+		if (c == EOF)
+			return false;
+		*in = (Bit8u)c;
+		return true;
+	}
+
+	bool File::readBit16u(Bit16u *in) {
+		Bit8u b[2];
+		if (read(&b[0], 2) != 2)
+			return false;
+		*in = ((b[0] << 8) | b[1]);
+		return true;
+	}
+
+	bool File::readBit32u(Bit32u *in) {
+		Bit8u b[4];
+		if (read(&b[0], 4) != 4)
+			return false;
+		*in = ((b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3]);
+		return true;
+	}
+
+	size_t ANSIFile::write(const void *out, size_t size) {
+		return fwrite(out, 1, size, fp);
+	}
+
+	bool ANSIFile::writeBit8u(Bit8u out) {
+		return fputc(out, fp) != EOF;
+	}
+
+	bool File::writeBit16u(Bit16u out) {
+		if (!writeBit8u((Bit8u)((out & 0xFF00) >> 8))) {
+			return false;
+		}
+		if (!writeBit8u((Bit8u)(out & 0x00FF))) {
+			return false;
+		}
+		return true;
+	}
+
+	bool File::writeBit32u(Bit32u out) {
+		if (!writeBit8u((Bit8u)((out & 0xFF000000) >> 24))) {
+			return false;
+		}
+		if (!writeBit8u((Bit8u)((out & 0x00FF0000) >> 16))) {
+			return false;
+		}
+		if (!writeBit8u((Bit8u)((out & 0x0000FF00) >> 8))) {
+			return false;
+		}
+		if (!writeBit8u((Bit8u)(out & 0x000000FF))) {
+			return false;
+		}
+		return true;
+	}
+
+	bool ANSIFile::isEOF() {
+		return feof(fp) != 0;
+	}
+}
diff -urN dosbox-0.73/src/gui/hq2x_d3d.cpp dosboxcvs/src/gui/hq2x_d3d.cpp
--- dosbox-0.73/src/gui/hq2x_d3d.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/hq2x_d3d.cpp	2009-07-08 20:43:21.000000000 +0300
@@ -0,0 +1,205 @@
+/*
+ *  Hq2x scaler pixel shader version support code by Mitja Gros (Mitja.Gros@gmail.com)
+ *
+ *  Original OpenGL-HQ rendering code
+ *  Copyright (C) 2004-2005 Jrg Walter <jwalt@garni.ch>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "hq2x_d3d.h"
+
+#if C_D3DSHADERS
+
+#define fmax(x,y) ((x)>(y)?(x):(y))
+#define fmin(x,y) ((x)<(y)?(x):(y))
+#define R 1
+#define T 2
+#define RT 4
+#define RT2 8
+#define L 16
+#define LB2 32
+#define LT2 64
+#define LT 128
+#define LB 256
+#define B 512
+#define RB2 1024
+#define RB 2048
+
+#define NODIAG 0x90
+#define H 1
+#define V 2
+#define D 4
+
+#define hmirror(p) swap_bits(swap_bits(swap_bits(swap_bits(swap_bits(p,R,L),RT,LT),RT2,LT2),RB,LB),RB2,LB2)
+#define vmirror(p) swap_bits(swap_bits(swap_bits(swap_bits(swap_bits(p,T,B),RT,RB),RT2,RB2),LT,LB),LT2,LB2)
+#define NO_BORDER(x) ((b&(x)) == 0)
+#define IS_BORDER(x) ((b&(x)) == (x))
+#define SETINTERP(percentage_inside) setinterp(xcenter,ycenter,percentage_inside, \
+                        NO_BORDER(R),NO_BORDER(T),NO_BORDER(RT), \
+                        IS_BORDER(R),IS_BORDER(T),IS_BORDER(RT), \
+                        texture+((x+(border%16)*HQ2X_RESOLUTION+y*16*HQ2X_RESOLUTION+(border&~15)*HQ2X_RESOLUTION*HQ2X_RESOLUTION)*4))
+
+static double sign(double a) {
+    return (a < 0?-1:1);
+}
+
+/*
+ This function calculates what percentage of a rectangle intersected by a line lies near the center of the
+ cordinate system. It is mathematically exact, and well-tested for xcenter > 0 and ycenter > 0 (it's only
+ used that way). It should be correct for other cases as well, but well... famous last words :)
+*/
+static double intersect_any(double xcenter, double ycenter, double xsize, double ysize, double yoffset, double gradient) {
+    double g = fabs(gradient)*xsize/ysize;
+    double o = -((yoffset-ycenter) + gradient*xcenter)/ysize*sign(ycenter)*sign(yoffset)-g*0.5+0.5;
+    double yl = o, yr = o+g, xb = -o/g, xt = (1-o)/g;
+    double area = 1.0;
+
+    if (yl >= 1.0) xt = xb = area = 0.0;
+    else if (yl > 0.0) {
+        area = 1.0-yl;
+        xb = 0.0;
+    }
+    else if (yr <= 0.0) yl = yr = area = 1.0;
+    else yl = o+xb*g;
+
+    if (xt <= 0.0) yr = yl = area = 0.0;
+    else if (xt < 1.0) {
+        area *= xt;
+        yr = 1.0;
+    }
+    else if (xb >= 1.0) xb = xt = area = 1.0;
+    else xt = (yr-o)/g;
+
+    area -= (xt-xb)*(yr-yl)/2;
+
+    return area;
+}
+
+static double intersect_h(double xcenter, double ycenter, double xsize, double ysize) {
+    return fmax(0.0,fmin(1.0,(.55-fabs(xcenter)+xsize/2.0)/xsize));
+}
+
+static double intersect_any_h(double xcenter, double ycenter, double xsize, double ysize, double yoffset, double gradient) {
+    double hinside = intersect_h(xcenter,ycenter,xsize,ysize);
+    return hinside*hinside*intersect_any(xcenter,ycenter,xsize,ysize,yoffset,gradient);
+}
+
+static double intersect_v(double xcenter, double ycenter, double xsize, double ysize) {
+    return fmax(0.0,fmin(1.0,(.55-fabs(ycenter)+ysize/2.0)/ysize));
+}
+
+static double intersect_any_v(double xcenter, double ycenter, double xsize, double ysize, double yoffset, double gradient) {
+    double vinside = intersect_v(xcenter,ycenter,xsize,ysize);
+    return vinside*vinside*intersect_any(xcenter,ycenter,xsize,ysize,yoffset,gradient);
+}
+
+static double intersect_hv(double xcenter, double ycenter, double xsize, double ysize) {
+    double hinside = intersect_h(xcenter,ycenter,xsize,ysize);
+    double vinside = intersect_v(xcenter,ycenter,xsize,ysize);
+    return (1-hinside)*(1-vinside)+hinside*vinside;
+}
+
+/* FIXME: not sure if this is correct, but it is rare enough and most likely near enough. fixes welcome :) */
+static double intersect_any_hv(double xcenter, double ycenter, double xsize, double ysize, double yoffset, double gradient) {
+    double hvinside = intersect_hv(xcenter,ycenter,xsize,ysize);
+    return hvinside*hvinside*intersect_any(xcenter,ycenter,xsize,ysize,yoffset,gradient);
+}
+
+static double intersect_hvd(double xcenter, double ycenter, double xsize, double ysize) {
+    return intersect_h(xcenter,ycenter,xsize,ysize)*intersect_v(xcenter,ycenter,xsize,ysize);
+}
+
+static void setinterp(double xcenter, double ycenter, double percentage_inside, int i1, int i2, int i3, int o1, int o2, int o3, unsigned char *factors) {
+    double d0, d1, d2, d3, percentage_outside, totaldistance_i, totaldistance_o;
+    xcenter = fabs(xcenter);
+    ycenter = fabs(ycenter);
+    d0 = (1-xcenter)*(1-ycenter);
+    d1 = xcenter*(1-ycenter);
+    d2 = (1-xcenter)*ycenter;
+    d3 = xcenter*ycenter;
+    if (i1 && i2) i3 = 0;
+    if (o1 && o2) o3 = 0;
+    percentage_outside = 1.0-percentage_inside;
+    totaldistance_i = d0+i1*d1+i2*d2+i3*d3;
+    totaldistance_o = o1*d1+o2*d2+o3*d3+1e-12; /* +1e-12: prevent division by zero */
+
+    factors[1] = (unsigned char)(((d1/totaldistance_i*percentage_inside*i1)+(d1/totaldistance_o*percentage_outside*o1))*255+.5);
+    factors[2] = (unsigned char)(((d2/totaldistance_i*percentage_inside*i2)+(d2/totaldistance_o*percentage_outside*o2))*255+.5);
+    factors[3] = (unsigned char)(((d3/totaldistance_i*percentage_inside*i3)+(d3/totaldistance_o*percentage_outside*o3))*255+.5);
+    factors[0] = 255-factors[1]-factors[2]-factors[3];/*(unsigned char)((d0/totaldistance_i*percentage_inside)*255+.5);*/
+}
+
+/* Wanna have gcc fun? #define this as a macro, get a fast machine and go fetch a coffe or two. See how it is used to get an idea why.
+   I aborted compilation after 5 minutes of CPU time on an Athlon64 3700+. */
+static int swap_bits(int num, int bit1, int bit2) {
+    return ((num & ~(bit1|bit2))|((num&bit1)?bit2:0)|((num&bit2)?bit1:0));
+}
+
+
+// width, height == rwidth, rheight
+// outwidth, outheight == width, height
+void BuildHq2xLookupTexture(Bitu outWidth, Bitu outHeight, Bitu rwidth, Bitu rheight, Bit8u* texture)
+{
+    double xsize, ysize;
+    unsigned char table[4096] = HQ2X_D3D_TABLE_DATA;
+
+    xsize = (double)rwidth / (double)outWidth;
+    ysize = (double)rheight / (double)outHeight;
+
+    for (int border = 0; border < 4096; border++) {
+	for (int y = 0; y < HQ2X_RESOLUTION; y++) {
+            for (int x = 0; x < HQ2X_RESOLUTION; x++) {
+                double xcenter = fabs((((double)x)+0.5) / (double)(HQ2X_RESOLUTION)-0.5)/0.958;
+                double ycenter = fabs((((double)y)+0.5) / (double)(HQ2X_RESOLUTION)-0.5)/0.958;
+                int sx = (x < HQ2X_RESOLUTION/2?-1:1);
+                int sy = (y < HQ2X_RESOLUTION/2?-1:1);
+                int b = (sy > 0?(sx > 0?border:hmirror(border)):(sx > 0?vmirror(border):vmirror(hmirror(border))));
+
+                if ((table[b] & NODIAG) == NODIAG) {
+                    if (table[b] & H) {
+                        if (table[b] & V) {
+                            if (table[b] & D) SETINTERP(intersect_hvd(xcenter,ycenter,xsize,ysize));
+                            else SETINTERP(intersect_hv(xcenter,ycenter,xsize,ysize));
+                        } else {
+                            SETINTERP(intersect_h(xcenter,ycenter,xsize,ysize));
+                        }
+                    } else if (table[b] & V) {
+                        SETINTERP(intersect_v(xcenter,ycenter,xsize,ysize));
+                    } else {
+                        SETINTERP(1.0);
+                    }
+                } else {
+                    double yoff = (table[b]&4?1:-1)*(((table[b] >> 3) & 3) + 1)/4.0;
+                    double grad = (table[b]&32?1:-1)*(((table[b] >> 6) & 3) + 1)/2.0;
+                    if (table[b] & H) {
+                        if (table[b] & V) {
+                            SETINTERP(intersect_any_hv(xcenter,ycenter,xsize,ysize,yoff,grad));
+                        } else {
+                            SETINTERP(intersect_any_h(xcenter,ycenter,xsize,ysize,yoff,grad));
+                        }
+                    } else if (table[b] & V) {
+                        SETINTERP(intersect_any_v(xcenter,ycenter,xsize,ysize,yoff,grad));
+                    } else {
+                        SETINTERP(intersect_any(xcenter,ycenter,xsize,ysize,yoff,grad));
+                    }
+                }
+
+            }
+        }
+    }
+}
+
+#endif
diff -urN dosbox-0.73/src/gui/hq2x_d3d.h dosboxcvs/src/gui/hq2x_d3d.h
--- dosbox-0.73/src/gui/hq2x_d3d.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/hq2x_d3d.h	2009-07-08 20:43:21.000000000 +0300
@@ -0,0 +1,294 @@
+/*
+ *  Hq2x scaler pixel shader version support code by Mitja Gros (Mitja.Gros@gmail.com)
+ *
+ *  OpenGL-HQ rendering code Copyright (C) 2004-2005 Jrg Walter <jwalt@garni.ch>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __HQ2X_DIRECT3D_H_
+#define __HQ2X_DIRECT3D_H_
+
+#include "config.h"
+
+#if C_D3DSHADERS
+#include <math.h>
+
+#define HQ2X_RESOLUTION 16
+
+void BuildHq2xLookupTexture(Bitu width, Bitu height, Bitu rwidth, Bitu rheight, Bit8u* texture);
+
+#define HQ2X_D3D_TABLE_DATA { \
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x96,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0xec,0x94,0x91,0xec,0xec,0x90,0x91,0xec,0xec,0x94,0x91,0xec,0xec,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x4c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x4c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x92,0x6c,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6c,0x4c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x6c,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x24,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x6c,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x6c,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0xe8,0x92,0xe8,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x4c,0x48,0x48,0x48,0x93,0x48,0x48,0x48,0x97,\
+0x90,0x20,0x92,0x20,0x94,0x20,0x92,0x20,0x90,0x20,0x92,0x20,0x94,0x20,0x92,0x20,\
+0x90,0x20,0xec,0xec,0x94,0x20,0xec,0xec,0x90,0x20,0xec,0x93,0x94,0x20,0xec,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x4c,0x48,0x91,0x48,0x93,0x48,0x48,0x48,0x97,\
+0x90,0x20,0x92,0x93,0x94,0x20,0x92,0x4c,0x90,0x20,0x92,0x20,0x94,0x20,0x92,0x20,\
+0x90,0x20,0x92,0x20,0x94,0x20,0x92,0x4c,0x90,0x20,0x92,0x93,0x94,0x20,0x92,0x4c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x6c,0x6c,0x48,0x48,0x6c,0x4c,0x48,0x48,0x6c,0x93,0x48,0x48,0x6c,0x97,\
+0x90,0x20,0x92,0x20,0x94,0x20,0x92,0x20,0x90,0x20,0x6c,0x20,0x94,0x20,0x92,0x20,\
+0x90,0x20,0x6c,0x20,0x94,0x20,0x6e,0x20,0x90,0x20,0x6c,0x93,0x94,0x20,0x6e,0x4c,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x04,0x48,0x48,0x6c,0x04,0x48,0x68,0x48,0x93,0x48,0xec,0x6c,0x4c,\
+0x90,0x20,0x92,0x93,0x94,0x20,0x92,0x04,0x90,0x20,0x6c,0x20,0x94,0x20,0x92,0x20,\
+0x90,0x20,0x92,0x04,0x94,0x20,0x92,0x04,0x90,0x20,0x92,0x93,0x94,0x20,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x68,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0x93,0x94,0x91,0xec,0x4c,0x90,0x91,0xec,0xec,0x94,0x91,0xec,0xec,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x4c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x93,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x68,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x97,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6c,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x24,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x6c,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x6c,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x48,0x48,0x48,0x48,0x4c,0x48,0x48,0x92,0x93,0x48,0x48,0x48,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0xec,0x94,0x91,0xec,0x4c,0x90,0x91,0xec,0x93,0x94,0x91,0xec,0x4c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x4c,0x48,0x48,0x48,0x4c,0x48,0x48,0x48,0x93,0x48,0x48,0x48,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x6c,0x6c,0x48,0x48,0x6c,0x4c,0x48,0x48,0x6c,0x93,0x48,0x48,0x96,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x4c,0x90,0x91,0x6c,0x93,0x94,0x91,0x6e,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x04,0x48,0x48,0x6c,0x04,0x48,0x48,0x48,0x93,0x48,0x48,0x6c,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x04,0x94,0x91,0x92,0x04,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0xec,0x94,0x91,0xec,0xec,0x90,0x68,0xec,0xec,0x94,0x91,0xec,0xec,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x68,0x94,0x6c,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x6c,0x24,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0xe8,0x24,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x68,0x94,0x6c,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x68,0x92,0x6c,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x6c,0x90,0x68,0x6c,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x6c,0x90,0x94,0x69,0x6e,0x6c,0x90,0x68,0x6c,0x93,0x94,0xe8,0x24,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x6c,0x90,0x68,0x6c,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x6c,0x6c,0x94,0x69,0x6e,0x6c,0x90,0x68,0x6c,0x93,0x94,0xe8,0x24,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x6c,0x90,0x68,0x6c,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,0x90,0x68,0x92,0x90,0x94,0xe8,0x92,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x97,0x90,0x68,0x6c,0x68,0x94,0xe8,0x92,0xe8,\
+0x90,0x68,0x92,0x90,0x94,0x69,0x92,0x68,0x90,0x68,0x92,0x93,0x94,0xe8,0x92,0x97,\
+0x90,0x68,0x92,0x4c,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,\
+0x48,0x68,0x48,0x68,0x48,0x6c,0x48,0x4c,0x48,0x68,0x48,0x93,0x48,0x6c,0x48,0x97,\
+0x90,0x68,0x92,0x4c,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0x91,0x92,0x68,\
+0x90,0x68,0xec,0xec,0x94,0x69,0xec,0xec,0x90,0x68,0xec,0x93,0x94,0x69,0xec,0x4c,\
+0x90,0x68,0x92,0x4c,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,\
+0x48,0x68,0x48,0x68,0x48,0x6c,0x48,0x4c,0x48,0x68,0x48,0x93,0x48,0x95,0x48,0x97,\
+0x90,0x68,0x92,0x93,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x6c,0x94,0x69,0x92,0x68,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x69,0x92,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,0x90,0x68,0x6c,0x68,0x94,0x69,0x92,0x68,\
+0x48,0x68,0x6c,0x6c,0x48,0x69,0x6e,0x90,0x48,0x68,0x6c,0x93,0x48,0x69,0x6e,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,0x90,0x68,0x6c,0x68,0x94,0x69,0x92,0x68,\
+0x90,0x68,0x6c,0x6c,0x94,0x69,0x6e,0x6c,0x90,0x68,0x6c,0x93,0x94,0x69,0x6e,0x97,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,0x90,0x68,0x6c,0x68,0x94,0x69,0x92,0x68,\
+0x48,0x68,0x48,0x68,0x48,0x69,0x48,0x68,0x48,0x68,0x48,0x93,0x48,0x91,0x48,0x97,\
+0x90,0x68,0x92,0x20,0x94,0x69,0x92,0x93,0x90,0x68,0x6c,0x20,0x94,0x69,0x92,0x68,\
+0x90,0x68,0x92,0x68,0x94,0x69,0x92,0x68,0x90,0x68,0x92,0x93,0x94,0x69,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x95,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x68,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x4c,0x90,0x68,0x92,0x93,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x97,0x90,0x68,0x6c,0x6c,0x94,0x91,0x24,0x24,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0x93,0x94,0x91,0xec,0xcc,0x90,0x68,0xec,0xec,0x94,0x91,0xec,0xec,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x68,0x6c,0x6c,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0xec,0x94,0x91,0x6e,0x93,0x90,0x68,0x6c,0xec,0x94,0x91,0x6e,0x6c,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x68,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xec,0x94,0x91,0x92,0xcc,0x90,0x68,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x6c,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x6c,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x24,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x6c,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x6c,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x91,0x6c,0x90,0x94,0x91,0x24,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x90,0x94,0x91,0x6e,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x24,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x90,0x94,0x91,0x92,0x97,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0xcc,0x48,0x6c,0x48,0xcc,0x48,0x48,0x6c,0x93,0x48,0x6c,0x14,0x4c,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0xec,0xcc,0x94,0x91,0xec,0xcc,0x90,0x91,0xec,0x93,0x94,0x91,0xec,0x97,\
+0x90,0x91,0x92,0x4c,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0xcc,0x48,0x6c,0x48,0xcc,0x48,0x48,0x48,0x93,0x48,0x6c,0x48,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0x4c,0x90,0x91,0x92,0x97,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0xcc,0x94,0x91,0x92,0xcc,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x6c,0x6c,0x48,0x48,0x6e,0x6c,0x48,0x48,0x6c,0x93,0x48,0x48,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x6c,0x6c,0x94,0x91,0x6e,0x6c,0x90,0x91,0x6c,0x93,0x94,0x91,0x6e,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x48,0x48,0x48,0x97,0x48,0x48,0x48,0x97,0x48,0x48,0x48,0x93,0x48,0x48,0x48,0x97,\
+0x90,0x91,0x92,0x20,0x94,0x91,0x92,0x04,0x90,0x91,0x6c,0x93,0x94,0x91,0x92,0x97,\
+0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,0x90,0x91,0x92,0x93,0x94,0x91,0x92,0x97,\
+}
+
+#endif // C_D3DSHADERS
+
+#endif // __HQ2X_DIRECT3D_H_
diff -urN dosbox-0.73/src/gui/Makefile.am dosboxcvs/src/gui/Makefile.am
--- dosbox-0.73/src/gui/Makefile.am	2009-04-25 21:12:22.000000000 +0300
+++ dosboxcvs/src/gui/Makefile.am	2009-07-08 20:43:38.000000000 +0300
@@ -7,5 +7,10 @@
 	render_templates_sai.h render_templates_hq.h \
 	render_templates_hq2x.h render_templates_hq3x.h \
 	midi.cpp midi_win32.h midi_oss.h midi_coreaudio.h midi_alsa.h \
-	midi_coremidi.h sdl_gui.cpp dosbox_splash.h
+	midi_coremidi.h sdl_gui.cpp dosbox_splash.h direct3d.cpp direct3d.h \
+	ScalingEffect.cpp ScalingEffect.h hq2x_d3d.cpp hq2x_d3d.h \
+	allpass.cpp comb.cpp file.cpp part.cpp partial.cpp synth.cpp \
+	partialManager.cpp revmodel.cpp tables.cpp delayReverb.cpp \
+	tva.cpp tvf.cpp tvp.cpp poly.cpp externalInterface.cpp \
+	blit/Blit.cpp blit/BlitSaw.cpp blit/BlitSquare.cpp blit/Generator.cpp blit/Stk.cpp
 
diff -urN dosbox-0.73/src/gui/Makefile.in dosboxcvs/src/gui/Makefile.in
--- dosbox-0.73/src/gui/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/gui/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -50,9 +54,16 @@
 libgui_a_LIBADD =
 am_libgui_a_OBJECTS = sdlmain.$(OBJEXT) sdl_mapper.$(OBJEXT) \
 	render.$(OBJEXT) render_scalers.$(OBJEXT) midi.$(OBJEXT) \
-	sdl_gui.$(OBJEXT)
+	sdl_gui.$(OBJEXT) direct3d.$(OBJEXT) ScalingEffect.$(OBJEXT) \
+	hq2x_d3d.$(OBJEXT) allpass.$(OBJEXT) comb.$(OBJEXT) \
+	file.$(OBJEXT) part.$(OBJEXT) partial.$(OBJEXT) \
+	synth.$(OBJEXT) partialManager.$(OBJEXT) revmodel.$(OBJEXT) \
+	tables.$(OBJEXT) delayReverb.$(OBJEXT) tva.$(OBJEXT) \
+	tvf.$(OBJEXT) tvp.$(OBJEXT) poly.$(OBJEXT) \
+	externalInterface.$(OBJEXT) Blit.$(OBJEXT) BlitSaw.$(OBJEXT) \
+	BlitSquare.$(OBJEXT) Generator.$(OBJEXT) Stk.$(OBJEXT)
 libgui_a_OBJECTS = $(am_libgui_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -72,6 +83,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -83,6 +96,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -93,8 +107,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -104,7 +119,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -122,12 +136,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -139,43 +156,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libgui.a
 libgui_a_SOURCES = sdlmain.cpp sdl_mapper.cpp dosbox_logo.h \
@@ -184,7 +190,12 @@
 	render_templates_sai.h render_templates_hq.h \
 	render_templates_hq2x.h render_templates_hq3x.h \
 	midi.cpp midi_win32.h midi_oss.h midi_coreaudio.h midi_alsa.h \
-	midi_coremidi.h sdl_gui.cpp dosbox_splash.h
+	midi_coremidi.h sdl_gui.cpp dosbox_splash.h direct3d.cpp direct3d.h \
+	ScalingEffect.cpp ScalingEffect.h hq2x_d3d.cpp hq2x_d3d.h \
+	allpass.cpp comb.cpp file.cpp part.cpp partial.cpp synth.cpp \
+	partialManager.cpp revmodel.cpp tables.cpp delayReverb.cpp \
+	tva.cpp tvf.cpp tvp.cpp poly.cpp externalInterface.cpp \
+	blit/Blit.cpp blit/BlitSaw.cpp blit/BlitSquare.cpp blit/Generator.cpp blit/Stk.cpp
 
 all: all-am
 
@@ -233,34 +244,128 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Blit.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BlitSaw.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BlitSquare.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Generator.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ScalingEffect.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Stk.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/allpass.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/comb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/delayReverb.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/direct3d.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/externalInterface.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hq2x_d3d.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/midi.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/part.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/partial.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/partialManager.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poly.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/render.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/render_scalers.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/revmodel.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdl_gui.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdl_mapper.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sdlmain.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/synth.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tables.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tva.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tvf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tvp.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
+Blit.o: blit/Blit.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Blit.o -MD -MP -MF "$(DEPDIR)/Blit.Tpo" -c -o Blit.o `test -f 'blit/Blit.cpp' || echo '$(srcdir)/'`blit/Blit.cpp; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Blit.Tpo" "$(DEPDIR)/Blit.Po"; else rm -f "$(DEPDIR)/Blit.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Blit.cpp' object='Blit.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Blit.o `test -f 'blit/Blit.cpp' || echo '$(srcdir)/'`blit/Blit.cpp
+
+Blit.obj: blit/Blit.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Blit.obj -MD -MP -MF "$(DEPDIR)/Blit.Tpo" -c -o Blit.obj `if test -f 'blit/Blit.cpp'; then $(CYGPATH_W) 'blit/Blit.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Blit.cpp'; fi`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Blit.Tpo" "$(DEPDIR)/Blit.Po"; else rm -f "$(DEPDIR)/Blit.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Blit.cpp' object='Blit.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Blit.obj `if test -f 'blit/Blit.cpp'; then $(CYGPATH_W) 'blit/Blit.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Blit.cpp'; fi`
+
+BlitSaw.o: blit/BlitSaw.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT BlitSaw.o -MD -MP -MF "$(DEPDIR)/BlitSaw.Tpo" -c -o BlitSaw.o `test -f 'blit/BlitSaw.cpp' || echo '$(srcdir)/'`blit/BlitSaw.cpp; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/BlitSaw.Tpo" "$(DEPDIR)/BlitSaw.Po"; else rm -f "$(DEPDIR)/BlitSaw.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/BlitSaw.cpp' object='BlitSaw.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o BlitSaw.o `test -f 'blit/BlitSaw.cpp' || echo '$(srcdir)/'`blit/BlitSaw.cpp
+
+BlitSaw.obj: blit/BlitSaw.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT BlitSaw.obj -MD -MP -MF "$(DEPDIR)/BlitSaw.Tpo" -c -o BlitSaw.obj `if test -f 'blit/BlitSaw.cpp'; then $(CYGPATH_W) 'blit/BlitSaw.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/BlitSaw.cpp'; fi`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/BlitSaw.Tpo" "$(DEPDIR)/BlitSaw.Po"; else rm -f "$(DEPDIR)/BlitSaw.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/BlitSaw.cpp' object='BlitSaw.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o BlitSaw.obj `if test -f 'blit/BlitSaw.cpp'; then $(CYGPATH_W) 'blit/BlitSaw.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/BlitSaw.cpp'; fi`
+
+BlitSquare.o: blit/BlitSquare.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT BlitSquare.o -MD -MP -MF "$(DEPDIR)/BlitSquare.Tpo" -c -o BlitSquare.o `test -f 'blit/BlitSquare.cpp' || echo '$(srcdir)/'`blit/BlitSquare.cpp; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/BlitSquare.Tpo" "$(DEPDIR)/BlitSquare.Po"; else rm -f "$(DEPDIR)/BlitSquare.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/BlitSquare.cpp' object='BlitSquare.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o BlitSquare.o `test -f 'blit/BlitSquare.cpp' || echo '$(srcdir)/'`blit/BlitSquare.cpp
+
+BlitSquare.obj: blit/BlitSquare.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT BlitSquare.obj -MD -MP -MF "$(DEPDIR)/BlitSquare.Tpo" -c -o BlitSquare.obj `if test -f 'blit/BlitSquare.cpp'; then $(CYGPATH_W) 'blit/BlitSquare.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/BlitSquare.cpp'; fi`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/BlitSquare.Tpo" "$(DEPDIR)/BlitSquare.Po"; else rm -f "$(DEPDIR)/BlitSquare.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/BlitSquare.cpp' object='BlitSquare.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o BlitSquare.obj `if test -f 'blit/BlitSquare.cpp'; then $(CYGPATH_W) 'blit/BlitSquare.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/BlitSquare.cpp'; fi`
+
+Generator.o: blit/Generator.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Generator.o -MD -MP -MF "$(DEPDIR)/Generator.Tpo" -c -o Generator.o `test -f 'blit/Generator.cpp' || echo '$(srcdir)/'`blit/Generator.cpp; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Generator.Tpo" "$(DEPDIR)/Generator.Po"; else rm -f "$(DEPDIR)/Generator.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Generator.cpp' object='Generator.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Generator.o `test -f 'blit/Generator.cpp' || echo '$(srcdir)/'`blit/Generator.cpp
+
+Generator.obj: blit/Generator.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Generator.obj -MD -MP -MF "$(DEPDIR)/Generator.Tpo" -c -o Generator.obj `if test -f 'blit/Generator.cpp'; then $(CYGPATH_W) 'blit/Generator.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Generator.cpp'; fi`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Generator.Tpo" "$(DEPDIR)/Generator.Po"; else rm -f "$(DEPDIR)/Generator.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Generator.cpp' object='Generator.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Generator.obj `if test -f 'blit/Generator.cpp'; then $(CYGPATH_W) 'blit/Generator.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Generator.cpp'; fi`
+
+Stk.o: blit/Stk.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Stk.o -MD -MP -MF "$(DEPDIR)/Stk.Tpo" -c -o Stk.o `test -f 'blit/Stk.cpp' || echo '$(srcdir)/'`blit/Stk.cpp; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Stk.Tpo" "$(DEPDIR)/Stk.Po"; else rm -f "$(DEPDIR)/Stk.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Stk.cpp' object='Stk.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Stk.o `test -f 'blit/Stk.cpp' || echo '$(srcdir)/'`blit/Stk.cpp
+
+Stk.obj: blit/Stk.cpp
+@am__fastdepCXX_TRUE@	if $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT Stk.obj -MD -MP -MF "$(DEPDIR)/Stk.Tpo" -c -o Stk.obj `if test -f 'blit/Stk.cpp'; then $(CYGPATH_W) 'blit/Stk.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Stk.cpp'; fi`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/Stk.Tpo" "$(DEPDIR)/Stk.Po"; else rm -f "$(DEPDIR)/Stk.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='blit/Stk.cpp' object='Stk.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o Stk.obj `if test -f 'blit/Stk.cpp'; then $(CYGPATH_W) 'blit/Stk.cpp'; else $(CYGPATH_W) '$(srcdir)/blit/Stk.cpp'; fi`
+uninstall-info-am:
+
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -272,8 +377,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -283,12 +388,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -302,21 +408,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -377,20 +484,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -410,22 +509,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/gui/midi.cpp dosboxcvs/src/gui/midi.cpp
--- dosbox-0.73/src/gui/midi.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/gui/midi.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -76,6 +76,7 @@
 MidiHandler Midi_none;
 
 /* Include different midi drivers, lowest ones get checked first for default */
+#include "midi_mt32.h"
 
 #if defined(MACOSX)
 
diff -urN dosbox-0.73/src/gui/midi_mt32.h dosboxcvs/src/gui/midi_mt32.h
--- dosbox-0.73/src/gui/midi_mt32.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/midi_mt32.h	2010-10-29 14:18:10.956455575 +0300
@@ -0,0 +1,197 @@
+/*
+ *  Copyright (C) 2002-2003  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "mt32emu.h"
+#include "mixer.h"
+
+#include <SDL_thread.h>
+
+MT32Emu::Synth *_usesynth;
+MixerChannel *mt32chan;
+
+static struct {
+    SDL_mutex * mutex;
+    SDL_Thread * thread;
+    SDL_semaphore * sem;
+    volatile bool running, busy;
+
+    Bit8u len, play;
+    Bit8u Temp[MIXER_BUFSIZE], msg[SYSEX_SIZE];
+} mt32;
+
+static int MT32_Thread(void*) {
+
+   SDL_LockMutex(mt32.mutex);
+   while(mt32.running) {
+
+      Bitu len;
+      if(!(mt32.play) && !(mt32.len)) {
+        SDL_UnlockMutex(mt32.mutex);
+        SDL_SemWait(mt32.sem);
+        SDL_LockMutex(mt32.mutex);
+      }
+
+      mt32.busy = true;
+      while(mt32.play) {
+
+	    len = mt32.play;
+	    Bit32u *tmp = ((Bit32u*)mt32.msg);
+	    SDL_UnlockMutex(mt32.mutex);
+	    while(len--) {
+		_usesynth->playMsg(*tmp++);
+	    }
+	    SDL_LockMutex(mt32.mutex);
+	    len = tmp-(Bit32u*)mt32.msg;
+	    mt32.play -= len;
+	    if(mt32.play) SDL_memmove(mt32.msg, tmp, mt32.play<<2);
+      }
+
+      while(mt32.len) {
+
+	    len = (mt32.len>>2) < MIXER_BUFSIZE ? mt32.len : MIXER_BUFSIZE<<2;
+	    mt32.len -= len;
+
+#ifdef MT32DEBUG
+	    if(mt32.len) LOG_MSG("MT32:WARNING: len left (%d)", mt32.len);
+#endif
+
+	    SDL_UnlockMutex(mt32.mutex);
+	    _usesynth->render((Bit16s *)mt32.Temp, len);
+	    mt32chan->AddSamples_s16(len,(Bit16s *)mt32.Temp);
+	    SDL_LockMutex(mt32.mutex);
+	    break;
+      }
+      mt32.busy = false;
+   }
+
+   SDL_UnlockMutex(mt32.mutex);
+   return 0;
+}
+
+static void MT32_CallBack(Bitu len) {
+   SDL_LockMutex(mt32.mutex);
+   mt32.len += len;
+   SDL_UnlockMutex(mt32.mutex);
+   SDL_SemPost(mt32.sem);
+}
+
+static int report(void *userData, MT32Emu::ReportType type, const void *reportData) {
+   switch(type) {
+   case MT32Emu::ReportType_errorControlROM:
+      LOG(LOG_ALL,LOG_ERROR)("MT32:Couldn't find control files");
+      break;
+   case MT32Emu::ReportType_errorPCMROM:
+      LOG(LOG_ALL,LOG_ERROR)("MT32:Couldn't open MT32_PCM.ROM file");
+      break;
+   default:
+      //LOG(LOG_ALL,LOG_NORMAL)("MT32: Report %d",type);
+      break;
+   }
+   return 0;
+}
+
+class MidiHandler_mt32: public MidiHandler {
+private:
+   MT32Emu::Synth *_synth;
+   int _outputRate;
+   bool isOpen;
+
+public:
+   MidiHandler_mt32() : isOpen(false),MidiHandler() {};
+   const char * GetName(void) { return "mt32";};
+   bool Open(const char * conf) {
+      MT32Emu::SynthProperties tmpProp;
+      memset(&tmpProp, 0, sizeof(tmpProp));
+      tmpProp.sampleRate = atoi(conf);
+      if(tmpProp.sampleRate < 8192) tmpProp.sampleRate = 22050;
+      LOG_MSG("MT32:Set sample rate to %d", tmpProp.sampleRate);
+
+      /* Create MT32 thread */
+      mt32.mutex = SDL_CreateMutex();
+      mt32.sem = SDL_CreateSemaphore(0);
+      mt32.running = true;
+      mt32.busy = false;
+      mt32.play = 0;
+      mt32.thread = SDL_CreateThread(MT32_Thread, NULL);
+
+      tmpProp.useDefaultReverb = true;
+      tmpProp.useReverb = true;
+      tmpProp.reverbType = 1;
+      tmpProp.reverbTime = 5;
+      tmpProp.reverbLevel = 3;
+      //tmpProp.printDebug = &vdebug;
+      tmpProp.report = &report;
+      _synth = new MT32Emu::Synth();
+      if (_synth->open(tmpProp)==0) {
+         LOG(LOG_ALL,LOG_ERROR)("MT32:Error initialising emulation");
+         return false;
+      }
+      _usesynth=_synth;
+
+      mt32chan=MIXER_AddChannel(MT32_CallBack,tmpProp.sampleRate,"MT32");
+      mt32chan->Enable(false);
+      return true;
+   };
+   void Close(void) {
+      if (!isOpen) return;
+      mt32chan->Enable(false);
+      mt32.running = false;
+      SDL_SemPost(mt32.sem);
+      SDL_WaitThread(mt32.thread, NULL);
+      SDL_DestroyMutex(mt32.mutex);
+      _synth->close();
+      delete _synth;
+      _synth = NULL;
+      isOpen=false;
+   };
+   void PlayMsg(Bit8u * msg) {
+      mt32chan->Enable(true);
+
+      // Try to queue play commands
+      SDL_LockMutex(mt32.mutex);
+      // Playcommand buffer full?
+      while(!(mt32.play < SYSEX_SIZE>>2)) {
+        SDL_UnlockMutex(mt32.mutex);
+        LOG_MSG("MT32:Playback buffer full...");
+        SDL_LockMutex(mt32.mutex);
+      }
+      SDL_memcpy(mt32.msg+(mt32.play<<2), msg, sizeof(Bit32u));
+      mt32.play ++;
+      SDL_UnlockMutex(mt32.mutex);
+      SDL_SemPost(mt32.sem);
+   };
+   void PlaySysex(Bit8u * sysex,Bitu len) {
+      SDL_LockMutex(mt32.mutex);
+      while(mt32.busy) {
+        SDL_UnlockMutex(mt32.mutex);
+#ifdef MT32DEBUG
+        LOG_MSG("MT32:Waiting to deliver sysex");
+#endif
+        SDL_LockMutex(mt32.mutex);
+      }
+
+      if(sysex[0] == 0xf0) {
+         _synth->playSysex(sysex, len);
+      } else {
+         _synth->playSysexWithoutFraming(sysex, len);
+      }
+      SDL_UnlockMutex(mt32.mutex);
+   };
+};
+
+MidiHandler_mt32 Midi_mt32;
diff -urN dosbox-0.73/src/gui/part.cpp dosboxcvs/src/gui/part.cpp
--- dosbox-0.73/src/gui/part.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/part.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,590 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+#include <math.h>
+
+#include "mt32emu.h"
+
+namespace MT32Emu {
+
+static const Bit8u PartialStruct[13] = {
+	0, 0, 2, 2, 1, 3,
+	3, 0, 3, 0, 2, 1, 3 };
+
+static const Bit8u PartialMixStruct[13] = {
+	0, 1, 0, 1, 1, 0,
+	1, 3, 3, 2, 2, 2, 2 };
+
+static const float floatKeyfollow[17] = {
+	-1.0f, -1.0f/2.0f, -1.0f/4.0f, 0.0f,
+	1.0f/8.0f, 1.0f/4.0f, 3.0f/8.0f, 1.0f/2.0f, 5.0f/8.0f, 3.0f/4.0f, 7.0f/8.0f, 1.0f,
+	5.0f/4.0f, 3.0f/2.0f, 2.0f,
+	1.0009765625f, 1.0048828125f
+};
+
+
+RhythmPart::RhythmPart(Synth *useSynth, unsigned int usePartNum): Part(useSynth, usePartNum) {
+	strcpy(name, "Rhythm");
+	rhythmTemp = &synth->mt32ram.rhythmTemp[0];
+	refresh();
+}
+
+Part::Part(Synth *useSynth, unsigned int usePartNum) {
+	this->synth = useSynth;
+	this->partNum = usePartNum;
+	patchCache[0].dirty = true;
+	holdpedal = false;
+	patchTemp = &synth->mt32ram.patchTemp[partNum];
+	if (usePartNum == 8) {
+		// Nasty hack for rhythm
+		timbreTemp = NULL;
+	} else {
+		sprintf(name, "Part %d", partNum + 1);
+		timbreTemp = &synth->mt32ram.timbreTemp[partNum];
+	}
+	currentInstr[0] = 0;
+	currentInstr[10] = 0;
+	expression = 100;
+	activePartialCount = 0;
+	memset(patchCache, 0, sizeof(patchCache));
+	for (int i = 0; i < MT32EMU_MAX_POLY; i++) {
+		freePolys.push_front(new Poly(this));
+	}
+}
+
+Part::~Part() {
+	while (!activePolys.empty()) {
+		delete activePolys.front();
+		activePolys.pop_front();
+	}
+	while (!freePolys.empty()) {
+		delete freePolys.front();
+		freePolys.pop_front();
+	}
+}
+
+void Part::setDataEntryMSB(unsigned char midiDataEntryMSB) {
+	if (nrpn) {
+		// The last RPN-related control change was for an NRPN,
+		// which the real synths don't support.
+		return;
+	}
+	if (rpn != 0) {
+		// The RPN has been set to something other than 0,
+		// which is the only RPN that these synths support
+		return;
+	}
+	patchTemp->patch.benderRange = midiDataEntryMSB > 24 ? 24 : midiDataEntryMSB;
+	updatePitchBenderRange();
+}
+
+void Part::setNRPN() {
+	nrpn = true;
+}
+
+void Part::setRPNLSB(unsigned char midiRPNLSB) {
+	nrpn = false;
+	rpn = (rpn & 0xFF00) | midiRPNLSB;
+}
+
+void Part::setRPNMSB(unsigned char midiRPNMSB) {
+	nrpn = false;
+	rpn = (rpn & 0x00FF) | (midiRPNMSB << 8);
+}
+
+void Part::setHoldPedal(bool pressed) {
+	if (holdpedal && !pressed) {
+		holdpedal = false;
+		stopPedalHold();
+	} else {
+		holdpedal = pressed;
+	}
+}
+
+Bit32s Part::getPitchBend() const {
+	return pitchBend;
+}
+
+void Part::setBend(unsigned int midiBend) {
+	// CONFIRMED:
+	pitchBend = (((signed)midiBend - 8192) * pitchBenderRange) >> 14; // PORTABILITY NOTE: Assumes arithmetic shift
+}
+
+Bit8u Part::getModulation() const {
+	return modulation;
+}
+
+void Part::setModulation(unsigned int midiModulation) {
+	modulation = (Bit8u)midiModulation;
+}
+
+void Part::resetAllControllers() {
+	modulation = 0;
+	expression = 100;
+	pitchBend = 0;
+	setHoldPedal(false);
+}
+
+void Part::reset() {
+	resetAllControllers();
+	allSoundOff();
+	rpn = 0xFFFF;
+}
+
+void RhythmPart::refresh() {
+	// (Re-)cache all the mapped timbres ahead of time
+	for (unsigned int drumNum = 0; drumNum < synth->controlROMMap->rhythmSettingsCount; drumNum++) {
+		int drumTimbreNum = rhythmTemp[drumNum].timbre;
+		if (drumTimbreNum >= 127) // 94 on MT-32
+			continue;
+		PatchCache *cache = drumCache[drumNum];
+		backupCacheToPartials(cache);
+		for (int t = 0; t < 4; t++) {
+			// Common parameters, stored redundantly
+			cache[t].dirty = true;
+			cache[t].reverb = rhythmTemp[drumNum].reverbSwitch > 0;
+		}
+	}
+}
+
+void Part::refresh() {
+	backupCacheToPartials(patchCache);
+	for (int t = 0; t < 4; t++) {
+		// Common parameters, stored redundantly
+		patchCache[t].dirty = true;
+		patchCache[t].reverb = patchTemp->patch.reverbSwitch > 0;
+	}
+	memcpy(currentInstr, timbreTemp->common.name, 10);
+}
+
+const char *Part::getCurrentInstr() const {
+	return &currentInstr[0];
+}
+
+void RhythmPart::refreshTimbre(unsigned int absTimbreNum) {
+	for (int m = 0; m < 85; m++) {
+		if (rhythmTemp[m].timbre == absTimbreNum - 128)
+			drumCache[m][0].dirty = true;
+	}
+}
+
+void Part::refreshTimbre(unsigned int absTimbreNum) {
+	if (getAbsTimbreNum() == absTimbreNum) {
+		memcpy(currentInstr, timbreTemp->common.name, 10);
+		patchCache[0].dirty = true;
+	}
+}
+
+int Part::fixBiaslevel(int srcpnt, int *dir) {
+	int noteat = srcpnt & 0x3F;
+	int outnote;
+	if (srcpnt < 64)
+		*dir = 0;
+	else
+		*dir = 1;
+	outnote = 33 + noteat;
+	//LOG_MSG("MT32:Bias note %d, dir %d", outnote, *dir);
+
+	return outnote;
+}
+
+int Part::fixKeyfollow(int srckey) {
+	if (srckey>=0 && srckey<=16) {
+		int keyfix[17] = { -256*16, -128*16, -64*16, 0, 32*16, 64*16, 96*16, 128*16, (128+32)*16, 192*16, (192+32)*16, 256*16, (256+64)*16, (256+128)*16, (512)*16, 4100, 4116};
+		return keyfix[srckey];
+	} else {
+		//LOG(LOG_ERROR|LOG_MISC,"Missed key: %d", srckey);
+		return 256;
+	}
+}
+
+void Part::setPatch(const PatchParam *patch) {
+	patchTemp->patch = *patch;
+}
+
+void RhythmPart::setTimbre(TimbreParam * /*timbre*/) {
+	LOG_MSG("MT32:%s: Attempted to call setTimbre() - doesn't make sense for rhythm", name);
+}
+
+void Part::setTimbre(TimbreParam *timbre) {
+	*timbreTemp = *timbre;
+}
+
+unsigned int RhythmPart::getAbsTimbreNum() const {
+	LOG_MSG("MT32:%s: Attempted to call getAbsTimbreNum() - doesn't make sense for rhythm", name);
+	return 0;
+}
+
+unsigned int Part::getAbsTimbreNum() const {
+	return (patchTemp->patch.timbreGroup * 64) + patchTemp->patch.timbreNum;
+}
+
+void RhythmPart::setProgram(unsigned int patchNum) {
+	LOG_MSG("MT32:%s: Attempt to set program (%d) on rhythm is invalid", name, patchNum);
+}
+
+void Part::setProgram(unsigned int patchNum) {
+	setPatch(&synth->mt32ram.patches[patchNum]);
+	updatePitchBenderRange();
+	allSoundOff();
+	setTimbre(&synth->mt32ram.timbres[getAbsTimbreNum()].timbre);
+	refresh();
+}
+
+void Part::updatePitchBenderRange() {
+	pitchBenderRange = patchTemp->patch.benderRange * 683;
+}
+
+void Part::backupCacheToPartials(PatchCache cache[4]) {
+	// check if any partials are still playing with the old patch cache
+	// if so then duplicate the cached data from the part to the partial so that
+	// we can change the part's cache without affecting the partial.
+	// We delay this until now to avoid a copy operation with every note played
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		(*polyIt)->backupCacheToPartials(cache);
+	}
+}
+
+void Part::cacheTimbre(PatchCache cache[4], const TimbreParam *timbre) {
+	backupCacheToPartials(cache);
+	int partialCount = 0;
+	for (int t = 0; t < 4; t++) {
+		if (((timbre->common.partialMute >> t) & 0x1) == 1) {
+			cache[t].playPartial = true;
+			partialCount++;
+		} else {
+			cache[t].playPartial = false;
+			continue;
+		}
+
+		// Calculate and cache common parameters
+		cache[t].srcPartial = timbre->partial[t];
+
+		cache[t].pcm = timbre->partial[t].wg.pcmWave;
+
+		switch (t) {
+		case 0:
+			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure12] & 0x2) ? true : false;
+			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure12];
+			cache[t].structurePosition = 0;
+			cache[t].structurePair = 1;
+			break;
+		case 1:
+			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure12] & 0x1) ? true : false;
+			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure12];
+			cache[t].structurePosition = 1;
+			cache[t].structurePair = 0;
+			break;
+		case 2:
+			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure34] & 0x2) ? true : false;
+			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure34];
+			cache[t].structurePosition = 0;
+			cache[t].structurePair = 3;
+			break;
+		case 3:
+			cache[t].PCMPartial = (PartialStruct[(int)timbre->common.partialStructure34] & 0x1) ? true : false;
+			cache[t].structureMix = PartialMixStruct[(int)timbre->common.partialStructure34];
+			cache[t].structurePosition = 1;
+			cache[t].structurePair = 2;
+			break;
+		default:
+			break;
+		}
+
+		cache[t].partialParam = &timbre->partial[t];
+
+		cache[t].waveform = timbre->partial[t].wg.waveform;
+		cache[t].pulsewidth = timbre->partial[t].wg.pulseWidth;
+		cache[t].pwsens = timbre->partial[t].wg.pulseWidthVeloSensitivity;
+
+		// Calculate and cache filter stuff
+		cache[t].filtEnv = timbre->partial[t].tvf;
+		cache[t].filtkeyfollow  = fixKeyfollow(cache[t].filtEnv.keyfollow);
+		cache[t].filtEnv.envDepth = (char)((float)cache[t].filtEnv.envDepth);
+		cache[t].filtsustain  = cache[t].filtEnv.envLevel[3];
+	}
+	for (int t = 0; t < 4; t++) {
+		// Common parameters, stored redundantly
+		cache[t].dirty = false;
+		cache[t].partialCount = partialCount;
+		cache[t].sustain = (timbre->common.noSustain == 0);
+	}
+	//LOG_MSG("MT32:Res 1: %d 2: %d 3: %d 4: %d", cache[0].waveform, cache[1].waveform, cache[2].waveform, cache[3].waveform);
+
+#if MT32EMU_MONITOR_INSTRUMENTS == 1
+	LOG_MSG("MT32:%s (%s): Recached timbre", name, currentInstr);
+	for (int i = 0; i < 4; i++) {
+		LOG_MSG("MT32: %d: play=%s, pcm=%s (%d), wave=%d", i, cache[i].playPartial ? "YES" : "NO", cache[i].PCMPartial ? "YES" : "NO", timbre->partial[i].wg.pcmWave, timbre->partial[i].wg.waveform);
+	}
+#endif
+}
+
+const char *Part::getName() const {
+	return name;
+}
+
+void Part::setVolume(unsigned int midiVolume) {
+	// CONFIRMED: This calculation matches the table used in the control ROM
+	patchTemp->outputLevel = (Bit8u)(midiVolume * 100 / 127);
+	//LOG_MSG("MT32:%s (%s): Set volume to %d", name, currentInstr, midiVolume);
+}
+
+Bit8u Part::getExpression() const {
+	return expression;
+}
+
+void Part::setExpression(unsigned int midiExpression) {
+	// CONFIRMED: This calculation matches the table used in the control ROM
+	expression = (Bit8u)(midiExpression * 100 / 127);
+}
+
+void RhythmPart::setPan(unsigned int midiPan)
+{
+	// CONFIRMED: This does change patchTemp, but has no actual effect on playback.
+	LOG_MSG("MT32:%s: Pointlessly setting pan (%d) on rhythm part", name, midiPan);
+	Part::setPan(midiPan);
+}
+
+void Part::setPan(unsigned int midiPan) {
+	// NOTE: Panning is inverted compared to GM.
+
+	// CM-32L: Divide by 8.5
+	patchTemp->panpot = (Bit8u)((midiPan << 3) / 68);
+	// FIXME: MT-32: Divide by 9
+	//patchTemp->panpot = (Bit8u)(midiPan / 9);
+
+	//LOG_MSG("MT32:%s (%s): Set pan to %d", name, currentInstr, panpot);
+}
+
+unsigned int Part::midiKeyToKey(unsigned int midiKey, const char *debugAction) {
+	int key = midiKey + patchTemp->patch.keyShift;
+	if (key < 36) {
+		LOG_MSG("MT32:%s (%s): Attempted to perform \"%s\" on invalid key %d (%d after keyshift) < 36; moving up by octaves", name, currentInstr, debugAction, midiKey, key);
+		while (key < 36)
+			key += 12;
+	} else if (key > 132) {
+		LOG_MSG("MT32:%s (%s): Attempted to perform \"%s\" on invalid key %d (%d after keyshift) > 132; moving down by octaves", name, currentInstr, debugAction, midiKey, key);
+		while (key > 132) {
+			key -= 12;
+		}
+	}
+	key -= 24;
+	return key;
+}
+
+void RhythmPart::noteOn(unsigned int midiKey, unsigned int velocity) {
+	if (midiKey < 24 || midiKey > 108)/*> 87 on MT-32)*/ {
+		LOG_MSG("MT32:%s: Attempted to play invalid key %d (velocity %d)", name, midiKey, velocity);
+		return;
+	}
+	unsigned int key = midiKey;
+	unsigned int drumNum = key - 24;
+	int drumTimbreNum = rhythmTemp[drumNum].timbre;
+	if (drumTimbreNum >= 127) { // 94 on MT-32
+		LOG_MSG("MT32:%s: Attempted to play unmapped key %d (velocity %d)", name, midiKey, velocity);
+		return;
+	}
+	// CONFIRMED: Two special cases described by Mok
+	if (drumTimbreNum == 64 + 6) {
+		noteOff(0);
+		key = 1;
+	} else if (drumTimbreNum == 64 + 7) {
+		// This noteOff(0) is not performed on MT-32, only LAPC-I
+		noteOff(0);
+		key = 0;
+	}
+	int absTimbreNum = drumTimbreNum + 128;
+	TimbreParam *timbre = &synth->mt32ram.timbres[absTimbreNum].timbre;
+	memcpy(currentInstr, timbre->common.name, 10);
+#if MT32EMU_MONITOR_INSTRUMENTS == 1
+	LOG_MSG("MT32:%s (%s): starting poly (drum %d, timbre %d) - key %d (velocity %d)", name, currentInstr, drumNum, absTimbreNum, midiKey, velocity);
+#endif
+	if (drumCache[drumNum][0].dirty) {
+		cacheTimbre(drumCache[drumNum], timbre);
+	}
+	playPoly(drumCache[drumNum], &rhythmTemp[drumNum], midiKey, key, velocity);
+}
+
+void Part::noteOn(unsigned int midiKey, unsigned int velocity) {
+	unsigned int key = midiKeyToKey(midiKey, "Note On");
+#if MT32EMU_MONITOR_INSTRUMENTS == 1
+	LOG_MSG("MT32:%s (%s): starting poly - key %d (velocity %d)", name, currentInstr, midiKey, velocity);
+#endif
+	if (patchCache[0].dirty) {
+		cacheTimbre(patchCache, timbreTemp);
+	}
+	playPoly(patchCache, NULL, midiKey, key, velocity);
+}
+
+bool Part::abortFirstPoly(unsigned int key) {
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		if (poly->getKey() == key) {
+			poly->abort();
+			return true;
+		}
+	}
+	return false;
+}
+
+bool Part::abortFirstPoly(PolyState polyState) {
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		if (poly->getState() == polyState) {
+			poly->abort();
+			return true;
+		}
+	}
+	return false;
+}
+
+bool Part::abortFirstPoly() {
+	if (activePolys.empty())
+		return false;
+	activePolys.front()->abort();
+	return true;
+}
+
+void Part::playPoly(const PatchCache cache[4], const MemParams::RhythmTemp *rhythmTemp, unsigned int midiKey, unsigned int key, unsigned int velocity) {
+	if((patchTemp->patch.assignMode & 2) == 0) {
+		// Single-assign mode
+		abortFirstPoly(key);
+	}
+
+	unsigned int needPartials = cache[0].partialCount;
+	if (needPartials == 0) {
+		LOG_MSG("MT32:%s (%s): Completely muted instrument", name, this->currentInstr);
+		return;
+	}
+
+	if (!synth->partialManager->freePartials(needPartials, partNum)) {
+		LOG_MSG("MT32:%s (%s): Insufficient free partials to play key %d (velocity %d); needed=%d, free=%d", name, currentInstr, midiKey, velocity, needPartials, synth->partialManager->getFreePartialCount());
+		return;
+	}
+
+	if (freePolys.empty()) {
+		LOG_MSG("MT32:%s (%s): No free poly to play key %d (velocity %d)", name, currentInstr, midiKey, velocity);
+		return;
+	}
+	Poly *poly = freePolys.front();
+	freePolys.pop_front();
+	if (patchTemp->patch.assignMode & 1) {
+		// Priority to data first received
+		activePolys.push_front(poly);
+	} else {
+		activePolys.push_back(poly);
+	}
+
+	Partial *partials[4];
+	for (int x = 0; x < 4; x++) {
+		if (cache[x].playPartial) {
+			partials[x] = synth->partialManager->allocPartial(partNum);
+			activePartialCount++;
+		} else {
+			partials[x] = NULL;
+		}
+	}
+	poly->reset(key, velocity, cache[0].sustain, partials);
+
+	for (int x = 0; x < 4; x++) {
+		if (partials[x] != NULL) {
+			partials[x]->startPartial(this, poly, &cache[x], rhythmTemp, partials[cache[x].structurePair]);
+		}
+	}
+}
+
+void Part::allNotesOff() {
+	// The MIDI specification states - and Mok confirms - that all notes off (0x7B)
+	// should treat the hold pedal as usual.
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		// FIXME: This has special handling of key 0 in NoteOff that Mok has not yet confirmed
+		// applies to AllNotesOff.
+		poly->noteOff(holdpedal);
+	}
+}
+
+void Part::allSoundOff() {
+	// MIDI "All sound off" (0x78) should release notes immediately regardless of the hold pedal.
+	// This controller is not actually implemented by the synths, though (according to the docs and Mok) -
+	// we're only using this method internally.
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		poly->startDecay();
+	}
+}
+
+void Part::stopPedalHold() {
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		poly->stopPedalHold();
+	}
+}
+
+void RhythmPart::noteOff(unsigned int midiKey) {
+	stopNote(midiKey);
+}
+
+void Part::noteOff(unsigned int midiKey) {
+	stopNote(midiKeyToKey(midiKey, "Note Off"));
+}
+
+void Part::stopNote(unsigned int key) {
+#if MT32EMU_MONITOR_INSTRUMENTS == 1
+	LOG_MSG("MT32:%s (%s): stopping key %d", name, currentInstr, key);
+#endif
+
+	for (std::list<Poly*>::iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		// Generally, non-sustaining instruments ignore note off. They die away eventually anyway.
+		// Key 0 (only used by special cases on rhythm part) reacts to note off even if non-sustaining or pedal held.
+		if (poly->getKey() == key && (poly->canSustain() || key == 0)) {
+			if (poly->noteOff(holdpedal && key != 0)) {
+				break;
+			}
+		}
+	}
+}
+
+const MemParams::PatchTemp *Part::getPatchTemp() const {
+	return patchTemp;
+}
+
+unsigned int Part::getActivePartialCount() const {
+	return activePartialCount;
+}
+
+unsigned int Part::getActiveNonReleasingPartialCount() const {
+	unsigned int activePartialCount = 0;
+	for (std::list<Poly*>::const_iterator polyIt = activePolys.begin(); polyIt != activePolys.end(); polyIt++) {
+		Poly *poly = *polyIt;
+		if (poly->getState() != POLY_Releasing) {
+			activePartialCount += poly->getActivePartialCount();
+		}
+	}
+	return activePartialCount;
+}
+
+void Part::partialDeactivated(Poly *poly) {
+	activePartialCount--;
+	if (!poly->isActive()) {
+		activePolys.remove(poly);
+		freePolys.push_front(poly);
+	}
+}
+
+}
diff -urN dosbox-0.73/src/gui/partial.cpp dosboxcvs/src/gui/partial.cpp
--- dosbox-0.73/src/gui/partial.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/partial.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,656 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <math.h>
+#include <string.h>
+
+#include "mt32emu.h"
+
+#define FIXEDPOINT_UDIV(x, y, point) (((x) << (point)) / ((y)))
+#define FIXEDPOINT_SDIV(x, y, point) (((x) * (1 << point)) / ((y)))
+#define FIXEDPOINT_UMULT(x, y, point) (((x) * (y)) >> point)
+#define FIXEDPOINT_SMULT(x, y, point) (((x) * (y)) / (1 << point))
+
+using namespace MT32Emu;
+
+Partial::Partial(Synth *useSynth, int debugPartialNum) :
+	synth(useSynth), debugPartialNum(debugPartialNum), tva(new TVA(this)), tvp(new TVP(this))
+{
+	ownerPart = -1;
+	poly = NULL;
+	pair = NULL;
+	// BlitSaws are initialised with dummy values here - they'll be reset the first time they're used anyway.
+	// We're not allocating lazily since deferring memory allocations until sound is actually playing doesn't seem like a good idea.
+	posSaw = new BlitSaw(1, 0.5);
+	negSaw = new BlitSaw(1, 0.0);
+}
+
+Partial::~Partial() {
+	delete posSaw;
+	delete negSaw;
+	delete tva;
+	delete tvp;
+}
+
+int Partial::getOwnerPart() const {
+	return ownerPart;
+}
+
+bool Partial::isActive() const {
+	return ownerPart > -1;
+}
+
+const Poly *Partial::getPoly() const {
+	return this->poly;
+}
+
+void Partial::activate(int part) {
+	// This just marks the partial as being assigned to a part
+	ownerPart = part;
+}
+
+void Partial::deactivate() {
+	if (!isActive())
+		return;
+	ownerPart = -1;
+	if (poly != NULL) {
+		poly->partialDeactivated(this);
+		if (pair != NULL) {
+			pair->pair = NULL;
+		}
+	}
+}
+
+void Partial::initKeyFollow(int key) {
+	// Calculate keyfollow for filter.
+	int keyfollow = ((key - MIDDLEC) * patchCache->filtkeyfollow) / 4096;
+	if (keyfollow > 108)
+		keyfollow = 108;
+	else if (keyfollow < -108)
+		keyfollow = -108;
+	filtVal = synth->tables.tvfKeyfollowMult[keyfollow + 108];
+}
+
+// DEPRECATED: This should probably go away eventually, it's currently only used as a kludge to protect our old assumptions that
+// rhythm part notes were always played as key MIDDLEC.
+int Partial::getKey() const {
+	if (poly == NULL) {
+		return -1;
+	} else if (ownerPart == 8) {
+		// FIXME: Hack, should go away after new pitch stuff is committed (and possibly some TVF changes)
+		return MIDDLEC;
+	} else {
+		return poly->getKey();
+	}
+}
+
+void Partial::startPartial(const Part *part, Poly *usePoly, const PatchCache *useCache, const MemParams::RhythmTemp *rhythmTemp, Partial *pairPartial) {
+	if (usePoly == NULL || useCache == NULL) {
+		LOG_MSG("MT32:*** Error: Starting partial for owner %d, usePoly=%s, useCache=%s", ownerPart, usePoly == NULL ? "*** NULL ***" : "OK", useCache == NULL ? "*** NULL ***" : "OK");
+		return;
+	}
+	patchCache = useCache;
+	poly = usePoly;
+	mixType = patchCache->structureMix;
+	structurePosition = patchCache->structurePosition;
+
+	play = true;
+	initKeyFollow(getKey()); // Initialises filtVal and realVal
+	keyLookup = &synth->tables.keyLookups[getKey() - 12];
+
+	Bit8u panSetting = rhythmTemp != NULL ? rhythmTemp->panpot : part->getPatchTemp()->panpot;
+	if(mixType == 3) {
+		if(structurePosition == 0) {
+			if(panSetting > 7) {
+				panSetting = (panSetting - 7) * 2;
+			} else {
+				panSetting = 0;
+			}
+		} else {
+			if(panSetting < 7) {
+				panSetting = panSetting * 2;
+			} else {
+				panSetting = 14;
+			}
+		}
+		// Do a normal mix independent of any pair partial.
+		mixType = 0;
+		pairPartial = NULL;
+	}
+	// FIXME: Sample analysis suggests that this is linear, but there are some some quirks that still need to be resolved.
+	// On the real devices, there are only 8 real pan positions.
+	stereoVolume.leftvol = panSetting * 32768 / 14;
+	stereoVolume.rightvol = 32768 - stereoVolume.leftvol;
+
+	if (patchCache->PCMPartial) {
+		pcmNum = patchCache->pcm;
+		if (synth->controlROMMap->pcmCount > 128) {
+			// CM-32L, etc. support two "banks" of PCMs, selectable by waveform type parameter.
+			if (patchCache->waveform > 1) {
+				pcmNum += 128;
+			}
+		}
+		pcmWave = &synth->pcmWaves[pcmNum];
+	} else {
+		pcmWave = NULL;
+	}
+
+	pastCarrier = 0;
+	pastOsc = 0;
+	pastDesCarrier = 0;
+
+	pulsewidth = patchCache->pulsewidth + synth->tables.pwVelfollowAdd[patchCache->pwsens][poly->getVelocity()];
+	if (pulsewidth > 100) {
+		pulsewidth = 100;
+	} else if (pulsewidth < 0) {
+		pulsewidth = 0;
+	}
+
+	filtEnv.envpos = 0;
+	filtEnv.envstat = -1;
+	filtEnv.envbase = 0;
+	filtEnv.envdist = 0;
+	filtEnv.envsize = 0;
+	filtEnv.sustaining = false;
+	filtEnv.decaying = false;
+	filtEnv.prevlevel = 0;
+	filtEnv.counter = 0;
+	filtEnv.count = 0;
+
+	loopPos = 0;
+	pcmPosition = 0.0f;
+	intPCMPosition = 0;
+	pair = pairPartial;
+	useNoisePair = pairPartial == NULL && (mixType == 1 || mixType == 2);
+	alreadyOutputed = false;
+	tva->reset(part, patchCache, rhythmTemp);
+	tvp->reset(part, patchCache);
+	firstSample = true;
+	memset(history,0,sizeof(history));
+}
+
+Bit16s Partial::getPCMSample(unsigned int position) {
+	if (position >= pcmWave->len) {
+		if (!pcmWave->loop) {
+			return 0;
+		}
+		position = position % pcmWave->len;
+	}
+	return synth->pcmROMData[pcmWave->addr + position];
+}
+
+Bit16s *Partial::generateSamples(long length) {
+	if (!isActive() || alreadyOutputed) {
+		return NULL;
+	}
+	if (poly == NULL) {
+		LOG_MSG("MT32:*** ERROR: poly is NULL at Partial::generateSamples()!");
+		return NULL;
+	}
+
+	alreadyOutputed = true;
+
+	// Generate samples
+
+	Bit16s *partialBuf = &myBuffer[0];
+	while (length--) {
+		float sample = 0;
+		float amp = tva->nextAmp();
+		if (!tva->play) {
+			deactivate();
+			break;
+		}
+
+		Bit16u pitch = tvp->nextPitch();
+
+		// Aka (slightly slower): powf(2.0f, pitchVal / 4096.0f - 16.0f) * 32000.0f
+		float freq = powf(2.0f, pitch / 4096.0f - 1.034215715f);
+
+		if (patchCache->PCMPartial) {
+			// Render PCM waveform
+			int len = pcmWave->len;
+			if (intPCMPosition >= len && !pcmWave->loop) {
+				// We're now past the end of a non-looping PCM waveform so it's time to die.
+				play = false;
+				deactivate();
+				break;
+			}
+			Bit32u pcmAddr = pcmWave->addr;
+			float positionDelta = freq * 2048.0f / synth->myProp.sampleRate;
+			float newPCMPosition = pcmPosition + positionDelta;
+			int newIntPCMPosition = (int)newPCMPosition;
+
+			if (amp != 0.0f) {
+				// Only bother doing the actual sample calculation if someone's going to hear it.
+				if (positionDelta < 1.0f) {
+					// Linear interpolation
+					int firstSample = synth->pcmROMData[pcmAddr + intPCMPosition];
+					int nextSample = getPCMSample(intPCMPosition + 1);
+					sample = firstSample + (nextSample - firstSample) * (pcmPosition - intPCMPosition);
+				} else if (intPCMPosition == newIntPCMPosition) {
+					// Small optimisation
+					sample = synth->pcmROMData[pcmAddr + newIntPCMPosition];
+				} else {
+					// Average all the samples in the range
+					double sampleSum = synth->pcmROMData[pcmAddr + intPCMPosition] * ((intPCMPosition + 1) - pcmPosition); // First sample may not be 100% in range
+					for (int position = intPCMPosition + 1; position < newIntPCMPosition; position++) {
+						sampleSum += getPCMSample(position);
+					}
+					sampleSum += getPCMSample(newIntPCMPosition) * (newPCMPosition - newIntPCMPosition); // Last sample may not be 100% in range
+					sample = (float)(sampleSum / positionDelta);
+				}
+			} else {
+				// If a sample is calculated in the woods, and the current TVA value's too low to hear it, is there any point?
+				sample = 0.0f;
+			}
+			if (pcmWave->loop) {
+				newPCMPosition = fmodf(newPCMPosition, pcmWave->len);
+				newIntPCMPosition = newIntPCMPosition % pcmWave->len;
+			}
+			pcmPosition = newPCMPosition;
+			intPCMPosition = newIntPCMPosition;
+		} else {
+			// Render synthesised waveform
+			if(firstSample) {
+				firstSample = false;
+				float spw = synth->tables.pwFactorf[pulsewidth];
+				if ((patchCache->waveform & 1) != 0 && spw < 0.5f) {
+					spw = 0.5f - ((0.5f - spw) * 2.0f);
+				}
+				posSaw->reset(freq, spw);
+				negSaw->reset(freq, 0.0);
+			} else {
+				posSaw->setFrequency(freq);
+				negSaw->setFrequency(freq);
+			}
+			Bit32s filtval = getFiltEnvelope();
+
+			float phase = negSaw->getPhase();
+
+			sample = posSaw->tick() - negSaw->tick();
+			float freqsum = 0;
+			freqsum = ((powf(256.0f, (((float)filtval / 128.0f) - 1.0f))) * posSaw->getStartFreq());
+			if(freqsum >= (FILTERGRAN - 500.0))
+				freqsum = (FILTERGRAN - 500.0f);
+			filtval = (Bit32s)freqsum;
+
+			sample = (floorf((synth->iirFilter)((sample * WGAMP), &history[0], synth->tables.filtCoeff[filtval][(int)patchCache->filtEnv.resonance])));
+
+			if ((patchCache->waveform & 1) != 0) {
+				//CC: Sawtooth samples are finally generated here by multipling an in-sync cosine
+				//with the generated square wave.
+
+				//CC: Computers are fast these days.  Not caring to use a LUT or fixed point anymore.
+				//If I port this to the iPhone I may reconsider.
+				sample = ((cosf(phase * 2.0f)) * sample) + (WGAMP * 0.1618f);
+			}
+
+			if (sample < -32768.0f) {
+#ifdef MT32DEBUG
+				// These are really a problem, why not use doubles?
+				LOG_MSG("MT32:Overdriven amplitude for waveform=%d, freqsum=%f: %f < -32768", patchCache->waveform, freqsum, sample);
+#endif
+				sample = -32768.0f;
+			}
+			else if (sample > 32767.0f) {
+#ifdef MT32DEBUG
+				LOG_MSG("MT32:Overdriven amplitude for waveform=%d, freqsum=%f: %f > 32767", patchCache->waveform, freqsum, sample);
+#endif
+				sample = 32767.0f;
+			}
+			filtEnv.envpos++;
+		}
+
+		// Multiply sample with current TVA value and add to buffer.
+		*partialBuf++ = (Bit16s)(amp * sample);
+	}
+	// We may have deactivated and broken out of the loop before the end of the buffer,
+	// if so then fill the remainder with 0s.
+	if (++length > 0)
+		memset(partialBuf, 0, length * 2);
+	return &myBuffer[0];
+}
+
+Bit16s *Partial::mixBuffers(Bit16s * buf1, Bit16s *buf2, int len) {
+	if (buf1 == NULL)
+		return buf2;
+	if (buf2 == NULL)
+		return buf1;
+
+	Bit16s *outBuf = buf1;
+	while (len--) {
+		*buf1 = *buf1 + *buf2;
+		buf1++, buf2++;
+	}
+	return outBuf;
+}
+
+Bit16s *Partial::mixBuffersRingMix(Bit16s * buf1, Bit16s *buf2, int len) {
+	if (buf1 == NULL)
+		return NULL;
+	if (buf2 == NULL) {
+		Bit16s *outBuf = buf1;
+		while (len--) {
+			if (*buf1 < -8192)
+				*buf1 = -8192;
+			else if (*buf1 > 8192)
+				*buf1 = 8192;
+			buf1++;
+		}
+		return outBuf;
+	}
+
+	Bit16s *outBuf = buf1;
+	#define CUTOFF 2048
+	while (len--) {
+		int a[3], b[3], c[2], d[2], result;
+		a[0] = ((Bit32s)*buf1);
+		b[0] = ((Bit32s)*buf2);
+
+		a[1] = pastCarrier + ((CUTOFF * (a[0] - pastCarrier)) >> 12);
+		a[2] = a[1] + ((CUTOFF * (0 - a[1])) >> 12);
+		pastCarrier = a[2];
+
+		b[1] = pastOsc + ((CUTOFF * (b[0] - pastOsc)) >> 12);
+		b[2] = b[1] + ((CUTOFF * (0 - b[1])) >> 12);
+		pastOsc = b[2];
+
+		c[0] = a[1] ^ b[1];
+		c[1] = (a[2] * b[2]);
+
+		d[0] = pastDesCarrier + ((CUTOFF * (c[0] - pastDesCarrier)) >> 12);
+		d[1] = d[0] + ((CUTOFF * (c[1] - d[0])) >> 12);
+
+		pastDesCarrier = d[1];
+
+		result = ((d[0] >> 5) + a[0]);
+
+		if (result>32767)
+			result = 32767;
+		if (result<-32768)
+			result = -32768;
+		*buf1 = (Bit16s)(result);
+		buf1++;
+		buf2++;
+	}
+	return outBuf;
+}
+
+Bit16s *Partial::mixBuffersRing(Bit16s * buf1, Bit16s *buf2, int len) {
+	if (buf1 == NULL) {
+		return NULL;
+	}
+	if (buf2 == NULL) {
+		return NULL;
+	}
+
+	Bit16s *outBuf = buf1;
+	while (len--) {
+		int a[3], b[3], c[2], d[2], result;
+
+		a[0] = ((Bit32s)*buf1);
+		b[0] = ((Bit32s)*buf2);
+
+
+		a[1] = pastCarrier + ((CUTOFF * (a[0] - pastCarrier)) >> 12);
+		a[2] = a[1] + ((CUTOFF * (0 - a[1])) >> 12);
+		pastCarrier = a[2];
+
+
+		b[1] = pastOsc + ((CUTOFF * (b[0] - pastOsc)) >> 12);
+		b[2] = b[1] + ((CUTOFF * (0 - b[1])) >> 12);
+		pastOsc = b[2];
+
+		c[0] = a[1] ^ b[1];
+		c[1] = (a[2] * b[2]);
+
+		d[0] = pastDesCarrier + ((CUTOFF * (c[0] - pastDesCarrier)) >> 12);
+		d[1] = d[0] + ((CUTOFF * (c[1] - d[0])) >> 12);
+
+		pastDesCarrier = d[1];
+
+		result = d[0] >> 5;
+
+		if (result>32767)
+			result = 32767;
+		if (result<-32768)
+			result = -32768;
+		*buf1 = (Bit16s)(result);
+		buf1++;
+		buf2++;
+	}
+	return outBuf;
+}
+
+bool Partial::hasRingModulatingSlave() const {
+	return pair != NULL && structurePosition == 0 && (mixType == 1 || mixType == 2);
+}
+
+bool Partial::isRingModulatingSlave() const {
+	return pair != NULL && structurePosition == 1 && (mixType == 1 || mixType == 2);
+}
+
+bool Partial::isPCM() const {
+	return pcmWave != NULL;
+}
+
+const ControlROMPCMStruct *Partial::getControlROMPCMStruct() const {
+	if(pcmWave != NULL)
+		return pcmWave->controlROMPCMStruct;
+	return NULL;
+}
+
+Synth *Partial::getSynth() const {
+	return synth;
+}
+
+bool Partial::produceOutput(Bit16s *partialBuf, long length) {
+	if (!isActive() || alreadyOutputed)
+		return false;
+	if (poly == NULL) {
+		LOG_MSG("MT32:*** ERROR: poly is NULL at Partial::produceOutput()!");
+		return false;
+	}
+
+	Bit16s *pairBuf = NULL;
+	// Check for dependent partial
+	if (pair != NULL) {
+		if (!pair->alreadyOutputed) {
+			// Note: pair may have become NULL after this
+			pairBuf = pair->generateSamples(length);
+		}
+	} else if (useNoisePair) {
+		// Generate noise for pairless ring mix
+		pairBuf = synth->tables.noiseBuf;
+	}
+
+	Bit16s *myBuf = generateSamples(length);
+
+	if (myBuf == NULL && pairBuf == NULL)
+		return false;
+
+	Bit16s *p1buf, *p2buf;
+
+	if (structurePosition == 0 || pairBuf == NULL) {
+		p1buf = myBuf;
+		p2buf = pairBuf;
+	} else {
+		p2buf = myBuf;
+		p1buf = pairBuf;
+	}
+
+	//LOG_MSG("MT32:mixType: %d", mixType);
+
+	Bit16s *mixedBuf;
+	switch (mixType) {
+	case 0:
+		// Standard sound mix
+		mixedBuf = mixBuffers(p1buf, p2buf, length);
+		break;
+
+	case 1:
+		// Ring modulation with sound mix
+		mixedBuf = mixBuffersRingMix(p1buf, p2buf, length);
+		break;
+
+	case 2:
+		// Ring modulation alone
+		mixedBuf = mixBuffersRing(p1buf, p2buf, length);
+		break;
+
+	default:
+		mixedBuf = mixBuffers(p1buf, p2buf, length);
+		break;
+	}
+
+	if (mixedBuf == NULL)
+		return false;
+
+	while (length--) {
+		*partialBuf++ = (Bit16s)(((Bit32s)*mixedBuf * (Bit32s)stereoVolume.leftvol) >> 16);
+		*partialBuf++ = (Bit16s)(((Bit32s)*mixedBuf * (Bit32s)stereoVolume.rightvol) >> 16);
+		mixedBuf++;
+	}
+	return true;
+}
+
+Bit32s Partial::getFiltEnvelope() {
+	int reshigh;
+
+	int cutoff;
+
+	EnvelopeStatus *tStat = &filtEnv;
+
+	if (tStat->decaying) {
+		reshigh = tStat->envbase;
+		reshigh = (reshigh + ((tStat->envdist * tStat->envpos) / tStat->envsize));
+		if (tStat->envpos >= tStat->envsize)
+			reshigh = 0;
+	} else {
+		if (tStat->envstat==4) {
+			reshigh = patchCache->filtsustain;
+			if (!poly->canSustain()) {
+				startFiltDecay(reshigh);
+			}
+		} else {
+			if ((tStat->envstat==-1) || (tStat->envpos >= tStat->envsize)) {
+				if (tStat->envstat==-1)
+					tStat->envbase = 0;
+				else
+					tStat->envbase = patchCache->filtEnv.envLevel[tStat->envstat];
+				tStat->envstat++;
+				tStat->envpos = 0;
+				if (tStat->envstat == 3) {
+					tStat->envsize = synth->tables.envTime[(int)patchCache->filtEnv.envTime[tStat->envstat]];
+				} else {
+					Bit32u envTime = (int)patchCache->filtEnv.envTime[tStat->envstat];
+					if (tStat->envstat > 1) {
+						int envDiff = abs(patchCache->filtEnv.envLevel[tStat->envstat] - patchCache->filtEnv.envLevel[tStat->envstat - 1]);
+						if (envTime > synth->tables.envDeltaMaxTime[envDiff]) {
+							envTime = synth->tables.envDeltaMaxTime[envDiff];
+						}
+					}
+
+					tStat->envsize = (synth->tables.envTime[envTime] * keyLookup->envTimeMult[(int)patchCache->filtEnv.envTimeKeyfollow]) >> 8;
+				}
+
+				tStat->envsize++;
+				tStat->envdist = patchCache->filtEnv.envLevel[tStat->envstat] - tStat->envbase;
+			}
+
+			reshigh = tStat->envbase;
+			reshigh = (reshigh + ((tStat->envdist * tStat->envpos) / tStat->envsize));
+		}
+		tStat->prevlevel = reshigh;
+	}
+
+	cutoff = filtMultKeyfollow[patchCache->srcPartial.tvf.keyfollow] - filtMultKeyfollow[patchCache->srcPartial.wg.pitchKeyfollow];
+	cutoff *= ((Bit32s)getKey() - 60);
+	int dynamicBiasPoint = (Bit32s)patchCache->srcPartial.tvf.biasPoint;
+	if ((dynamicBiasPoint & 0x40) == 0) {
+		dynamicBiasPoint = dynamicBiasPoint + 33 - (Bit32s)getKey();
+		if (dynamicBiasPoint > 0) {
+			dynamicBiasPoint = -dynamicBiasPoint;
+			dynamicBiasPoint *= BiasLevel_MulTable[patchCache->srcPartial.tvf.biasLevel];
+			cutoff += dynamicBiasPoint;
+		}
+	} else {
+		dynamicBiasPoint = dynamicBiasPoint - 31 - (Bit32s)getKey();
+		if (dynamicBiasPoint <= 0) {
+			dynamicBiasPoint *= BiasLevel_MulTable[patchCache->srcPartial.tvf.biasLevel];
+			cutoff += dynamicBiasPoint;
+		}
+	}
+
+	cutoff += (((Bit32s)patchCache->srcPartial.tvf.cutoff << 4) - 800);
+	if (cutoff >= 0) {
+		Bit32u basePitch = tvp->getBasePitch();
+		int pitchAdjust = (basePitch >> 4) + cutoff - 3584;
+		if (pitchAdjust > 0) {
+			cutoff -= pitchAdjust;
+		}
+	} else {
+		if (cutoff < -2048) {
+			cutoff = -2048;
+		}
+	}
+	cutoff = (cutoff + 2056) >> 4;
+	if (cutoff > 255) {
+		cutoff = 255;
+	}
+
+	int veloFilEnv = (Bit32s)poly->getVelocity() * (Bit32s)patchCache->srcPartial.tvf.envVeloSensitivity;
+	int filEnv = (veloFilEnv << 2) >> 8;
+	veloFilEnv  = 109 - patchCache->srcPartial.tvf.envVeloSensitivity + filEnv;
+	filEnv = ((Bit32s)getKey() - 60) >> (4 - (Bit32s)patchCache->srcPartial.tvf.envDepthKeyfollow);
+	veloFilEnv += filEnv;
+	if (veloFilEnv < 0) {
+		veloFilEnv = 0;
+	}
+	veloFilEnv *= patchCache->srcPartial.tvf.envDepth;
+	filEnv = (veloFilEnv << 2) >> 8;
+	if (filEnv > 255) {
+		filEnv = 255;
+	}
+
+	filEnv = (filEnv * reshigh) >> 8;
+
+	return cutoff + filEnv;
+}
+
+bool Partial::shouldReverb() {
+	if (!isActive())
+		return false;
+	return patchCache->reverb;
+}
+
+void Partial::startDecayAll() {
+	tva->startDecay();
+	tvp->startDecay();
+	startFiltDecay(filtEnv.prevlevel);
+}
+
+void Partial::startFiltDecay(Bit32s startval) {
+	filtEnv.sustaining = false;
+	filtEnv.decaying = true;
+	filtEnv.envpos = 0;
+	filtEnv.envbase = startval;
+
+	filtEnv.envsize = FIXEDPOINT_UMULT(synth->tables.envDecayTime[(int)patchCache->filtEnv.envTime[4]], keyLookup->envTimeMult[(int)patchCache->filtEnv.envTimeKeyfollow], 8);
+	filtEnv.envdist = -startval;
+	filtEnv.envsize++;
+}
diff -urN dosbox-0.73/src/gui/partialManager.cpp dosboxcvs/src/gui/partialManager.cpp
--- dosbox-0.73/src/gui/partialManager.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/partialManager.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,185 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <string.h>
+
+#include "mt32emu.h"
+
+using namespace MT32Emu;
+
+PartialManager::PartialManager(Synth *useSynth, Part **parts) {
+	this->synth = useSynth;
+	this->parts = parts;
+	for (int i = 0; i < MT32EMU_MAX_PARTIALS; i++)
+		partialTable[i] = new Partial(synth, i);
+}
+
+PartialManager::~PartialManager(void) {
+	for (int i = 0; i < MT32EMU_MAX_PARTIALS; i++)
+		delete partialTable[i];
+}
+
+void PartialManager::clearAlreadyOutputed() {
+	for (int i = 0; i < MT32EMU_MAX_PARTIALS; i++)
+		partialTable[i]->alreadyOutputed = false;
+}
+
+bool PartialManager::shouldReverb(int i) {
+	return partialTable[i]->shouldReverb();
+}
+
+bool PartialManager::produceOutput(int i, Bit16s *buffer, Bit32u bufferLength) {
+	return partialTable[i]->produceOutput(buffer, bufferLength);
+}
+
+void PartialManager::deactivateAll() {
+	for (int i = 0; i < MT32EMU_MAX_PARTIALS; i++) {
+		partialTable[i]->deactivate();
+	}
+}
+
+unsigned int PartialManager::setReserve(Bit8u *rset) {
+	unsigned int pr = 0;
+	for (int x = 0; x <= 8; x++) {
+		numReservedPartialsForPart[x] = rset[x];
+		pr += rset[x];
+	}
+	return pr;
+}
+
+Partial *PartialManager::allocPartial(int partNum) {
+	Partial *outPartial = NULL;
+
+	// Get the first inactive partial
+	for (int partialNum = 0; partialNum < MT32EMU_MAX_PARTIALS; partialNum++) {
+		if (!partialTable[partialNum]->isActive()) {
+			outPartial = partialTable[partialNum];
+			break;
+		}
+	}
+	if (outPartial != NULL) {
+		outPartial->activate(partNum);
+	}
+	return outPartial;
+}
+
+unsigned int PartialManager::getFreePartialCount(void) {
+	int count = 0;
+	for (int i = 0; i < MT32EMU_MAX_PARTIALS; i++) {
+		if (!partialTable[i]->isActive())
+			count++;
+	}
+	return count;
+}
+
+// This method assumes that getFreePartials() has been called to make numReservedPartialsForPart up-to-date.
+// The rhythm part is considered part -1 for the purposes of the minPart argument (and as this suggests, is checked last, if at all).
+bool PartialManager::abortWhereReserveExceeded(PolyState polyState, int minPart) {
+	// Abort decaying polys in non-rhythm parts that have exceeded their partial reservation (working backwards from part 7)
+	for (int partNum = 7; partNum >= minPart; partNum--) {
+		int usePartNum = partNum == -1 ? 8 : partNum;
+		if (parts[usePartNum]->getActivePartialCount() > numReservedPartialsForPart[usePartNum]) {
+			// This part has exceeded its reserved partial count.
+			// We go through and look for a poly with the given state and abort the first one we find.
+			if (parts[usePartNum]->abortFirstPoly(polyState))
+				return true;
+		}
+	}
+	return false;
+}
+
+bool PartialManager::freePartials(unsigned int needed, int partNum) {
+	// CONFIRMED: Barring bugs, and the fact that poly abortion is immediate rather than just very fast,
+	// this matches the real LAPC-I according to information from Mok.
+
+	// BUGS: There are some bugs in the LAPC-I implementation. Simplifying a bit(!):
+	// 1) When allocating for rhythm part, while the number of active rhythm partials is less than the number of reserved rhythm partials,
+	//    held rhythm polys will potentially be aborted before releasing rhythm polys. This bug isn't present on MT-32.
+	// 2) When allocating for any part, once the number of partials on the allocating part is less than the number of partials reserved for that part,
+	//    partials will potentially be aborted in their priority order with no regard for their state (playing, held or releasing).
+	// I consider these to be bugs because I think that playing polys should always have priority over held polys,
+	// and held polys should always have priority over releasing polys.
+
+	// NOTE: This code generally aborts polys in parts (according to certain conditions) in the following order:
+	// 7, 6, 5, 4, 3, 2, 1, 0, 8 (rhythm)
+	// (from lowest priority, meaning most likely to have polys aborted, to highest priority, meaning least likely)
+
+	if (needed == 0) {
+		return true;
+	}
+
+	// Note that calling getFreePartialCount() also ensures that numReservedPartialsPerPart is up-to-date
+	if (getFreePartialCount() >= needed)
+		return true;
+
+	for (;;) {
+		// On the MT-32, this is: if (!abortWhereReserveExceeded(POLY_Releasing, -1)) {
+		if (!abortWhereReserveExceeded(POLY_Releasing, 0)) {
+			break;
+		}
+		if (getFreePartialCount() >= needed)
+			return true;
+	}
+
+	if (parts[partNum]->getActiveNonReleasingPartialCount() + needed > numReservedPartialsForPart[partNum]) {
+		// With the new partials we're freeing for, we would end up using more partials than we have reserved.
+		if (synth->getPart(partNum)->getPatchTemp()->patch.assignMode & 1) {
+			// Priority is given to earlier polys, so just give up
+			return false;
+		}
+		if (needed > numReservedPartialsForPart[partNum]) {
+			// We haven't even reserved enough partials to play this one poly, so:
+			// Only abort held polys in our own part and parts that have a lower priority
+			// (higher part number = lower priority, except for rhythm, which has the highest priority).
+			for (;;) {
+				if (!abortWhereReserveExceeded(POLY_Held, partNum == 8 ? -1 : partNum)) {
+					break;
+				}
+				if (getFreePartialCount() >= needed)
+					return true;
+			}
+			return false;
+		}
+	}
+	// At this point, we're certain that we've reserved enough partials to play our poly.
+	// Abort held polys in all parts (including rhythm only when being called for the rhythm part),
+	// from lowest to highest priority, until we have enough free partials.
+	for (;;) {
+		if (!abortWhereReserveExceeded(POLY_Held, partNum == 8 ? -1 : 0)) {
+			break;
+		}
+		if (getFreePartialCount() >= needed)
+			return true;
+	}
+
+	// Abort the target part's own polys indiscriminately (regardless of their state)
+	for (;;) {
+		if (!parts[partNum]->abortFirstPoly()) {
+			break;
+		}
+		if (getFreePartialCount() >= needed)
+			return true;
+	}
+
+	// Aww, not enough partials for you.
+	return false;
+}
+
+const Partial *PartialManager::getPartial(unsigned int partialNum) const {
+	if (partialNum > MT32EMU_MAX_PARTIALS - 1)
+		return NULL;
+	return partialTable[partialNum];
+}
diff -urN dosbox-0.73/src/gui/poly.cpp dosboxcvs/src/gui/poly.cpp
--- dosbox-0.73/src/gui/poly.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/poly.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,153 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mt32emu.h"
+
+namespace MT32Emu {
+
+Poly::Poly(Part *part) {
+	this->part = part;
+	key = 255;
+	velocity = 255;
+	sustain = false;
+	activePartialCount = 0;
+	for (int i = 0; i < 4; i++) {
+		partials[i] = NULL;
+	}
+	state = POLY_Inactive;
+}
+
+void Poly::reset(unsigned int key, unsigned int velocity, bool canSustain, Partial **partials) {
+	if(isActive()) {
+		// FIXME: Throw out some big ugly debug output with a lot of exclamation marks - we should never get here
+		abort();
+	}
+
+	this->key = key;
+	this->velocity = velocity;
+	this->sustain = canSustain;
+
+	activePartialCount = 0;
+	for (int i = 0; i < 4; i++) {
+		this->partials[i] = partials[i];
+		if (partials[i] != NULL) {
+			activePartialCount++;
+			state = POLY_Playing;
+		}
+	}
+}
+
+bool Poly::noteOff(bool pedalHeld) {
+	// Generally, non-sustaining instruments ignore note off. They die away eventually anyway.
+	// Key 0 (only used by special cases on rhythm part) reacts to note off even if non-sustaining or pedal held.
+	if (state == POLY_Inactive || state == POLY_Releasing) {
+		return false;
+	}
+	if (pedalHeld) {
+		state = POLY_Held;
+	} else {
+		startDecay();
+	}
+	return true;
+}
+
+bool Poly::stopPedalHold() {
+	if (state != POLY_Held)
+		return false;
+	return startDecay();
+}
+
+bool Poly::startDecay() {
+	if (state == POLY_Inactive || state == POLY_Releasing) {
+		return false;
+	}
+	state = POLY_Releasing;
+
+	for (int t = 0; t < 4; t++) {
+		Partial *partial = partials[t];
+		if (partial != NULL) {
+			partial->startDecayAll();
+		}
+	}
+	return true;
+}
+
+void Poly::abort() {
+	if (state == POLY_Inactive) {
+		return;
+	}
+	for (int t = 0; t < 4; t++) {
+		Partial *partial = partials[t];
+		if (partial != NULL) {
+			partial->deactivate();
+		}
+	}
+	if (state != POLY_Inactive) {
+		// FIXME: Throw out lots of debug output - this should never happen
+		// (Deactivating the partials above should've made them each call partialDeactivated(), ultimately changing the state to POLY_Inactive)
+		state = POLY_Inactive;
+	}
+}
+
+void Poly::backupCacheToPartials(PatchCache cache[4]) {
+	for (int partialNum = 0; partialNum < 4; partialNum++) {
+		Partial *partial = partials[partialNum];
+		if (partial != NULL && partial->patchCache == &cache[partialNum]) {
+			partial->cachebackup = cache[partialNum];
+			partial->patchCache = &partial->cachebackup;
+		}
+	}
+}
+
+unsigned int Poly::getKey() const {
+	return key;
+}
+
+unsigned int Poly::getVelocity() const {
+	return velocity;
+}
+
+bool Poly::canSustain() const {
+	return sustain;
+}
+
+PolyState Poly::getState() const {
+	return state;
+}
+
+unsigned int Poly::getActivePartialCount() const {
+	return activePartialCount;
+}
+
+bool Poly::isActive() const {
+	return state != POLY_Inactive;
+}
+
+// This is called by Partial to inform the poly that the Partial has deactivated
+void Poly::partialDeactivated(Partial *partial) {
+	for (int i = 0; i < 4; i++) {
+		if (partials[i] == partial) {
+			partials[i] = NULL;
+			activePartialCount--;
+		}
+	}
+	if (activePartialCount == 0) {
+		state = POLY_Inactive;
+	}
+	part->partialDeactivated(this);
+}
+
+}
diff -urN dosbox-0.73/src/gui/render.cpp dosboxcvs/src/gui/render.cpp
--- dosbox-0.73/src/gui/render.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/gui/render.cpp	2009-07-08 20:43:44.000000000 +0300
@@ -347,9 +347,9 @@
 			break;
 		}
 #endif
-	} else if (dblw) {
+	} else if (dblw && (render.scale.size < 4)) {
 		simpleBlock = &ScaleNormalDw;
-	} else if (dblh) {
+	} else if (dblh && (render.scale.size < 4)) {
 		simpleBlock = &ScaleNormalDh;
 	} else  {
 forcenormal:
@@ -409,8 +409,27 @@
 	width *= xscale;
 	Bitu skip = complexBlock ? 1 : 0;
 	if (gfx_flags & GFX_SCALING) {
+		if(render.scale.size == 4) {
+		    if(dblh)
+			gfx_scaleh *= 2;
+		    if(dblw)
+			gfx_scalew *= 2;
+		} else if(render.scale.size == 6) {
+		    if(dblh && dblw) {
+			gfx_scaleh *= 3; gfx_scalew *= 3;
+		    } else if(dblh) {
+			gfx_scaleh *= 2;
+		    } else if(dblw)
+			gfx_scalew *= 2;
+		}
 		height = MakeAspectTable(skip, render.src.height, yscale, yscale );
 	} else {
+		// Print a warning when hardware scalers are selected, hopefully the first
+		// video mode will not have dblh or dblw or AR will be wrong
+		if ((render.scale.size > 3)) {
+			LOG_MSG("Output does not support hardware scaling, switching to normal scalers");
+			render.scale.size >>= 1;
+		}
 		if ((gfx_flags & GFX_CAN_RANDOM) && gfx_scaleh > 1) {
 			gfx_scaleh *= yscale;
 			height = MakeAspectTable( skip, render.src.height, gfx_scaleh, yscale );
@@ -564,6 +583,10 @@
 	RENDER_CallBack( GFX_CallBackReset );
 } */
 
+bool RENDER_GetAspect(void) {
+	return render.aspect;
+}
+
 void RENDER_Init(Section * sec) {
 	Section_prop * section=static_cast<Section_prop *>(sec);
 
@@ -616,6 +639,8 @@
 	else if (scaler == "scan2x"){ render.scale.op = scalerOpScan;render.scale.size = 2; }
 	else if (scaler == "scan3x"){ render.scale.op = scalerOpScan;render.scale.size = 3; }
 #endif
+	else if (scaler == "hardware2x") { render.scale.op = scalerOpNormal;render.scale.size = 4; }
+	else if (scaler == "hardware3x") { render.scale.op = scalerOpNormal;render.scale.size = 6; }
 
 	//If something changed that needs a ReInit
 	// Only ReInit when there is a src.bpp (fixes crashes on startup and directly changing the scaler without a screen specified yet)
diff -urN dosbox-0.73/src/gui/revmodel.cpp dosboxcvs/src/gui/revmodel.cpp
--- dosbox-0.73/src/gui/revmodel.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/revmodel.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,256 @@
+// Reverb model implementation
+//
+// Written by Jezar at Dreampoint, June 2000
+// http://www.dreampoint.co.uk
+// This code is public domain
+
+#include "freeverb/revmodel.h"
+
+revmodel::revmodel()
+{
+	// Tie the components to their buffers
+	combL[0].setbuffer(bufcombL1,combtuningL1);
+	combR[0].setbuffer(bufcombR1,combtuningR1);
+	combL[1].setbuffer(bufcombL2,combtuningL2);
+	combR[1].setbuffer(bufcombR2,combtuningR2);
+	combL[2].setbuffer(bufcombL3,combtuningL3);
+	combR[2].setbuffer(bufcombR3,combtuningR3);
+	combL[3].setbuffer(bufcombL4,combtuningL4);
+	combR[3].setbuffer(bufcombR4,combtuningR4);
+	combL[4].setbuffer(bufcombL5,combtuningL5);
+	combR[4].setbuffer(bufcombR5,combtuningR5);
+	combL[5].setbuffer(bufcombL6,combtuningL6);
+	combR[5].setbuffer(bufcombR6,combtuningR6);
+	combL[6].setbuffer(bufcombL7,combtuningL7);
+	combR[6].setbuffer(bufcombR7,combtuningR7);
+	combL[7].setbuffer(bufcombL8,combtuningL8);
+	combR[7].setbuffer(bufcombR8,combtuningR8);
+	allpassL[0].setbuffer(bufallpassL1,allpasstuningL1);
+	allpassR[0].setbuffer(bufallpassR1,allpasstuningR1);
+	allpassL[1].setbuffer(bufallpassL2,allpasstuningL2);
+	allpassR[1].setbuffer(bufallpassR2,allpasstuningR2);
+	allpassL[2].setbuffer(bufallpassL3,allpasstuningL3);
+	allpassR[2].setbuffer(bufallpassR3,allpasstuningR3);
+	allpassL[3].setbuffer(bufallpassL4,allpasstuningL4);
+	allpassR[3].setbuffer(bufallpassR4,allpasstuningR4);
+
+	// Set default values
+	allpassL[0].setfeedback(0.5f);
+	allpassR[0].setfeedback(0.5f);
+	allpassL[1].setfeedback(0.5f);
+	allpassR[1].setfeedback(0.5f);
+	allpassL[2].setfeedback(0.5f);
+	allpassR[2].setfeedback(0.5f);
+	allpassL[3].setfeedback(0.5f);
+	allpassR[3].setfeedback(0.5f);
+	setwet(initialwet);
+	setroomsize(initialroom);
+	setdry(initialdry);
+	setdamp(initialdamp);
+	setwidth(initialwidth);
+	setmode(initialmode);
+
+	// Buffer will be full of rubbish - so we MUST mute them
+	mute();
+}
+
+void revmodel::mute()
+{
+	int i;
+
+	if (getmode() >= freezemode)
+		return;
+
+	for (i=0;i<numcombs;i++)
+	{
+		combL[i].mute();
+		combR[i].mute();
+	}
+	for (i=0;i<numallpasses;i++)
+	{
+		allpassL[i].mute();
+		allpassR[i].mute();
+	}
+}
+
+void revmodel::processreplace(const float *inputL, const float *inputR, float *outputL, float *outputR, long numsamples, int skip)
+{
+	float outL,outR,input;
+
+	while (numsamples-- > 0)
+	{
+		int i;
+
+		outL = outR = 0;
+		input = (*inputL + *inputR) * gain;
+
+		// Accumulate comb filters in parallel
+		for (i=0; i<numcombs; i++)
+		{
+			outL += combL[i].process(input);
+			outR += combR[i].process(input);
+		}
+
+		// Feed through allpasses in series
+		for (i=0; i<numallpasses; i++)
+		{
+			outL = allpassL[i].process(outL);
+			outR = allpassR[i].process(outR);
+		}
+
+		// Calculate output REPLACING anything already there
+		*outputL = outL*wet1 + outR*wet2 + *inputL*dry;
+		*outputR = outR*wet1 + outL*wet2 + *inputR*dry;
+
+		// Increment sample pointers, allowing for interleave (if any)
+		inputL += skip;
+		inputR += skip;
+		outputL += skip;
+		outputR += skip;
+	}
+}
+
+void revmodel::processmix(float *inputL, float *inputR, float *outputL, float *outputR, long numsamples, int skip)
+{
+	float outL,outR,input;
+
+	while (numsamples-- > 0)
+	{
+		int i;
+
+		outL = outR = 0;
+		input = (*inputL + *inputR) * gain;
+
+		// Accumulate comb filters in parallel
+		for (i=0; i<numcombs; i++)
+		{
+			outL += combL[i].process(input);
+			outR += combR[i].process(input);
+		}
+
+		// Feed through allpasses in series
+		for (i=0; i<numallpasses; i++)
+		{
+			outL = allpassL[i].process(outL);
+			outR = allpassR[i].process(outR);
+		}
+
+		// Calculate output MIXING with anything already there
+		*outputL += outL*wet1 + outR*wet2 + *inputL*dry;
+		*outputR += outR*wet1 + outL*wet2 + *inputR*dry;
+
+		// Increment sample pointers, allowing for interleave (if any)
+		inputL += skip;
+		inputR += skip;
+		outputL += skip;
+		outputR += skip;
+	}
+}
+
+void revmodel::update()
+{
+// Recalculate internal values after parameter change
+
+	int i;
+
+	wet1 = wet*(width/2 + 0.5f);
+	wet2 = wet*((1-width)/2);
+
+	if (mode >= freezemode)
+	{
+		roomsize1 = 1;
+		damp1 = 0;
+		gain = muted;
+	}
+	else
+	{
+		roomsize1 = roomsize;
+		damp1 = damp;
+		gain = fixedgain;
+	}
+
+	for (i=0; i<numcombs; i++)
+	{
+		combL[i].setfeedback(roomsize1);
+		combR[i].setfeedback(roomsize1);
+	}
+
+	for (i=0; i<numcombs; i++)
+	{
+		combL[i].setdamp(damp1);
+		combR[i].setdamp(damp1);
+	}
+}
+
+// The following get/set functions are not inlined, because
+// speed is never an issue when calling them, and also
+// because as you develop the reverb model, you may
+// wish to take dynamic action when they are called.
+
+void revmodel::setroomsize(float value)
+{
+	roomsize = (value*scaleroom) + offsetroom;
+	update();
+}
+
+float revmodel::getroomsize()
+{
+	return (roomsize-offsetroom)/scaleroom;
+}
+
+void revmodel::setdamp(float value)
+{
+	damp = value*scaledamp;
+	update();
+}
+
+float revmodel::getdamp()
+{
+	return damp/scaledamp;
+}
+
+void revmodel::setwet(float value)
+{
+	wet = value*scalewet;
+	update();
+}
+
+float revmodel::getwet()
+{
+	return wet/scalewet;
+}
+
+void revmodel::setdry(float value)
+{
+	dry = value*scaledry;
+}
+
+float revmodel::getdry()
+{
+	return dry/scaledry;
+}
+
+void revmodel::setwidth(float value)
+{
+	width = value;
+	update();
+}
+
+float revmodel::getwidth()
+{
+	return width;
+}
+
+void revmodel::setmode(float value)
+{
+	mode = value;
+	update();
+}
+
+float revmodel::getmode()
+{
+	if (mode >= freezemode)
+		return 1;
+	else
+		return 0;
+}
diff -urN dosbox-0.73/src/gui/ScalingEffect.cpp dosboxcvs/src/gui/ScalingEffect.cpp
--- dosbox-0.73/src/gui/ScalingEffect.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/ScalingEffect.cpp	2009-07-08 20:43:21.000000000 +0300
@@ -0,0 +1,648 @@
+/*
+Copyright (C) 2003 Ryan A. Nunn
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+
+#include "dosbox.h"
+
+#if (HAVE_D3D9_H) && (C_D3DSHADERS) && defined(WIN32)
+
+#include "ScalingEffect.h"
+
+ScalingEffect::ScalingEffect(LPDIRECT3DDEVICE9 pd3dDevice) :
+    m_scale(0.0f), m_pd3dDevice(pd3dDevice), m_pEffect(0)
+{
+    m_strName = "Unnamed";
+    KillThis();
+}
+
+ScalingEffect::~ScalingEffect(void)
+{
+    KillThis();
+}
+
+void ScalingEffect::KillThis()
+{
+    SAFE_RELEASE(m_pEffect);
+    m_strErrors.clear();
+    m_strName = "Unnamed";
+
+    m_MatWorldEffectHandle = 0;
+    m_MatViewEffectHandle = 0;
+    m_MatProjEffectHandle = 0;
+    m_MatWorldViewEffectHandle = 0;
+    m_MatViewProjEffectHandle = 0;
+    m_MatWorldViewProjEffectHandle = 0;
+
+    // Source Texture Handles
+    m_SourceDimsEffectHandle = 0;
+    m_TexelSizeEffectHandle = 0;
+    m_SourceTextureEffectHandle = 0;
+    m_WorkingTexture1EffectHandle = 0;
+    m_WorkingTexture2EffectHandle = 0;
+    m_Hq2xLookupTextureHandle = 0;
+
+    // Technique stuff
+    m_PreprocessTechnique1EffectHandle = 0;
+    m_PreprocessTechnique2EffectHandle = 0;
+    m_CombineTechniqueEffectHandle = 0;
+}
+
+HRESULT ScalingEffect::LoadEffect(const TCHAR *filename)
+{
+    KillThis();
+
+    LPD3DXBUFFER		lpBufferEffect = 0;
+    LPD3DXBUFFER		lpErrors = 0;
+    LPD3DXEFFECTCOMPILER	lpEffectCompiler = 0;
+
+    m_strErrors += filename;
+    m_strErrors += ":\n";
+
+    // First create an effect compiler
+    HRESULT hr = D3DXCreateEffectCompilerFromFile(filename, NULL, NULL, 0,
+						&lpEffectCompiler, &lpErrors);
+
+    // Errors...
+    if(FAILED(hr)) {
+	if(lpErrors) {
+	    m_strErrors += (char*) lpErrors->GetBufferPointer();
+	    SAFE_RELEASE(lpErrors);
+	}
+
+	m_strErrors += "Unable to create effect compiler from ";
+	m_strErrors += filename;
+    }
+
+    if(SUCCEEDED(hr)) {
+#ifdef C_D3DSHADERS_COMPILE_WITH_DEBUG
+	hr = lpEffectCompiler->CompileEffect(D3DXSHADER_DEBUG, &lpBufferEffect, &lpErrors);
+#else
+	hr = lpEffectCompiler->CompileEffect(0, &lpBufferEffect, &lpErrors);
+#endif
+
+	// Errors...
+	if(FAILED(hr)) {
+	    if(lpErrors) {
+		m_strErrors += (char*) lpErrors->GetBufferPointer();
+		SAFE_RELEASE(lpErrors);
+	    }
+
+	    m_strErrors += "Unable to compile effect from ";
+	    m_strErrors += filename;
+	}
+    }
+
+    if(SUCCEEDED(hr)) {
+	hr = D3DXCreateEffect(m_pd3dDevice,
+			    lpBufferEffect->GetBufferPointer(),
+			    lpBufferEffect->GetBufferSize(),
+			    NULL, NULL,
+			    0,
+			    NULL, &m_pEffect, &lpErrors);
+
+	// Errors...
+	if(FAILED(hr)) {
+	    if(lpErrors) {
+		m_strErrors += (char*) lpErrors->GetBufferPointer();
+		SAFE_RELEASE(lpErrors);
+	    }
+
+	    m_strErrors += "Unable to create effect from compiled ";
+	    m_strErrors += filename;
+	}
+    }
+
+    if(SUCCEEDED(hr)) {
+        m_pEffect->GetDesc(&m_EffectDesc);
+	hr = ParseParameters(lpEffectCompiler);
+    }
+
+    SAFE_RELEASE(lpErrors);
+    SAFE_RELEASE(lpBufferEffect);
+    SAFE_RELEASE(lpEffectCompiler);
+    return hr;
+}
+
+HRESULT ScalingEffect::ParseParameters(LPD3DXEFFECTCOMPILER lpEffectCompiler)
+{
+    HRESULT hr = S_OK;
+
+    if(m_pEffect == NULL)
+        return E_FAIL;
+
+    // Look at parameters for semantics and annotations that we know how to interpret
+    D3DXPARAMETER_DESC ParamDesc;
+    D3DXPARAMETER_DESC AnnotDesc;
+    D3DXHANDLE hParam;
+    D3DXHANDLE hAnnot;
+    LPDIRECT3DBASETEXTURE9 pTex = NULL;
+
+    for(UINT iParam = 0; iParam < m_EffectDesc.Parameters; iParam++) {
+        LPCSTR pstrName = NULL;
+        LPCSTR pstrFunction = NULL;
+        LPCSTR pstrTarget = NULL;
+        LPCSTR pstrTextureType = NULL;
+        INT Width = D3DX_DEFAULT;
+        INT Height= D3DX_DEFAULT;
+        INT Depth = D3DX_DEFAULT;
+
+        hParam = m_pEffect->GetParameter(NULL, iParam);
+        m_pEffect->GetParameterDesc(hParam, &ParamDesc);
+
+	if(ParamDesc.Semantic != NULL) {
+	    if(ParamDesc.Class == D3DXPC_MATRIX_ROWS || ParamDesc.Class == D3DXPC_MATRIX_COLUMNS) {
+		if(strcmpi(ParamDesc.Semantic, "world") == 0)
+		    m_MatWorldEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "view") == 0)
+		    m_MatViewEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "projection") == 0)
+		    m_MatProjEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "worldview") == 0)
+		    m_MatWorldViewEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "viewprojection") == 0)
+		    m_MatViewProjEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "worldviewprojection") == 0)
+		    m_MatWorldViewProjEffectHandle = hParam;
+	    }
+
+	    else if(ParamDesc.Class == D3DXPC_VECTOR && ParamDesc.Type == D3DXPT_FLOAT) {
+		if(strcmpi(ParamDesc.Semantic, "sourcedims") == 0)
+		    m_SourceDimsEffectHandle = hParam;
+		else if(strcmpi(ParamDesc.Semantic, "texelsize") == 0)
+		    m_TexelSizeEffectHandle = hParam;
+	    }
+
+	    else if(ParamDesc.Class == D3DXPC_SCALAR && ParamDesc.Type == D3DXPT_FLOAT) {
+		if(strcmpi(ParamDesc.Semantic, "SCALING") == 0)
+		    m_pEffect->GetFloat(hParam, &m_scale);
+	    }
+
+	    else if(ParamDesc.Class == D3DXPC_OBJECT && ParamDesc.Type == D3DXPT_TEXTURE) {
+		if(strcmpi(ParamDesc.Semantic, "SOURCETEXTURE") == 0)
+		    m_SourceTextureEffectHandle = hParam;
+		if(strcmpi(ParamDesc.Semantic, "WORKINGTEXTURE") == 0)
+		    m_WorkingTexture1EffectHandle = hParam;
+		if(strcmpi(ParamDesc.Semantic, "WORKINGTEXTURE1") == 0)
+		    m_WorkingTexture2EffectHandle = hParam;
+		if(strcmpi(ParamDesc.Semantic, "HQ2XLOOKUPTEXTURE") == 0)
+		    m_Hq2xLookupTextureHandle = hParam;
+	    }
+
+	    else if(ParamDesc.Class == D3DXPC_OBJECT && ParamDesc.Type == D3DXPT_STRING) {
+	        LPCSTR pstrTechnique = NULL;
+
+		if(strcmpi(ParamDesc.Semantic, "COMBINETECHNIQUE") == 0) {
+		    m_pEffect->GetString(hParam, &pstrTechnique);
+		    m_CombineTechniqueEffectHandle = m_pEffect->GetTechniqueByName(pstrTechnique);
+		}
+		else if(strcmpi(ParamDesc.Semantic, "PREPROCESSTECHNIQUE") == 0) {
+		    m_pEffect->GetString(hParam, &pstrTechnique);
+		    m_PreprocessTechnique1EffectHandle = m_pEffect->GetTechniqueByName(pstrTechnique);
+		}
+		else if(strcmpi(ParamDesc.Semantic, "PREPROCESSTECHNIQUE1") == 0) {
+		    m_pEffect->GetString(hParam, &pstrTechnique);
+		    m_PreprocessTechnique2EffectHandle = m_pEffect->GetTechniqueByName(pstrTechnique);
+		}
+		else if(strcmpi(ParamDesc.Semantic, "NAME") == 0)
+		    m_pEffect->GetString(hParam, &m_strName);
+
+	    }
+
+
+	}
+
+	for(UINT iAnnot = 0; iAnnot < ParamDesc.Annotations; iAnnot++) {
+            hAnnot = m_pEffect->GetAnnotation (hParam, iAnnot);
+            m_pEffect->GetParameterDesc(hAnnot, &AnnotDesc);
+            if(strcmpi(AnnotDesc.Name, "name") == 0)
+                m_pEffect->GetString(hAnnot, &pstrName);
+            else if(strcmpi(AnnotDesc.Name, "function") == 0)
+                m_pEffect->GetString(hAnnot, &pstrFunction);
+            else if(strcmpi(AnnotDesc.Name, "target") == 0)
+                m_pEffect->GetString(hAnnot, &pstrTarget);
+            else if(strcmpi(AnnotDesc.Name, "width") == 0)
+                m_pEffect->GetInt(hAnnot, &Width);
+            else if(strcmpi(AnnotDesc.Name, "height") == 0)
+                m_pEffect->GetInt(hAnnot, &Height);
+            else if(strcmpi(AnnotDesc.Name, "depth") == 0)
+                m_pEffect->GetInt(hAnnot, &Depth);
+            else if(strcmpi(AnnotDesc.Name, "type") == 0)
+                m_pEffect->GetString(hAnnot, &pstrTextureType);
+
+        }
+
+	// Not used in DOSBox
+/*	if(pstrName != NULL) {
+            pTex = NULL;
+            DXUtil_ConvertAnsiStringToGenericCch(strPath, pstrName, MAX_PATH);
+            if(pstrTextureType != NULL) {
+                if(strcmpi(pstrTextureType, "volume") == 0) {
+                    LPDIRECT3DVOLUMETEXTURE9 pVolumeTex = NULL;
+                    if(SUCCEEDED(hr = D3DXCreateVolumeTextureFromFileEx(m_pd3dDevice, strPath,
+                    	    Width, Height, Depth, 1, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
+                    	    D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, &pVolumeTex))) {
+                        pTex = pVolumeTex;
+                    }
+                    else {
+                        m_strErrors += "Could not load volume texture ";
+                        m_strErrors += pstrName;
+                    }
+                }
+                else if(strcmpi(pstrTextureType, "cube") == 0) {
+                    LPDIRECT3DCUBETEXTURE9 pCubeTex = NULL;
+                    if(SUCCEEDED(hr = D3DXCreateCubeTextureFromFileEx(m_pd3dDevice, strPath,
+                    	    Width, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
+                    	    D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, &pCubeTex))) {
+                        pTex = pCubeTex;
+                    }
+                    else {
+                        m_strErrors += "Could not load cube texture ";
+                        m_strErrors += pstrName;
+                    }
+                }
+            }
+            else {
+                LPDIRECT3DTEXTURE9 p2DTex = NULL;
+                if(SUCCEEDED(hr = D3DXCreateTextureFromFileEx(m_pd3dDevice, strPath,
+                	Width, Height, D3DX_DEFAULT, 0, D3DFMT_UNKNOWN, D3DPOOL_MANAGED,
+                	D3DX_DEFAULT, D3DX_DEFAULT, 0, NULL, NULL, &p2DTex))) {
+                    pTex = p2DTex;
+                }
+                else {
+                    m_strErrors += "Could not load texture ";
+                    m_strErrors += pstrName;
+                    m_strErrors += "\n";
+                }
+            }
+
+            // Apply successfully loaded texture to effect
+            if(SUCCEEDED(hr) && pTex != NULL) {
+                m_pEffect->SetTexture(m_pEffect->GetParameter(NULL, iParam), pTex);
+                SAFE_RELEASE(pTex);
+            }
+        }
+	else */
+	if(pstrFunction != NULL) {
+	    LPD3DXBUFFER pTextureShader = NULL;
+	    LPD3DXBUFFER lpErrors = 0;
+
+	    if(pstrTarget == NULL || strcmp(pstrTarget,"tx_1_1"))
+                pstrTarget = "tx_1_0";
+
+	    if(SUCCEEDED(hr = lpEffectCompiler->CompileShader(
+				pstrFunction, pstrTarget,
+				0, &pTextureShader, &lpErrors, NULL))) {
+		SAFE_RELEASE(lpErrors);
+
+		if(Width == D3DX_DEFAULT)
+                    Width = 64;
+		if(Height == D3DX_DEFAULT)
+                    Height = 64;
+		if(Depth == D3DX_DEFAULT)
+                    Depth = 64;
+
+#if D3DX_SDK_VERSION >= 22
+		LPD3DXTEXTURESHADER ppTextureShader;
+		D3DXCreateTextureShader((DWORD *)pTextureShader->GetBufferPointer(), &ppTextureShader);
+#endif
+
+		if(pstrTextureType != NULL) {
+                    if(strcmpi(pstrTextureType, "volume") == 0) {
+                        LPDIRECT3DVOLUMETEXTURE9 pVolumeTex = NULL;
+                        if(SUCCEEDED(hr = D3DXCreateVolumeTexture(m_pd3dDevice,
+                        	Width, Height, Depth, 1, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pVolumeTex))) {
+#if D3DX_SDK_VERSION >= 22
+                    	    if(SUCCEEDED(hr = D3DXFillVolumeTextureTX(pVolumeTex, ppTextureShader))) {
+#else
+                    	    if(SUCCEEDED(hr = D3DXFillVolumeTextureTX(pVolumeTex,
+					(DWORD *)pTextureShader->GetBufferPointer(), NULL, 0))) {
+#endif
+                                pTex = pVolumeTex;
+                            }
+                        }
+                    } else if(strcmpi(pstrTextureType, "cube") == 0) {
+                        LPDIRECT3DCUBETEXTURE9 pCubeTex = NULL;
+                        if(SUCCEEDED(hr = D3DXCreateCubeTexture(m_pd3dDevice,
+                        	Width, D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &pCubeTex))) {
+#if D3DX_SDK_VERSION >= 22
+                            if(SUCCEEDED(hr = D3DXFillCubeTextureTX(pCubeTex, ppTextureShader))) {
+#else
+                            if(SUCCEEDED(hr = D3DXFillCubeTextureTX(pCubeTex,
+					(DWORD *)pTextureShader->GetBufferPointer(), NULL, 0))) {
+#endif
+                                pTex = pCubeTex;
+                            }
+                        }
+                    }
+		} else {
+                    LPDIRECT3DTEXTURE9 p2DTex = NULL;
+                    if(SUCCEEDED(hr = D3DXCreateTexture(m_pd3dDevice, Width, Height,
+                    	    D3DX_DEFAULT, 0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED, &p2DTex))) {
+#if D3DX_SDK_VERSION >= 22
+                        if(SUCCEEDED(hr = D3DXFillTextureTX(p2DTex, ppTextureShader))) {
+#else
+                        if(SUCCEEDED(hr = D3DXFillTextureTX(p2DTex,
+				(DWORD *)pTextureShader->GetBufferPointer(), NULL, 0))) {
+#endif
+                            pTex = p2DTex;
+                        }
+                    }
+		}
+		m_pEffect->SetTexture(m_pEffect->GetParameter(NULL, iParam), pTex);
+		SAFE_RELEASE(pTex);
+		SAFE_RELEASE(pTextureShader);
+#if D3DX_SDK_VERSION >= 22
+		SAFE_RELEASE(ppTextureShader);
+#endif
+	    } else {
+		if(lpErrors) {
+		    m_strErrors += (char*) lpErrors->GetBufferPointer();
+		}
+
+		m_strErrors += "Could not compile texture shader ";
+		m_strErrors += pstrFunction;
+
+		SAFE_RELEASE(lpErrors);
+		return hr;
+	    }
+        }
+    }
+
+    return S_OK;
+}
+
+// Set Source texture
+HRESULT ScalingEffect::SetTextures(LPDIRECT3DTEXTURE9 lpSource, LPDIRECT3DTEXTURE9 lpWorking1,
+			LPDIRECT3DTEXTURE9 lpWorking2, LPDIRECT3DVOLUMETEXTURE9 lpHq2xLookupTexture)
+{
+    if(!m_SourceTextureEffectHandle) {
+	m_strErrors += "Texture with SOURCETEXTURE semantic not found";
+	return E_FAIL;
+    }
+
+    HRESULT hr = m_pEffect->SetTexture(m_SourceTextureEffectHandle, lpSource);
+
+    if(FAILED(hr)) {
+	m_strErrors += "Unable to set SOURCETEXTURE";
+	return hr;
+    }
+
+    if(m_WorkingTexture1EffectHandle) {
+	hr = m_pEffect->SetTexture(m_WorkingTexture1EffectHandle, lpWorking1);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set WORKINGTEXTURE";
+	    return hr;
+	}
+    }
+
+    if(m_WorkingTexture2EffectHandle) {
+	hr = m_pEffect->SetTexture(m_WorkingTexture2EffectHandle, lpWorking2);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set WORKINGTEXTURE1";
+	    return hr;
+	}
+    }
+
+    if(m_Hq2xLookupTextureHandle) {
+	hr = m_pEffect->SetTexture(m_Hq2xLookupTextureHandle, lpHq2xLookupTexture);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set HQ2XLOOKUPTEXTURE";
+	    return hr;
+	}
+    }
+
+    D3DXVECTOR4 fDims(256,256,1,1), fTexelSize(1,1,1,1);
+
+    if(lpSource) {
+	D3DSURFACE_DESC Desc;
+	lpSource->GetLevelDesc(0, &Desc);
+	fDims[0] = (FLOAT) Desc.Width;
+	fDims[1] = (FLOAT) Desc.Height;
+    }
+
+    fTexelSize[0] = 1/fDims[0];
+    fTexelSize[1] = 1/fDims[1];
+
+    if(m_SourceDimsEffectHandle) {
+	hr = m_pEffect->SetVector(m_SourceDimsEffectHandle, &fDims);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set SOURCEDIMS";
+	    return hr;
+	}
+    }
+
+    if(m_TexelSizeEffectHandle) {
+	hr = m_pEffect->SetVector(m_TexelSizeEffectHandle, &fTexelSize);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set TEXELSIZE";
+	    return hr;
+	}
+    }
+
+    return hr;
+}
+
+// Set the Matrices for this frame
+HRESULT ScalingEffect::SetMatrices(D3DXMATRIX &matProj, D3DXMATRIX &matView, D3DXMATRIX &matWorld)
+{
+    HRESULT hr = S_OK;
+
+    if(m_MatWorldEffectHandle != NULL) {
+	hr = m_pEffect->SetMatrix(m_MatWorldEffectHandle, &matWorld);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set WORLD matrix";
+	    return hr;
+	}
+    }
+
+    if(m_MatViewEffectHandle != NULL) {
+	hr = m_pEffect->SetMatrix(m_MatViewEffectHandle, &matView);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set VIEW matrix";
+	    return hr;
+	}
+    }
+
+    if(m_MatProjEffectHandle != NULL) {
+	hr = m_pEffect->SetMatrix(m_MatProjEffectHandle, &matProj);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set PROJECTION matrix";
+	    return hr;
+	}
+    }
+
+    if(m_MatWorldViewEffectHandle != NULL) {
+	D3DXMATRIX matWorldView = matWorld * matView;
+	hr = m_pEffect->SetMatrix(m_MatWorldViewEffectHandle, &matWorldView);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set WORLDVIEW matrix";
+	    return hr;
+	}
+    }
+
+    if(m_MatViewProjEffectHandle != NULL) {
+	D3DXMATRIX matViewProj = matView * matProj;
+	hr = m_pEffect->SetMatrix(m_MatViewProjEffectHandle, &matViewProj);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set VIEWPROJECTION matrix";
+	    return hr;
+	}
+    }
+
+    if(m_MatWorldViewProjEffectHandle != NULL) {
+	D3DXMATRIX matWorldViewProj = matWorld * matView * matProj;
+	hr = m_pEffect->SetMatrix(m_MatWorldViewProjEffectHandle, &matWorldViewProj);
+	if(FAILED(hr)) {
+	    m_strErrors += "Unable to set WORLDVIEWPROJECTION matrix";
+	    return hr;
+	}
+    }
+
+    return hr;
+}
+
+
+// Returns Number of passes for this technique
+HRESULT ScalingEffect::Begin(Pass pass, UINT* pPasses)
+{
+    HRESULT hr = S_OK;
+
+    switch (pass) {
+	case Preprocess1:
+	    hr = m_pEffect->SetTechnique(m_PreprocessTechnique1EffectHandle);
+	    break;
+	case Preprocess2:
+	    hr = m_pEffect->SetTechnique(m_PreprocessTechnique2EffectHandle);
+	    break;
+	case Combine:
+	    hr = m_pEffect->SetTechnique(m_CombineTechniqueEffectHandle);
+	    break;
+    }
+
+    if(FAILED(hr)) {
+	m_strErrors += "SetTechnique failed";
+	return E_FAIL;
+    }
+
+    return m_pEffect->Begin(pPasses, D3DXFX_DONOTSAVESTATE|D3DXFX_DONOTSAVESHADERSTATE);
+}
+
+// Render Pass in technique
+HRESULT ScalingEffect::BeginPass(UINT Pass)
+{
+#if D3DX_SDK_VERSION >= 22
+    return m_pEffect->BeginPass(Pass);
+#else
+    return m_pEffect->Pass(Pass);
+#endif
+}
+
+// End Pass of this technique
+HRESULT ScalingEffect::EndPass()
+{
+#if D3DX_SDK_VERSION >= 22
+    return m_pEffect->EndPass();
+#else
+    return S_OK;
+#endif
+}
+
+// End rendering of this technique
+HRESULT ScalingEffect::End()
+{
+    return m_pEffect->End();
+}
+
+// Validates the effect
+HRESULT ScalingEffect::Validate()
+{
+    HRESULT hr;
+
+    // Now we check to see if they all exist
+    if(!m_MatWorldEffectHandle || !m_MatWorldViewEffectHandle ||
+		!m_MatWorldViewProjEffectHandle) {
+        m_strErrors += "Effect doesn't have any world matrix handles";
+	return E_FAIL;
+    }
+
+    if(!m_MatViewEffectHandle || !m_MatWorldViewEffectHandle ||
+		!m_MatViewProjEffectHandle || !m_MatWorldViewProjEffectHandle) {
+        m_strErrors += "Effect doesn't have any view matrix handles";
+	return E_FAIL;
+    }
+
+    if(!m_MatProjEffectHandle || !m_MatViewProjEffectHandle ||
+		!m_MatWorldViewProjEffectHandle) {
+        m_strErrors += "Effect doesn't have any projection matrix handles";
+	return E_FAIL;
+    }
+
+    if(!m_SourceTextureEffectHandle) {
+        m_strErrors += "Effect doesn't have a SOURCETEXTURE handle";
+	return E_FAIL;
+    }
+
+    if(!m_CombineTechniqueEffectHandle) {
+        m_strErrors += "Effect doesn't have a COMBINETECHNIQUE handle";
+	return E_FAIL;
+    }
+
+    if(!m_WorkingTexture1EffectHandle && m_PreprocessTechnique1EffectHandle) {
+        m_strErrors += "Effect doesn't have a WORKINGTEXTURE handle but uses preprocess steps";
+	return E_FAIL;
+    }
+
+    if(!m_WorkingTexture2EffectHandle && m_PreprocessTechnique2EffectHandle) {
+        m_strErrors += "Effect doesn't have a WORKINGTEXTURE1 handle but uses 2 preprocess steps";
+	return E_FAIL;
+    }
+
+    // Validate this
+    if(m_PreprocessTechnique1EffectHandle) {
+	hr = m_pEffect->ValidateTechnique(m_PreprocessTechnique1EffectHandle);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "ValidateTechnique for PREPROCESSTECHNIQUE failed";
+	    return hr;
+	}
+    }
+
+    if(m_PreprocessTechnique2EffectHandle) {
+	hr = m_pEffect->ValidateTechnique(m_PreprocessTechnique2EffectHandle);
+
+	if(FAILED(hr)) {
+	    m_strErrors += "ValidateTechnique for PREPROCESSTECHNIQUE1 failed";
+	    return hr;
+	}
+    }
+
+    hr = m_pEffect->ValidateTechnique(m_CombineTechniqueEffectHandle);
+
+    if(FAILED(hr)) {
+	m_strErrors += "ValidateTechnique for COMBINETECHNIQUE failed";
+	return hr;
+    }
+
+    return S_OK;
+}
+
+#endif	// C_D3DSHADERS
diff -urN dosbox-0.73/src/gui/ScalingEffect.h dosboxcvs/src/gui/ScalingEffect.h
--- dosbox-0.73/src/gui/ScalingEffect.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/ScalingEffect.h	2009-07-08 20:43:21.000000000 +0300
@@ -0,0 +1,100 @@
+/*
+Copyright (C) 2003 Ryan A. Nunn
+
+This program is free software; you can redistribute it and/or
+modify it under the terms of the GNU General Public License
+as published by the Free Software Foundation; either version 2
+of the License, or (at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+
+#pragma once
+
+#include <string>
+#include <d3d9.h>
+#include <d3dx9.h>
+
+#define SAFE_RELEASE(p)		{ if(p) { (p)->Release(); (p)=NULL; } }
+
+class ScalingEffect
+{
+    float				m_scale;
+    LPCSTR				m_strName;
+    std::string				m_strErrors;
+    LPDIRECT3DDEVICE9			m_pd3dDevice;
+
+    LPD3DXEFFECT			m_pEffect;
+    D3DXEFFECT_DESC			m_EffectDesc;
+
+    // Matrix Handles
+    D3DXHANDLE m_MatWorldEffectHandle;
+    D3DXHANDLE m_MatViewEffectHandle;
+    D3DXHANDLE m_MatProjEffectHandle;
+    D3DXHANDLE m_MatWorldViewEffectHandle;
+    D3DXHANDLE m_MatViewProjEffectHandle;
+    D3DXHANDLE m_MatWorldViewProjEffectHandle;
+
+    // Texture Handles
+    D3DXHANDLE m_SourceDimsEffectHandle;
+    D3DXHANDLE m_TexelSizeEffectHandle;
+    D3DXHANDLE m_SourceTextureEffectHandle;
+    D3DXHANDLE m_WorkingTexture1EffectHandle;
+    D3DXHANDLE m_WorkingTexture2EffectHandle;
+    D3DXHANDLE m_Hq2xLookupTextureHandle;
+
+    // Technique stuff
+    D3DXHANDLE	m_PreprocessTechnique1EffectHandle;
+    D3DXHANDLE	m_PreprocessTechnique2EffectHandle;
+    D3DXHANDLE	m_CombineTechniqueEffectHandle;
+
+public:
+    enum Pass { Preprocess1, Preprocess2, Combine };
+
+    ScalingEffect(LPDIRECT3DDEVICE9 pd3dDevice);
+    ~ScalingEffect(void);
+
+    void KillThis();
+
+    HRESULT LoadEffect(const TCHAR *filename);
+
+    const char *getErrors() { return m_strErrors.c_str(); }
+
+    LPCSTR getName() { return m_strName; }
+    float getScale() { return m_scale; }
+
+    // Does it have a preprocess step
+    BOOL hasPreprocess() { return m_PreprocessTechnique1EffectHandle!=0; }
+    BOOL hasPreprocess2() { return m_PreprocessTechnique2EffectHandle!=0; }
+
+    // Set The Textures
+    HRESULT SetTextures( LPDIRECT3DTEXTURE9 lpSource, LPDIRECT3DTEXTURE9 lpWorking1,
+		LPDIRECT3DTEXTURE9 lpWorking2, LPDIRECT3DVOLUMETEXTURE9 lpHq2xLookupTexture );
+
+    // Set the Matrices for this frame
+    HRESULT SetMatrices( D3DXMATRIX &matProj, D3DXMATRIX &matView, D3DXMATRIX &matWorld );
+
+    // Begin the technique
+    // Returns Number of passes for this technique
+    HRESULT Begin(Pass pass, UINT* pPasses);
+
+    // Render Pass in technique
+    HRESULT BeginPass(UINT Pass);
+    HRESULT EndPass();
+
+    // End rendering of this technique
+    HRESULT End();
+
+    // Validates the effect
+    HRESULT Validate();
+
+private:
+    HRESULT ParseParameters(LPD3DXEFFECTCOMPILER lpEffectCompiler);
+};
diff -urN dosbox-0.73/src/gui/sdlmain.cpp dosboxcvs/src/gui/sdlmain.cpp
--- dosbox-0.73/src/gui/sdlmain.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/gui/sdlmain.cpp	2010-10-29 14:12:37.128646090 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: sdlmain.cpp,v 1.153 2009/05/25 16:29:36 qbix79 Exp $ */
+/* $Id: sdlmain.cpp,v 1.154 2009/06/01 10:25:51 qbix79 Exp $ */
 
 #ifndef _GNU_SOURCE
 #define _GNU_SOURCE
@@ -111,6 +111,12 @@
 };
 #endif
 
+#if (HAVE_D3D9_H)
+#include "direct3d.h"
+
+CDirect3D* d3d = NULL;
+#endif
+
 #define STDOUT_FILE	TEXT("stdout.txt")
 #define STDERR_FILE	TEXT("stderr.txt")
 #define DEFAULT_CONFIG_FILE "/dosbox.conf"
@@ -132,10 +138,12 @@
 #endif
 
 enum SCREEN_TYPES	{
+	SCREEN_OPENGLHQ,
 	SCREEN_SURFACE,
 	SCREEN_SURFACE_DDRAW,
 	SCREEN_OVERLAY,
-	SCREEN_OPENGL
+	SCREEN_OPENGL,
+	SCREEN_DIRECT3D
 };
 
 enum PRIORITY_LEVELS {
@@ -223,8 +231,10 @@
 
 static SDL_Block sdl;
 
+#include "cpu.h"
+Bitu frames = 0;
+
 extern const char* RunningProgram;
-extern bool CPU_CycleAutoAdjust;
 //Globals for keyboard initialisation
 bool startup_state_numlock=false;
 bool startup_state_capslock=false;
@@ -236,11 +246,14 @@
 	if(frameskip != -1) internal_frameskip = frameskip;
 	if(CPU_CycleAutoAdjust) {
 		if (internal_cycles>=100)
-			sprintf(title,"DOSBox %s, Cpu Cycles:      max, Frameskip %2d, Program: %8s",VERSION,internal_frameskip,RunningProgram);
+			sprintf(title,"Core: %s, Cpu Cycles: %8d <    max, FPS: %d, skip %2d, Program: %8s",core_mode,CPU_CyclesCur,frames,internal_frameskip,RunningProgram);
 		else
-			sprintf(title,"DOSBox %s, Cpu Cycles:   [%3d%%], Frameskip %2d, Program: %8s",VERSION,internal_cycles,internal_frameskip,RunningProgram);
+			sprintf(title,"Core: %s, Cpu Cycles: %8d <   [%3d%%], FPS: %d, skip %2d, Program: %8s",core_mode,CPU_CyclesCur,internal_cycles,frames,internal_frameskip,RunningProgram);
 	} else {
-		sprintf(title,"DOSBox %s, Cpu Cycles: %8d, Frameskip %2d, Program: %8s",VERSION,internal_cycles,internal_frameskip,RunningProgram);
+		if (CPU_AutoDetermineMode&CPU_AUTODETERMINE_CYCLES)
+			sprintf(title,"Core: %s, Cpu Cycles: %8d =   auto, FPS: %d, skip %2d, Program: %8s",core_mode,CPU_CyclesCur,frames,internal_frameskip,RunningProgram);
+		else
+			sprintf(title,"Core: %s, Cpu Cycles: %8d = %8d, FPS: %d, skip %2d, Program: %8s",core_mode,CPU_CyclesCur,internal_cycles,frames,internal_frameskip,RunningProgram);
 	}
 
 	if(paused) strcat(title," PAUSED");
@@ -286,6 +299,8 @@
 Bitu GFX_GetBestMode(Bitu flags) {
 	Bitu testbpp,gotbpp;
 	switch (sdl.desktop.want_type) {
+	case SCREEN_OPENGLHQ:
+		flags|=GFX_SCALING;
 	case SCREEN_SURFACE:
 check_surface:
 		/* Check if we can satisfy the depth it loves */
@@ -339,6 +354,15 @@
 		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 		break;
 #endif
+#if (HAVE_D3D9_H) && defined(WIN32)
+	case SCREEN_DIRECT3D:
+		flags|=GFX_SCALING;
+		if(GCC_UNLIKELY(d3d->bpp16))
+		    flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_32);
+		else
+		    flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
+		break;
+#endif
 	default:
 		goto check_surface;
 		break;
@@ -407,6 +431,11 @@
 	}
 }
 
+#ifdef WIN32
+#define putenv _putenv
+#endif
+
+extern bool RENDER_GetAspect(void);
 Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
 	if (sdl.updating)
 		GFX_EndUpdate( 0 );
@@ -425,6 +454,67 @@
 		sdl.blit.surface=0;
 	}
 	switch (sdl.desktop.want_type) {
+	case SCREEN_OPENGLHQ:
+		static char scale[64];
+		if (flags & GFX_CAN_8) bpp=8;
+		if (flags & GFX_CAN_15) bpp=15;
+		if (flags & GFX_CAN_16) bpp=16;
+		if (flags & GFX_CAN_32) bpp=32;
+		sdl.desktop.type=SCREEN_SURFACE;
+		sdl.clip.x=0;
+		sdl.clip.y=0;
+		if(!sdl.desktop.fullscreen) {
+		    if(sdl.desktop.window.width && sdl.desktop.window.height) {
+			scalex=(double)sdl.desktop.window.width/(sdl.draw.width*sdl.draw.scalex);
+			scaley=(double)sdl.desktop.window.height/(sdl.draw.height*sdl.draw.scaley);
+			if(scalex < scaley) {
+			    sdl.clip.w=sdl.desktop.window.width;
+			    sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley*scalex);
+			} else {
+			    sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex*scaley);
+			    sdl.clip.h=(Bit16u)sdl.desktop.window.height;
+			}
+		    } else {
+			sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex);
+			sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley);
+		    }
+		    snprintf(scale,64,"SDL_OPENGLHQ_WINRES=%dx%d",sdl.clip.w,sdl.clip.h);
+		    sdl.clip.w=width; sdl.clip.h=height;
+
+    		} else if(!sdl.desktop.full.fixed) {
+		    snprintf(scale,64,"SDL_OPENGLHQ_FULLRES=%dx%d",sdl.draw.width*(Uint16)sdl.draw.scalex,
+								sdl.draw.height*(Uint16)sdl.draw.scaley);
+		    sdl.clip.w=width; sdl.clip.h=height;
+		} else {
+		    snprintf(scale,64,"SDL_OPENGLHQ_FULLRES=%dx%d",sdl.desktop.full.width,sdl.desktop.full.height);
+		    scalex=(double)sdl.desktop.full.width/(sdl.draw.width*sdl.draw.scalex);
+		    scaley=(double)sdl.desktop.full.height/(sdl.draw.height*sdl.draw.scaley);
+		    sdl.clip.w=width; sdl.clip.h=height;
+
+		    if (scalex < scaley)
+			height *= scaley/scalex;
+		    else
+			width *= scalex/scaley;
+		    sdl.clip.x=(Sint16)((width-sdl.clip.w)/2);
+		    sdl.clip.y=(Sint16)((height-sdl.clip.h)/2);
+		}
+		putenv(scale);
+		sdl.surface=SDL_SetVideoMode(width,height,bpp,(sdl.desktop.fullscreen?SDL_FULLSCREEN:0)|SDL_HWSURFACE|SDL_ANYFORMAT);
+		if (sdl.surface) {
+		    switch (sdl.surface->format->BitsPerPixel) {
+			case 8:retFlags = GFX_CAN_8;break;
+			case 15:retFlags = GFX_CAN_15;break;
+			case 16:retFlags = GFX_CAN_16;break;
+			case 32:retFlags = GFX_CAN_32;break;
+			default:break;
+		    }
+		    if (retFlags) {
+			if (sdl.surface->flags & SDL_HWSURFACE)
+			    retFlags |= GFX_HARDWARE;
+			retFlags |= GFX_SCALING;
+		    }
+		}
+		break;
 	case SCREEN_SURFACE:
 dosurface:
 		if (flags & GFX_CAN_8) bpp=8;
@@ -441,7 +531,15 @@
 				sdl.surface=SDL_SetVideoMode(sdl.desktop.full.width,sdl.desktop.full.height,bpp,
 					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
 					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
-				if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
+				if (sdl.surface == NULL) {
+					sdl.desktop.fullscreen=false;
+					LOG_MSG("Fullscreen video mode not supported: %s",
+						SDL_GetError());
+					//mouselocked=false;
+					GFX_CaptureMouse();
+					goto dosurface;
+				}
+
 			} else {
 				sdl.clip.x=0;sdl.clip.y=0;
 				sdl.surface=SDL_SetVideoMode(width,height,bpp,
@@ -650,6 +748,99 @@
 	break;
 		}//OPENGL
 #endif	//C_OPENGL
+#if (HAVE_D3D9_H) && defined(WIN32)
+	    case SCREEN_DIRECT3D: {
+		// Calculate texture size
+		if((!d3d->square) && (!d3d->pow2)) {
+		    d3d->dwTexWidth=width;
+		    d3d->dwTexHeight=height;
+		} else if(d3d->square) {
+		    int texsize=2 << int_log2(width > height ? width : height);
+		    d3d->dwTexWidth=d3d->dwTexHeight=texsize;
+		} else {
+		    d3d->dwTexWidth=2 << int_log2(width);
+		    d3d->dwTexHeight=2 << int_log2(height);
+		}
+
+		sdl.clip.x=0; sdl.clip.y=0;
+		if(sdl.desktop.fullscreen) {
+		    if(sdl.desktop.full.fixed) {
+			sdl.clip.w=sdl.desktop.full.width;
+			sdl.clip.h=sdl.desktop.full.height;
+			scalex=(double)sdl.desktop.full.width/width;
+			scaley=(double)sdl.desktop.full.height/height;
+		    }
+		} else {
+		    if((sdl.desktop.window.width) && (sdl.desktop.window.height)) {
+			scalex=(double)sdl.desktop.window.width/(sdl.draw.width*sdl.draw.scalex);
+			scaley=(double)sdl.desktop.window.height/(sdl.draw.height*sdl.draw.scaley);
+			if(scalex < scaley) {
+			    sdl.clip.w=sdl.desktop.window.width;
+			    sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley*scalex);
+			} else {
+			    sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex*scaley);
+			    sdl.clip.h=(Bit16u)sdl.desktop.window.height;
+			}
+			scalex=(double)sdl.clip.w/width;
+			scaley=(double)sdl.clip.h/height;
+		    } else {
+			sdl.clip.w=(Bit16u)(width*scalex);
+			sdl.clip.h=(Bit16u)(height*scaley);
+		    }
+		}
+
+		Section_prop *section=static_cast<Section_prop *>(control->GetSection("sdl"));
+		if(section) {
+		    d3d->LoadPixelShader(section->Get_string("pixelshader"), scalex, scaley);
+		} else {
+		    LOG_MSG("SDL:D3D:Could not get pixelshader info, shader disabled");
+		}
+
+		d3d->aspect=RENDER_GetAspect();
+		if((sdl.desktop.fullscreen) && (!sdl.desktop.full.fixed)) {
+		    // Don't do aspect ratio correction when fullfixed=false
+		    d3d->aspect=2;
+		    sdl.clip.w=(Uint16)scalex;
+		    sdl.clip.h=(Uint16)scaley;
+		    // Do fullscreen scaling if pixel shaders are enabled
+		    // or the game uses some weird resolution
+		    if((d3d->psActive) || (sdl.clip.w != sdl.clip.h)) {
+			sdl.clip.w*=width;
+			sdl.clip.h*=height;
+		    } else { // just use native resolution
+			sdl.clip.w=width;
+			sdl.clip.h=height;
+		    }
+		} else if(!sdl.desktop.fullscreen) d3d->aspect=-1;
+
+		// Create a dummy sdl surface
+		// D3D will hang or crash when using fullscreen with ddraw surface, therefore we hack SDL to provide
+		// a GDI window with an additional 0x40 flag. If this fails or stock SDL is used, use WINDIB output
+		if(GCC_UNLIKELY(d3d->bpp16)) {
+		    sdl.surface=SDL_SetVideoMode(sdl.clip.w,sdl.clip.h,16,sdl.desktop.fullscreen ? SDL_FULLSCREEN|0x40 : 0x40);
+		    retFlags = GFX_CAN_16 | GFX_SCALING;
+		} else {
+		    sdl.surface=SDL_SetVideoMode(sdl.clip.w,sdl.clip.h,0,sdl.desktop.fullscreen ? SDL_FULLSCREEN|0x40 : 0x40);
+		    retFlags = GFX_CAN_32 | GFX_SCALING;
+		}
+
+		if (sdl.surface == NULL) E_Exit("Could not set video mode %ix%i-%i: %s",sdl.clip.w,sdl.clip.h,
+					d3d->bpp16 ? 16:32,SDL_GetError());
+		sdl.desktop.type=SCREEN_DIRECT3D;
+
+		if(d3d->dynamic) retFlags |= GFX_HARDWARE;
+
+		if(GCC_UNLIKELY(d3d->Resize3DEnvironment(sdl.clip.w,sdl.clip.h,width,
+						    height,sdl.desktop.fullscreen) != S_OK)) {
+		    retFlags = 0;
+		}
+#if LOG_D3D
+		LOG_MSG("SDL:D3D:Display mode set to: %dx%d with %fx%f scale",
+				    sdl.clip.w, sdl.clip.h,sdl.draw.scalex, sdl.draw.scaley);
+#endif
+		break;
+	    }
+#endif
 	default:
 		goto dosurface;
 		break;
@@ -740,6 +931,11 @@
 		sdl.updating=true;
 		return true;
 #endif
+#if (HAVE_D3D9_H) && defined(WIN32)
+	case SCREEN_DIRECT3D:
+		sdl.updating=d3d->LockTexture(pixels, pitch);
+		return sdl.updating;
+#endif
 	default:
 		break;
 	}
@@ -754,6 +950,7 @@
 	if (!sdl.updating)
 		return;
 	sdl.updating=false;
+	frames++;
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
 		if (SDL_MUSTLOCK(sdl.surface)) {
@@ -817,17 +1014,17 @@
 	case SCREEN_OPENGL:
 #if defined(NVIDIA_PixelDataRange)
 		if (sdl.opengl.pixel_data_range) {
-            glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 			glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0,
 					sdl.draw.width, sdl.draw.height, GL_BGRA_EXT,
-					GL_UNSIGNED_INT_8_8_8_8_REV, sdl.opengl.framebuf);
+					GL_UNSIGNED_BYTE, sdl.opengl.framebuf);
 			glCallList(sdl.opengl.displaylist);
 			SDL_GL_SwapBuffers();
 		} else
 #endif
 		if (changedLines) {
 			Bitu y = 0, index = 0;
-            glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 			while (y < sdl.draw.height) {
 				if (!(index & 1)) {
 					y += changedLines[index];
@@ -836,7 +1033,7 @@
 					Bitu height = changedLines[index];
 					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
 						sdl.draw.width, height, GL_BGRA_EXT,
-						GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
+						GL_UNSIGNED_BYTE, pixels );
 					y += height;
 				}
 				index++;
@@ -846,6 +1043,13 @@
 		}
 		break;
 #endif
+#if (HAVE_D3D9_H) && defined(WIN32)
+	case SCREEN_DIRECT3D:
+		if(GCC_UNLIKELY(!d3d->UnlockTexture(changedLines))) {
+			E_Exit("Failed to draw screen!");
+		}
+		break;
+#endif
 	default:
 		break;
 	}
@@ -882,9 +1086,18 @@
 #endif
 		}
 	case SCREEN_OPENGL:
-//		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
-		//USE BGRA
+#ifdef WORDS_BIGENDIAN
+		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
+#else
 		return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);
+#endif
+	case SCREEN_DIRECT3D:
+#if (HAVE_D3D9_H) && defined(WIN32)
+		if(GCC_UNLIKELY(d3d->bpp16))
+		    return SDL_MapRGB(sdl.surface->format,red,green,blue);
+		else
+#endif
+		    return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);
 	}
 	return 0;
 }
@@ -904,6 +1117,10 @@
 	if (sdl.draw.callback) (sdl.draw.callback)( GFX_CallBackStop );
 	if (sdl.mouse.locked) GFX_CaptureMouse();
 	if (sdl.desktop.fullscreen) GFX_SwitchFullScreen();
+#if (HAVE_D3D9_H) && defined(WIN32)
+	if ((sdl.desktop.type==SCREEN_DIRECT3D) && (d3d))
+		delete d3d;
+#endif
 }
 
 static void KillSwitch(bool pressed) {
@@ -989,6 +1206,10 @@
 };
 #include "dosbox_splash.h"
 
+#if (HAVE_D3D9_H) && defined(WIN32)
+#include "SDL_syswm.h"
+#endif
+
 //extern void UI_Run(bool);
 static void GUI_StartUp(Section * sec) {
 	sec->AddDestroyFunction(&GUI_ShutDown);
@@ -1111,6 +1332,28 @@
 		sdl.desktop.want_type=SCREEN_OPENGL;
 		sdl.opengl.bilinear=false;
 #endif
+#if (HAVE_D3D9_H) && defined(WIN32)
+	} else if (output == "direct3d") {
+		sdl.desktop.want_type=SCREEN_DIRECT3D;
+#if LOG_D3D
+		LOG_MSG("SDL:Direct3D activated");
+#endif
+#endif
+	} else if (output == "openglhq") {
+		char *oldvideo = getenv("SDL_VIDEODRIVER");
+
+		if (oldvideo && strcmp(oldvideo,"openglhq")) {
+		    char *driver = (char *)malloc(strlen(oldvideo)+strlen("SDL_OPENGLHQ_VIDEODRIVER=")+1);
+		    strcpy(driver,"SDL_OPENGLHQ_VIDEODRIVER=");
+		    strcat(driver,oldvideo);
+		    putenv(driver);
+		    free(driver);
+		}
+		if (sdl.desktop.doublebuf) putenv("SDL_OPENGLHQ_DOUBLEBUF=1");
+		SDL_QuitSubSystem(SDL_INIT_VIDEO);
+		putenv("SDL_VIDEODRIVER=openglhq");
+		SDL_InitSubSystem(SDL_INIT_VIDEO);
+		sdl.desktop.want_type=SCREEN_OPENGLHQ;
 	} else {
 		LOG_MSG("SDL:Unsupported output device %s, switching back to surface",output.c_str());
 		sdl.desktop.want_type=SCREEN_SURFACE;//SHOULDN'T BE POSSIBLE anymore
@@ -1155,7 +1398,31 @@
 	sdl.desktop.bpp=sdl.surface->format->BitsPerPixel;
 	if (sdl.desktop.bpp==24) {
 		LOG_MSG("SDL:You are running in 24 bpp mode, this will slow down things!");
+	}	
+#if (HAVE_D3D9_H) && defined(WIN32)
+	if(sdl.desktop.want_type==SCREEN_DIRECT3D) {
+	    SDL_SysWMinfo wmi;
+	    SDL_VERSION(&wmi.version);
+
+	    if(!SDL_GetWMInfo(&wmi)) {
+		LOG_MSG("SDL:Error retrieving window information");
+		E_Exit("Failed to get window info");
+	    }
+
+	    if(sdl.desktop.fullscreen) {
+		GFX_CaptureMouse();
+	    }
+
+	    if(d3d) delete d3d;
+	    d3d = new CDirect3D(640,400);
+
+	    if(!d3d) E_Exit("Failed to create d3d object");
+
+	    if(d3d->InitializeDX(wmi.window,sdl.desktop.doublebuf) != S_OK)
+		    E_Exit("Unable to initialize DirectX");
 	}
+#endif
+
 	GFX_Stop();
 	SDL_WM_SetCaption("DOSBox",VERSION);
 
@@ -1480,11 +1747,14 @@
 	const char* outputs[] = {
 		"surface", "overlay",
 #if C_OPENGL
-		"opengl", "openglnb",
+		"opengl", "openglnb", "openglhq",
 #endif
 #if (HAVE_DDRAW_H) && defined(WIN32)
 		"ddraw",
 #endif
+#if (HAVE_D3D9_H) && defined(WIN32)
+		"direct3d",
+#endif
 		0 };
 	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"surface");
 	Pstring->Set_help("What video system to use for output.");
@@ -1515,6 +1785,11 @@
 	Pstring = sdl_sec->Add_path("mapperfile",Property::Changeable::Always,"mapper.txt");
 	Pstring->Set_help("File used to load/save the key/event mappings from.");
 
+#if (HAVE_D3D9_H) && (C_D3DSHADERS) && defined(WIN32)
+	Pstring = sdl_sec->Add_string("pixelshader",Property::Changeable::Always,"none");
+	Pstring->Set_help("Pixelshader program (effect file must be in Shaders subdirectory).");
+#endif
+
 	Pbool = sdl_sec->Add_bool("usescancodes",Property::Changeable::Always,true);
 	Pbool->Set_help("Avoid usage of symkeys, might not work on all operating systems.");
 }
@@ -1716,7 +1991,7 @@
 	LOG_MSG("---");
 
 	/* Init SDL */
-	putenv(const_cast<char*>("SDL_DISABLE_LOCK_KEYS=1")); //Workaround debian/ubuntu fixes for SDL.
+	//putenv(const_cast<char*>("SDL_DISABLE_LOCK_KEYS=1")); //Workaround debian/ubuntu fixes for SDL.
 	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO|SDL_INIT_TIMER|SDL_INIT_CDROM
 		|SDL_INIT_NOPARACHUTE
 		) < 0 ) E_Exit("Can't init SDL %s",SDL_GetError());
@@ -1816,7 +2091,7 @@
 
 		/* Init the keyMapper */
 		MAPPER_Init();
-		if (control->cmdline->FindExist("-startmapper")) MAPPER_Run(false);
+		if (control->cmdline->FindExist("-startmapper")) MAPPER_RunInternal();
 		/* Start up main machine */
 		control->StartUp();
 		/* Shutdown everything */
diff -urN dosbox-0.73/src/gui/sdl_mapper.cpp dosboxcvs/src/gui/sdl_mapper.cpp
--- dosbox-0.73/src/gui/sdl_mapper.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/gui/sdl_mapper.cpp	2009-07-08 20:43:15.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: sdl_mapper.cpp,v 1.59 2009/05/14 18:01:25 qbix79 Exp $ */
+/* $Id: sdl_mapper.cpp,v 1.60 2009/06/01 10:25:51 qbix79 Exp $ */
 
 #include <vector>
 #include <list>
@@ -1575,6 +1575,9 @@
 		case MK_kpminus:
 			key=SDLK_KP_MINUS;
 			break;
+		case MK_equals:
+			key=SDLK_EQUALS;
+			break;
 		case MK_scrolllock:
 			key=SDLK_SCROLLOCK;
 			break;
@@ -1584,6 +1587,18 @@
 		case MK_printscreen:
 			key=SDLK_PRINT;
 			break;
+		case MK_1:
+			key=SDLK_1;
+			break;
+		case MK_2:
+			key=SDLK_2;
+			break;
+		case MK_3:
+			key=SDLK_3;
+			break;
+		case MK_4:
+			key=SDLK_4;
+			break;
 		}
 		sprintf(buf,"%s \"key %d%s%s%s\"",
 			entry,
@@ -2075,7 +2090,7 @@
 	for(CHandlerEventVector_it it=handlergroup.begin();it!=handlergroup.end();it++)
 		if(strcmp((*it)->buttonname,buttonname) == 0) return;
 
-	char tempname[17];
+	char tempname[27];
 	strcpy(tempname,"hand_");
 	strcat(tempname,eventname);
 	new CHandlerEvent(tempname,handler,key,mods,buttonname);
@@ -2126,7 +2141,7 @@
 	SDL_Event event;
 	while (SDL_PollEvent(&event)) {
 		switch (event.type) {
-		case SDL_MOUSEBUTTONDOWN:
+		case SDL_MOUSEBUTTONUP:
 			/* Check the press */
 			for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
 				if ((*but_it)->OnTop(event.button.x,event.button.y)) {
@@ -2272,7 +2287,10 @@
 		return;
 	KEYBOARD_ClrBuffer();	//Clear buffer
 	GFX_LosingFocus();		//Release any keys pressed (buffer gets filled again).
+	MAPPER_RunInternal();
+}
 
+void MAPPER_RunInternal() {
 	int cursor = SDL_ShowCursor(SDL_QUERY);
 	SDL_ShowCursor(SDL_ENABLE);
 	bool mousetoggle=false;
diff -urN dosbox-0.73/src/gui/synth.cpp dosboxcvs/src/gui/synth.cpp
--- dosbox-0.73/src/gui/synth.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/synth.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,1428 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <math.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include "mt32emu.h"
+
+#include "delayReverb.h"
+
+namespace MT32Emu {
+
+const ControlROMMap ControlROMMaps[7] = {
+	// ID    IDc IDbytes                     PCMmap  PCMc  tmbrA   tmbrAO, tmbrAC tmbrB   tmbrBO, tmbrBC tmbrR   trC  rhythm  rhyC  rsrv    panpot  prog    rhyMax  patMax  sysMax  timMax
+	{0x4014, 22, "\000 ver1.04 14 July 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x73A6,  85,  0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A},
+	{0x4014, 22, "\000 ver1.05 06 Aug, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x7414,  85,  0x57C7, 0x57E2, 0x57D0, 0x5252, 0x525E, 0x526E, 0x520A},
+	{0x4014, 22, "\000 ver1.06 31 Aug, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x7414,  85,  0x57D9, 0x57F4, 0x57E2, 0x5264, 0x5270, 0x5280, 0x521C},
+	{0x4010, 22, "\000 ver1.07 10 Oct, 87 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x73fe,  85,  0x57B1, 0x57CC, 0x57BA, 0x523C, 0x5248, 0x5258, 0x51F4}, // MT-32 revision 1
+	{0x4010, 22, "\000verX.XX  30 Sep, 88 ", 0x3000,  128, 0x8000, 0x0000, false, 0xC000, 0x4000, false, 0x3200,  30, 0x741C,  85,  0x57E5, 0x5800, 0x57EE, 0x5270, 0x527C, 0x528C, 0x5228}, // MT-32 Blue Ridge mod
+	{0x2205, 22, "\000CM32/LAPC1.00 890404", 0x8100,  256, 0x8000, 0x8000, false, 0x8080, 0x8000, false, 0x8500,  64, 0x8580,  85,  0x4F65, 0x4F80, 0x4F6E, 0x48A1, 0x48A5, 0x48BE, 0x48D5},
+	{0x2205, 22, "\000CM32/LAPC1.02 891205", 0x8100,  256, 0x8000, 0x8000, true,  0x8080, 0x8000, true,  0x8500,  64, 0x8580,  85,  0x4F93, 0x4FAE, 0x4F9C, 0x48CB, 0x48CF, 0x48E8, 0x48FF}  // CM-32L
+	// (Note that all but CM-32L ROM actually have 86 entries for rhythmTemp)
+};
+
+float iir_filter_normal(float input, float *hist1_ptr, const float *coef_ptr) {
+	float *hist2_ptr;
+	float output,new_hist;
+
+	hist2_ptr = hist1_ptr + 1; // next history
+
+	// 1st number of coefficients array is overall input scale factor, or filter gain
+	output = input * (*coef_ptr++);
+
+	output = output - *hist1_ptr * (*coef_ptr++);
+	new_hist = output - *hist2_ptr * (*coef_ptr++); // poles
+
+	output = new_hist + *hist1_ptr * (*coef_ptr++);
+	output = output + *hist2_ptr * (*coef_ptr++);   // zeros
+
+	*hist2_ptr++ = *hist1_ptr;
+	*hist1_ptr++ = new_hist;
+	hist1_ptr++;
+	hist2_ptr++;
+
+	// i = 1
+	output = output - *hist1_ptr * (*coef_ptr++);
+	new_hist = output - *hist2_ptr * (*coef_ptr++); // poles
+
+	output = new_hist + *hist1_ptr * (*coef_ptr++);
+	output = output + *hist2_ptr * (*coef_ptr++);   // zeros
+
+	*hist2_ptr++ = *hist1_ptr;
+	*hist1_ptr++ = new_hist;
+	/*
+	hist1_ptr++;
+	hist2_ptr++;
+
+	// i = 2
+	output = output - *hist1_ptr * (*coef_ptr++);
+	new_hist = output - *hist2_ptr * (*coef_ptr++); // poles
+
+	output = new_hist + *hist1_ptr * (*coef_ptr++);
+	output = output + *hist2_ptr * (*coef_ptr++);   // zeros
+
+	*hist2_ptr++ = *hist1_ptr;
+	*hist1_ptr++ = new_hist;
+	*/
+
+	return(output);
+}
+
+static inline Bit16s clipBit16s(Bit32s a)
+{
+	// Clamp values above 32767 to 32767, and values below -32768 to -32768
+	if ((a + 32768) & ~65535) {
+		return (a >> 31) ^ 32767;
+	}
+	return a;
+}
+
+Bit8u Synth::calcSysexChecksum(const Bit8u *data, Bit32u len, Bit8u checksum) {
+	for (unsigned int i = 0; i < len; i++) {
+		checksum = checksum + data[i];
+	}
+	checksum = checksum & 0x7f;
+	if (checksum)
+		checksum = 0x80 - checksum;
+	return checksum;
+}
+
+Synth::Synth() {
+	isOpen = false;
+	reverbModel = NULL;
+	delayReverbModel = NULL;
+	reverbEnabled = true;
+	reverbOverridden = false;
+	setReverbModel(NULL); // Creates a default FreeverbModel
+	setDelayReverbModel(NULL); // Creates a default DelayReverb.
+	partialManager = NULL;
+	memset(parts, 0, sizeof(parts));
+}
+
+Synth::~Synth() {
+	close(); // Make sure we're closed and everything is freed
+	delete reverbModel;
+	delete delayReverbModel;
+}
+
+int Synth::report(ReportType type, const void *data) {
+	if (myProp.report != NULL) {
+		return myProp.report(myProp.userData, type, data);
+	}
+	return 0;
+}
+
+unsigned int Synth::getSampleRate() const {
+	return myProp.sampleRate;
+}
+
+void Synth::setReverbModel(ReverbModel *reverbModel) {
+	delete this->reverbModel;
+	if(reverbModel == NULL)
+		reverbModel = new FreeverbModel();
+	this->reverbModel = reverbModel;
+	if(isOpen)
+		setReverbParameters(mt32ram.system.reverbMode, mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+}
+
+void Synth::setDelayReverbModel(ReverbModel *delayReverbModel) {
+	delete this->delayReverbModel;
+	if(delayReverbModel == NULL)
+		delayReverbModel = new DelayReverb();
+	this->delayReverbModel = delayReverbModel;
+	if(isOpen)
+		setReverbParameters(mt32ram.system.reverbMode, mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+}
+
+void Synth::setReverbEnabled(bool reverbEnabled) {
+	this->reverbEnabled = reverbEnabled;
+}
+
+bool Synth::isReverbEnabled() const {
+	return reverbEnabled;
+}
+
+void Synth::setReverbOverridden(bool reverbOverridden) {
+	this->reverbOverridden = reverbOverridden;
+}
+
+bool Synth::isReverbOverridden() const {
+	return reverbOverridden;
+}
+
+void Synth::setReverbParameters(Bit8u mode, Bit8u time, Bit8u level) {
+	if(reverbOverridden)
+		return;
+	if(mode == 3)
+		delayReverbModel->setParameters(mode, time, level);
+	else
+		reverbModel->setParameters(mode, time, level);
+}
+
+File *Synth::openFile(const char *filename, File::OpenMode mode) {
+	if (myProp.openFile != NULL) {
+		return myProp.openFile(myProp.userData, filename, mode);
+	}
+	char pathBuf[2048];
+	if (myProp.baseDir != NULL) {
+		strcpy(&pathBuf[0], myProp.baseDir);
+		strcat(&pathBuf[0], filename);
+		filename = pathBuf;
+	}
+	ANSIFile *file = new ANSIFile();
+	if (!file->open(filename, mode)) {
+		delete file;
+		return NULL;
+	}
+	return file;
+}
+
+void Synth::closeFile(File *file) {
+	if (myProp.closeFile != NULL) {
+		myProp.closeFile(myProp.userData, file);
+	} else {
+		file->close();
+		delete file;
+	}
+}
+
+bool Synth::loadPreset(File *file) {
+	bool inSys = false;
+	Bit8u sysexBuf[MAX_SYSEX_SIZE];
+	Bit16u syslen = 0;
+	bool rc = true;
+	for (;;) {
+		Bit8u c;
+		if (!file->readBit8u(&c)) {
+			if (!file->isEOF()) {
+				rc = false;
+			}
+			break;
+		}
+		sysexBuf[syslen] = c;
+		if (inSys) {
+			syslen++;
+			if (c == 0xF7) {
+				playSysex(&sysexBuf[0], syslen);
+				inSys = false;
+				syslen = 0;
+			} else if (syslen == MAX_SYSEX_SIZE) {
+				LOG_MSG("MT32:MAX_SYSEX_SIZE (%d) exceeded while processing preset, ignoring message", MAX_SYSEX_SIZE);
+				inSys = false;
+				syslen = 0;
+			}
+		} else if (c == 0xF0) {
+			syslen++;
+			inSys = true;
+		}
+	}
+	return rc;
+}
+
+bool Synth::loadControlROM(const char *filename) {
+	File *file = openFile(filename, File::OpenMode_read); // ROM File
+	if (file == NULL) {
+		return false;
+	}
+	bool rc = (file->read(controlROMData, CONTROL_ROM_SIZE) == CONTROL_ROM_SIZE);
+
+	closeFile(file);
+	if (!rc)
+		return rc;
+
+	// Control ROM successfully loaded, now check whether it's a known type
+	controlROMMap = NULL;
+	for (unsigned int i = 0; i < sizeof (ControlROMMaps) / sizeof (ControlROMMaps[0]); i++) {
+		if (memcmp(&controlROMData[ControlROMMaps[i].idPos], ControlROMMaps[i].idBytes, ControlROMMaps[i].idLen) == 0) {
+			controlROMMap = &ControlROMMaps[i];
+			return true;
+		}
+	}
+	return false;
+}
+
+bool Synth::loadPCMROM(const char *filename) {
+	File *file = openFile(filename, File::OpenMode_read); // ROM File
+	if (file == NULL) {
+		return false;
+	}
+	bool rc = true;
+	int i;
+	for (i = 0; i < pcmROMSize; i++) {
+		Bit8u s;
+		if (!file->readBit8u(&s)) {
+			if (!file->isEOF()) {
+				rc = false;
+			}
+			break;
+		}
+		Bit8u c;
+		if (!file->readBit8u(&c)) {
+			if (!file->isEOF()) {
+				rc = false;
+			} else {
+				LOG_MSG("MT32:PCM ROM file has an odd number of bytes! Ignoring last");
+			}
+			break;
+		}
+
+		short e;
+		int bit;
+		int u;
+		int order[16] = {0, 9, 1 ,2, 3, 4, 5, 6, 7, 10, 11, 12, 13, 14, 15, 8};
+
+		e = 0;
+		for (u = 0; u < 15; u++) {
+			if (order[u] < 8)
+				bit = (s >> (7 - order[u])) & 0x1;
+			else
+				bit = (c >> (7  - (order[u] - 8))) & 0x1;
+			e = e | (short)(bit << (15 - u));
+		}
+
+		/*
+		//Bit16s e = (((s & 0x7f) << 4) | ((c & 0x40) << 6) | ((s & 0x80) << 6) | ((c & 0x3f))) << 2;
+		if (e<0)
+			e = -32767 - e;
+		int ut = abs(e);
+		int dif = 0x7fff - ut;
+		x = exp(((float)((float)0x8000-(float)dif) / (float)0x1000));
+		e = (int)((float)e * (x/3200));
+		*/
+
+		// File is companded (dB?), convert to linear PCM
+		// MINDB = -96
+		// MAXDB = -15
+		float testval;
+		testval = (float)((~e) & 0x7fff);
+		testval = -(testval / 400.00f);
+		//testval = -(testval / 341.32291666666666666666666666667);
+		float vol = powf(8, testval / 20) * 32767.0f;
+
+		if (e > 0)
+			vol = -vol;
+
+		//pcmROMData[i] = (Bit16s)vol;
+		pcmROMData[i] = (Bit16s)(vol / 2);
+	}
+	if (i != pcmROMSize) {
+		LOG_MSG("MT32:PCM ROM file is too short (expected %d, got %d)", pcmROMSize, i);
+		rc = false;
+	}
+	closeFile(file);
+	return rc;
+}
+
+bool Synth::initPCMList(Bit16u mapAddress, Bit16u count) {
+	ControlROMPCMStruct *tps = (ControlROMPCMStruct *)&controlROMData[mapAddress];
+	for (int i = 0; i < count; i++) {
+		int rAddr = tps[i].pos * 0x800;
+		int rLenExp = (tps[i].len & 0x70) >> 4;
+		int rLen = 0x800 << rLenExp;
+		//Bit8u rFlag = tps[i].len & 0x0F;
+		Bit16u rTuneOffset = (tps[i].pitchMSB << 8) | tps[i].pitchLSB;
+		// The number below is confirmed to a reasonable degree of accuracy on CM-32L
+		double STANDARDFREQ = 442.0;
+		float rTune = (float)(STANDARDFREQ * pow(2.0, (0x5000 - rTuneOffset) / 4056.0 - 9.0 / 12.0));
+		//LOG_MSG("MT32:%f,%d,%d", pTune, tps[i].pitchCoarse, tps[i].pitchFine);
+		if (rAddr + rLen > pcmROMSize) {
+			LOG_MSG("MT32:Control ROM error: Wave map entry %d points to invalid PCM address 0x%04X, length 0x%04X", i, rAddr, rLen);
+			return false;
+		}
+		pcmWaves[i].addr = rAddr;
+		pcmWaves[i].len = rLen;
+		pcmWaves[i].loop = (tps[i].len & 0x80) != 0;
+		pcmWaves[i].unaffectedByMasterTune = (tps[i].len & 0x01) == 0;
+		pcmWaves[i].tune = rTune;
+		pcmWaves[i].controlROMPCMStruct = &tps[i];
+	}
+	return false;
+}
+
+bool Synth::initCompressedTimbre(int timbreNum, const Bit8u *src, unsigned int srcLen) {
+	// "Compressed" here means that muted partials aren't present in ROM (except in the case of partial 0 being muted).
+	// Instead the data from the previous unmuted partial is used.
+	if (srcLen < sizeof(TimbreParam::CommonParam)) {
+		return false;
+	}
+	TimbreParam *timbre = &mt32ram.timbres[timbreNum].timbre;
+	timbresMemoryRegion->write(timbreNum, 0, src, sizeof(TimbreParam::CommonParam), true);
+	unsigned int srcPos = sizeof(TimbreParam::CommonParam);
+	unsigned int memPos = sizeof(TimbreParam::CommonParam);
+	for (int t = 0; t < 4; t++) {
+		if (t != 0 && ((timbre->common.partialMute >> t) & 0x1) == 0x00) {
+			// This partial is muted - we'll copy the previously copied partial, then
+			srcPos -= sizeof(TimbreParam::PartialParam);
+		} else if (srcPos + sizeof(TimbreParam::PartialParam) >= srcLen) {
+			return false;
+		}
+		timbresMemoryRegion->write(timbreNum, memPos, src + srcPos, sizeof(TimbreParam::PartialParam));
+		srcPos += sizeof(TimbreParam::PartialParam);
+		memPos += sizeof(TimbreParam::PartialParam);
+	}
+	return true;
+}
+
+bool Synth::initTimbres(Bit16u mapAddress, Bit16u offset, int count, int startTimbre, bool compressed) {
+	const Bit8u *timbreMap = &controlROMData[mapAddress];
+	for (Bit16u i = 0; i < count * 2; i += 2) {
+		Bit16u address = (timbreMap[i + 1] << 8) | timbreMap[i];
+		if (!compressed && (address + offset + sizeof(TimbreParam) > CONTROL_ROM_SIZE)) {
+			LOG_MSG("MT32:Control ROM error: Timbre map entry 0x%04x for timbre %d points to invalid timbre address 0x%04x", i, startTimbre, address);
+			return false;
+		}
+		address += offset;
+		if (compressed) {
+			if(!initCompressedTimbre(startTimbre, &controlROMData[address], CONTROL_ROM_SIZE - address)) {
+				LOG_MSG("MT32:Control ROM error: Timbre map entry 0x%04x for timbre %d points to invalid timbre at 0x%04x", i, startTimbre, address);
+				return false;
+			}
+		}
+		else
+			timbresMemoryRegion->write(startTimbre, 0, &controlROMData[address], sizeof(TimbreParam), true);
+		startTimbre++;
+	}
+	return true;
+}
+
+bool Synth::open(SynthProperties &useProp) {
+	if (isOpen)
+		return false;
+	Stk::setSampleRate(useProp.sampleRate);
+	reverbModel->reset();
+	reverbModel->setSampleRate(useProp.sampleRate);
+	delayReverbModel->reset();
+	delayReverbModel->setSampleRate(useProp.sampleRate);
+	myProp = useProp;
+	if (useProp.baseDir != NULL) {
+		myProp.baseDir = new char[strlen(useProp.baseDir) + 1];
+		strcpy(myProp.baseDir, useProp.baseDir);
+	}
+
+	// This is to help detect bugs
+	memset(&mt32ram, '?', sizeof(mt32ram));
+
+	LOG_MSG("MT32:Loading Control ROM");
+	if (!loadControlROM("CM32L_CONTROL.ROM")) {
+		if (!loadControlROM("MT32_CONTROL.ROM")) {
+			LOG_MSG("MT32:Init Error - Missing or invalid MT32_CONTROL.ROM");
+			report(ReportType_errorControlROM, &errno);
+			return false;
+		}
+	}
+
+	initMemoryRegions();
+
+	// 512KB PCM ROM for MT-32, etc.
+	// 1MB PCM ROM for CM-32L, LAPC-I, CM-64, CM-500
+	// Note that the size below is given in samples (16-bit), not bytes
+	pcmROMSize = controlROMMap->pcmCount == 256 ? 512 * 1024 : 256 * 1024;
+	pcmROMData = new Bit16s[pcmROMSize];
+
+	LOG_MSG("MT32:Loading PCM ROM");
+	if (!loadPCMROM("CM32L_PCM.ROM")) {
+		if (!loadPCMROM("MT32_PCM.ROM")) {
+			LOG_MSG("MT32:Init Error - Missing MT32_PCM.ROM");
+			report(ReportType_errorPCMROM, &errno);
+			return false;
+		}
+	}
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Timbre Bank A");
+#endif
+	if (!initTimbres(controlROMMap->timbreAMap, controlROMMap->timbreAOffset, 0x40, 0, controlROMMap->timbreACompressed)) {
+		return false;
+	}
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Timbre Bank B");
+#endif
+	if (!initTimbres(controlROMMap->timbreBMap, controlROMMap->timbreBOffset, 0x40, 64, controlROMMap->timbreBCompressed)) {
+		return false;
+	}
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Timbre Bank R");
+#endif
+	if (!initTimbres(controlROMMap->timbreRMap, 0, controlROMMap->timbreRCount, 192, true)) {
+		return false;
+	}
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Timbre Bank M");
+#endif
+	// CM-64 seems to initialise all bytes in this bank to 0.
+	memset(&mt32ram.timbres[128], 0, sizeof (mt32ram.timbres[128]) * 64);
+
+	partialManager = new PartialManager(this, parts);
+
+	pcmWaves = new PCMWaveEntry[controlROMMap->pcmCount];
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising PCM List");
+#endif
+	initPCMList(controlROMMap->pcmTable, controlROMMap->pcmCount);
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Rhythm Temp");
+#endif
+	memcpy(mt32ram.rhythmTemp, &controlROMData[controlROMMap->rhythmSettings], controlROMMap->rhythmSettingsCount * 4);
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising Patches");
+#endif
+	for (Bit8u i = 0; i < 128; i++) {
+		PatchParam *patch = &mt32ram.patches[i];
+		patch->timbreGroup = i / 64;
+		patch->timbreNum = i % 64;
+		patch->keyShift = 24;
+		patch->fineTune = 50;
+		patch->benderRange = 12;
+		patch->assignMode = 0;
+		patch->reverbSwitch = 1;
+		patch->dummy = 0;
+	}
+
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:Initialising System");
+#endif
+	// The MT-32 manual claims that "Standard pitch" is 442Hz.
+	mt32ram.system.masterTune = 0x4A; // Confirmed on CM-64
+	mt32ram.system.reverbMode = 0; // Confirmed
+	mt32ram.system.reverbTime = 5; // Confirmed
+	mt32ram.system.reverbLevel = 3; // Confirmed
+	memcpy(mt32ram.system.reserveSettings, &controlROMData[controlROMMap->reserveSettings], 9); // Confirmed
+	for (Bit8u i = 0; i < 9; i++) {
+		// This is the default: {1, 2, 3, 4, 5, 6, 7, 8, 9}
+		// An alternative configuration can be selected by holding "Master Volume"
+		// and pressing "PART button 1" on the real MT-32's frontpanel.
+		// The channel assignment is then {0, 1, 2, 3, 4, 5, 6, 7, 9}
+		mt32ram.system.chanAssign[i] = i + 1;
+	}
+	mt32ram.system.masterVol = 100; // Confirmed
+	if (!refreshSystem())
+		return false;
+
+	for (int i = 0; i < 9; i++) {
+		MemParams::PatchTemp *patchTemp = &mt32ram.patchTemp[i];
+
+		// Note that except for the rhythm part, these patch fields will be set in setProgram() below anyway.
+		patchTemp->patch.timbreGroup = 0;
+		patchTemp->patch.timbreNum = 0;
+		patchTemp->patch.keyShift = 24;
+		patchTemp->patch.fineTune = 50;
+		patchTemp->patch.benderRange = 12;
+		patchTemp->patch.assignMode = 0;
+		patchTemp->patch.reverbSwitch = 1;
+		patchTemp->patch.dummy = 0;
+
+		patchTemp->outputLevel = 80;
+		patchTemp->panpot = controlROMData[controlROMMap->panSettings + i];
+		memset(patchTemp->dummyv, 0, sizeof(patchTemp->dummyv));
+		patchTemp->dummyv[1] = 127;
+
+		if(i < 8) {
+		parts[i] = new Part(this, i);
+		parts[i]->setProgram(controlROMData[controlROMMap->programSettings + i]);
+		} else {
+			parts[i] = new RhythmPart(this, i);
+		}
+	}
+
+	// For resetting mt32 mid-execution
+	mt32default = mt32ram;
+
+	iirFilter = &iir_filter_normal;
+
+	isOpen = true;
+	isEnabled = false;
+
+	LOG_MSG("MT32:*** Initialisation complete ***");
+	return true;
+}
+
+void Synth::close(void) {
+	if (!isOpen)
+		return;
+
+	if (partialManager != NULL) {
+		delete partialManager;
+		partialManager = NULL;
+	}
+
+	for (int i = 0; i < 9; i++) {
+		if (parts[i] != NULL) {
+			delete parts[i];
+			parts[i] = NULL;
+		}
+	}
+	if (myProp.baseDir != NULL) {
+		delete myProp.baseDir;
+		myProp.baseDir = NULL;
+	}
+
+	delete[] pcmWaves;
+	delete[] pcmROMData;
+
+	deleteMemoryRegions();
+
+	isOpen = false;
+}
+
+void Synth::playMsg(Bit32u msg) {
+	// FIXME: Implement active sensing
+	unsigned char code     = (unsigned char)((msg & 0x0000F0) >> 4);
+	unsigned char chan     = (unsigned char) (msg & 0x00000F);
+	unsigned char note     = (unsigned char)((msg & 0x00FF00) >> 8);
+	unsigned char velocity = (unsigned char)((msg & 0xFF0000) >> 16);
+	isEnabled = true;
+
+	//LOG_MSG("MT32:Playing chan %d, code 0x%01x note: 0x%02x", chan, code, note);
+
+	char part = chantable[chan];
+	if (part < 0 || part > 8) {
+		LOG_MSG("MT32:Play msg on unreg chan %d (%d): code=0x%01x, vel=%d", chan, part, code, velocity);
+		return;
+	}
+	playMsgOnPart(part, code, note, velocity);
+}
+
+void Synth::playMsgOnPart(unsigned char part, unsigned char code, unsigned char note, unsigned char velocity) {
+	Bit32u bend;
+
+	//LOG_MSG("MT32:Synth::playMsg(0x%02x)",msg);
+	switch (code) {
+	case 0x8:
+		//LOG_MSG("MT32:Note OFF - Part %d", part);
+		// The MT-32 ignores velocity for note off
+		parts[part]->noteOff(note);
+		break;
+	case 0x9:
+		//LOG_MSG("MT32:Note ON - Part %d, Note %d Vel %d", part, note, velocity);
+		if (velocity == 0) {
+			// MIDI defines note-on with velocity 0 as being the same as note-off with velocity 40
+			parts[part]->noteOff(note);
+		} else {
+			parts[part]->noteOn(note, velocity);
+		}
+		break;
+	case 0xB: // Control change
+		switch (note) {
+		case 0x01:  // Modulation
+			//LOG_MSG("MT32:Modulation: %d", velocity);
+			parts[part]->setModulation(velocity);
+			break;
+		case 0x06:
+			parts[part]->setDataEntryMSB(velocity);
+			break;
+		case 0x07:  // Set volume
+			//LOG_MSG("MT32:Volume set: %d", velocity);
+			parts[part]->setVolume(velocity);
+			break;
+		case 0x0A:  // Pan
+			//LOG_MSG("MT32:Pan set: %d", velocity);
+			parts[part]->setPan(velocity);
+			break;
+		case 0x0B:
+			//LOG_MSG("MT32:Expression set: %d", velocity);
+			parts[part]->setExpression(velocity);
+			break;
+		case 0x40: // Hold (sustain) pedal
+			//LOG_MSG("MT32:Hold pedal set: %d", velocity);
+			parts[part]->setHoldPedal(velocity >= 64);
+			break;
+
+		case 0x62:
+		case 0x63:
+			parts[part]->setNRPN();
+			break;
+		case 0x64:
+			parts[part]->setRPNLSB(velocity);
+			break;
+		case 0x65:
+			parts[part]->setRPNMSB(velocity);
+			break;
+
+		case 0x79: // Reset all controllers
+			//LOG_MSG("MT32:Reset all controllers");
+			parts[part]->resetAllControllers();
+			break;
+
+		case 0x7B: // All notes off
+			//LOG_MSG("MT32:All notes off");
+			parts[part]->allNotesOff();
+			break;
+
+		case 0x7C:
+		case 0x7D:
+		case 0x7E:
+		case 0x7F:
+			// CONFIRMED:Mok: A real LAPC-I responds to these controllers as follows:
+			parts[part]->setHoldPedal(false);
+			parts[part]->allNotesOff();
+			break;
+
+		default:
+			LOG_MSG("MT32:Unknown MIDI Control code: 0x%02x - vel 0x%02x", note, velocity);
+			break;
+		}
+
+		break;
+	case 0xC: // Program change
+		//LOG_MSG("MT32:Program change %01x", note);
+		parts[part]->setProgram(note);
+		break;
+	case 0xE: // Pitch bender
+		bend = (velocity << 7) | (note);
+		//LOG_MSG("MT32:Pitch bender %02x", bend);
+		parts[part]->setBend(bend);
+		break;
+	default:
+		LOG_MSG("MT32:Unknown Midi code: 0x%01x - %02x - %02x", code, note, velocity);
+		break;
+	}
+
+	//midiOutShortMsg(m_out, msg);
+}
+
+void Synth::playSysex(const Bit8u *sysex, Bit32u len) {
+	if (len < 2) {
+		LOG_MSG("MT32:playSysex: Message is too short for sysex (%d bytes)", len);
+	}
+	if (sysex[0] != 0xF0) {
+		LOG_MSG("MT32:playSysex: Message lacks start-of-sysex (0xF0)");
+		return;
+	}
+	// Due to some programs (e.g. Java) sending buffers with junk at the end, we have to go through and find the end marker rather than relying on len.
+	Bit32u endPos;
+	for (endPos = 1; endPos < len; endPos++)
+	{
+		if (sysex[endPos] == 0xF7)
+			break;
+	}
+	if (endPos == len) {
+		LOG_MSG("MT32:playSysex: Message lacks end-of-sysex (0xf7)");
+		return;
+	}
+	playSysexWithoutFraming(sysex + 1, endPos - 1);
+}
+
+void Synth::playSysexWithoutFraming(const Bit8u *sysex, Bit32u len) {
+	if (len < 4) {
+		LOG_MSG("MT32:playSysexWithoutFraming: Message is too short (%d bytes)!", len);
+		return;
+	}
+	if (sysex[0] != SYSEX_MANUFACTURER_ROLAND) {
+		LOG_MSG("MT32:playSysexWithoutFraming: Header not intended for this device manufacturer: %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		return;
+	}
+	if (sysex[2] == SYSEX_MDL_D50) {
+		LOG_MSG("MT32:playSysexWithoutFraming: Header is intended for model D-50 (not yet supported): %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		return;
+	}
+	else if (sysex[2] != SYSEX_MDL_MT32) {
+		LOG_MSG("MT32:playSysexWithoutFraming: Header not intended for model MT-32: %02x %02x %02x %02x", (int)sysex[0], (int)sysex[1], (int)sysex[2], (int)sysex[3]);
+		return;
+	}
+	playSysexWithoutHeader(sysex[1], sysex[3], sysex + 4, len - 4);
+}
+
+void Synth::playSysexWithoutHeader(unsigned char device, unsigned char command, const Bit8u *sysex, Bit32u len) {
+	if (device > 0x10) {
+		// We have device ID 0x10 (default, but changeable, on real MT-32), < 0x10 is for channels
+		LOG_MSG("MT32:playSysexWithoutHeader: Message is not intended for this device ID (provided: %02x, expected: 0x10 or channel)", (int)device);
+		return;
+	}
+	// This is checked early in the real devices (before any sysex length checks or further processing)
+	if (command == SYSEX_CMD_DT1 && sysex[0] == 0x7F) {
+		reset();
+		return;
+	}
+	if (len < 4) {
+		LOG_MSG("MT32:playSysexWithoutHeader: Message is too short (%d bytes)!", len);
+		return;
+	}
+	unsigned char checksum = calcSysexChecksum(sysex, len - 1, 0);
+	if (checksum != sysex[len - 1]) {
+		LOG_MSG("MT32:playSysexWithoutHeader: Message checksum is incorrect (provided: %02x, expected: %02x)!", sysex[len - 1], checksum);
+		return;
+	}
+	len -= 1; // Exclude checksum
+	switch (command) {
+	case SYSEX_CMD_DT1:
+		writeSysex(device, sysex, len);
+		break;
+	case SYSEX_CMD_RQ1:
+		readSysex(device, sysex, len);
+		break;
+	default:
+		LOG_MSG("MT32:playSysexWithoutHeader: Unsupported command %02x", command);
+		return;
+	}
+}
+
+void Synth::readSysex(unsigned char /*device*/, const Bit8u * /*sysex*/, Bit32u /*len*/) {
+}
+
+void Synth::writeSysex(unsigned char device, const Bit8u *sysex, Bit32u len) {
+	Bit32u addr = (sysex[0] << 16) | (sysex[1] << 8) | (sysex[2]);
+	addr = MT32EMU_MEMADDR(addr);
+	sysex += 3;
+	len -= 3;
+	//LOG_MSG("MT32:Sysex addr: 0x%06x", MT32EMU_SYSEXMEMADDR(addr));
+	// NOTE: Please keep both lower and upper bounds in each check, for ease of reading
+
+	// Process channel-specific sysex by converting it to device-global
+	if (device < 0x10) {
+#ifdef MT32DEBUG
+		LOG_MSG("MT32:WRITE-CHANNEL: Channel %d temp area 0x%06x", device, MT32EMU_SYSEXMEMADDR(addr));
+#endif
+		if (/*addr >= MT32EMU_MEMADDR(0x000000) && */addr < MT32EMU_MEMADDR(0x010000)) {
+			int offset;
+			if (chantable[device] == -1) {
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Channel not mapped to a partial... 0 offset)");
+#endif
+				offset = 0;
+			} else if (chantable[device] == 8) {
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Channel mapped to rhythm... 0 offset)");
+#endif
+				offset = 0;
+			} else {
+				offset = chantable[device] * sizeof(MemParams::PatchTemp);
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Setting extra offset to %d)", offset);
+#endif
+			}
+			addr += MT32EMU_MEMADDR(0x030000) + offset;
+		} else if (/*addr >= 0x010000 && */ addr < MT32EMU_MEMADDR(0x020000)) {
+			addr += MT32EMU_MEMADDR(0x030110) - MT32EMU_MEMADDR(0x010000);
+		} else if (/*addr >= 0x020000 && */ addr < MT32EMU_MEMADDR(0x030000)) {
+			int offset;
+			if (chantable[device] == -1) {
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Channel not mapped to a partial... 0 offset)");
+#endif
+				offset = 0;
+			} else if (chantable[device] == 8) {
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Channel mapped to rhythm... 0 offset)");
+#endif
+				offset = 0;
+			} else {
+				offset = chantable[device] * sizeof(TimbreParam);
+#ifdef MT32DEBUG
+				LOG_MSG("MT32: (Setting extra offset to %d)", offset);
+#endif
+			}
+			addr += MT32EMU_MEMADDR(0x040000) - MT32EMU_MEMADDR(0x020000) + offset;
+		} else {
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:writeSysex: Invalid channel %d address 0x%06x", device, MT32EMU_SYSEXMEMADDR(addr));
+#endif
+			return;
+		}
+	}
+
+	// Process device-global sysex (possibly converted from channel-specific sysex above)
+	for (;;) {
+		// Find the appropriate memory region
+		const MemoryRegion *region = findMemoryRegion(addr);
+
+		if (region == NULL) {
+			LOG_MSG("MT32:Sysex write to unrecognised address %06x, len %d", MT32EMU_SYSEXMEMADDR(addr), len);
+			break;
+		}
+		writeMemoryRegion(region, addr, region->getClampedLen(addr, len), sysex);
+
+		Bit32u next = region->next(addr, len);
+		if (next == 0) {
+			break;
+		}
+		addr += next;
+		sysex += next;
+		len -= next;
+	}
+}
+
+void Synth::readMemory(Bit32u addr, Bit32u len, Bit8u *data) {
+	const MemoryRegion *region = findMemoryRegion(addr);
+	if (region != NULL) {
+		readMemoryRegion(region, addr, len, data);
+	}
+}
+
+void Synth::initMemoryRegions() {
+	// Timbre max tables are slightly more complicated than the others, which are used directly from the ROM.
+	// The ROM (sensibly) just has maximums for TimbreParam.commonParam followed by just one TimbreParam.partialParam,
+	// so we produce a table with all partialParams filled out, as well as padding for PaddedTimbre, for quick lookup.
+	paddedTimbreMaxTable = new Bit8u[sizeof(MemParams::PaddedTimbre)];
+	memcpy(&paddedTimbreMaxTable[0], &controlROMData[controlROMMap->timbreMaxTable], sizeof(TimbreParam::CommonParam) + sizeof(TimbreParam::PartialParam)); // commonParam and one partialParam
+	int pos = sizeof(TimbreParam::CommonParam) + sizeof(TimbreParam::PartialParam);
+	for (int i = 0; i < 3; i++) {
+		memcpy(&paddedTimbreMaxTable[pos], &controlROMData[controlROMMap->timbreMaxTable + sizeof(TimbreParam::CommonParam)], sizeof(TimbreParam::PartialParam));
+		pos += sizeof(TimbreParam::PartialParam);
+	}
+	memset(&paddedTimbreMaxTable[pos], 0, 10); // Padding
+	patchTempMemoryRegion = new PatchTempMemoryRegion(this, (Bit8u *)&mt32ram.patchTemp[0], &controlROMData[controlROMMap->patchMaxTable]);
+	rhythmTempMemoryRegion = new RhythmTempMemoryRegion(this, (Bit8u *)&mt32ram.rhythmTemp[0], &controlROMData[controlROMMap->rhythmMaxTable]);
+	timbreTempMemoryRegion = new TimbreTempMemoryRegion(this, (Bit8u *)&mt32ram.timbreTemp[0], paddedTimbreMaxTable);
+	patchesMemoryRegion = new PatchesMemoryRegion(this, (Bit8u *)&mt32ram.patches[0], &controlROMData[controlROMMap->patchMaxTable]);
+	timbresMemoryRegion = new TimbresMemoryRegion(this, (Bit8u *)&mt32ram.timbres[0], paddedTimbreMaxTable);
+	systemMemoryRegion = new SystemMemoryRegion(this, (Bit8u *)&mt32ram.system, &controlROMData[controlROMMap->systemMaxTable]);
+	displayMemoryRegion = new DisplayMemoryRegion(this);
+	resetMemoryRegion = new ResetMemoryRegion(this);
+}
+
+void Synth::deleteMemoryRegions() {
+	delete patchTempMemoryRegion;
+	patchTempMemoryRegion = NULL;
+	delete rhythmTempMemoryRegion;
+	rhythmTempMemoryRegion = NULL;
+	delete timbreTempMemoryRegion;
+	timbreTempMemoryRegion = NULL;
+	delete patchesMemoryRegion;
+	patchesMemoryRegion = NULL;
+	delete timbresMemoryRegion;
+	timbresMemoryRegion = NULL;
+	delete systemMemoryRegion;
+	systemMemoryRegion = NULL;
+	delete displayMemoryRegion;
+	displayMemoryRegion = NULL;
+	delete resetMemoryRegion;
+	resetMemoryRegion = NULL;
+
+	delete paddedTimbreMaxTable;
+	paddedTimbreMaxTable = NULL;
+}
+
+MemoryRegion *Synth::findMemoryRegion(Bit32u addr) {
+	MemoryRegion *regions[] = {
+			patchTempMemoryRegion,
+			rhythmTempMemoryRegion,
+			timbreTempMemoryRegion,
+			patchesMemoryRegion,
+			timbresMemoryRegion,
+			systemMemoryRegion,
+			displayMemoryRegion,
+			resetMemoryRegion,
+			NULL};
+	for (int pos = 0; regions[pos] != NULL; pos++) {
+		if (regions[pos]->contains(addr)) {
+			return regions[pos];
+		}
+	}
+	return NULL;
+}
+
+void Synth::readMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u len, Bit8u *data) {
+	unsigned int first = region->firstTouched(addr);
+	//unsigned int last = region->lastTouched(addr, len);
+	unsigned int off = region->firstTouchedOffset(addr);
+	len = region->getClampedLen(addr, len);
+
+	unsigned int m;
+
+	if (region->isReadable()) {
+		region->read(first, off, data, len);
+	} else {
+		// FIXME: We might want to do these properly in future
+		for (m = 0; m < len; m += 2) {
+			data[m] = 0xff;
+			if (m + 1 < len) {
+				data[m+1] = (Bit8u)region->type;
+			}
+		}
+	}
+}
+
+void Synth::writeMemoryRegion(const MemoryRegion *region, Bit32u addr, Bit32u len, const Bit8u *data) {
+	unsigned int first = region->firstTouched(addr);
+	unsigned int last = region->lastTouched(addr, len);
+	unsigned int off = region->firstTouchedOffset(addr);
+	switch (region->type) {
+	case MR_PatchTemp:
+		region->write(first, off, data, len);
+		//LOG_MSG("MT32:Patch temp: Patch %d, offset %x, len %d", off/16, off % 16, len);
+
+		for (unsigned int i = first; i <= last; i++) {
+			int absTimbreNum = mt32ram.patchTemp[i].patch.timbreGroup * 64 + mt32ram.patchTemp[i].patch.timbreNum;
+			char timbreName[11];
+			memcpy(timbreName, mt32ram.timbres[absTimbreNum].timbre.common.name, 10);
+			timbreName[10] = 0;
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:WRITE-PARTPATCH (%d-%d@%d..%d): %d; timbre=%d (%s), outlevel=%d", first, last, off, off + len, i, absTimbreNum, timbreName, mt32ram.patchTemp[i].outputLevel);
+#endif
+			if (parts[i] != NULL) {
+				if (i != 8) {
+					// Note: Confirmed on CM-64 that we definitely *should* update the timbre here,
+					// but only in the case that the sysex actually writes to those values
+					if (i == first && off > 2) {
+#ifdef MT32DEBUG
+						LOG_MSG("MT32: (Not updating timbre, since those values weren't touched)");
+#endif
+					} else {
+						parts[i]->setTimbre(&mt32ram.timbres[parts[i]->getAbsTimbreNum()].timbre);
+					}
+				}
+				parts[i]->refresh();
+			}
+		}
+		break;
+	case MR_RhythmTemp:
+		region->write(first, off, data, len);
+		for (unsigned int i = first; i <= last; i++) {
+			int timbreNum = mt32ram.rhythmTemp[i].timbre;
+			char timbreName[11];
+			if (timbreNum < 94) {
+				memcpy(timbreName, mt32ram.timbres[128 + timbreNum].timbre.common.name, 10);
+				timbreName[10] = 0;
+			} else {
+				strcpy(timbreName, "[None]");
+			}
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:WRITE-RHYTHM (%d-%d@%d..%d): %d; level=%02x, panpot=%02x, reverb=%02x, timbre=%d (%s)", first, last, off, off + len, i, mt32ram.rhythmTemp[i].outputLevel, mt32ram.rhythmTemp[i].panpot, mt32ram.rhythmTemp[i].reverbSwitch, mt32ram.rhythmTemp[i].timbre, timbreName);
+#endif
+		}
+		if (parts[8] != NULL) {
+			parts[8]->refresh();
+		}
+		break;
+	case MR_TimbreTemp:
+		region->write(first, off, data, len);
+		for (unsigned int i = first; i <= last; i++) {
+			char instrumentName[11];
+			memcpy(instrumentName, mt32ram.timbreTemp[i].common.name, 10);
+			instrumentName[10] = 0;
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:WRITE-PARTTIMBRE (%d-%d@%d..%d): timbre=%d (%s)", first, last, off, off + len, i, instrumentName);
+#endif
+			if (parts[i] != NULL) {
+				parts[i]->refresh();
+			}
+		}
+		break;
+	case MR_Patches:
+		region->write(first, off, data, len);
+		for (unsigned int i = first; i <= last; i++) {
+			PatchParam *patch = &mt32ram.patches[i];
+			int patchAbsTimbreNum = patch->timbreGroup * 64 + patch->timbreNum;
+			char instrumentName[11];
+			memcpy(instrumentName, mt32ram.timbres[patchAbsTimbreNum].timbre.common.name, 10);
+			instrumentName[10] = 0;
+			Bit8u *n = (Bit8u *)patch;
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:WRITE-PATCH (%d-%d@%d..%d): %d; timbre=%d (%s) %02X%02X%02X%02X%02X%02X%02X%02X", first, last, off, off + len, i, patchAbsTimbreNum, instrumentName, n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7]);
+#endif
+			// FIXME:KG: The below is definitely dodgy. We just guess that this is the patch that the part was using
+			// based on a timbre match (but many patches could have the same timbre!)
+			// If this refresh is really correct, we should store the patch number in use by each part.
+			/*
+			for (int part = 0; part < 8; part++) {
+				if (parts[part] != NULL) {
+					int partPatchAbsTimbreNum = mt32ram.patchSettings[part].patch.timbreGroup * 64 + mt32ram.patchSettings[part].patch.timbreNum;
+					if (parts[part]->getAbsTimbreNum() == patchAbsTimbreNum) {
+						parts[part]->setPatch(patch);
+						parts[part]->RefreshPatch();
+					}
+				}
+			}
+			*/
+		}
+		break;
+	case MR_Timbres:
+		// Timbres
+		first += 128;
+		last += 128;
+		region->write(first, off, data, len);
+		for (unsigned int i = first; i <= last; i++) {
+			char instrumentName[11];
+			memcpy(instrumentName, mt32ram.timbres[i].timbre.common.name, 10);
+			instrumentName[10] = 0;
+#ifdef MT32DEBUG
+			LOG_MSG("MT32:WRITE-TIMBRE (%d-%d@%d..%d): %d; name=\"%s\"", first, last, off, off + len, i, instrumentName);
+#endif
+			// FIXME:KG: Not sure if the stuff below should be done (for rhythm and/or parts)...
+			// Does the real MT-32 automatically do this?
+			for (unsigned int part = 0; part < 9; part++) {
+				if (parts[part] != NULL) {
+					parts[part]->refreshTimbre(i);
+				}
+			}
+		}
+		break;
+	case MR_System:
+		region->write(0, off, data, len);
+
+		report(ReportType_devReconfig, NULL);
+
+#ifdef MT32DEBUG
+		LOG_MSG("MT32:WRITE-SYSTEM:");
+#endif
+		refreshSystem();
+		break;
+	case MR_Display:
+		char buf[MAX_SYSEX_SIZE];
+		memcpy(&buf, &data[0], len);
+		buf[len] = 0;
+#ifdef MT32DEBUG
+		LOG_MSG("MT32:WRITE-LCD: %s", buf);
+#endif
+		report(ReportType_lcdMessage, buf);
+		//This might be fun :)
+		if(strcmp(buf, ""))
+			LOG_MSG("MT32: %s", buf);
+		break;
+	case MR_Reset:
+		reset();
+		break;
+	}
+}
+
+bool Synth::refreshSystem() {
+	memset(chantable, -1, sizeof(chantable));
+
+	for (unsigned int i = 0; i < 9; i++) {
+		//LOG(LOG_MISC|LOG_ERROR,"Part %d set to MIDI channel %d",i,mt32ram.system.chanAssign[i]);
+		if (mt32ram.system.chanAssign[i] == 16 && parts[i] != NULL) {
+			parts[i]->allSoundOff();
+		} else {
+			chantable[(int)mt32ram.system.chanAssign[i]] = (char)i;
+		}
+	}
+	//FIXME:KG: This is just an educated guess.
+	// The LAPC-I documentation claims a range of 427.5Hz-452.6Hz (similar to what we have here)
+	// The MT-32 documentation claims a range of 432.1Hz-457.6Hz
+	masterTune = 440.0f * powf(2.0f, (mt32ram.system.masterTune - 64.0f) / (128.0f * 12.0f));
+#ifdef MT32DEBUG
+	LOG_MSG("MT32: Master Tune: %f", masterTune);
+	LOG_MSG("MT32: Reverb: mode=%d, time=%d, level=%d", mt32ram.system.reverbMode, mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+#endif
+	report(ReportType_newReverbMode,  &mt32ram.system.reverbMode);
+	report(ReportType_newReverbTime,  &mt32ram.system.reverbTime);
+	report(ReportType_newReverbLevel, &mt32ram.system.reverbLevel);
+
+	setReverbParameters(mt32ram.system.reverbMode, mt32ram.system.reverbTime, mt32ram.system.reverbLevel);
+
+	Bit8u *rset = mt32ram.system.reserveSettings;
+#ifdef MT32DEBUG
+	LOG_MSG("MT32: Partial reserve: 1=%02d 2=%02d 3=%02d 4=%02d 5=%02d 6=%02d 7=%02d 8=%02d Rhythm=%02d", rset[0], rset[1], rset[2], rset[3], rset[4], rset[5], rset[6], rset[7], rset[8]);
+#endif
+	int pr = partialManager->setReserve(rset);
+	if (pr != 32) {
+#ifdef MT32DEBUG
+		LOG_MSG("MT32: (Partial Reserve Table with less than 32 partials reserved!)");
+#endif
+	}
+	rset = mt32ram.system.chanAssign;
+#ifdef MT32DEBUG
+	LOG_MSG("MT32: Part assign:     1=%02d 2=%02d 3=%02d 4=%02d 5=%02d 6=%02d 7=%02d 8=%02d Rhythm=%02d", rset[0], rset[1], rset[2], rset[3], rset[4], rset[5], rset[6], rset[7], rset[8]);
+	LOG_MSG("MT32: Master volume: %d", mt32ram.system.masterVol);
+#endif
+	if (!tables.init(this, pcmWaves, (float)myProp.sampleRate, masterTune)) {
+		report(ReportType_errorSampleRate, NULL);
+		return false;
+	}
+	return true;
+}
+
+void Synth::reset() {
+#ifdef MT32DEBUG
+	LOG_MSG("MT32:RESET");
+#endif
+	report(ReportType_devReset, NULL);
+	partialManager->deactivateAll();
+	mt32ram = mt32default;
+	for (int i = 0; i < 9; i++) {
+		parts[i]->reset();
+		if (i != 8) {
+			parts[i]->setProgram(controlROMData[controlROMMap->programSettings + i]);
+		} else {
+			parts[8]->refresh();
+		}
+	}
+	refreshSystem();
+	isEnabled = false;
+}
+
+bool Synth::dumpTimbre(File *file, const TimbreParam *timbre, Bit32u address) {
+	// Sysex header
+	if (!file->writeBit8u(0xF0))
+		return false;
+	if (!file->writeBit8u(0x41))
+		return false;
+	if (!file->writeBit8u(0x10))
+		return false;
+	if (!file->writeBit8u(0x16))
+		return false;
+	if (!file->writeBit8u(0x12))
+		return false;
+
+	char lsb = (char)(address & 0x7f);
+	char isb = (char)((address >> 7) & 0x7f);
+	char msb = (char)(((address >> 14) & 0x7f) | 0x08);
+
+	//Address
+	if (!file->writeBit8u(msb))
+		return false;
+	if (!file->writeBit8u(isb))
+		return false;
+	if (!file->writeBit8u(lsb))
+		return false;
+
+	//Data
+	if (file->write(timbre, 246) != 246)
+		return false;
+
+	//Checksum
+	unsigned char checksum = calcSysexChecksum((const Bit8u *)timbre, 246, msb + isb + lsb);
+	if (!file->writeBit8u(checksum))
+		return false;
+
+	//End of sysex
+	if (!file->writeBit8u(0xF7))
+		return false;
+	return true;
+}
+
+int Synth::dumpTimbres(const char *filename, int start, int len) {
+	File *file = openFile(filename, File::OpenMode_write);
+	if (file == NULL)
+		return -1;
+
+	for (int timbreNum = start; timbreNum < start + len; timbreNum++) {
+		int useaddr = (timbreNum - start) * 256;
+		TimbreParam *timbre = &mt32ram.timbres[timbreNum].timbre;
+		if (!dumpTimbre(file, timbre, useaddr))
+			break;
+	}
+	closeFile(file);
+	return 0;
+}
+
+void ProduceOutput1(Bit16s *useBuf, Bit16s *stream, Bit32u len) {
+	int end = len * 2;
+	while (end--) {
+		*stream = clipBit16s((Bit32s)*stream + ((Bit32s)*useBuf++));
+		stream++;
+	}
+}
+
+void Synth::render(Bit16s *stream, Bit32u len) {
+	memset(stream, 0, len * sizeof (Bit16s) * 2);
+	if (!isEnabled)
+		return;
+	while (len > 0) {
+		Bit32u thisLen = len > MAX_SAMPLE_OUTPUT ? MAX_SAMPLE_OUTPUT : len;
+		doRender(stream, thisLen);
+		len -= thisLen;
+		stream += 2 * thisLen;
+	}
+}
+
+void Synth::doRender(Bit16s *stream, Bit32u len) {
+	if (reverbEnabled) {
+		for (unsigned int i = 0; i < MT32EMU_MAX_PARTIALS; i++) {
+			if (partialManager->shouldReverb(i)) {
+				if (partialManager->produceOutput(i, &tmpBuffer[0], len)) {
+					ProduceOutput1(&tmpBuffer[0], stream, len);
+				}
+			}
+		}
+		Bit32u m = 0;
+		for (unsigned int i = 0; i < len; i++) {
+			sndbufl[i] = (float)stream[m] / 32767.0f;
+			m++;
+			sndbufr[i] = (float)stream[m] / 32767.0f;
+			m++;
+		}
+		if (mt32ram.system.reverbMode == 3) {
+			delayReverbModel->process(sndbufl, sndbufr, outbufl, outbufr, len);
+		}
+		else {
+			reverbModel->process(sndbufl, sndbufr, outbufl, outbufr, len);
+		}
+		m=0;
+		for (unsigned int i = 0; i < len; i++) {
+			stream[m] = clipBit16s(outbufl[i] * 32767.0f);
+			m++;
+			stream[m] = clipBit16s(outbufr[i] * 32767.0f);
+			m++;
+		}
+		for (unsigned int i = 0; i < MT32EMU_MAX_PARTIALS; i++) {
+			if (!partialManager->shouldReverb(i)) {
+				if (partialManager->produceOutput(i, &tmpBuffer[0], len)) {
+					ProduceOutput1(&tmpBuffer[0], stream, len);
+				}
+			}
+		}
+	} else {
+		for (unsigned int i = 0; i < MT32EMU_MAX_PARTIALS; i++) {
+			if (partialManager->produceOutput(i, &tmpBuffer[0], len))
+				ProduceOutput1(&tmpBuffer[0], stream, len);
+		}
+	}
+
+	partialManager->clearAlreadyOutputed();
+
+#if MT32EMU_MONITOR_PARTIALS == 1
+	samplepos += len;
+	if (samplepos > myProp.SampleRate * 5) {
+		samplepos = 0;
+		int partialUsage[9];
+		partialManager->GetPerPartPartialUsage(partialUsage);
+		LOG_MSG("MT32:1:%02d 2:%02d 3:%02d 4:%02d 5:%02d 6:%02d 7:%02d 8:%02d", partialUsage[0], partialUsage[1], partialUsage[2], partialUsage[3], partialUsage[4], partialUsage[5], partialUsage[6], partialUsage[7]);
+		LOG_MSG("MT32:Rhythm: %02d  TOTAL: %02d", partialUsage[8], MT32EMU_MAX_PARTIALS - partialManager->GetFreePartialCount());
+	}
+#endif
+}
+
+bool Synth::isActive() const {
+	for (int partialNum = 0; partialNum < MT32EMU_MAX_PARTIALS; partialNum++) {
+		if (partialManager->getPartial(partialNum)->isActive()) {
+			return true;
+		}
+	}
+	return false;
+}
+
+const Partial *Synth::getPartial(unsigned int partialNum) const {
+	return partialManager->getPartial(partialNum);
+}
+
+const Part *Synth::getPart(unsigned int partNum) const {
+	if (partNum > 8)
+		return NULL;
+	return parts[partNum];
+}
+
+void MemoryRegion::read(unsigned int entry, unsigned int off, Bit8u *dst, unsigned int len) const {
+	off += entry * entrySize;
+	// This method should never be called with out-of-bounds parameters,
+	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
+	if (off > entrySize * entries - 1) {
+		LOG_MSG("MT32:read[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+		return;
+	}
+	if (off + len > entrySize * entries) {
+		LOG_MSG("MT32:read[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+		len = entrySize * entries - off;
+	}
+	Bit8u *src = getRealMemory();
+	if (src == NULL) {
+		LOG_MSG("MT32:read[%d]: unreadable region: entry=%d, off=%d, len=%d", type, entry, off, len);
+	}
+	memcpy(dst, src + off, len);
+}
+
+void MemoryRegion::write(unsigned int entry, unsigned int off, const Bit8u *src, unsigned int len, bool init) const {
+	unsigned int memOff = entry * entrySize + off;
+	// This method should never be called with out-of-bounds parameters,
+	// or on an unsupported region - seeing any of this debug output indicates a bug in the emulator
+	if (off > entrySize * entries - 1) {
+		LOG_MSG("MT32:write[%d]: parameters start out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+		return;
+	}
+	if (off + len > entrySize * entries) {
+		LOG_MSG("MT32:write[%d]: parameters end out of bounds: entry=%d, off=%d, len=%d", type, entry, off, len);
+		len = entrySize * entries - off;
+	}
+	Bit8u *dest = getRealMemory();
+	if (dest == NULL) {
+		LOG_MSG("MT32:write[%d]: unwritable region: entry=%d, off=%d, len=%d", type, entry, off, len);
+	}
+
+	for (unsigned int i = 0; i < len; i++) {
+		Bit8u desiredValue = src[i];
+		Bit8u maxValue = getMaxValue(memOff);
+		// maxValue == 0 means write-protected unless called from initialisation code, in which case it really means the maximum value is 0.
+		if (maxValue != 0 || init) {
+			if (desiredValue > maxValue) {
+				LOG_MSG("MT32:write[%d]: Wanted 0x%02x at %d, but max 0x%02x", type, desiredValue, memOff, maxValue);
+				desiredValue = maxValue;
+			}
+			dest[memOff] = desiredValue;
+		} else if (desiredValue != 0){
+			// Only output debug info if they wanted to write non-zero, since a lot of things cause this to spit out a lot of debug info otherwise.
+			LOG_MSG("MT32:write[%d]: Wanted 0x%02x at %d, but write-protected", type, desiredValue, memOff);
+		}
+		memOff++;
+	}
+}
+
+FreeverbModel::FreeverbModel() {
+	freeverb = NULL; // Will be initialised with the first setParameters() call.
+}
+
+FreeverbModel::~FreeverbModel() {
+	delete freeverb;
+}
+
+void FreeverbModel::setSampleRate(unsigned int sampleRate) {
+	// FIXME: We don't deal with this at all.
+}
+
+void FreeverbModel::process(const float *inLeft, const float *inRight, float *outLeft, float *outRight, long numSamples) {
+	freeverb->processreplace(inLeft, inRight, outLeft, outRight, numSamples, 1);
+}
+
+void FreeverbModel::setParameters(Bit8u mode, Bit8u time, Bit8u level) {
+	// FIXME:KG: I don't think it's necessary to recreate freeverb's model... Just set the parameters.
+	reset();
+
+	switch (mode) {
+	case 0:
+		freeverb->setroomsize(.1f);
+		//freeverb->setdamp(.75f);
+		freeverb->setdamp(1.0f);
+		break;
+	case 1:
+		freeverb->setroomsize(.5f);
+		//freeverb->setdamp(.5f);
+		freeverb->setdamp(1.0f);
+		break;
+	case 2:
+		freeverb->setroomsize(.5f);
+		//freeverb->setdamp(.1f);
+		freeverb->setdamp(1.0f);
+		break;
+	case 3:
+		freeverb->setroomsize(1.0f);
+		//freeverb->setdamp(.75f);
+		freeverb->setdamp(1.0f);
+		break;
+	default:
+		freeverb->setroomsize(.1f);
+		//freeverb->setdamp(.5f);
+		freeverb->setdamp(1.0f);
+		break;
+	}
+	freeverb->setdry(1);
+	freeverb->setwet((float)level / 5.0f);
+	freeverb->setwidth((float)time / 6.0f);
+}
+
+void FreeverbModel::reset() {
+	delete freeverb;
+	freeverb = new revmodel();
+}
+
+}
diff -urN dosbox-0.73/src/gui/tables.cpp dosboxcvs/src/gui/tables.cpp
--- dosbox-0.73/src/gui/tables.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/tables.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,308 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "mt32emu.h"
+
+#define FIXEDPOINT_MAKE(x, point) ((Bit32u)((1 << point) * x))
+
+namespace MT32Emu {
+
+//Envelope time keyfollow exponential coefficients
+static const double tkcatconst[5] = {0.0, 0.005853144, 0.011148054, 0.019086143, 0.043333215};
+static const double tkcatmult[5] = {1.0, 1.058245688, 1.048488989, 1.016049301, 1.097538067};
+
+// Begin filter stuff
+
+// Pre-warp the coefficients of a numerator or denominator.
+// Note that a0 is assumed to be 1, so there is no wrapping
+// of it.
+static void prewarp(double *a1, double *a2, double fc, double fs) {
+	double wp;
+
+	wp = 2.0 * fs * tan(DOUBLE_PI * fc / fs);
+
+	*a2 = *a2 / (wp * wp);
+	*a1 = *a1 / wp;
+}
+
+// Transform the numerator and denominator coefficients
+// of s-domain biquad section into corresponding
+// z-domain coefficients.
+//
+//      Store the 4 IIR coefficients in array pointed by coef
+//      in following order:
+//             beta1, beta2    (denominator)
+//             alpha1, alpha2  (numerator)
+//
+// Arguments:
+//             a0-a2   - s-domain numerator coefficients
+//             b0-b2   - s-domain denominator coefficients
+//             k               - filter gain factor. initially set to 1
+//                                and modified by each biquad section in such
+//                                a way, as to make it the coefficient by
+//                                which to multiply the overall filter gain
+//                                in order to achieve a desired overall filter gain,
+//                                specified in initial value of k.
+//             fs             - sampling rate (Hz)
+//             coef    - array of z-domain coefficients to be filled in.
+//
+// Return:
+//             On return, set coef z-domain coefficients
+static void bilinear(double a0, double a1, double a2, double b0, double b1, double b2, double *k, double fs, float *coef) {
+	double ad, bd;
+
+	// alpha (Numerator in s-domain)
+	ad = 4. * a2 * fs * fs + 2. * a1 * fs + a0;
+	// beta (Denominator in s-domain)
+	bd = 4. * b2 * fs * fs + 2. * b1* fs + b0;
+
+	// update gain constant for this section
+	*k *= ad/bd;
+
+	// Denominator
+	*coef++ = (float)((2. * b0 - 8. * b2 * fs * fs) / bd);           // beta1
+	*coef++ = (float)((4. * b2 * fs * fs - 2. * b1 * fs + b0) / bd); // beta2
+
+	// Nominator
+	*coef++ = (float)((2. * a0 - 8. * a2 * fs * fs) / ad);           // alpha1
+	*coef = (float)((4. * a2 * fs * fs - 2. * a1 * fs + a0) / ad);   // alpha2
+}
+
+// a0-a2: numerator coefficients
+// b0-b2: denominator coefficients
+// fc: Filter cutoff frequency
+// fs: sampling rate
+// k: overall gain factor
+// coef: pointer to 4 iir coefficients
+static void szxform(double *a0, double *a1, double *a2, double *b0, double *b1, double *b2, double fc, double fs, double *k, float *coef) {
+	// Calculate a1 and a2 and overwrite the original values
+	prewarp(a1, a2, fc, fs);
+	prewarp(b1, b2, fc, fs);
+	bilinear(*a0, *a1, *a2, *b0, *b1, *b2, k, fs, coef);
+}
+
+static void initFilter(float fs, float fc, float *icoeff, float Q) {
+	float *coef;
+	double a0, a1, a2, b0, b1, b2;
+
+	double k = 1.0;    // Set overall filter gain factor
+	coef = icoeff + 1; // Skip k, or gain
+
+	// Section 1
+	a0 = 1.0;
+	a1 = 0;
+	a2 = 0;
+	b0 = 1.0;
+	b1 = 0.765367 / Q;
+	//b1 = 0.5176387 / Q; // Divide by resonance or Q
+	b2 = 1.0;
+	szxform(&a0, &a1, &a2, &b0, &b1, &b2, fc, fs, &k, coef);
+	coef += 4;         // Point to next filter section
+
+	// Section 2
+	a0 = 1.0;
+	a1 = 0;
+	a2 = 0;
+	b0 = 1.0;
+	b1 = 1.847759 / Q;
+	//b1 = 1.414214  / Q;
+	b2 = 1.0;
+	szxform(&a0, &a1, &a2, &b0, &b1, &b2, fc, fs, &k, coef);
+	coef += 4;         // Point to next filter section
+
+	/*
+	// Section 3
+	a0 = 1.0;
+	a1 = 0;
+	a2 = 0;
+	b0 = 1.0;
+	b1 = 1.931852 / Q;
+	b2 = 1.0;
+	szxform(&a0, &a1, &a2, &b0, &b1, &b2, fc, fs, &k, coef);
+	*/
+	icoeff[0] = (float)k;
+}
+
+void Tables::initFiltCoeff(float samplerate) {
+	for (int j = 0; j < FILTERGRAN; j++) {
+		for (int res = 0; res < 31; res++) {
+			float tres = resonanceFactor[res];
+			initFilter((float)samplerate, (float)j, filtCoeff[j][res], tres);
+		}
+	}
+}
+
+void Tables::initEnvelopes(float samplerate) {
+	for (int lf = 0; lf <= 100; lf++) {
+		float elf = (float)lf;
+
+		// General envelope
+		// This formula fits observation of the CM-32L by +/- 0.03s or so for the second time value in the filter,
+		// when all other times were 0 and all levels were 100. Note that variations occur depending on the level
+		// delta of the section, which we're not fully emulating.
+		float seconds = powf(2.0f, (elf / 8.0f) + 7.0f) / 32768.0f;
+		int samples = (int)(seconds * samplerate);
+		envTime[lf] = samples;
+
+		// Cap on envelope times depending on the level delta
+		if (elf == 0) {
+			envDeltaMaxTime[lf] = 63;
+		} else {
+			float cap = 11.0f * logf(elf) + 64;
+			if (cap > 100.0f) {
+				cap = 100.0f;
+			}
+			envDeltaMaxTime[lf] = (int)cap;
+		}
+
+		// This (approximately) represents the time durations when the target level is 0.
+		// Not sure why this is a special case, but it's seen to be from the real thing.
+		seconds = powf(2, (elf / 8.0f) + 6) / 32768.0f;
+		envDecayTime[lf]  = (int)(seconds * samplerate);
+	}
+}
+
+void Tables::initMT32ConstantTables(Synth *synth) {
+	int lf;
+	LOG_MSG("MT32:Initialising Constant Tables");
+	for (lf = 0; lf <= 100; lf++) {
+		// CONFIRMED:KG: This matches a ROM table found by Mok
+		float fVal = (2.0f - log10f(lf + 1.0f)) * 128.0f;
+        int val = (int)(fVal + 1.0);
+        if (val > 255)
+        	val = 255;
+        levelToAmpSubtraction[lf] = (Bit8u)val;
+	}
+
+	envLogarithmicTime[0] = 64;
+	for(lf = 1; lf <= 255; lf++) {
+		// CONFIRMED:KG: This matches a ROM table found by Mok
+		envLogarithmicTime[lf] = (Bit8u)ceilf(64.0f + logf(lf) / FLOAT_LN_2 * 8.0f);
+	}
+
+	// CONFIRMED:KG: I'm too lazy to work out a real formula for this one, but it matches the LAPC-I table found by Mok
+	// NOTE: Very different in MT-32
+	memset(masterVolToAmpSubtraction, 8, 71);
+	memset(masterVolToAmpSubtraction + 71, 7, 3);
+	memset(masterVolToAmpSubtraction + 74, 6, 4);
+	memset(masterVolToAmpSubtraction + 78, 5, 3);
+	memset(masterVolToAmpSubtraction + 81, 4, 4);
+	memset(masterVolToAmpSubtraction + 85, 3, 3);
+	memset(masterVolToAmpSubtraction + 88, 2, 4);
+	memset(masterVolToAmpSubtraction + 92, 1, 4);
+	memset(masterVolToAmpSubtraction + 96, 0, 5);
+
+	for (int i = 0; i <= 100; i++) {
+		pulseWidth100To255[i] = (int)(i * 255 / 100.0f + 0.5f);
+		//LOG_MSG("MT32:%d: %d", i, pulseWidth100To255[i]);
+	}
+	for (lf = -108; lf <= 108; lf++) {
+		tvfKeyfollowMult[lf + 108] = (int)(256 * powf(2.0f, (float)(lf / 24.0f)));
+		//LOG_MSG("MT32:KT %d = %d", f, keytable[f+108]);
+	}
+
+	for (int res = 0; res < 31; res++) {
+		resonanceFactor[res] = powf((float)res / 30.0f, 5.0f) +1.0f;
+	}
+
+	int velt, dep;
+	for (velt = 0; velt < 128; velt++) {
+		for (dep = -7; dep < 8; dep++) {
+			float fldep = (float)abs(dep) / 7.0f;
+			fldep = powf(fldep,2.5f);
+			if (dep < 0)
+				fldep = fldep * -1.0f;
+			pwVelfollowAdd[dep+7][velt] = Bit32s((fldep * (float)velt * 100) / 128.0);
+		}
+	}
+
+	for (lf = 0; lf <= 100; lf++) {
+		float mv = lf / 100.0f;
+		float pt = mv - 0.5f;
+		if (pt < 0)
+			pt = 0;
+
+		// Approximation from sample comparison
+		pwFactorf[lf] = ((pt * 179.0f) + 128.0f) / 64.0f;
+		pwFactorf[lf] = 1.0f / pwFactorf[lf];
+	}
+
+	for (unsigned int i = 0; i < MAX_SAMPLE_OUTPUT; i++) {
+		int myRand;
+		myRand = rand();
+		//myRand = ((myRand - 16383) * 7168) >> 16;
+		// This one is slower but works with all values of RAND_MAX
+		myRand = (int)((myRand - RAND_MAX / 2) / (float)RAND_MAX * (7168 / 2));
+		//FIXME:KG: Original ultimately set the lowest two bits to 0, for no obvious reason
+		noiseBuf[i] = (Bit16s)myRand;
+	}
+}
+
+static void initDep(KeyLookup *keyLookup, float f) {
+	for (int dep = 0; dep < 5; dep++) {
+		if (dep == 0) {
+			keyLookup->envTimeMult[dep] = 256;
+		} else {
+			float ff = (float)(exp(tkcatconst[dep] * ((float)MIDDLEC - f)) * tkcatmult[dep]);
+			keyLookup->envTimeMult[dep] = (int)(ff * 256.0f);
+		}
+	}
+}
+
+Bit16s Tables::clampWF(Synth *synth, const char *n, float ampVal, double input) {
+	Bit32s x = (Bit32s)(input * ampVal);
+	if (x < -ampVal - 1) {
+		LOG_MSG("MT32:%s==%d<-WGAMP-1!", n, x);
+		x = (Bit32s)(-ampVal - 1);
+	} else if (x > ampVal) {
+		LOG_MSG("MT32:%s==%d>WGAMP!", n, x);
+		x = (Bit32s)ampVal;
+	}
+	return (Bit16s)x;
+}
+
+Tables::Tables() {
+	initialisedSampleRate = 0.0f;
+	initialisedMasterTune = 0.0f;
+}
+
+bool Tables::init(Synth *synth, PCMWaveEntry *pcmWaves, float sampleRate, float masterTune) {
+	if (sampleRate <= 0.0f) {
+		LOG_MSG("MT32:Bad sampleRate (%f <= 0.0f)", sampleRate);
+		return false;
+	}
+	if (initialisedSampleRate == 0.0f) {
+		initMT32ConstantTables(synth);
+	}
+	if (initialisedSampleRate != sampleRate) {
+		initFiltCoeff(sampleRate);
+		initEnvelopes(sampleRate);
+		for (int key = 12; key <= 108; key++) {
+			initDep(&keyLookups[key - 12], (float)key);
+		}
+	}
+	if (initialisedSampleRate != sampleRate || initialisedMasterTune != masterTune) {
+		initialisedSampleRate = sampleRate;
+		initialisedMasterTune = masterTune;
+	}
+	return true;
+}
+
+}
diff -urN dosbox-0.73/src/gui/tva.cpp dosboxcvs/src/gui/tva.cpp
--- dosbox-0.73/src/gui/tva.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/tva.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,386 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mt32emu.h"
+
+#include <math.h>
+
+namespace MT32Emu {
+
+// FIXME: Need to confirm that this is correct. Sounds about right.
+const int TVA_TARGET_AMP_MULT = 0x800000;
+const int MAX_CURRENT_AMP = 0xFF * TVA_TARGET_AMP_MULT;
+
+// CONFIRMED: Matches a table in ROM - haven't got around to coming up with a formula for it yet.
+static Bit8u biasLevelToAmpSubtractionCoeff[13] = {255, 187, 137, 100, 74, 54, 40, 29, 21, 15, 10, 5, 0};
+
+// When entering nextPhase, targetPhase is immediately incremented, and the descriptions/names below represent
+// their use after the increment.
+enum {
+	// When this is the target phase, level[0] is targeted within time[0], and velocity potentially affects time
+	PHASE_ATTACK = 1,
+
+	// When this is the target phase, level[1] is targeted within time[1]
+	PHASE_2 = 2,
+
+	// When this is the target phase, level[2] is targeted within time[2]
+	PHASE_3 = 3,
+
+	// When this is the target phase, level[3] is targeted within time[3]
+	PHASE_4 = 4,
+
+	// When this is the target phase, immediately goes to PHASE_RELEASE unless the poly is set to sustain.
+	// Aborts the partial if level[3] is 0.
+	// Otherwise level[3] is continued, no phase change will occur until some external influence (like pedal release)
+	PHASE_SUSTAIN = 5,
+
+	// 0 is targeted within time[4] (the time calculation is quite different from the other phases)
+	PHASE_RELEASE = 6,
+
+	// It's PHASE_DEAD, Jim.
+	PHASE_DEAD = 7
+};
+
+TVA::TVA(const Partial *partial) :
+	partial(partial), system(&partial->getSynth()->mt32ram.system) {
+}
+
+void TVA::setAmpIncrement(Bit8u ampIncrement) {
+	this->ampIncrement = ampIncrement;
+
+	largeAmpInc = ampIncrement & 0x7F;
+	// FIXME: We could use a table for this in future
+	largeAmpInc = (unsigned int)((powf(10.0f, (float)((largeAmpInc - 1.0f) / 26.0f))) * 256.0f);
+}
+
+float TVA::nextAmp() {
+	// FIXME: This whole method is based on guesswork
+	Bit32u target = targetAmp * TVA_TARGET_AMP_MULT;
+	if (ampIncrement == 0) {
+		currentAmp = target;
+	} else {
+		if ((ampIncrement & 0x80) != 0) {
+			// Lowering amp
+			if (largeAmpInc > currentAmp) {
+				currentAmp = target;
+				nextPhase();
+			} else {
+				currentAmp -= largeAmpInc;
+				if (currentAmp <= target) {
+					currentAmp = target;
+					nextPhase();
+				}
+			}
+		} else {
+			// Raising amp
+			if (MAX_CURRENT_AMP - currentAmp < largeAmpInc) {
+				currentAmp = target;
+				nextPhase();
+			} else {
+				currentAmp += largeAmpInc;
+				if(currentAmp >= target) {
+					currentAmp = target;
+					nextPhase();
+				}
+			}
+		}
+	}
+	// FIXME:KG: Note that the "65536.0f" here is slightly arbitrary, and needs to be confirmed. 32768.0f is more likely.
+	// FIXME:KG: We should perhaps use something faster once we've got the details sorted out, but the real synth's amp level changes pretty smoothly.
+	return powf(2.0f, (float)currentAmp / TVA_TARGET_AMP_MULT / 16.0f - 1.0f) / 65536.0f;
+}
+
+static int multBias(const Tables *tables, Bit8u biasLevel, int bias) {
+	return (bias * biasLevelToAmpSubtractionCoeff[biasLevel]) >> 5;
+}
+
+static int calcBiasAmpSubtraction(const Tables *tables, Bit8u biasPoint, Bit8u biasLevel, int key) {
+	if ((biasPoint & 0x40) == 0) {
+		int bias = biasPoint + 33 - key;
+		if (bias > 0) {
+			return multBias(tables, biasLevel, bias);
+		}
+	} else {
+		int bias = biasPoint - 31 - key;
+		if (bias < 0) {
+			bias = -bias;
+			return multBias(tables, biasLevel, bias);
+		}
+	}
+	return 0;
+}
+
+static int calcBiasAmpSubtractions(const Tables *tables, const TimbreParam::PartialParam *partialParam, int key) {
+	int biasAmpSubtraction1 = calcBiasAmpSubtraction(tables, partialParam->tva.biasPoint1, partialParam->tva.biasLevel1, key);
+	if (biasAmpSubtraction1 > 255)
+		return 255;
+	int biasAmpSubtraction2 = calcBiasAmpSubtraction(tables, partialParam->tva.biasPoint2, partialParam->tva.biasLevel2, key);
+	if (biasAmpSubtraction2 > 255)
+		return 255;
+	int biasAmpSubtraction = biasAmpSubtraction1 + biasAmpSubtraction2;
+	if (biasAmpSubtraction > 255)
+		return 255;
+	return biasAmpSubtraction;
+}
+
+static int calcVeloAmpSubtraction(const Tables *tables, Bit8u veloSensitivity, unsigned int velocity) {
+	// FIXME:KG: Better variable names
+	int velocityMult = veloSensitivity - 50;
+	int absVelocityMult = velocityMult < 0 ? -velocityMult : velocityMult;
+	velocityMult = (signed)((unsigned)(velocityMult * ((signed)velocity - 64)) << 2);
+	return absVelocityMult - (velocityMult >> 8); // PORTABILITY NOTE: Assumes arithmetic shift
+}
+
+static int calcBasicAmp(const Tables *tables, const Partial *partial, const MemParams::System *system, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, const MemParams::RhythmTemp *rhythmTemp, int biasAmpSubtraction, int veloAmpSubtraction, Bit8u expression) {
+	int amp = 155;
+
+	if (!partial->isRingModulatingSlave()) {
+		amp -= tables->masterVolToAmpSubtraction[system->masterVol];
+		if (amp < 0)
+			return 0;
+		amp -= tables->levelToAmpSubtraction[patchTemp->outputLevel];
+		if (amp < 0)
+			return 0;
+		amp -= tables->levelToAmpSubtraction[expression];
+		if (amp < 0)
+			return 0;
+		if (rhythmTemp != NULL) {
+			amp -= tables->levelToAmpSubtraction[rhythmTemp->outputLevel];
+			if (amp < 0)
+				return 0;
+		}
+	}
+	amp -= biasAmpSubtraction;
+	if (amp < 0)
+		return 0;
+	amp -= tables->levelToAmpSubtraction[partialParam->tva.level];
+	if (amp < 0)
+		return 0;
+	amp -= veloAmpSubtraction;
+	if (amp < 0)
+		return 0;
+	if (amp > 155)
+		amp = 155;
+	amp -= partialParam->tvf.resonance >> 1;
+	if (amp < 0)
+		return 0;
+	return amp;
+}
+
+int calcKeyTimeSubtraction(Bit8u envTimeKeyfollow, int key) {
+	if (envTimeKeyfollow == 0)
+		return 0;
+	return (key - 60) >> (5 - envTimeKeyfollow); // PORTABILITY NOTE: Assumes arithmetic shift
+}
+
+void TVA::reset(const Part *part, const PatchCache *patchCache, const MemParams::RhythmTemp *rhythmTemp) {
+	this->part = part;
+	this->partialParam = patchCache->partialParam;
+	this->patchTemp = part->getPatchTemp();
+	this->rhythmTemp = rhythmTemp;
+
+	play = true;
+
+	Tables *tables = &partial->getSynth()->tables;
+
+	int key = partial->getPoly()->getKey();
+	int velocity = partial->getPoly()->getVelocity();
+
+	keyTimeSubtraction = calcKeyTimeSubtraction(partialParam->tva.envTimeKeyfollow, key);
+
+	biasAmpSubtraction = calcBiasAmpSubtractions(tables, partialParam, key);
+	veloAmpSubtraction = calcVeloAmpSubtraction(tables, partialParam->tva.veloSensitivity, velocity);
+
+	int newTargetAmp = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+
+	if (partialParam->tva.envTime[0] == 0) {
+		// Initially go to the PHASE_ATTACK target amp, and spend the next phase going from there to the PHASE_2 target amp
+		// Note that this means that velocity never affects time for this partial.
+		newTargetAmp += partialParam->tva.envLevel[0];
+		targetPhase = PHASE_2 - 1; // The first target used in nextPhase() will be PHASE_2
+	} else {
+		// Initially go to the base amp determined by TVA level, part volume, etc., and spend the next phase going from there to the full PHASE_ATTACK target amp.
+		targetPhase = PHASE_ATTACK - 1; // The first target used in nextPhase() will be PHASE_ATTACK
+	}
+
+	// "Go downward as quickly as possible".
+	// Since currentAmp is 0, nextAmp() will notice that we're already at or below the target and trying to go downward,
+	// and therefore jump to the target immediately and call nextPhase().
+	setAmpIncrement(0x80 | 127);
+	targetAmp = (Bit8u)newTargetAmp;
+
+	currentAmp = 0;
+}
+
+void TVA::startDecay() {
+	if (targetPhase >= PHASE_RELEASE)
+		return;
+	targetPhase = PHASE_RELEASE; // The next time nextPhase() is called, it will think PHASE_RELEASE has finished and the partial will be aborted
+	if (partialParam->tva.envTime[4] == 0)
+		setAmpIncrement(1);
+	else
+		setAmpIncrement(-partialParam->tva.envTime[4]);
+	targetAmp = 0;
+}
+
+void TVA::recalcSustain() {
+	// We get pinged periodically by the pitch code to recalculate our values when in sustain.
+	// This is done so that the TVA will respond to things like MIDI expression and volume changes while it's sustaining, which it otherwise wouldn't do.
+
+	// The check for envLevel[3] == 0 strikes me as slightly dumb. FIXME: Explain why
+	if (targetPhase != PHASE_SUSTAIN || partialParam->tva.envLevel[3] == 0)
+		return;
+	// We're sustaining. Recalculate all the values
+	Tables *tables = &partial->getSynth()->tables;
+	int newTargetAmp = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+	newTargetAmp += partialParam->tva.envLevel[3];
+	// FIXME: This whole concept seems flawed.  We don't really know what the *actual* amp value is, right? It may well not be targetAmp yet (unless I've missed something). So we could end up going in the wrong direction...
+	int ampDelta = newTargetAmp - targetAmp;
+
+	// Calculate an increment to get to the new amp value in a short, more or less consistent amount of time
+	if (ampDelta >= 0) {
+		setAmpIncrement(tables->envLogarithmicTime[(Bit8u)ampDelta] - 2);
+	} else {
+		setAmpIncrement((tables->envLogarithmicTime[(Bit8u)-ampDelta] - 2) | 0x80);
+	}
+	targetAmp = newTargetAmp;
+	// Configure so that once the transition's complete and nextPhase() is called, we'll just re-enter sustain phase (or decay phase, depending on parameters at the time).
+	targetPhase = PHASE_SUSTAIN - 1;
+}
+
+void TVA::nextPhase() {
+	Tables *tables = &partial->getSynth()->tables;
+
+	if (targetPhase >= PHASE_DEAD || !play) {
+		LOG_MSG("MT32:TVA::nextPhase(): Shouldn't have got here with targetPhase %d, play=%s", targetPhase, play ? "true" : "false");
+		return;
+	}
+	targetPhase++;
+
+	if (targetPhase == PHASE_DEAD) {
+		play = false;
+		return;
+	}
+
+	bool allLevelsZeroFromNowOn = false;
+	if (partialParam->tva.envLevel[3] == 0) {
+		if (targetPhase == PHASE_4)
+			allLevelsZeroFromNowOn = true;
+		else if (partialParam->tva.envLevel[2] == 0) {
+			if (targetPhase == PHASE_3)
+				allLevelsZeroFromNowOn = true;
+			else if (partialParam->tva.envLevel[1] == 0) {
+				if (targetPhase == PHASE_2)
+					allLevelsZeroFromNowOn = true;
+				else if (partialParam->tva.envLevel[0] == 0) {
+					if (targetPhase == PHASE_ATTACK) // this line added, missing in ROM - FIXME: Add description of repercussions
+						allLevelsZeroFromNowOn = true;
+				}
+			}
+		}
+	}
+
+	int newTargetAmp;
+	int newAmpIncrement;
+	int envPointIndex = targetPhase - 1;
+
+	if (!allLevelsZeroFromNowOn) {
+		newTargetAmp = calcBasicAmp(tables, partial, system, partialParam, patchTemp, rhythmTemp, biasAmpSubtraction, veloAmpSubtraction, part->getExpression());
+
+		if (targetPhase == PHASE_SUSTAIN || targetPhase == PHASE_RELEASE) {
+			if (partialParam->tva.envLevel[3] == 0) {
+				play = false;
+				return;
+			}
+			if (!partial->getPoly()->canSustain()) {
+				targetPhase = PHASE_RELEASE;
+				newTargetAmp = 0;
+				newAmpIncrement = -partialParam->tva.envTime[4];
+				if (newAmpIncrement >= 0) {
+					// FIXME: This must mean newAmpIncrement was 0, and we're now making it 1, which makes us go in the wrong direction. WTF?
+					newAmpIncrement++;
+				}
+			} else {
+				newTargetAmp += partialParam->tva.envLevel[3];
+				newAmpIncrement = 0;
+			}
+		} else {
+			newTargetAmp += partialParam->tva.envLevel[envPointIndex];
+		}
+	} else {
+		newTargetAmp = 0;
+	}
+
+	if ((targetPhase != PHASE_SUSTAIN && targetPhase != PHASE_RELEASE) || allLevelsZeroFromNowOn) {
+		int envTimeSetting  = partialParam->tva.envTime[envPointIndex];
+
+		if (targetPhase == PHASE_ATTACK) {
+			envTimeSetting -= ((signed)partial->getPoly()->getVelocity() - 64) >> (6 - partialParam->tva.envTimeVeloSensitivity);  // PORTABILITY NOTE: Assumes arithmetic shift
+
+			if (envTimeSetting <= 0 && partialParam->tva.envTime[envPointIndex] != 0) {
+					envTimeSetting = 1;
+			}
+		} else {
+			envTimeSetting -= keyTimeSubtraction;
+		}
+		if (envTimeSetting > 0)
+		{
+			int ampDelta = newTargetAmp - targetAmp;
+			if (ampDelta <= 0) {
+				if (ampDelta == 0) {
+					// targetAmp and newTargetAmp are the same.
+					// We'd never get anywhere if we used these parameters, so instead make targetAmp one less than it really should be and set ampDelta accordingly
+					ampDelta--; // i.e. ampDelta = -1;
+					newTargetAmp--;
+					if (newTargetAmp < 0) {
+						// Oops, newTargetAmp is less than zero now, so let's do it the other way:
+						// Make newTargetAmp one more than it really should've been and set ampDelta accordingly
+						// FIXME: This means ampDelta will be positive just below here where it's inverted, and we'll end up using envLogarithmicTime[-1], and we'll be setting newAmpIncrement to be descending later on, etc..
+						ampDelta = -ampDelta; // i.e. ampDelta = 1;
+						newTargetAmp = -newTargetAmp;
+					}
+				}
+				ampDelta = -ampDelta;
+				newAmpIncrement = tables->envLogarithmicTime[(Bit8u)ampDelta] - envTimeSetting;
+				if (newAmpIncrement <= 0) {
+					newAmpIncrement = 1;
+				}
+				newAmpIncrement = newAmpIncrement | 0x80;
+			} else {
+				// FIXME: The last 22 or so entries in this table are 128 - surely that fucks things up, since that ends up being -128 signed?
+				newAmpIncrement = tables->envLogarithmicTime[(Bit8u)ampDelta] - envTimeSetting;
+				if (newAmpIncrement <= 0) {
+					newAmpIncrement = 1;
+				}
+			}
+		}
+		else
+		{
+			// FIXME: Shouldn't we be ensuring that targetAmp != newTargetAmp here?
+			newAmpIncrement = newTargetAmp >= targetAmp ? (0x80 | 127) : 127;
+		}
+
+		// FIXME: What's the point of this? It's checked or set to non-zero everywhere above
+		if (newAmpIncrement == 0) {
+			newAmpIncrement = 1;
+		}
+	}
+
+	targetAmp = (Bit8u)newTargetAmp;
+	setAmpIncrement((Bit8u)newAmpIncrement);
+}
+
+}
diff -urN dosbox-0.73/src/gui/tvf.cpp dosboxcvs/src/gui/tvf.cpp
--- dosbox-0.73/src/gui/tvf.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/tvf.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,256 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <math.h>
+
+#include "mt32emu.h"
+
+namespace MT32Emu {
+
+// FIXME: Need to confirm that this is correct. Sounds about right.
+const int TVF_TARGET_MULT = 0x800000;
+const int MAX_CURRENT = 0xFF * TVF_TARGET_MULT;
+
+// When entering nextPhase, targetPhase is immediately incremented, and the descriptions/names below represent
+// their use after the increment.
+enum {
+	// When this is the target phase, level[0] is targeted within time[0]
+	// Note that this phase is always set up in reset(), not nextPhase()
+	PHASE_ATTACK = 1,
+
+	// When this is the target phase, level[1] is targeted within time[1]
+	PHASE_2 = 2,
+
+	// When this is the target phase, level[2] is targeted within time[2]
+	PHASE_3 = 3,
+
+	// When this is the target phase, level[3] is targeted within time[3]
+	PHASE_4 = 4,
+
+	// When this is the target phase, immediately goes to PHASE_RELEASE unless the poly is set to sustain.
+	// Otherwise level[3] is continued with increment 0 - no phase change will occur until some external influence (like pedal release)
+	PHASE_SUSTAIN = 5,
+
+	// 0 is targeted within time[4] (the time calculation is quite different from the other phases)
+	PHASE_RELEASE = 6,
+
+	// 0 is targeted with increment 0 (thus theoretically staying that way forever)
+	PHASE_DONE = 7
+};
+
+static int calcBaseCutoff(const Tables *tables, const TimbreParam::PartialParam *partialParam, Bit32u basePitch, unsigned int key) {
+	// This table matches the values used by a real LAPC-I.
+	static const Bit8s biasLevelToBiasMult[] = {85, 42, 21, 16, 10, 5, 2, 0, -2, -5, -10, -16, -21, -74, -85};
+	// These values represent unique options with no consistent pattern, so we have to use something like a table in any case.
+	// The table entries, when divided by 21, match approximately what the manual claims:
+	// -1, -1/2, -1/4, 0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1, 5/4, 3/2, 2, s1, s2
+	// Note that the entry for 1/8 is rounded to 2 (from 1/8 * 21 = 2.625), which seems strangely inaccurate compared to the others.
+	static const Bit8s keyfollowMult21[] = {-21, -10, -5, 0, 2, 5, 8, 10, 13, 16, 18, 21, 26, 32, 42, 21, 21};
+	int baseCutoff = keyfollowMult21[partialParam->tvf.keyfollow] - keyfollowMult21[partialParam->wg.pitchKeyfollow]; // baseCutoff range here: -63 to 63
+	baseCutoff *= (int)key - 60;
+	int biasPoint = partialParam->tvf.biasPoint;
+	if ((biasPoint & 0x40) == 0) {
+		int bias = biasPoint + 33 - key;
+		if (bias > 0) {
+			bias = -bias;
+			baseCutoff += bias * biasLevelToBiasMult[partialParam->tvf.biasLevel];
+		}
+	} else {
+		int bias = biasPoint - 31 - key;
+		if (bias < 0) {
+			baseCutoff += bias * biasLevelToBiasMult[partialParam->tvf.biasLevel];
+		}
+	}
+	baseCutoff += ((partialParam->tvf.cutoff << 4) - 800);
+	if (baseCutoff >= 0) {
+		// FIXME: Potentially bad if initialCutoff ends up below -2056?
+		int pitchDeltaThing = (basePitch >> 4) + baseCutoff - 3584;
+		if (pitchDeltaThing > 0) {
+			baseCutoff -= pitchDeltaThing;
+		}
+	} else if (baseCutoff < -2048) {
+		baseCutoff = -2048;
+	}
+	baseCutoff += 2056;
+	baseCutoff >>= 4; // PORTABILITY NOTE: Hmm... Depends whether it could've been below -2056, but maybe arithmetic shift assumed?
+	if (baseCutoff > 255) {
+		baseCutoff = 255;
+	}
+	return (Bit8u)baseCutoff;
+}
+
+TVF::TVF(const Partial *partial) :
+	partial(partial) {
+}
+
+void TVF::setIncrement(Bit8u increment) {
+	// FIXME: This is just a guess - absolutely no idea whether this is the same as for TVA::setAmpIncrement(), which it copies.
+	this->increment = increment;
+
+	bigIncrement = increment & 0x7F;
+	// FIXME: We could use a table for this in future
+	bigIncrement = (unsigned int)((powf(10.0f, (float)((bigIncrement - 1.0f) / 26.0f))) * 256.0f);
+}
+
+void TVF::reset(const TimbreParam::PartialParam *partialParam, unsigned int basePitch) {
+	this->partialParam = partialParam;
+
+	unsigned int key = partial->getPoly()->getKey();
+	unsigned int velocity = partial->getPoly()->getVelocity();
+
+	Tables *tables = &partial->getSynth()->tables;
+
+	baseCutoff = calcBaseCutoff(tables, partialParam, basePitch, key);
+
+	int newLevelMult = velocity * partialParam->tvf.envVeloSensitivity;
+	newLevelMult >>= 6;
+	newLevelMult += 109 - partialParam->tvf.envVeloSensitivity;
+	newLevelMult += ((signed)key - 60) >> (4 - partialParam->tvf.envDepthKeyfollow);
+	if (newLevelMult < 0) {
+		newLevelMult = 0;
+	}
+	newLevelMult *= partialParam->tvf.envDepth;
+	newLevelMult >>= 6;
+	if (newLevelMult > 255) {
+		newLevelMult = 255;
+	}
+	levelMult = newLevelMult;
+
+	if (partialParam->tvf.envTimeKeyfollow != 0) {
+		keyTimeSubtraction = ((signed)key - 60) >> (5 - partialParam->tvf.envTimeKeyfollow);
+	} else {
+		keyTimeSubtraction = 0;
+	}
+
+	int newTarget = (newLevelMult * partialParam->tvf.envLevel[0]) >> 8;
+	int envTimeSetting = partialParam->tvf.envTime[0] - keyTimeSubtraction;
+	int newIncrement;
+	if (envTimeSetting <= 0) {
+		newIncrement = (0x80 | 127);
+	} else {
+		newIncrement = tables->envLogarithmicTime[newTarget] - envTimeSetting;
+		if (newIncrement <= 0) {
+			newIncrement = 1;
+		}
+	}
+	increment = newIncrement;
+	target = newTarget;
+	targetPhase = PHASE_2 - 1;
+}
+
+unsigned int TVF::nextFilt() {
+	// FIXME: This whole method is basically a copy of TVA::nextAmp(), which may be completely inappropriate for TVF.
+	Bit32u bigTarget = target * TVF_TARGET_MULT;
+	if (increment == 0) {
+		current = bigTarget;
+	} else {
+		if ((increment & 0x80) != 0) {
+			// Lowering
+			if (bigIncrement > current) {
+				current = bigTarget;
+				nextPhase();
+			} else {
+				current -= bigIncrement;
+				if (current <= bigTarget) {
+					current = bigTarget;
+					nextPhase();
+				}
+			}
+		} else {
+			// Raising
+			if (MAX_CURRENT - current < bigIncrement) {
+				current = bigTarget;
+				nextPhase();
+			} else {
+				current += bigIncrement;
+				if(current >= bigTarget) {
+					current = bigTarget;
+					nextPhase();
+				}
+			}
+		}
+	}
+	// FIXME: Absolutely nfi whether this is right
+	int cutoff = baseCutoff * current / TVF_TARGET_MULT;
+	cutoff >>= 8;
+	return cutoff;
+}
+
+void TVF::startDecay() {
+	if (targetPhase >= PHASE_RELEASE)
+		return;
+	targetPhase = PHASE_DONE - 1;
+	if (partialParam->tvf.envTime[4] == 0)
+		setIncrement(1);
+	else
+		setIncrement(-partialParam->tvf.envTime[4]);
+	target = 0;
+}
+
+void TVF::nextPhase() {
+	Tables *tables = &partial->getSynth()->tables;
+	targetPhase++;
+
+	switch (targetPhase) {
+	case PHASE_DONE:
+		increment = 0;
+		target = 0;
+		return;
+	case PHASE_SUSTAIN:
+	case PHASE_RELEASE:
+		// FIXME: Afaict targetPhase should never be PHASE_RELEASE here. And if it were, this is an odd way to handle it.
+		if (!partial->getPoly()->canSustain()) {
+			startDecay(); // FIXME: This should actually start decay even if phase is already 6. Does that matter?
+			return;
+		}
+		increment = 0;
+		target = (levelMult * partialParam->tvf.envLevel[3]) >> 8;
+		return;
+	}
+
+	int envPointIndex = targetPhase - 1;
+	// FIXME: Should the result perhaps be cast to Bit8s?
+	int envTimeSetting = (int)partialParam->tvf.envTime[envPointIndex] - keyTimeSubtraction;
+
+	int newTarget = (levelMult * partialParam->tvf.envLevel[envPointIndex]) >> 8;
+	int newIncrement;
+	if (envTimeSetting > 0) {
+		int targetDelta = newTarget - target;
+		if (targetDelta == 0 ) {
+			if (newTarget == 0 ) {
+				targetDelta = 1;
+				newTarget = 1;
+			} else {
+				targetDelta = -1;
+				newTarget--;
+			}
+		}
+		// FIXME: Can't newIncrement be negative or over 127 here? Casting to Bit8u to emulate...
+		newIncrement = (Bit8u)(tables->envLogarithmicTime[targetDelta < 0 ? -targetDelta : targetDelta] - envTimeSetting);
+		if (newIncrement <= 0) {
+			newIncrement = 1;
+		}
+		if (targetDelta < 0) {
+			newIncrement |= 0x80;
+		}
+	} else {
+		newIncrement = newTarget >= target ? (0x80 | 127) : 127;
+	}
+	increment = newIncrement;
+	target = newTarget;
+}
+
+}
diff -urN dosbox-0.73/src/gui/tvp.cpp dosboxcvs/src/gui/tvp.cpp
--- dosbox-0.73/src/gui/tvp.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/gui/tvp.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -0,0 +1,317 @@
+/* Copyright (C) 2003-2009 Dean Beeler, Jerome Fisher
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU Lesser General Public License as published by
+ *  the Free Software Foundation, either version 2.1 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <math.h>
+#include <stdlib.h>
+
+#include "mt32emu.h"
+
+namespace MT32Emu {
+
+// FIXME: Add Explanation
+static Bit16u lowerDurationToDivisor[] = {34078, 37162, 40526, 44194, 48194, 52556, 57312, 62499};
+
+// These values represent unique options with no consistent pattern, so we have to use something like a table in any case.
+// The table matches exactly what the manual claims (when divided by 8192):
+// -1, -1/2, -1/4, 0, 1/8, 1/4, 3/8, 1/2, 5/8, 3/4, 7/8, 1, 5/4, 3/2, 2, s1, s2
+// ...except for the last two entries, which are supposed to be "1 cent above 1" and "2 cents above 1", respectively. They can only be roughly approximated with this integer math.
+static Bit16s pitchKeyfollowMult[] = {-8192, -4096, -2048, 0, 1024, 2048, 3072, 4096, 5120, 6144, 7168, 8192, 10240, 12288, 16384, 8198, 8226};
+
+// Note: Keys < 60 use keyToPitchTable[60 - key], keys >= 60 use keyToPitchTable[key - 60].
+// FIXME: This table could really be shorter, since we never use e.g. key 127.
+static Bit16u keyToPitchTable[] = {
+		    0,   341,   683,  1024,  1365,  1707,  2048,  2389,
+		 2731,  3072,  3413,  3755,  4096,  4437,  4779,  5120,
+		 5461,  5803,  6144,  6485,  6827,  7168,  7509,  7851,
+		 8192,  8533,  8875,  9216,  9557,  9899, 10240, 10581,
+		10923, 11264, 11605, 11947, 12288, 12629, 12971, 13312,
+		13653, 13995, 14336, 14677, 15019, 15360, 15701, 16043,
+		16384, 16725, 17067, 17408, 17749, 18091, 18432, 18773,
+		19115, 19456, 19797, 20139, 20480, 20821, 21163, 21504,
+		21845, 22187, 22528, 22869
+};
+
+TVP::TVP(const Partial *partial) :
+	partial(partial), system(&partial->getSynth()->mt32ram.system) {
+	unsigned int sampleRate = partial->getSynth()->myProp.sampleRate;
+	// We want to do processing 4000 times per second. FIXME: This is pretty arbitrary.
+	this->maxCounter = sampleRate / 4000;
+	// The timer runs at 500kHz. We only need to bother updating it every maxCounter samples, before we do processing.
+	// This is how much to increment it by every maxCounter samples.
+	this->processTimerIncrement = 500000 * maxCounter / sampleRate;
+}
+
+static Bit16s keyToPitch(unsigned int key) {
+	// We're using a table to do: return round_to_nearest_or_even((key - 60) * (4096.0 / 12.0))
+	// Banker's rounding is just slightly annoying to do in C++
+	int k = (int)key;
+	Bit16s pitch = keyToPitchTable[abs(k - 60)];
+	return key < 60 ? -pitch : pitch;
+}
+
+static inline Bit32s coarseToPitch(Bit8u coarse) {
+	return (coarse - 36) * 4096 / 12; // One semitone per coarse offset
+}
+
+static inline Bit32s fineToPitch(Bit8u fine) {
+	return (fine - 50) * 4096 / 1200; // One cent per fine offset
+}
+
+static Bit32u calcBasePitch(const Partial *partial, const TimbreParam::PartialParam *partialParam, const MemParams::PatchTemp *patchTemp, unsigned int key) {
+	Bit32s basePitch = keyToPitch(key);
+	basePitch = (basePitch * pitchKeyfollowMult[partialParam->wg.pitchKeyfollow]) >> 13; // PORTABILITY NOTE: Assumes arithmetic shift
+	basePitch += coarseToPitch(partialParam->wg.pitchCoarse);
+	basePitch += fineToPitch(partialParam->wg.pitchFine);
+	// NOTE:Mok: This is done on MT-32, but not LAPC-I:
+	//pitch += coarseToPitch(patchTemp->patch.keyShift + 12);
+	basePitch += fineToPitch(patchTemp->patch.fineTune);
+
+	const ControlROMPCMStruct *controlROMPCMStruct = partial->getControlROMPCMStruct();
+	if (controlROMPCMStruct != NULL) {
+		basePitch += (Bit32s)((((Bit32s)controlROMPCMStruct->pitchMSB) << 8) | (Bit32s)controlROMPCMStruct->pitchLSB);
+	} else {
+		if ((partialParam->wg.waveform & 1) == 0) {
+			basePitch += 37133; // This puts Middle C at around 261.64Hz (assuming no other modifications, masterTune of 64, etc.)
+		} else {
+			// Sawtooth waves are effectively double the frequency of square waves.
+			// Thus we add 4096 less than for square waves here, which results in halving the frequency.
+			basePitch += 33037;
+		}
+	}
+	if (basePitch < 0) {
+		basePitch = 0;
+	}
+	if (basePitch > 59392) {
+		basePitch = 59392;
+	}
+	return (Bit32u)basePitch;
+}
+
+static Bit32u calcVeloMult(Bit8u veloSensitivity, unsigned int velocity) {
+	if (veloSensitivity == 0 || veloSensitivity > 3) {
+		// Note that on CM-32L/LAPC-I veloSensitivity is never > 3, since it's clipped to 3 by the max tables.
+		return 21845; // aka floor(4096 / 12 * 64), aka ~64 semitones
+	}
+	// When velocity is 127, the multiplier is 21845, aka ~64 semitones (regardless of veloSensitivity).
+	// The lower the velocity, the lower the multiplier. The veloSensitivity determines the amount decreased per velocity value.
+	// The minimum multiplier (with velocity 0, veloSensitivity 3) is 170 (~half a semitone).
+	Bit32u veloMult = 32768;
+	veloMult -= (127 - velocity) << (5 + veloSensitivity);
+	veloMult *= 21845;
+	veloMult >>= 15;
+	return veloMult;
+}
+
+static Bit32s calcTargetPitchOffsetWithoutLFO(const TimbreParam::PartialParam *partialParam, int levelIndex, unsigned int velocity)
+{
+	int veloMult = calcVeloMult(partialParam->pitchEnv.veloSensitivity, velocity);
+	int targetPitchOffsetWithoutLFO = partialParam->pitchEnv.level[levelIndex] - 50;
+	targetPitchOffsetWithoutLFO = (Bit32s)(targetPitchOffsetWithoutLFO * veloMult) >> (16 - partialParam->pitchEnv.depth); // PORTABILITY NOTE: Assumes arithmetic shift
+	return targetPitchOffsetWithoutLFO;
+}
+
+void TVP::reset(const Part *part, const PatchCache *patchCache) {
+	this->part = part;
+	this->partialParam = patchCache->partialParam;
+	this->patchTemp = part->getPatchTemp();
+
+	unsigned int key = partial->getPoly()->getKey();
+	unsigned int velocity = partial->getPoly()->getVelocity();
+
+	// FIXME: We're using a per-TVP timer instead of a system-wide one for convenience.
+	timeElapsed = 0;
+
+	basePitch = calcBasePitch(partial, partialParam, patchTemp, key);
+	currentPitchOffset = calcTargetPitchOffsetWithoutLFO(partialParam, 0, velocity);
+	targetPitchOffsetWithoutLFO = currentPitchOffset;
+	phase = 0;
+
+	if (partialParam->pitchEnv.timeKeyfollow) {
+		timeKeyfollowSubtraction = (key - 60) >> (5 - partialParam->pitchEnv.timeKeyfollow); // PORTABILITY NOTE: Assumes arithmetic shift
+	}
+	else
+		timeKeyfollowSubtraction = 0;
+	lfoPitchOffset = 0;
+	counter = 0;
+	pitch = basePitch;
+
+	// These don't really need to be initialised, but it aids debugging.
+	pitchOffsetChangePerBigTick = 0;
+	targetPitchOffsetReachedBigTick = 0;
+	shifts = 0;
+}
+
+Bit32u TVP::getBasePitch() const {
+	return basePitch;
+}
+
+void TVP::updatePitch() {
+	Bit32s newPitch = basePitch + currentPitchOffset;
+	if (!partial->isPCM() || (partial->getControlROMPCMStruct()->len & 0x01) == 0) { // FIXME: Use !partial->pcmWaveEntry->unaffectedByMasterTune instead
+		// FIXME: masterTune recalculation doesn't really happen here, and there are various bugs not yet emulated
+		// 171 is ~half a semitone.
+		newPitch += ((system->masterTune - 64) * 171) >> 6; // PORTABILITY NOTE: Assumes arithmetic shift.
+	}
+	if ((partialParam->wg.pitchBenderEnabled & 1) != 0) {
+		newPitch += part->getPitchBend();
+	}
+	if (newPitch < 0)
+		newPitch = 0;
+	if (newPitch > 59392)
+		newPitch = 59392;
+	pitch = (Bit16u)newPitch;
+
+	// FIXME: We're doing this here because that's what the CM-32L does - we should probably move this somewhere more appropriate in future.
+	partial->tva->recalcSustain();
+}
+
+void TVP::targetPitchOffsetReached() {
+	currentPitchOffset = targetPitchOffsetWithoutLFO + lfoPitchOffset;
+
+	switch (phase) {
+	case 3:
+	case 4:
+	{
+		int newLFOPitchOffset = (part->getModulation() * partialParam->pitchLFO.modSensitivity) >> 7;
+		newLFOPitchOffset = (newLFOPitchOffset + partialParam->pitchLFO.depth) << 1;
+		if (pitchOffsetChangePerBigTick > 0) {
+			// Go in the opposite direction to last time
+			newLFOPitchOffset = -newLFOPitchOffset;
+		}
+		lfoPitchOffset = newLFOPitchOffset;
+		int targetPitchOffset = targetPitchOffsetWithoutLFO + lfoPitchOffset;
+		setupPitchChange(targetPitchOffset, 101 - partialParam->pitchLFO.rate);
+		updatePitch();
+		break;
+	}
+	case 6:
+		updatePitch();
+		break;
+	default:
+		nextPhase();
+	}
+}
+
+void TVP::nextPhase() {
+	phase++;
+	int envIndex = phase == 6 ? 4 : phase;
+
+	targetPitchOffsetWithoutLFO = calcTargetPitchOffsetWithoutLFO(partialParam, envIndex, partial->getPoly()->getVelocity()); // pitch we'll reach at the end
+
+	int changeDuration = partialParam->pitchEnv.time[envIndex - 1];
+	changeDuration -= timeKeyfollowSubtraction;
+	if (changeDuration > 0) {
+		setupPitchChange(targetPitchOffsetWithoutLFO, changeDuration); // changeDuration between 0 and 112 now
+		updatePitch();
+	} else {
+		targetPitchOffsetReached();
+	}
+}
+
+// Shifts val to the left until bit 31 is 1 and returns the number of shifts
+static Bit8u normalise(Bit32u &val) {
+	Bit8u leftShifts;
+	for(leftShifts = 0; leftShifts < 31; leftShifts++) {
+		if((val & 0x80000000) != 0) {
+			break;
+		}
+		val = val << 1;
+	}
+	return leftShifts;
+}
+
+void TVP::setupPitchChange(int targetPitchOffset, Bit8u changeDuration) {
+	Bit32s pitchOffsetDelta = targetPitchOffset - currentPitchOffset;
+	if (pitchOffsetDelta > 32767 || pitchOffsetDelta < -32768) {
+		// FIXME: Weird, will end up being set to 32767 when it should be < -32768. Apparently a bug in the original, or is it never < -32768?
+		pitchOffsetDelta = 32767;
+	}
+	// We want to maximise the number of bits of the Bit16s "pitchOffsetChangePerBigTick" we use in order to get the best possible precision later
+	Bit32u absPitchOffsetDelta = abs((int)pitchOffsetDelta) << 16;
+	Bit8u normalisationShifts = normalise(absPitchOffsetDelta); // FIXME: Double-check: normalisationShifts is usually between 0 and 15 here, unless the delta is 0, in which case it's 31
+	absPitchOffsetDelta = absPitchOffsetDelta >> 1; // Make room for the sign bit
+
+	changeDuration--; // changeDuration's now between 0 and 111
+	unsigned int upperDuration = changeDuration >> 3; // upperDuration's now between 0 and 13
+	shifts = normalisationShifts + upperDuration + 2;
+	Bit16u divisor = lowerDurationToDivisor[changeDuration & 7];
+	Bit16s newPitchOffsetChangePerBigTick = ((absPitchOffsetDelta & 0xFFFF0000) / divisor) >> 1; // Result now fits within 15 bits. FIXME: Check nothing's getting sign-extended incorrectly
+	if (pitchOffsetDelta < 0) {
+		newPitchOffsetChangePerBigTick = -newPitchOffsetChangePerBigTick;
+	}
+	pitchOffsetChangePerBigTick = newPitchOffsetChangePerBigTick;
+
+	int currentBigTick = timeElapsed >> 8;
+	int durationInBigTicks = divisor >> (12 - upperDuration);
+	if (durationInBigTicks > 32767) {
+		durationInBigTicks = 32767;
+	}
+	targetPitchOffsetReachedBigTick = currentBigTick + durationInBigTicks;
+}
+
+void TVP::startDecay() {
+	phase = 5;
+	lfoPitchOffset = 0;
+	targetPitchOffsetReachedBigTick = timeElapsed >> 8; // FIXME: Afaict there's no good reason for this - check
+}
+
+Bit16u TVP::nextPitch() {
+	// FIXME: Write explanation of counter and time increment
+	if(counter == 0)
+	{
+		timeElapsed += processTimerIncrement;
+		timeElapsed = timeElapsed & 0x00FFFFFF;
+		process();
+	}
+	counter = (counter + 1) % maxCounter;
+	return pitch;
+}
+
+void TVP::process() {
+
+	if (phase == 0) {
+		targetPitchOffsetReached();
+		return;
+	}
+	if (phase == 5) {
+		nextPhase();
+		return;
+	}
+	if (phase > 7) {
+		updatePitch();
+		return;
+	}
+
+	int negativeBigTicksRemaining = (timeElapsed >> 8) - targetPitchOffsetReachedBigTick;
+	if (negativeBigTicksRemaining >= 0) {
+		// We've reached the time for a phase change
+		targetPitchOffsetReached();
+		return;
+	}
+	// FIXME: Write explanation for this stuff
+	int rightShifts = shifts;
+	if (rightShifts > 13) {
+		rightShifts -= 13;
+		negativeBigTicksRemaining = negativeBigTicksRemaining >> rightShifts; // PORTABILITY NOTE: Assumes arithmetic shift
+		rightShifts = 13;
+	}
+	int newResult = ((Bit32s)(negativeBigTicksRemaining * pitchOffsetChangePerBigTick)) >> rightShifts; // PORTABILITY NOTE: Assumes arithmetic shift
+	newResult += targetPitchOffsetWithoutLFO + lfoPitchOffset;
+	currentPitchOffset = newResult;
+	updatePitch();
+}
+
+}
diff -urN dosbox-0.73/src/hardware/cmos.cpp dosboxcvs/src/hardware/cmos.cpp
--- dosbox-0.73/src/hardware/cmos.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/cmos.cpp	2009-06-16 21:19:18.000000000 +0300
@@ -16,9 +16,10 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: cmos.cpp,v 1.28 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: cmos.cpp,v 1.29 2009/06/16 18:19:18 qbix79 Exp $ */
 
 #include <time.h>
+#include <math.h>
 
 #include "dosbox.h"
 #include "timer.h"
@@ -27,6 +28,7 @@
 #include "mem.h"
 #include "bios_disk.h"
 #include "setup.h"
+#include "cross.h" //fmod on certain platforms
 
 static struct {
 	Bit8u regs[0x40];
@@ -64,8 +66,9 @@
 	cmos.timer.delay=(1000.0f/(32768.0f / (1 << (cmos.timer.div - 1))));
 	if (!cmos.timer.div || !cmos.timer.enabled) return;
 	LOG(LOG_PIT,LOG_NORMAL)("RTC Timer at %.2f hz",1000.0/cmos.timer.delay);
-	PIC_AddEvent(cmos_timerevent,cmos.timer.delay);
-//	PIC_AddEvent(cmos_timerevent,(double)cmos.timer.delay-fmod(PIC_FullIndex(),(double)cmos.timer.delay)); //Should be more like a real pc. Check
+//	PIC_AddEvent(cmos_timerevent,cmos.timer.delay);
+	/* A rtc is always running */
+	PIC_AddEvent(cmos_timerevent,(double)cmos.timer.delay-fmod(PIC_FullIndex(),(double)cmos.timer.delay)); //Should be more like a real pc. Check
 //	status reg A reading with this (and with other delays actually)
 }
 
diff -urN dosbox-0.73/src/hardware/.cvsignore dosboxcvs/src/hardware/.cvsignore
--- dosbox-0.73/src/hardware/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/hardware/dbopl.cpp dosboxcvs/src/hardware/dbopl.cpp
--- dosbox-0.73/src/hardware/dbopl.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/hardware/dbopl.cpp	2009-06-10 22:54:51.000000000 +0300
@@ -32,6 +32,8 @@
 	//DUNNO Keyon in 4op, switch to 2op without keyoff.
 */
 
+/* $Id: dbopl.cpp,v 1.10 2009/06/10 19:54:51 harekiet Exp $ */
+
 
 #include <math.h>
 #include <stdlib.h>
@@ -472,7 +474,7 @@
 	}
 }
 
-void Operator::Write40( const Chip* chip, Bit8u val ) {
+void Operator::Write40( const Chip* /*chip*/, Bit8u val ) {
 	if (!(reg40 ^ val )) 
 		return;
 	reg40 = val;
@@ -803,46 +805,33 @@
 	}
 	Bit32s sample = Op(1)->GetSample( mod ); 
 
-	Operator* op2 = ( this + 1 )->Op(0);
-	Operator* op4 = ( this + 2 )->Op(0);
 
 	//Precalculate stuff used by other outputs
-	Bit32u noiseBit = (chip->ForwardNoise() & 0x1) << 1;
-	Bit32u c2 = op2->ForwardWave();
-	//(bit 7 ^ bit 2) | bit 3 -> combined in bit 1
-	Bit32u phaseBit = ( (c2 >> 6) ^ ( c2 >> 1 ) ) | ( c2 >> 2 );
-	Bit32u c4 = op4->ForwardWave();
-	//bit 5 ^ bit 3 to bit 1
-	Bit32u gateBit = ( c4 >> 4 ) ^ ( c4 >> 3 );
-	phaseBit = (phaseBit | gateBit) & 0x2;
+	Bit32u noiseBit = chip->ForwardNoise() & 0x1;
+	Bit32u c2 = Op(2)->ForwardWave();
+	Bit32u c5 = Op(5)->ForwardWave();
+	Bit32u phaseBit = (((c2 & 0x88) ^ ((c2<<5) & 0x80)) | ((c5 ^ (c5<<2)) & 0x20)) ? 0x02 : 0x00;
 
 	//Hi-Hat
-	Bit32u hhVol = op2->ForwardVolume();
+	Bit32u hhVol = Op(2)->ForwardVolume();
 	if ( !ENV_SILENT( hhVol ) ) {
-		/* when phase & 0x200 is set and noise=1 then phase = 0x200|0xd0 */
-		/* when phase & 0x200 is set and noise=0 then phase = 0x200|(0xd0>>2), ie no change */
-		Bit32u hhIndex = ( phaseBit << 8 ) | ( 0xd0 >> ( phaseBit ^ noiseBit ) ); 
-		sample += op2->GetWave( hhIndex, hhVol );
+		Bit32u hhIndex = (phaseBit<<8) | (0x34 << ( phaseBit ^ (noiseBit << 1 )));
+		sample += Op(2)->GetWave( hhIndex, hhVol );
 	}
 	//Snare Drum
-	Operator* op3 = ( this + 1 )->Op(1);
-	Bit32u sdVol = op3->ForwardVolume();
+	Bit32u sdVol = Op(3)->ForwardVolume();
 	if ( !ENV_SILENT( sdVol ) ) {
-		Bit32u sdBits = 0x100 + (c2 & 0x100);
-		Bit32u sdIndex = sdBits ^ ( noiseBit << 7 );
-		sample += op3->GetWave( sdIndex, sdVol );
+		Bit32u sdIndex = ( 0x100 + (c2 & 0x100) ) ^ ( noiseBit << 8 );
+		sample += Op(3)->GetWave( sdIndex, sdVol );
 	}
 	//Tom-tom
-	Bit32u ttVol = op4->ForwardVolume();
-	if ( !ENV_SILENT( ttVol ) ) {
-		sample += op4->GetWave( c4, ttVol );
-	}
+	sample += Op(4)->GetSample( 0 );
+
 	//Top-Cymbal
-	Operator* op5 = ( this + 2 )->Op(1);
-	Bit32u tcVol = op5->ForwardVolume();
+	Bit32u tcVol = Op(5)->ForwardVolume();
 	if ( !ENV_SILENT( tcVol ) ) {
 		Bit32u tcIndex = (1 + phaseBit) << 8;
-		sample += op5->GetWave( tcIndex, tcVol );
+		sample += Op(5)->GetWave( tcIndex, tcVol );
 	}
 	sample <<= 1;
 	if ( opl3Mode ) {
@@ -1261,7 +1250,7 @@
 		Bit32s original = (Bit32u)( (AttackSamplesTable[ index ] << shift) / scale);
 		 
 		Bit32s guessAdd = (Bit32u)( scale * (EnvelopeIncreaseTable[ index ] << ( RATE_SH - shift - 3 )));
-		Bit32s bestAdd;
+		Bit32s bestAdd = guessAdd;
 		Bit32u bestDiff = 1 << 30;
 		for( Bit32u passes = 0; passes < 16; passes ++ ) {
 			Bit32s volume = ENV_MAX;
@@ -1368,7 +1357,7 @@
 	for ( int i = 0; i < 384; i++ ) {
 		int s = i * 8;
 		//TODO maybe keep some of the precision errors of the original table?
-		double val = ( 0.5 + ( pow(2, -1 + ( 255 - s) * ( 1.0 /256 ) )) * ( 1 << MUL_SH ));
+		double val = ( 0.5 + ( pow(2.0, -1.0 + ( 255 - s) * ( 1.0 /256 ) )) * ( 1 << MUL_SH ));
 		MulTable[i] = (Bit16u)(val);
 	}
 
@@ -1379,7 +1368,7 @@
 	}
 	//Exponential wave
 	for ( int i = 0; i < 256; i++ ) {
-		WaveTable[ 0x700 + i ] = (Bit16s)( 0.5 + ( pow(2, -1 + ( 255 - i * 8) * ( 1.0 /256 ) ) ) * 4085 );
+		WaveTable[ 0x700 + i ] = (Bit16s)( 0.5 + ( pow(2.0, -1.0 + ( 255 - i * 8) * ( 1.0 /256 ) ) ) * 4085 );
 		WaveTable[ 0x6ff - i ] = -WaveTable[ 0x700 + i ];
 	}
 #endif
diff -urN dosbox-0.73/src/hardware/disney.cpp dosboxcvs/src/hardware/disney.cpp
--- dosbox-0.73/src/hardware/disney.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/hardware/disney.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -24,6 +24,8 @@
 #include "mixer.h"
 #include "pic.h"
 #include "setup.h"
+#include "bios.h"
+#include "mem.h"
 
 #define DISNEY_BASE 0x0378
 
@@ -370,6 +372,8 @@
 	DISNEY(Section* configuration):Module_base(configuration) {
 		Section_prop * section=static_cast<Section_prop *>(configuration);
 		if(!section->Get_bool("disney")) return;
+		Bit16u baseaddr[3]={0x378,mem_readw(BIOS_ADDRESS_LPT2),mem_readw(BIOS_ADDRESS_LPT3)};
+		BIOS_SetLPTPorts(baseaddr);
 	
 		WriteHandler.Install(DISNEY_BASE,disney_write,IO_MB,3);
 		ReadHandler.Install(DISNEY_BASE,disney_read,IO_MB,3);
diff -urN dosbox-0.73/src/hardware/hardopl.cpp dosboxcvs/src/hardware/hardopl.cpp
--- dosbox-0.73/src/hardware/hardopl.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/hardopl.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,86 @@
+#include "config.h"
+#include "../libs/porttalk/porttalk.h"
+#include "inout.h"
+#include "logging.h"
+
+#if defined (WIN32) || defined (LINUX)
+
+static Bit16s hardopldiff;
+
+static void write_hwio(Bitu port,Bitu val,Bitu /*iolen*/) {
+	if(port<0x388) port += hardopldiff;
+	//LOG_MSG("write port %x",port);
+	outportb(port, val);
+}
+
+static Bitu read_hwio(Bitu port,Bitu /*iolen*/) {
+	if(port<0x388) port += hardopldiff;
+	//LOG_MSG("read port %x",port);
+	Bitu retval = inportb(port);
+	return retval;
+}
+
+bool hwopl_dirty=false;
+
+static IO_ReadHandleObject* hwOPL_ReadHandler[10] ;
+static IO_WriteHandleObject* hwOPL_WriteHandler[10];
+
+const Bit16u oplports[]={
+		0x0,0x1,0x2,0x3,0x8,0x9,
+		0x388,0x389,0x38A,0x38B};
+
+void HARDOPL_Init(Bitu hardwareaddr, Bitu blasteraddr)
+{
+	//LOG_MSG("hoplinit");
+	if(!(hardwareaddr==0x210 || hardwareaddr==0x220 || hardwareaddr==0x230 ||
+		 hardwareaddr==0x240 || hardwareaddr==0x250 || hardwareaddr==0x260 ||
+		 hardwareaddr==0x280)) {
+			LOG_MSG("OPL passthrough: Invalid hardware base address. Aborting.");
+			return;
+		 }
+	
+	if(!initPorttalk())
+	{
+#ifdef WIN32		
+		LOG_MSG("OPL passthrough: Porttalk not loaded. Aborting.");
+#endif
+#ifdef LINUX
+		LOG_MSG("OPL passthrough: permission denied. Aborting.");
+#endif
+		return;
+	}
+
+
+	hardopldiff=hardwareaddr-blasteraddr;
+	hwopl_dirty=true;
+
+	// map the port
+	LOG_MSG("Port mappings hardware -> DOSBox:");
+	for(int i = 0; i < 10; i++)
+	{
+		hwOPL_ReadHandler[i]=new IO_ReadHandleObject();
+		hwOPL_WriteHandler[i]=new IO_WriteHandleObject();
+		Bit16u port=oplports[i];
+		if(i<6) port+=blasteraddr; 
+		hwOPL_ReadHandler[i]->Install(port,read_hwio,IO_MB);
+		hwOPL_WriteHandler[i]->Install(port,write_hwio,IO_MB);
+
+		if(i<6) port+=hardopldiff;
+		LOG_MSG("%x -> %x",port,i<6?port-hardopldiff:port);
+		addIOPermission(port);
+	}
+	setPermissionList();
+}
+
+void HWOPL_Cleanup()
+{
+	if(hwopl_dirty) {
+		for(int i = 0; i < 10; i++) {
+			delete hwOPL_ReadHandler[i];
+			delete hwOPL_WriteHandler[i];
+		}
+		hwopl_dirty=false;
+	}
+
+}
+#endif // win32/linux
diff -urN dosbox-0.73/src/hardware/hardware.cpp dosboxcvs/src/hardware/hardware.cpp
--- dosbox-0.73/src/hardware/hardware.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/hardware/hardware.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -36,7 +36,7 @@
 #include "../libs/zmbv/zmbv.cpp"
 #endif
 
-static std::string capturedir;
+std::string capturedir;
 extern const char* RunningProgram;
 Bitu CaptureState;
 
diff -urN dosbox-0.73/src/hardware/Makefile.am dosboxcvs/src/hardware/Makefile.am
--- dosbox-0.73/src/hardware/Makefile.am	2009-04-25 15:45:49.000000000 +0300
+++ dosboxcvs/src/hardware/Makefile.am	2010-10-29 14:14:51.659333678 +0300
@@ -1,6 +1,6 @@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 
-SUBDIRS = serialport
+SUBDIRS = serialport parport
 
 EXTRA_DIST = opl.cpp opl.h fmopl.c fmopl.h ymf262.h ymf262.c adlib.h dbopl.h
 
@@ -10,6 +10,4 @@
                         memory.cpp mixer.cpp pcspeaker.cpp pic.cpp sblaster.cpp tandy_sound.cpp timer.cpp \
 			vga.cpp vga_attr.cpp vga_crtc.cpp vga_dac.cpp vga_draw.cpp vga_gfx.cpp vga_other.cpp \
 			vga_memory.cpp vga_misc.cpp vga_seq.cpp vga_xga.cpp vga_s3.cpp vga_tseng.cpp vga_paradise.cpp \
-			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp
-
-
+			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp ne2000.cpp hardopl.cpp
diff -urN dosbox-0.73/src/hardware/Makefile.in dosboxcvs/src/hardware/Makefile.in
--- dosbox-0.73/src/hardware/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/hardware/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -59,9 +63,10 @@
 	vga_seq.$(OBJEXT) vga_xga.$(OBJEXT) vga_s3.$(OBJEXT) \
 	vga_tseng.$(OBJEXT) vga_paradise.$(OBJEXT) cmos.$(OBJEXT) \
 	disney.$(OBJEXT) gus.$(OBJEXT) mpu401.$(OBJEXT) ipx.$(OBJEXT) \
-	ipxserver.$(OBJEXT) dbopl.$(OBJEXT)
+	ipxserver.$(OBJEXT) dbopl.$(OBJEXT) ne2000.$(OBJEXT) \
+	hardopl.$(OBJEXT) glide.$(OBJEXT)
 libhardware_a_OBJECTS = $(am_libhardware_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -73,13 +78,10 @@
 DIST_SOURCES = $(libhardware_a_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -87,6 +89,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -98,6 +102,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -108,8 +113,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -119,7 +125,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -137,12 +142,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -154,52 +162,41 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
-SUBDIRS = serialport
+SUBDIRS = serialport parport
 EXTRA_DIST = opl.cpp opl.h fmopl.c fmopl.h ymf262.h ymf262.c adlib.h dbopl.h
 noinst_LIBRARIES = libhardware.a
 libhardware_a_SOURCES = adlib.cpp dma.cpp gameblaster.cpp hardware.cpp iohandler.cpp joystick.cpp keyboard.cpp \
                         memory.cpp mixer.cpp pcspeaker.cpp pic.cpp sblaster.cpp tandy_sound.cpp timer.cpp \
 			vga.cpp vga_attr.cpp vga_crtc.cpp vga_dac.cpp vga_draw.cpp vga_gfx.cpp vga_other.cpp \
 			vga_memory.cpp vga_misc.cpp vga_seq.cpp vga_xga.cpp vga_s3.cpp vga_tseng.cpp vga_paradise.cpp \
-			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp
+			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp ne2000.cpp hardopl.cpp glide.cpp
 
 all: all-recursive
 
@@ -254,7 +251,9 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/disney.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dma.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gameblaster.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glide.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gus.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hardopl.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hardware.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iohandler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ipx.Po@am__quote@
@@ -264,6 +263,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/memory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mixer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mpu401.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ne2000.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pcspeaker.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sblaster.Po@am__quote@
@@ -285,18 +285,19 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/vga_xga.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -329,7 +330,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -373,8 +375,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -399,8 +401,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -410,12 +412,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -429,21 +432,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -457,7 +461,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -465,8 +469,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -522,20 +524,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am:
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -555,24 +549,22 @@
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-generic \
-	clean-noinstLIBRARIES ctags ctags-recursive distclean \
-	distclean-compile distclean-generic distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-data install-data-am install-dvi install-dvi-am \
-	install-exec install-exec-am install-html install-html-am \
-	install-info install-info-am install-man install-pdf \
-	install-pdf-am install-ps install-ps-am install-strip \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-noinstLIBRARIES clean-recursive \
+	ctags ctags-recursive distclean distclean-compile \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am html html-am info info-am install install-am \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
 	installcheck installcheck-am installdirs installdirs-am \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
-	tags tags-recursive uninstall uninstall-am
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/hardware/mixer.cpp dosboxcvs/src/hardware/mixer.cpp
--- dosbox-0.73/src/hardware/mixer.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/hardware/mixer.cpp	2009-07-08 20:43:38.000000000 +0300
@@ -165,8 +165,11 @@
 	}
 }
 
+static SDL_mutex * mixer_mut;
+
 template<class Type,bool stereo,bool signeddata,bool nativeorder>
 inline void MixerChannel::AddSamples(Bitu len, const Type* data) {
+	SDL_LockMutex(mixer_mut);
 	Bits diff[2];
 	Bitu mixpos=mixer.pos+done;
 	freq_index&=MIXER_REMAIN;
@@ -180,7 +183,7 @@
 			if (stereo) last[1]+=diff[1];
 			pos=new_pos;
 thestart:
-			if (pos>=len) return;
+			if (pos>=len) goto theend;
 			if ( sizeof( Type) == 1) {
 				if (!signeddata) {
 					if (stereo) {
@@ -261,6 +264,8 @@
 		mixer.work[mixpos][1]+=sample*volmul[1];
 		mixpos++;done++;
 	}
+theend:
+	SDL_UnlockMutex(mixer_mut);
 }
 
 void MixerChannel::AddStretched(Bitu len,Bit16s * data) {
@@ -521,6 +526,7 @@
 }
 
 static void MIXER_Stop(Section* sec) {
+    SDL_DestroyMutex(mixer_mut);
 }
 
 class MIXER : public Program {
@@ -633,6 +639,7 @@
 	memset(mixer.work,0,sizeof(mixer.work));
 	mixer.mastervol[0]=1.0f;
 	mixer.mastervol[1]=1.0f;
+	mixer_mut = SDL_CreateMutex();
 
 	/* Start the Mixer using SDL Sound at 22 khz */
 	SDL_AudioSpec spec;
diff -urN dosbox-0.73/src/hardware/ne2000.cpp dosboxcvs/src/hardware/ne2000.cpp
--- dosbox-0.73/src/hardware/ne2000.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/ne2000.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,1660 @@
+#include "config.h"
+
+#ifdef C_NE2000
+
+
+#include "dosbox.h"
+#include <string.h>
+#include <stdio.h>
+#include "support.h"
+#include "inout.h"
+#include "setup.h"
+#include "callback.h"
+#include "timer.h"
+#include "pic.h"
+#include "cpu.h"
+
+/* Couldn't find a real spec for the NE2000 out there, hence this is adapted heavily from Bochs */
+
+
+/////////////////////////////////////////////////////////////////////////
+// $Id: ne2k.cc,v 1.56.2.1 2004/02/02 22:37:22 cbothamy Exp $
+/////////////////////////////////////////////////////////////////////////
+//
+//  Copyright (C) 2002  MandrakeSoft S.A.
+//
+//    MandrakeSoft S.A.
+//    43, rue d'Aboukir
+//    75002 Paris - France
+//    http://www.linux-mandrake.com/
+//    http://www.mandrakesoft.com/
+//
+//  This library is free software; you can redistribute it and/or
+//  modify it under the terms of the GNU Lesser General Public
+//  License as published by the Free Software Foundation; either
+//  version 2 of the License, or (at your option) any later version.
+//
+//  This library is distributed in the hope that it will be useful,
+//  but WITHOUT ANY WARRANTY; without even the implied warranty of
+//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+//  Lesser General Public License for more details.
+//
+//  You should have received a copy of the GNU Lesser General Public
+//  License along with this library; if not, write to the Free Software
+//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+// Peter Grehan (grehan@iprg.nokia.com) coded all of this
+// NE2000/ether stuff.
+
+#include "ne2000.h"
+
+#define HAVE_REMOTE
+
+#include "pcap.h"
+// Handle to WinPCap device
+pcap_t *adhandle = 0;
+static void NE2000_TX_Event(Bitu val);
+
+#ifdef WIN32
+// DLL loading
+#define pcap_sendpacket(A,B,C)			PacketSendPacket(A,B,C)
+#define pcap_close(A)					PacketClose(A)
+#define pcap_freealldevs(A)				PacketFreealldevs(A)
+#define pcap_open(A,B,C,D,E,F)			PacketOpen(A,B,C,D,E,F)
+#define pcap_next_ex(A,B,C)				PacketNextEx(A,B,C)
+#define pcap_findalldevs_ex(A,B,C,D)	PacketFindALlDevsEx(A,B,C,D)
+
+int (*PacketSendPacket)(pcap_t *, const u_char *, int) = 0;
+void (*PacketClose)(pcap_t *) = 0;
+void (*PacketFreealldevs)(pcap_if_t *) = 0;
+pcap_t* (*PacketOpen)(char const *,int,int,int,struct pcap_rmtauth *,char *) = 0;
+int (*PacketNextEx)(pcap_t *, struct pcap_pkthdr **, const u_char **) = 0;
+int (*PacketFindALlDevsEx)(char *, struct pcap_rmtauth *, pcap_if_t **, char *) = 0;
+
+#endif
+
+//Never completely fill the ne2k ring so that we never
+// hit the unclear completely full buffer condition.
+#define BX_NE2K_NEVER_FULL_RING (1)
+
+#define LOG_THIS theNE2kDevice->
+//#define BX_DEBUG 
+//#define BX_INFO 
+#define BX_NULL_TIMER_HANDLE NULL
+#define BX_PANIC 
+#define BX_ERROR 
+#define BX_RESET_HARDWARE 0
+#define BX_RESET_SOFTWARE 1
+
+bx_ne2k_c* theNE2kDevice = NULL;
+
+  
+bx_ne2k_c::bx_ne2k_c(void)
+{
+  s.tx_timer_index = BX_NULL_TIMER_HANDLE;
+}
+
+
+bx_ne2k_c::~bx_ne2k_c(void)
+{
+  // nothing for now
+}
+
+//
+// reset - restore state to power-up, cancelling all i/o
+//
+void
+bx_ne2k_c::reset(unsigned type)
+{
+  BX_DEBUG ("reset");
+  // Zero out registers and memory
+  memset( & BX_NE2K_THIS s.CR,  0, sizeof(BX_NE2K_THIS s.CR) );
+  memset( & BX_NE2K_THIS s.ISR, 0, sizeof(BX_NE2K_THIS s.ISR));
+  memset( & BX_NE2K_THIS s.IMR, 0, sizeof(BX_NE2K_THIS s.IMR));
+  memset( & BX_NE2K_THIS s.DCR, 0, sizeof(BX_NE2K_THIS s.DCR));
+  memset( & BX_NE2K_THIS s.TCR, 0, sizeof(BX_NE2K_THIS s.TCR));
+  memset( & BX_NE2K_THIS s.TSR, 0, sizeof(BX_NE2K_THIS s.TSR));
+  //memset( & BX_NE2K_THIS s.RCR, 0, sizeof(BX_NE2K_THIS s.RCR));
+  memset( & BX_NE2K_THIS s.RSR, 0, sizeof(BX_NE2K_THIS s.RSR));
+  BX_NE2K_THIS s.tx_timer_active = 0;
+  BX_NE2K_THIS s.local_dma  = 0;
+  BX_NE2K_THIS s.page_start = 0;
+  BX_NE2K_THIS s.page_stop  = 0;
+  BX_NE2K_THIS s.bound_ptr  = 0;
+  BX_NE2K_THIS s.tx_page_start = 0;
+  BX_NE2K_THIS s.num_coll   = 0;
+  BX_NE2K_THIS s.tx_bytes   = 0;
+  BX_NE2K_THIS s.fifo       = 0;
+  BX_NE2K_THIS s.remote_dma = 0;
+  BX_NE2K_THIS s.remote_start = 0;
+  BX_NE2K_THIS s.remote_bytes = 0;
+  BX_NE2K_THIS s.tallycnt_0 = 0;
+  BX_NE2K_THIS s.tallycnt_1 = 0;
+  BX_NE2K_THIS s.tallycnt_2 = 0;
+
+  //memset( & BX_NE2K_THIS s.physaddr, 0, sizeof(BX_NE2K_THIS s.physaddr));
+  //memset( & BX_NE2K_THIS s.mchash, 0, sizeof(BX_NE2K_THIS s.mchash));
+  BX_NE2K_THIS s.curr_page = 0;
+
+  BX_NE2K_THIS s.rempkt_ptr   = 0;
+  BX_NE2K_THIS s.localpkt_ptr = 0;
+  BX_NE2K_THIS s.address_cnt  = 0;
+
+  memset( & BX_NE2K_THIS s.mem, 0, sizeof(BX_NE2K_THIS s.mem));
+  
+  // Set power-up conditions
+  BX_NE2K_THIS s.CR.stop      = 1;
+    BX_NE2K_THIS s.CR.rdma_cmd  = 4;
+  BX_NE2K_THIS s.ISR.reset    = 1;
+  BX_NE2K_THIS s.DCR.longaddr = 1;
+  PIC_DeActivateIRQ(s.base_irq);
+  //DEV_pic_lower_irq(BX_NE2K_THIS s.base_irq);
+}
+
+//
+// read_cr/write_cr - utility routines for handling reads/writes to
+// the Command Register
+//
+Bit32u
+bx_ne2k_c::read_cr(void)
+{
+  Bit32u val = 
+         (((BX_NE2K_THIS s.CR.pgsel    & 0x03) << 6) |
+	  ((BX_NE2K_THIS s.CR.rdma_cmd & 0x07) << 3) |
+	  (BX_NE2K_THIS s.CR.tx_packet << 2) |
+	  (BX_NE2K_THIS s.CR.start     << 1) |
+	  (BX_NE2K_THIS s.CR.stop));
+  BX_DEBUG("read CR returns 0x%08x", val);
+  return val;
+}
+
+void
+bx_ne2k_c::write_cr(Bit32u value)
+{
+  BX_DEBUG ("wrote 0x%02x to CR", value);
+
+  // Validate remote-DMA
+  if ((value & 0x38) == 0x00) {
+    BX_DEBUG("CR write - invalid rDMA value 0");
+    value |= 0x20; /* dma_cmd == 4 is a safe default */
+	//value = 0x22; /* dma_cmd == 4 is a safe default */
+  }
+
+  // Check for s/w reset
+  if (value & 0x01) {
+    BX_NE2K_THIS s.ISR.reset = 1;
+    BX_NE2K_THIS s.CR.stop   = 1;
+  } else {
+    BX_NE2K_THIS s.CR.stop = 0;
+  }
+
+  BX_NE2K_THIS s.CR.rdma_cmd = (value & 0x38) >> 3;
+  
+  // If start command issued, the RST bit in the ISR
+  // must be cleared
+  if ((value & 0x02) && !BX_NE2K_THIS s.CR.start) {
+    BX_NE2K_THIS s.ISR.reset = 0;
+  }
+
+  BX_NE2K_THIS s.CR.start = ((value & 0x02) == 0x02);
+  BX_NE2K_THIS s.CR.pgsel = (value & 0xc0) >> 6;
+
+    // Check for send-packet command
+    if (BX_NE2K_THIS s.CR.rdma_cmd == 3) {
+	// Set up DMA read from receive ring
+		BX_NE2K_THIS s.remote_start = BX_NE2K_THIS s.remote_dma =
+			BX_NE2K_THIS s.bound_ptr * 256;
+		BX_NE2K_THIS s.remote_bytes = *((Bit16u*) &
+			BX_NE2K_THIS s.mem[BX_NE2K_THIS s.bound_ptr * 256 + 2 - BX_NE2K_MEMSTART]);
+		BX_INFO("Sending buffer #x%x length %d",
+			BX_NE2K_THIS s.remote_start,
+			BX_NE2K_THIS s.remote_bytes);
+    }
+
+  // Check for start-tx
+    if ((value & 0x04) && BX_NE2K_THIS s.TCR.loop_cntl) {
+		// loopback mode
+		if (BX_NE2K_THIS s.TCR.loop_cntl != 1) {
+			BX_INFO("Loop mode %d not supported.", BX_NE2K_THIS s.TCR.loop_cntl);
+		} else {
+			rx_frame (& BX_NE2K_THIS s.mem[BX_NE2K_THIS s.tx_page_start*256 -
+				BX_NE2K_MEMSTART],
+				BX_NE2K_THIS s.tx_bytes);
+
+			// do a TX interrupt
+			// Generate an interrupt if not masked and not one in progress
+			if (BX_NE2K_THIS s.IMR.tx_inte && !BX_NE2K_THIS s.ISR.pkt_tx) {
+				//LOG_MSG("tx complete interrupt");
+				PIC_ActivateIRQ(s.base_irq);
+			}
+			BX_NE2K_THIS s.ISR.pkt_tx = 1;
+		}
+    } else if (value & 0x04) {
+		// start-tx and no loopback
+		if (BX_NE2K_THIS s.CR.stop || !BX_NE2K_THIS s.CR.start)
+			BX_PANIC(("CR write - tx start, dev in reset"));
+	    
+		if (BX_NE2K_THIS s.tx_bytes == 0)
+			BX_PANIC(("CR write - tx start, tx bytes == 0"));
+
+#ifdef notdef    
+    // XXX debug stuff
+    printf("packet tx (%d bytes):\t", BX_NE2K_THIS s.tx_bytes);
+    for (int i = 0; i < BX_NE2K_THIS s.tx_bytes; i++) {
+      printf("%02x ", BX_NE2K_THIS s.mem[BX_NE2K_THIS s.tx_page_start*256 - 
+				BX_NE2K_MEMSTART + i]);
+      if (i && (((i+1) % 16) == 0)) 
+	printf("\t");
+    }
+    printf("");
+#endif    
+
+    // Send the packet to the system driver
+	/* TODO: Transmit packet */
+    //BX_NE2K_THIS ethdev->sendpkt(& BX_NE2K_THIS s.mem[BX_NE2K_THIS s.tx_page_start*256 - BX_NE2K_MEMSTART], BX_NE2K_THIS s.tx_bytes);
+	pcap_sendpacket(adhandle,&s.mem[s.tx_page_start*256 - BX_NE2K_MEMSTART], s.tx_bytes);
+	// some more debug
+	if (BX_NE2K_THIS s.tx_timer_active) {
+      BX_PANIC(("CR write, tx timer still active"));
+	  PIC_RemoveEvents(NE2000_TX_Event);
+	}
+	//LOG_MSG("send packet command");
+	//s.tx_timer_index = (64 + 96 + 4*8 + BX_NE2K_THIS s.tx_bytes*8)/10;
+	s.tx_timer_active = 1;
+	PIC_AddEvent(NE2000_TX_Event,(float)((64 + 96 + 4*8 + BX_NE2K_THIS s.tx_bytes*8)/10000.0),0);
+    // Schedule a timer to trigger a tx-complete interrupt
+    // The number of microseconds is the bit-time / 10.
+    // The bit-time is the preamble+sfd (64 bits), the
+    // inter-frame gap (96 bits), the CRC (4 bytes), and the
+    // the number of bits in the frame (s.tx_bytes * 8).
+    //
+
+	/* TODO: Code transmit timer */
+	/*
+    bx_pc_system.activate_timer(BX_NE2K_THIS s.tx_timer_index,
+				(64 + 96 + 4*8 + BX_NE2K_THIS s.tx_bytes*8)/10,
+				0); // not continuous
+	*/
+  } // end transmit-start branch
+
+  // Linux probes for an interrupt by setting up a remote-DMA read
+  // of 0 bytes with remote-DMA completion interrupts enabled.
+  // Detect this here
+  if (BX_NE2K_THIS s.CR.rdma_cmd == 0x01 &&
+      BX_NE2K_THIS s.CR.start &&
+      BX_NE2K_THIS s.remote_bytes == 0) {
+    BX_NE2K_THIS s.ISR.rdma_done = 1;
+    if (BX_NE2K_THIS s.IMR.rdma_inte) {
+		PIC_ActivateIRQ(s.base_irq);
+      //DEV_pic_raise_irq(BX_NE2K_THIS s.base_irq);
+    }
+  }
+}
+
+//
+// chipmem_read/chipmem_write - access the 64K private RAM.
+// The ne2000 memory is accessed through the data port of
+// the asic (offset 0) after setting up a remote-DMA transfer.
+// Both byte and word accesses are allowed.
+// The first 16 bytes contains the MAC address at even locations,
+// and there is 16K of buffer memory starting at 16K
+//
+Bit32u bx_ne2k_c::chipmem_read(Bit32u address, unsigned int io_len)
+{
+  Bit32u retval = 0;
+
+  if ((io_len == 2) && (address & 0x1)) 
+    BX_PANIC(("unaligned chipmem word read"));
+
+  // ROM'd MAC address
+  if ((address >=0) && (address <= 31)) {
+    retval = BX_NE2K_THIS s.macaddr[address];
+    if ((io_len == 2) || (io_len == 4)) {
+      retval |= (BX_NE2K_THIS s.macaddr[address + 1] << 8);
+	  if (io_len == 4) {
+			retval |= (BX_NE2K_THIS s.macaddr[address + 2] << 16);
+			retval |= (BX_NE2K_THIS s.macaddr[address + 3] << 24);
+	  }
+    }
+    return (retval);
+  }
+
+  if ((address >= BX_NE2K_MEMSTART) && (address < BX_NE2K_MEMEND)) {
+    retval = BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART];
+    if ((io_len == 2) || (io_len == 4)) {
+      retval |= (BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART + 1] << 8);
+    }
+	if (io_len == 4) {
+       retval |= (BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART + 2] << 16);
+       retval |= (BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART + 3] << 24);
+    }
+    return (retval);
+  }
+
+  BX_DEBUG("out-of-bounds chipmem read, %04X", address);
+
+  return (0xff);
+}
+
+void 
+bx_ne2k_c::chipmem_write(Bit32u address, Bit32u value, unsigned io_len)
+{
+  if ((io_len == 2) && (address & 0x1)) 
+    BX_PANIC(("unaligned chipmem word write"));
+
+  if ((address >= BX_NE2K_MEMSTART) && (address < BX_NE2K_MEMEND)) {
+    BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART] = value & 0xff;
+    if (io_len == 2)
+      BX_NE2K_THIS s.mem[address - BX_NE2K_MEMSTART + 1] = value >> 8;
+  } else
+    BX_DEBUG("out-of-bounds chipmem write, %04X", address);
+}
+
+//
+// asic_read/asic_write - This is the high 16 bytes of i/o space
+// (the lower 16 bytes is for the DS8390). Only two locations
+// are used: offset 0, which is used for data transfer, and
+// offset 0xf, which is used to reset the device.
+// The data transfer port is used to as 'external' DMA to the
+// DS8390. The chip has to have the DMA registers set up, and
+// after that, insw/outsw instructions can be used to move
+// the appropriate number of bytes to/from the device.
+//
+Bit32u 
+bx_ne2k_c::asic_read(Bit32u offset, unsigned int io_len)
+{
+  Bit32u retval = 0;
+
+  switch (offset) {
+  case 0x0:  // Data register
+    //
+    // A read remote-DMA command must have been issued,
+    // and the source-address and length registers must  
+    // have been initialised.
+    //
+    if (io_len > BX_NE2K_THIS s.remote_bytes)
+      {
+       BX_ERROR("ne2K: dma read underrun iolen=%d remote_bytes=%d",io_len,BX_NE2K_THIS s.remote_bytes);
+       //return 0;
+      }
+
+    //BX_INFO(("ne2k read DMA: addr=%4x remote_bytes=%d",BX_NE2K_THIS s.remote_dma,BX_NE2K_THIS s.remote_bytes));
+    retval = chipmem_read(BX_NE2K_THIS s.remote_dma, io_len);
+    //
+    // The 8390 bumps the address and decreases the byte count
+    // by the selected word size after every access, not by
+    // the amount of data requested by the host (io_len).
+    //
+    BX_NE2K_THIS s.remote_dma += (BX_NE2K_THIS s.DCR.wdsize + 1);
+    if (BX_NE2K_THIS s.remote_dma == BX_NE2K_THIS s.page_stop << 8) {
+      BX_NE2K_THIS s.remote_dma = BX_NE2K_THIS s.page_start << 8;
+    }
+    // keep s.remote_bytes from underflowing
+    if (BX_NE2K_THIS s.remote_bytes > 1)
+      BX_NE2K_THIS s.remote_bytes -= (BX_NE2K_THIS s.DCR.wdsize + 1);
+    else
+      BX_NE2K_THIS s.remote_bytes = 0;
+
+	// If all bytes have been written, signal remote-DMA complete
+	if (BX_NE2K_THIS s.remote_bytes == 0) {
+	    BX_NE2K_THIS s.ISR.rdma_done = 1;
+	    if (BX_NE2K_THIS s.IMR.rdma_inte) {
+			PIC_ActivateIRQ(s.base_irq);
+		//DEV_pic_raise_irq(BX_NE2K_THIS s.base_irq);
+		}
+	}
+    break;
+
+  case 0xf:  // Reset register
+    theNE2kDevice->reset(BX_RESET_SOFTWARE);
+	//retval=0x1;
+    break;
+
+  default:
+    BX_INFO("asic read invalid address %04x", (unsigned) offset);
+    break;
+  }
+
+  return (retval);
+}
+
+void
+bx_ne2k_c::asic_write(Bit32u offset, Bit32u value, unsigned io_len)
+{
+  BX_DEBUG("asic write addr=0x%02x, value=0x%04x", (unsigned) offset, (unsigned) value);
+  switch (offset) {
+  case 0x0:  // Data register - see asic_read for a description
+
+    if ((io_len == 2) && (BX_NE2K_THIS s.DCR.wdsize == 0)) {
+      BX_PANIC(("dma write length 2 on byte mode operation"));
+      break;
+    }
+
+    if (BX_NE2K_THIS s.remote_bytes == 0)
+      BX_PANIC(("ne2K: dma write, byte count 0"));
+
+    chipmem_write(BX_NE2K_THIS s.remote_dma, value, io_len);
+    // is this right ??? asic_read uses DCR.wordsize
+    BX_NE2K_THIS s.remote_dma   += io_len;
+    if (BX_NE2K_THIS s.remote_dma == BX_NE2K_THIS s.page_stop << 8) {
+      BX_NE2K_THIS s.remote_dma = BX_NE2K_THIS s.page_start << 8;
+    }
+
+    BX_NE2K_THIS s.remote_bytes -= io_len;
+    if (BX_NE2K_THIS s.remote_bytes > BX_NE2K_MEMSIZ)
+      BX_NE2K_THIS s.remote_bytes = 0;
+
+    // If all bytes have been written, signal remote-DMA complete
+    if (BX_NE2K_THIS s.remote_bytes == 0) {
+      BX_NE2K_THIS s.ISR.rdma_done = 1;
+      if (BX_NE2K_THIS s.IMR.rdma_inte) {
+	  PIC_ActivateIRQ(s.base_irq);
+	  //DEV_pic_raise_irq(BX_NE2K_THIS s.base_irq);
+      }
+    }
+    break;
+
+  case 0xf:  // Reset register
+    theNE2kDevice->reset(BX_RESET_SOFTWARE);
+    break;
+
+  default: // this is invalid, but happens under win95 device detection
+    BX_INFO("asic write invalid address %04x, ignoring", (unsigned) offset);
+    break ;
+  }
+}
+
+//
+// page0_read/page0_write - These routines handle reads/writes to
+// the 'zeroth' page of the DS8390 register file
+//
+Bit32u
+bx_ne2k_c::page0_read(Bit32u offset, unsigned int io_len)
+{
+  BX_DEBUG("page 0 read from port %04x, len=%u", (unsigned) offset,
+	   (unsigned) io_len);
+  if (io_len > 1) {
+    BX_ERROR("bad length! page 0 read from port %04x, len=%u", (unsigned) offset,
+             (unsigned) io_len); /* encountered with win98 hardware probe */
+	return 0;
+  }
+
+
+  switch (offset) {
+  case 0x1:  // CLDA0
+    return (BX_NE2K_THIS s.local_dma & 0xff);
+    break;
+
+  case 0x2:  // CLDA1
+    return (BX_NE2K_THIS s.local_dma >> 8);
+    break;
+
+  case 0x3:  // BNRY
+    return (BX_NE2K_THIS s.bound_ptr);
+    break;
+
+  case 0x4:  // TSR
+    return ((BX_NE2K_THIS s.TSR.ow_coll    << 7) |
+	    (BX_NE2K_THIS s.TSR.cd_hbeat   << 6) |
+	    (BX_NE2K_THIS s.TSR.fifo_ur    << 5) |
+	    (BX_NE2K_THIS s.TSR.no_carrier << 4) |
+	    (BX_NE2K_THIS s.TSR.aborted    << 3) |
+	    (BX_NE2K_THIS s.TSR.collided   << 2) |
+	    (BX_NE2K_THIS s.TSR.tx_ok));
+    break;
+
+  case 0x5:  // NCR
+    return (BX_NE2K_THIS s.num_coll);
+    break;
+    
+  case 0x6:  // FIFO
+    // reading FIFO is only valid in loopback mode
+    BX_ERROR(("reading FIFO not supported yet"));
+    return (BX_NE2K_THIS s.fifo);
+    break;
+
+  case 0x7:  // ISR
+    return ((BX_NE2K_THIS s.ISR.reset     << 7) |
+	    (BX_NE2K_THIS s.ISR.rdma_done << 6) |
+	    (BX_NE2K_THIS s.ISR.cnt_oflow << 5) |
+	    (BX_NE2K_THIS s.ISR.overwrite << 4) |
+	    (BX_NE2K_THIS s.ISR.tx_err    << 3) |
+	    (BX_NE2K_THIS s.ISR.rx_err    << 2) |
+	    (BX_NE2K_THIS s.ISR.pkt_tx    << 1) |
+	    (BX_NE2K_THIS s.ISR.pkt_rx));
+    break;
+    
+  case 0x8:  // CRDA0
+    return (BX_NE2K_THIS s.remote_dma & 0xff);
+    break;
+
+  case 0x9:  // CRDA1
+    return (BX_NE2K_THIS s.remote_dma >> 8);
+    break;
+
+  case 0xa:  // reserved
+    BX_INFO(("reserved read - page 0, 0xa"));
+    return (0xff);
+    break;
+
+  case 0xb:  // reserved
+    BX_INFO(("reserved read - page 0, 0xb"));
+    return (0xff);
+    break;
+    
+  case 0xc:  // RSR
+    return ((BX_NE2K_THIS s.RSR.deferred    << 7) |
+	    (BX_NE2K_THIS s.RSR.rx_disabled << 6) |
+	    (BX_NE2K_THIS s.RSR.rx_mbit     << 5) |
+	    (BX_NE2K_THIS s.RSR.rx_missed   << 4) |
+	    (BX_NE2K_THIS s.RSR.fifo_or     << 3) |
+	    (BX_NE2K_THIS s.RSR.bad_falign  << 2) |
+	    (BX_NE2K_THIS s.RSR.bad_crc     << 1) |
+	    (BX_NE2K_THIS s.RSR.rx_ok));
+    break;
+    
+  case 0xd:  // CNTR0
+    return (BX_NE2K_THIS s.tallycnt_0);
+    break;
+
+  case 0xe:  // CNTR1
+    return (BX_NE2K_THIS s.tallycnt_1);
+    break;
+
+  case 0xf:  // CNTR2
+    return (BX_NE2K_THIS s.tallycnt_2);
+    break;
+
+  default:
+    BX_PANIC("page 0 offset %04x out of range", (unsigned) offset);
+  }
+
+  return(0);
+}
+
+void
+bx_ne2k_c::page0_write(Bit32u offset, Bit32u value, unsigned io_len)
+{
+  BX_DEBUG("page 0 write to port %04x, len=%u", (unsigned) offset,
+	   (unsigned) io_len);
+
+  // It appears to be a common practice to use outw on page0 regs...
+
+  // break up outw into two outb's
+  if (io_len == 2) {
+    page0_write(offset, (value & 0xff), 1);
+    page0_write(offset + 1, ((value >> 8) & 0xff), 1);
+    return;
+  }
+
+  switch (offset) {
+  case 0x1:  // PSTART
+    BX_NE2K_THIS s.page_start = value;
+    break;
+
+  case 0x2:  // PSTOP
+	// BX_INFO(("Writing to PSTOP: %02x", value));
+    BX_NE2K_THIS s.page_stop = value;
+    break;
+
+  case 0x3:  // BNRY
+    BX_NE2K_THIS s.bound_ptr = value;
+    break;
+
+  case 0x4:  // TPSR
+    BX_NE2K_THIS s.tx_page_start = value;
+    break;
+
+  case 0x5:  // TBCR0
+    // Clear out low byte and re-insert
+    BX_NE2K_THIS s.tx_bytes &= 0xff00;
+    BX_NE2K_THIS s.tx_bytes |= (value & 0xff);
+    break;
+
+  case 0x6:  // TBCR1
+    // Clear out high byte and re-insert
+    BX_NE2K_THIS s.tx_bytes &= 0x00ff;
+    BX_NE2K_THIS s.tx_bytes |= ((value & 0xff) << 8);
+    break;
+
+  case 0x7:  // ISR
+    value &= 0x7f;  // clear RST bit - status-only bit
+    // All other values are cleared iff the ISR bit is 1
+    BX_NE2K_THIS s.ISR.pkt_rx    &= ~((bx_bool)((value & 0x01) == 0x01));
+	BX_NE2K_THIS s.ISR.pkt_tx    &= ~((bx_bool)((value & 0x02) == 0x02));
+    BX_NE2K_THIS s.ISR.rx_err    &= ~((bx_bool)((value & 0x04) == 0x04));
+    BX_NE2K_THIS s.ISR.tx_err    &= ~((bx_bool)((value & 0x08) == 0x08));
+    BX_NE2K_THIS s.ISR.overwrite &= ~((bx_bool)((value & 0x10) == 0x10));
+    BX_NE2K_THIS s.ISR.cnt_oflow &= ~((bx_bool)((value & 0x20) == 0x20));
+    BX_NE2K_THIS s.ISR.rdma_done &= ~((bx_bool)((value & 0x40) == 0x40));
+    value = ((BX_NE2K_THIS s.ISR.rdma_done << 6) |
+             (BX_NE2K_THIS s.ISR.cnt_oflow << 5) |
+             (BX_NE2K_THIS s.ISR.overwrite << 4) |
+             (BX_NE2K_THIS s.ISR.tx_err    << 3) |
+             (BX_NE2K_THIS s.ISR.rx_err    << 2) |
+             (BX_NE2K_THIS s.ISR.pkt_tx    << 1) |
+             (BX_NE2K_THIS s.ISR.pkt_rx));
+    value &= ((BX_NE2K_THIS s.IMR.rdma_inte << 6) |
+              (BX_NE2K_THIS s.IMR.cofl_inte << 5) |
+              (BX_NE2K_THIS s.IMR.overw_inte << 4) |
+              (BX_NE2K_THIS s.IMR.txerr_inte << 3) |
+              (BX_NE2K_THIS s.IMR.rxerr_inte << 2) |
+              (BX_NE2K_THIS s.IMR.tx_inte << 1) |
+              (BX_NE2K_THIS s.IMR.rx_inte));
+    if (value == 0)
+	  PIC_DeActivateIRQ(s.base_irq);
+      //DEV_pic_lower_irq(BX_NE2K_THIS s.base_irq);
+    break;
+
+  case 0x8:  // RSAR0
+    // Clear out low byte and re-insert
+    BX_NE2K_THIS s.remote_start &= 0xff00;
+    BX_NE2K_THIS s.remote_start |= (value & 0xff);
+    BX_NE2K_THIS s.remote_dma = BX_NE2K_THIS s.remote_start;
+    break;
+
+  case 0x9:  // RSAR1
+    // Clear out high byte and re-insert
+    BX_NE2K_THIS s.remote_start &= 0x00ff;
+    BX_NE2K_THIS s.remote_start |= ((value & 0xff) << 8);
+    BX_NE2K_THIS s.remote_dma = BX_NE2K_THIS s.remote_start;
+    break;
+
+  case 0xa:  // RBCR0
+    // Clear out low byte and re-insert
+    BX_NE2K_THIS s.remote_bytes &= 0xff00;
+    BX_NE2K_THIS s.remote_bytes |= (value & 0xff);
+    break;
+
+  case 0xb:  // RBCR1
+    // Clear out high byte and re-insert
+    BX_NE2K_THIS s.remote_bytes &= 0x00ff;
+    BX_NE2K_THIS s.remote_bytes |= ((value & 0xff) << 8);
+    break;
+
+  case 0xc:  // RCR
+    // Check if the reserved bits are set
+    if (value & 0xc0)
+      BX_INFO(("RCR write, reserved bits set"));
+
+    // Set all other bit-fields
+    BX_NE2K_THIS s.RCR.errors_ok = ((value & 0x01) == 0x01);
+    BX_NE2K_THIS s.RCR.runts_ok  = ((value & 0x02) == 0x02);
+    BX_NE2K_THIS s.RCR.broadcast = ((value & 0x04) == 0x04);
+    BX_NE2K_THIS s.RCR.multicast = ((value & 0x08) == 0x08);
+    BX_NE2K_THIS s.RCR.promisc   = ((value & 0x10) == 0x10);
+    BX_NE2K_THIS s.RCR.monitor   = ((value & 0x20) == 0x20);
+
+    // Monitor bit is a little suspicious...
+    if (value & 0x20)
+      BX_INFO(("RCR write, monitor bit set!"));
+    break;
+
+  case 0xd:  // TCR
+    // Check reserved bits
+    if (value & 0xe0)
+      BX_ERROR(("TCR write, reserved bits set"));
+
+    // Test loop mode (not supported)
+    if (value & 0x06) {
+      BX_NE2K_THIS s.TCR.loop_cntl = (value & 0x6) >> 1;
+      BX_INFO("TCR write, loop mode %d not supported", BX_NE2K_THIS s.TCR.loop_cntl);
+    } else {
+      BX_NE2K_THIS s.TCR.loop_cntl = 0;
+    }
+
+    // Inhibit-CRC not supported.
+    if (value & 0x01)
+      BX_PANIC(("TCR write, inhibit-CRC not supported"));
+
+    // Auto-transmit disable very suspicious
+    if (value & 0x08)
+      BX_PANIC(("TCR write, auto transmit disable not supported"));
+
+    // Allow collision-offset to be set, although not used
+    BX_NE2K_THIS s.TCR.coll_prio = ((value & 0x08) == 0x08);
+    break;
+
+  case 0xe:  // DCR
+    // the loopback mode is not suppported yet
+    if (!(value & 0x08)) {
+      BX_ERROR(("DCR write, loopback mode selected"));
+    }
+    // It is questionable to set longaddr and auto_rx, since they
+    // aren't supported on the ne2000. Print a warning and continue
+    if (value & 0x04)
+      BX_INFO(("DCR write - LAS set ???"));
+    if (value & 0x10)
+      BX_INFO(("DCR write - AR set ???"));
+
+    // Set other values.
+    BX_NE2K_THIS s.DCR.wdsize   = ((value & 0x01) == 0x01);
+    BX_NE2K_THIS s.DCR.endian   = ((value & 0x02) == 0x02);
+    BX_NE2K_THIS s.DCR.longaddr = ((value & 0x04) == 0x04); // illegal ?
+    BX_NE2K_THIS s.DCR.loop     = ((value & 0x08) == 0x08);
+    BX_NE2K_THIS s.DCR.auto_rx  = ((value & 0x10) == 0x10); // also illegal ?
+    BX_NE2K_THIS s.DCR.fifo_size = (value & 0x50) >> 5;
+    break;
+
+  case 0xf:  // IMR
+    // Check for reserved bit
+	if (value & 0x80)
+      BX_PANIC(("IMR write, reserved bit set"));
+
+    // Set other values
+    BX_NE2K_THIS s.IMR.rx_inte    = ((value & 0x01) == 0x01);
+    BX_NE2K_THIS s.IMR.tx_inte    = ((value & 0x02) == 0x02);
+    BX_NE2K_THIS s.IMR.rxerr_inte = ((value & 0x04) == 0x04);
+    BX_NE2K_THIS s.IMR.txerr_inte = ((value & 0x08) == 0x08);
+    BX_NE2K_THIS s.IMR.overw_inte = ((value & 0x10) == 0x10);
+    BX_NE2K_THIS s.IMR.cofl_inte  = ((value & 0x20) == 0x20);
+    BX_NE2K_THIS s.IMR.rdma_inte  = ((value & 0x40) == 0x40);
+	if(BX_NE2K_THIS s.ISR.pkt_tx && BX_NE2K_THIS s.IMR.tx_inte) {
+	  LOG_MSG("tx irq retrigger");
+	  PIC_ActivateIRQ(s.base_irq);
+	}
+    break;
+  default:
+    BX_PANIC("page 0 write, bad offset %0x", offset);
+  }
+}
+
+
+//
+// page1_read/page1_write - These routines handle reads/writes to
+// the first page of the DS8390 register file
+//
+Bit32u
+bx_ne2k_c::page1_read(Bit32u offset, unsigned int io_len)
+{
+  BX_DEBUG("page 1 read from port %04x, len=%u", (unsigned) offset,
+	   (unsigned) io_len);
+  if (io_len > 1)
+    BX_PANIC("bad length! page 1 read from port %04x, len=%u", (unsigned) offset,
+             (unsigned) io_len);
+
+  switch (offset) {
+  case 0x1:  // PAR0-5
+  case 0x2:
+  case 0x3:
+  case 0x4:
+  case 0x5:
+  case 0x6:
+    return (BX_NE2K_THIS s.physaddr[offset - 1]);
+    break;
+
+  case 0x7:  // CURR
+      BX_DEBUG("returning current page: %02x", (BX_NE2K_THIS s.curr_page));
+    return (BX_NE2K_THIS s.curr_page);
+
+  case 0x8:  // MAR0-7
+  case 0x9:
+  case 0xa:
+  case 0xb:
+  case 0xc:
+  case 0xd:
+  case 0xe:
+  case 0xf:
+    return (BX_NE2K_THIS s.mchash[offset - 8]);
+    break;
+
+  default:
+    BX_PANIC("page 1 r offset %04x out of range", (unsigned) offset);
+  }
+
+  return (0);
+}
+
+void
+bx_ne2k_c::page1_write(Bit32u offset, Bit32u value, unsigned io_len)
+{
+  BX_DEBUG("page 1 w offset %04x", (unsigned) offset);
+  switch (offset) {
+  case 0x1:  // PAR0-5
+  case 0x2:
+  case 0x3:
+  case 0x4:
+  case 0x5:
+  case 0x6:
+    BX_NE2K_THIS s.physaddr[offset - 1] = value;
+    break;
+    
+  case 0x7:  // CURR
+    BX_NE2K_THIS s.curr_page = value;
+    break;
+
+  case 0x8:  // MAR0-7
+  case 0x9:
+  case 0xa:
+  case 0xb:
+  case 0xc:
+  case 0xd:
+  case 0xe:
+  case 0xf:
+    BX_NE2K_THIS s.mchash[offset - 8] = value;
+    break;
+
+  default:
+    BX_PANIC("page 1 w offset %04x out of range", (unsigned) offset);
+  }  
+}
+
+
+//
+// page2_read/page2_write - These routines handle reads/writes to
+// the second page of the DS8390 register file
+//
+Bit32u
+bx_ne2k_c::page2_read(Bit32u offset, unsigned int io_len)
+{
+  BX_DEBUG("page 2 read from port %04x, len=%u", (unsigned) offset, (unsigned) io_len);
+
+  if (io_len > 1)
+    BX_PANIC("bad length!  page 2 read from port %04x, len=%u", (unsigned) offset, (unsigned) io_len);
+
+  switch (offset) {
+  case 0x1:  // PSTART
+    return (BX_NE2K_THIS s.page_start);
+    break;
+
+  case 0x2:  // PSTOP
+    return (BX_NE2K_THIS s.page_stop);
+    break;
+
+  case 0x3:  // Remote Next-packet pointer
+    return (BX_NE2K_THIS s.rempkt_ptr);
+    break;
+
+  case 0x4:  // TPSR
+    return (BX_NE2K_THIS s.tx_page_start);
+    break;
+
+  case 0x5:  // Local Next-packet pointer
+    return (BX_NE2K_THIS s.localpkt_ptr);
+    break;
+
+  case 0x6:  // Address counter (upper)
+    return (BX_NE2K_THIS s.address_cnt >> 8);
+    break;
+
+  case 0x7:  // Address counter (lower)
+    return (BX_NE2K_THIS s.address_cnt & 0xff);
+    break;
+
+  case 0x8:  // Reserved
+  case 0x9:
+  case 0xa:
+  case 0xb:
+    BX_ERROR("reserved read - page 2, 0x%02x", (unsigned) offset);
+    return (0xff);
+    break;
+
+  case 0xc:  // RCR
+    return ((BX_NE2K_THIS s.RCR.monitor   << 5) |
+	    (BX_NE2K_THIS s.RCR.promisc   << 4) |
+	    (BX_NE2K_THIS s.RCR.multicast << 3) |
+	    (BX_NE2K_THIS s.RCR.broadcast << 2) |
+	    (BX_NE2K_THIS s.RCR.runts_ok  << 1) |
+	    (BX_NE2K_THIS s.RCR.errors_ok));
+    break;
+
+  case 0xd:  // TCR
+    return ((BX_NE2K_THIS s.TCR.coll_prio   << 4) |
+	    (BX_NE2K_THIS s.TCR.ext_stoptx  << 3) |
+	    ((BX_NE2K_THIS s.TCR.loop_cntl & 0x3) << 1) |
+	    (BX_NE2K_THIS s.TCR.crc_disable));
+    break;
+
+  case 0xe:  // DCR
+    return (((BX_NE2K_THIS s.DCR.fifo_size & 0x3) << 5) |
+	    (BX_NE2K_THIS s.DCR.auto_rx  << 4) |
+	    (BX_NE2K_THIS s.DCR.loop     << 3) |
+	    (BX_NE2K_THIS s.DCR.longaddr << 2) |
+	    (BX_NE2K_THIS s.DCR.endian   << 1) |
+	    (BX_NE2K_THIS s.DCR.wdsize));
+    break;
+
+  case 0xf:  // IMR
+    return ((BX_NE2K_THIS s.IMR.rdma_inte  << 6) |
+	    (BX_NE2K_THIS s.IMR.cofl_inte  << 5) |
+	    (BX_NE2K_THIS s.IMR.overw_inte << 4) |
+	    (BX_NE2K_THIS s.IMR.txerr_inte << 3) |
+	    (BX_NE2K_THIS s.IMR.rxerr_inte << 2) |
+	    (BX_NE2K_THIS s.IMR.tx_inte    << 1) |
+	    (BX_NE2K_THIS s.IMR.rx_inte));
+    break;
+
+  default:
+    BX_PANIC("page 2 offset %04x out of range", (unsigned) offset);
+  }
+
+  return (0);
+};
+
+void
+bx_ne2k_c::page2_write(Bit32u offset, Bit32u value, unsigned io_len)
+{
+  // Maybe all writes here should be BX_PANIC()'d, since they
+  // affect internal operation, but let them through for now
+  // and print a warning.
+  if (offset != 0)
+    BX_ERROR(("page 2 write ?"));
+
+  switch (offset) {
+  case 0x1:  // CLDA0
+    // Clear out low byte and re-insert
+    BX_NE2K_THIS s.local_dma &= 0xff00;
+    BX_NE2K_THIS s.local_dma |= (value & 0xff);
+    break;
+
+  case 0x2:  // CLDA1
+    // Clear out high byte and re-insert
+    BX_NE2K_THIS s.local_dma &= 0x00ff;
+    BX_NE2K_THIS s.local_dma |= ((value & 0xff) << 8);
+    break;
+
+  case 0x3:  // Remote Next-pkt pointer
+    BX_NE2K_THIS s.rempkt_ptr = value;
+    break;
+
+  case 0x4:
+    BX_PANIC(("page 2 write to reserved offset 4"));
+    break;
+
+  case 0x5:  // Local Next-packet pointer
+    BX_NE2K_THIS s.localpkt_ptr = value;
+    break;
+
+  case 0x6:  // Address counter (upper)
+    // Clear out high byte and re-insert
+    BX_NE2K_THIS s.address_cnt &= 0x00ff;
+    BX_NE2K_THIS s.address_cnt |= ((value & 0xff) << 8);
+    break;
+
+  case 0x7:  // Address counter (lower)
+    // Clear out low byte and re-insert
+    BX_NE2K_THIS s.address_cnt &= 0xff00;
+    BX_NE2K_THIS s.address_cnt |= (value & 0xff);
+    break;
+
+  case 0x8:
+  case 0x9:
+  case 0xa:
+  case 0xb:
+  case 0xc:
+  case 0xd:
+  case 0xe:
+  case 0xf:
+    BX_PANIC("page 2 write to reserved offset %0x", offset);
+    break;
+   
+  default:
+    BX_PANIC("page 2 write, illegal offset %0x", offset);
+    break;
+  }
+}
+  
+//
+// page3_read/page3_write - writes to this page are illegal
+//
+Bit32u
+bx_ne2k_c::page3_read(Bit32u offset, unsigned int io_len)
+{
+  BX_PANIC(("page 3 read attempted"));
+  return (0);
+}
+
+void
+bx_ne2k_c::page3_write(Bit32u offset, Bit32u value, unsigned io_len)
+{
+  BX_PANIC(("page 3 write attempted"));
+}
+
+//
+// tx_timer_handler/tx_timer
+//
+void
+bx_ne2k_c::tx_timer_handler(void *this_ptr)
+{
+  bx_ne2k_c *class_ptr = (bx_ne2k_c *) this_ptr;
+
+  class_ptr->tx_timer();
+}
+
+void
+bx_ne2k_c::tx_timer(void)
+{
+  BX_DEBUG(("tx_timer"));
+  BX_NE2K_THIS s.TSR.tx_ok = 1;
+  // Generate an interrupt if not masked and not one in progress
+  if (BX_NE2K_THIS s.IMR.tx_inte && !BX_NE2K_THIS s.ISR.pkt_tx) {
+		//LOG_MSG("tx complete interrupt");
+	  PIC_ActivateIRQ(s.base_irq);
+    //DEV_pic_raise_irq(BX_NE2K_THIS s.base_irq);
+  } //else 	  LOG_MSG("no tx complete interrupt");
+  BX_NE2K_THIS s.ISR.pkt_tx = 1;
+  BX_NE2K_THIS s.tx_timer_active = 0;
+}
+
+
+//
+// read_handler/read - i/o 'catcher' function called from BOCHS
+// mainline when the CPU attempts a read in the i/o space registered
+// by this ne2000 instance
+//
+Bit32u bx_ne2k_c::read_handler(void *this_ptr, Bit32u address, unsigned io_len)
+{
+#if !BX_USE_NE2K_SMF
+  bx_ne2k_c *class_ptr = (bx_ne2k_c *) this_ptr;
+
+  return( class_ptr->read(address, io_len) );
+}
+
+Bit32u bx_ne2k_c::read(Bit32u address, unsigned io_len)
+{
+#else
+  UNUSED(this_ptr);
+#endif  // !BX_USE_NE2K_SMF
+  BX_DEBUG("read addr %x, len %d", address, io_len);
+  Bit32u retval = 0;
+  int offset = address - BX_NE2K_THIS s.base_address;
+
+  if (offset >= 0x10) {
+    retval = asic_read(offset - 0x10, io_len);
+  } else if (offset == 0x00) {
+    retval = read_cr();
+  } else {
+    switch (BX_NE2K_THIS s.CR.pgsel) {
+    case 0x00:
+      retval = page0_read(offset, io_len);
+      break;
+
+    case 0x01:
+      retval = page1_read(offset, io_len);
+      break;
+
+    case 0x02:
+      retval = page2_read(offset, io_len);
+      break;
+
+    case 0x03:
+      retval = page3_read(offset, io_len);
+      break;
+
+    default:
+      BX_PANIC("ne2K: unknown value of pgsel in read - %d",
+	       BX_NE2K_THIS s.CR.pgsel);
+    }
+  }
+
+  return (retval);
+}
+
+//
+// write_handler/write - i/o 'catcher' function called from BOCHS
+// mainline when the CPU attempts a write in the i/o space registered
+// by this ne2000 instance
+//
+void
+bx_ne2k_c::write_handler(void *this_ptr, Bit32u address, Bit32u value, 
+			 unsigned io_len)
+{
+#if !BX_USE_NE2K_SMF
+  bx_ne2k_c *class_ptr = (bx_ne2k_c *) this_ptr;
+  
+  class_ptr->write(address, value, io_len);
+}
+
+void
+bx_ne2k_c::write(Bit32u address, Bit32u value, unsigned io_len)
+{
+#else
+  UNUSED(this_ptr);
+#endif  // !BX_USE_NE2K_SMF
+  BX_DEBUG("write with length %d", io_len);
+  int offset = address - BX_NE2K_THIS s.base_address;
+
+  //
+  // The high 16 bytes of i/o space are for the ne2000 asic -
+  //  the low 16 bytes are for the DS8390, with the current
+  //  page being selected by the PS0,PS1 registers in the
+  //  command register
+  //
+  if (offset >= 0x10) {
+    asic_write(offset - 0x10, value, io_len);
+	} else if (offset == 0x00) {
+    write_cr(value);
+  } else {
+    switch (BX_NE2K_THIS s.CR.pgsel) {
+    case 0x00:
+      page0_write(offset, value, io_len);
+      break;
+
+    case 0x01:
+      page1_write(offset, value, io_len);
+      break;
+
+    case 0x02:
+      page2_write(offset, value, io_len);
+      break;
+
+    case 0x03:
+      page3_write(offset, value, io_len);
+      break;
+
+    default:
+      BX_PANIC("ne2K: unknown value of pgsel in write - %d",
+	       BX_NE2K_THIS s.CR.pgsel);
+    }
+  }
+}
+
+
+/*
+ * mcast_index() - return the 6-bit index into the multicast
+ * table. Stolen unashamedly from FreeBSD's if_ed.c
+ */
+unsigned
+bx_ne2k_c::mcast_index(const void *dst)
+{
+#define POLYNOMIAL 0x04c11db6
+  unsigned long crc = 0xffffffffL;
+  int carry, i, j;
+  unsigned char b;
+  unsigned char *ep = (unsigned char *) dst;
+
+  for (i = 6; --i >= 0;) {
+    b = *ep++;
+    for (j = 8; --j >= 0;) {
+      carry = ((crc & 0x80000000L) ? 1 : 0) ^ (b & 0x01);
+      crc <<= 1;
+      b >>= 1;
+      if (carry)
+	crc = ((crc ^ POLYNOMIAL) | carry);
+    }
+  }
+  return (crc >> 26);
+#undef POLYNOMIAL
+}
+
+/*
+ * Callback from the eth system driver when a frame has arrived
+ */
+/*
+void
+bx_ne2k_c::rx_handler(void *arg, const void *buf, unsigned len)
+{
+    // BX_DEBUG(("rx_handler with length %d", len));
+  bx_ne2k_c *class_ptr = (bx_ne2k_c *) arg;
+  if(
+  class_ptr->rx_frame(buf, len);
+}
+*/
+/*
+ * rx_frame() - called by the platform-specific code when an
+ * ethernet frame has been received. The destination address
+ * is tested to see if it should be accepted, and if the
+ * rx ring has enough room, it is copied into it and
+ * the receive process is updated
+ */
+void
+bx_ne2k_c::rx_frame(const void *buf, unsigned io_len)
+{
+  int pages;
+  int avail;
+  unsigned idx;
+  int wrapped;
+  int nextpage;
+  unsigned char pkthdr[4];
+  unsigned char *pktbuf = (unsigned char *) buf;
+  unsigned char *startptr;
+  static unsigned char bcast_addr[6] = {0xff,0xff,0xff,0xff,0xff,0xff};
+
+  if(io_len != 60) {
+	BX_DEBUG("rx_frame with length %d", io_len);
+  }
+
+	//LOG_MSG("stop=%d, pagestart=%x, dcr_loop=%x, tcr_loopcntl=%x",
+	//	BX_NE2K_THIS s.CR.stop, BX_NE2K_THIS s.page_start,
+	//	BX_NE2K_THIS s.DCR.loop, BX_NE2K_THIS s.TCR.loop_cntl);
+  if ((BX_NE2K_THIS s.CR.stop != 0) ||
+      (BX_NE2K_THIS s.page_start == 0) /*||
+      ((BX_NE2K_THIS s.DCR.loop == 0) &&
+       (BX_NE2K_THIS s.TCR.loop_cntl != 0))*/) {
+    return;
+  }
+
+  // Add the pkt header + CRC to the length, and work
+  // out how many 256-byte pages the frame would occupy
+  pages = (io_len + 4 + 4 + 255)/256;
+
+  if (BX_NE2K_THIS s.curr_page < BX_NE2K_THIS s.bound_ptr) {
+    avail = BX_NE2K_THIS s.bound_ptr - BX_NE2K_THIS s.curr_page;    
+  } else {
+    avail = (BX_NE2K_THIS s.page_stop - BX_NE2K_THIS s.page_start) -
+      (BX_NE2K_THIS s.curr_page - BX_NE2K_THIS s.bound_ptr);
+    wrapped = 1;
+  }
+
+  // Avoid getting into a buffer overflow condition by not attempting
+  // to do partial receives. The emulation to handle this condition
+  // seems particularly painful.
+  if ((avail < pages) 
+#if BX_NE2K_NEVER_FULL_RING
+      || (avail == pages)
+#endif
+      ) {
+	BX_DEBUG("no space");
+    return;
+  }
+
+  if ((io_len < 40/*60*/) && !BX_NE2K_THIS s.RCR.runts_ok) {
+    BX_DEBUG("rejected small packet, length %d", io_len);
+    return;
+  }
+  // some computers don't care...
+  if (io_len < 60) io_len=60;
+
+  // Do address filtering if not in promiscuous mode
+  if (! BX_NE2K_THIS s.RCR.promisc) {
+    if (!memcmp(buf, bcast_addr, 6)) {
+      if (!BX_NE2K_THIS s.RCR.broadcast) {
+	return;
+      }
+    } else if (pktbuf[0] & 0x01) {
+	if (! BX_NE2K_THIS s.RCR.multicast) {
+	    return;
+	}
+      idx = mcast_index(buf);
+      if (!(BX_NE2K_THIS s.mchash[idx >> 3] & (1 << (idx & 0x7)))) {
+	return;
+      }
+    } else if (0 != memcmp(buf, BX_NE2K_THIS s.physaddr, 6)) {
+      return;
+    }
+  } else {
+      BX_DEBUG(("rx_frame promiscuous receive"));
+  }
+
+    BX_INFO("rx_frame %d to %x:%x:%x:%x:%x:%x from %x:%x:%x:%x:%x:%x",
+  	   io_len,
+  	   pktbuf[0], pktbuf[1], pktbuf[2], pktbuf[3], pktbuf[4], pktbuf[5],
+  	   pktbuf[6], pktbuf[7], pktbuf[8], pktbuf[9], pktbuf[10], pktbuf[11]);
+
+  nextpage = BX_NE2K_THIS s.curr_page + pages;
+  if (nextpage >= BX_NE2K_THIS s.page_stop) {
+    nextpage -= BX_NE2K_THIS s.page_stop - BX_NE2K_THIS s.page_start;
+  }
+
+  // Setup packet header
+  pkthdr[0] = 0;	// rx status - old behavior
+  pkthdr[0] = 1;        // Probably better to set it all the time
+                        // rather than set it to 0, which is clearly wrong.
+  if (pktbuf[0] & 0x01) {
+    pkthdr[0] |= 0x20;  // rx status += multicast packet
+  }
+  pkthdr[1] = nextpage;	// ptr to next packet
+  pkthdr[2] = (io_len + 4) & 0xff;	// length-low
+  pkthdr[3] = (io_len + 4) >> 8;	// length-hi
+
+  // copy into buffer, update curpage, and signal interrupt if config'd
+  startptr = & BX_NE2K_THIS s.mem[BX_NE2K_THIS s.curr_page * 256 -
+			       BX_NE2K_MEMSTART];
+  if ((nextpage > BX_NE2K_THIS s.curr_page) ||
+      ((BX_NE2K_THIS s.curr_page + pages) == BX_NE2K_THIS s.page_stop)) {
+    memcpy(startptr, pkthdr, 4);
+    memcpy(startptr + 4, buf, io_len);
+    BX_NE2K_THIS s.curr_page = nextpage;
+  } else {
+    int endbytes = (BX_NE2K_THIS s.page_stop - BX_NE2K_THIS s.curr_page) 
+      * 256;
+    memcpy(startptr, pkthdr, 4);
+    memcpy(startptr + 4, buf, endbytes - 4);
+    startptr = & BX_NE2K_THIS s.mem[BX_NE2K_THIS s.page_start * 256 -
+				 BX_NE2K_MEMSTART];
+    memcpy(startptr, (void *)(pktbuf + endbytes - 4),
+	   io_len - endbytes + 8);    
+    BX_NE2K_THIS s.curr_page = nextpage;
+  }
+  
+  BX_NE2K_THIS s.RSR.rx_ok = 1;
+  if (pktbuf[0] & 0x80) {
+    BX_NE2K_THIS s.RSR.rx_mbit = 1;
+  }
+
+  BX_NE2K_THIS s.ISR.pkt_rx = 1;
+
+  if (BX_NE2K_THIS s.IMR.rx_inte) {
+	//LOG_MSG("packet rx interrupt");
+	  PIC_ActivateIRQ(s.base_irq);
+    //DEV_pic_raise_irq(BX_NE2K_THIS s.base_irq);
+  } //else LOG_MSG("no packet rx interrupt");
+
+}
+
+//Bit8u macaddr[6] = { 0xAC, 0xDE, 0x48, 0x8E, 0x89, 0x19 };
+
+Bitu dosbox_read(Bitu port, Bitu len) {
+	Bitu retval = theNE2kDevice->read(port,len);
+	//LOG_MSG("ne2k rd port %x val %4x len %d page %d, CS:IP %8x:%8x",
+	//	port, retval, len, theNE2kDevice->s.CR.pgsel,SegValue(cs),reg_eip);
+	return retval;
+}
+void dosbox_write(Bitu port, Bitu val, Bitu len) {
+	//LOG_MSG("ne2k wr port %x val %4x len %d page %d, CS:IP %8x:%8x",
+	//	port, val, len,theNE2kDevice->s.CR.pgsel,SegValue(cs),reg_eip);
+	theNE2kDevice->write(port, val, len);
+}
+
+void bx_ne2k_c::init()
+{
+  //BX_DEBUG(("Init $Id: ne2k.cc,v 1.56.2.1 2004/02/02 22:37:22 cbothamy Exp $"));
+
+  // Read in values from config file
+  //BX_NE2K_THIS s.base_address = 0x300;
+  //BX_NE2K_THIS s.base_irq     = 3;
+  /*
+  if (BX_NE2K_THIS s.tx_timer_index == BX_NULL_TIMER_HANDLE) {
+    BX_NE2K_THIS s.tx_timer_index =
+      bx_pc_system.register_timer(this, tx_timer_handler, 0,
+                                  0,0, "ne2k"); // one-shot, inactive
+  }*/
+  // Register the IRQ and i/o port addresses
+  //DEV_register_irq(BX_NE2K_THIS s.base_irq, "NE2000 ethernet NIC");
+
+   //DEV_register_ioread_handler(this, read_handler, addr, "ne2000 NIC", 3);
+   //DEV_register_iowrite_handler(this, write_handler, addr, "ne2000 NIC", 3);
+
+
+  BX_INFO("port 0x%x/32 irq %d mac %02x:%02x:%02x:%02x:%02x:%02x",
+           BX_NE2K_THIS s.base_address,
+           BX_NE2K_THIS s.base_irq,
+           BX_NE2K_THIS s.physaddr[0],
+           BX_NE2K_THIS s.physaddr[1],
+           BX_NE2K_THIS s.physaddr[2],
+           BX_NE2K_THIS s.physaddr[3],
+           BX_NE2K_THIS s.physaddr[4],
+           BX_NE2K_THIS s.physaddr[5]);
+
+  // Initialise the mac address area by doubling the physical address
+  BX_NE2K_THIS s.macaddr[0]  = BX_NE2K_THIS s.physaddr[0];
+  BX_NE2K_THIS s.macaddr[1]  = BX_NE2K_THIS s.physaddr[0];
+  BX_NE2K_THIS s.macaddr[2]  = BX_NE2K_THIS s.physaddr[1];
+  BX_NE2K_THIS s.macaddr[3]  = BX_NE2K_THIS s.physaddr[1];
+  BX_NE2K_THIS s.macaddr[4]  = BX_NE2K_THIS s.physaddr[2];
+  BX_NE2K_THIS s.macaddr[5]  = BX_NE2K_THIS s.physaddr[2];
+  BX_NE2K_THIS s.macaddr[6]  = BX_NE2K_THIS s.physaddr[3];
+  BX_NE2K_THIS s.macaddr[7]  = BX_NE2K_THIS s.physaddr[3];
+  BX_NE2K_THIS s.macaddr[8]  = BX_NE2K_THIS s.physaddr[4];
+  BX_NE2K_THIS s.macaddr[9]  = BX_NE2K_THIS s.physaddr[4];
+  BX_NE2K_THIS s.macaddr[10] = BX_NE2K_THIS s.physaddr[5];
+  BX_NE2K_THIS s.macaddr[11] = BX_NE2K_THIS s.physaddr[5];
+    
+  // ne2k signature
+  for (Bitu i = 12; i < 32; i++) 
+    BX_NE2K_THIS s.macaddr[i] = 0x57;
+    
+  // Bring the register state into power-up state
+  reset(BX_RESET_HARDWARE);
+}
+
+static void NE2000_TX_Event(Bitu val) {
+	theNE2kDevice->tx_timer();
+}
+
+static void NE2000_Poller(void) {
+	int res;
+	struct pcap_pkthdr *header;
+	u_char *pkt_data;
+//#if 0
+	while((res = pcap_next_ex( adhandle, &header, (const u_char **)&pkt_data)) > 0) {
+		//LOG_MSG("NE2000: Received %d bytes", header->len);
+		
+		// don't receive in loopback modes
+		if((theNE2kDevice->s.DCR.loop == 0) || (theNE2kDevice->s.TCR.loop_cntl != 0))
+			return;
+		theNE2kDevice->rx_frame(pkt_data, header->len);
+	}
+//#endif
+}
+#ifdef WIN32
+#include <windows.h>
+#endif
+
+class NE2K: public Module_base {
+private:
+	// Data
+	IO_ReadHandleObject ReadHandler8[0x20];
+	IO_WriteHandleObject WriteHandler8[0x20];
+	IO_ReadHandleObject ReadHandler16[0x10];
+	IO_WriteHandleObject WriteHandler16[0x10];
+
+public:
+	bool load_success;
+	NE2K(Section* configuration):Module_base(configuration) {
+		Section_prop * section=static_cast<Section_prop *>(configuration);
+
+		load_success = true;
+		// enabled?
+
+		if(!section->Get_bool("ne2000")) {
+			load_success = false;
+			return;
+		}
+
+#ifdef WIN32
+/*		
+		int (*PacketSendPacket)(pcap_t *, const u_char *, int);
+		void (*PacketClose)(pcap_t *);
+		void (*PacketFreealldevs)(pcap_if_t *);
+		pcap_t* (*PacketOpen)(char const *,int,int,int,struct pcap_rmtauth *,char *);
+		int (*PacketNextEx)(pcap_t *, struct pcap_pkthdr **, const u_char **);
+		int (*PacketFindALlDevsEx)(char *, struct pcap_rmtauth *, pcap_if_t **, char *);
+*/
+		// init the library
+		HINSTANCE pcapinst;
+		pcapinst = LoadLibrary("WPCAP.DLL");
+		if(pcapinst==NULL) {
+			LOG_MSG("WinPcap has to be installed for the NE2000 to work.");
+			load_success = false;
+			return;
+		}
+		FARPROC psp;
+		
+		psp = GetProcAddress(pcapinst,"pcap_sendpacket");
+		if(!PacketSendPacket) PacketSendPacket =
+			(int (__cdecl *)(pcap_t *,const u_char *,int))psp;
+		
+		psp = GetProcAddress(pcapinst,"pcap_close");
+		if(!PacketClose) PacketClose =
+			(void (__cdecl *)(pcap_t *)) psp;
+		
+		psp = GetProcAddress(pcapinst,"pcap_freealldevs");
+		if(!PacketFreealldevs) PacketFreealldevs =
+			(void (__cdecl *)(pcap_if_t *)) psp;
+
+		psp = GetProcAddress(pcapinst,"pcap_open");
+		if(!PacketOpen) PacketOpen =
+			(pcap_t* (__cdecl *)(char const *,int,int,int,struct pcap_rmtauth *,char *)) psp;
+
+		psp = GetProcAddress(pcapinst,"pcap_next_ex");
+		if(!PacketNextEx) PacketNextEx = 
+			(int (__cdecl *)(pcap_t *, struct pcap_pkthdr **, const u_char **)) psp;
+
+		psp = GetProcAddress(pcapinst,"pcap_findalldevs_ex");
+		if(!PacketFindALlDevsEx) PacketFindALlDevsEx =
+			(int (__cdecl *)(char *, struct pcap_rmtauth *, pcap_if_t **, char *)) psp;
+
+		if(PacketFindALlDevsEx==0 || PacketNextEx==0 || PacketOpen==0 || 
+			PacketFreealldevs==0 || PacketClose==0 || PacketSendPacket==0) {
+			LOG_MSG("Wrong WinPcap version or something");
+			load_success = false;
+			return;
+		}
+
+#endif
+
+		// get irq and base
+		Bitu irq = section->Get_int("nicirq");
+		if(!(irq==3 || irq==4  || irq==5  || irq==6 ||irq==7 ||
+			irq==9 || irq==10 || irq==11 || irq==12 ||irq==14 ||irq==15)) {
+			irq=3;
+		}
+		Bitu base = section->Get_hex("nicbase");
+		if(!(base==0x260||base==0x280||base==0x300||base==0x320||base==0x340||base==0x380)) {
+			base=0x300;
+		}
+
+		// mac address
+		const char* macstring=section->Get_string("macaddr");
+		Bitu macint[6];
+		Bit8u mac[6];
+		if(sscanf(macstring,"%02x:%02x:%02x:%02x:%02x:%02x",
+			&macint[0],&macint[1],&macint[2],&macint[3],&macint[4],&macint[5]) != 6) {
+			mac[0]=0xac;mac[1]=0xde;mac[2]=0x48;
+			mac[3]=0x88;mac[4]=0xbb;mac[5]=0xaa;
+		} else {
+			mac[0]=macint[0]; mac[1]=macint[1];
+			mac[2]=macint[2]; mac[3]=macint[3];
+			mac[4]=macint[4]; mac[5]=macint[5];
+		}
+
+		// find out which pcap device to use
+		const char* realnicstring=section->Get_string("realnic");
+		pcap_if_t *alldevs;
+		pcap_if_t *currentdev = NULL;
+		char errbuf[PCAP_ERRBUF_SIZE];
+		Bitu userdev;
+#ifdef WIN32
+		if (pcap_findalldevs_ex(PCAP_SRC_IF_STRING, NULL, &alldevs, errbuf) == -1)
+#else
+		if (pcap_findalldevs(&alldevs, errbuf) == -1)
+#endif
+ 		{
+			LOG_MSG("Cannot enumerate network interfaces: %s\n", errbuf);
+			load_success = false;
+			return;
+		}
+		if (!strcasecmp(realnicstring,"list")) {
+			// print list and quit
+			Bitu i = 0;
+			LOG_MSG("\nNetwork Interface List \n-----------------------------------");
+			for(currentdev=alldevs; currentdev!=NULL; currentdev=currentdev->next) {
+				const char* desc = "no description"; 
+				if(currentdev->description) desc=currentdev->description;
+				i++;
+				LOG_MSG("%2d. %s\n    (%s)\n",i,currentdev->name,desc);
+			}
+			pcap_freealldevs(alldevs);
+			load_success = false;
+			return;
+		} else if(1==sscanf(realnicstring,"%u",&userdev)) {
+			// user passed us a number
+			Bitu i = 0;
+			currentdev=alldevs;
+			while(currentdev!=NULL) {
+				i++;
+				if(i==userdev) break;
+				else currentdev=currentdev->next;
+			}
+		} else {
+			// user might have passed a piece of name
+			for(currentdev=alldevs; currentdev!=NULL; currentdev=currentdev->next) {
+				if(strstr(currentdev->name,realnicstring)) {
+					break;
+				}else if(currentdev->description!=NULL &&
+					strstr(currentdev->description,realnicstring)) {
+					break;
+				}
+			}
+		}
+
+		if(currentdev==NULL) {
+			LOG_MSG("Unable to find network interface - check realnic parameter\n");
+			load_success = false;
+			pcap_freealldevs(alldevs);
+			return;
+		}
+		// print out which interface we are going to use
+        const char* desc = "no description"; 
+		if(currentdev->description) desc=currentdev->description;
+		LOG_MSG("Using Network interface:\n%s\n(%s)\n",currentdev->name,desc);
+		
+		// attempt to open it
+#ifdef WIN32
+		if ( (adhandle= pcap_open(
+			currentdev->name, // name of the device
+            65536,            // portion of the packet to capture
+                              // 65536 = whole packet 
+            PCAP_OPENFLAG_PROMISCUOUS,    // promiscuous mode
+            -1,             // read timeout
+            NULL,             // authentication on the remote machine
+            errbuf            // error buffer
+            ) ) == NULL)
+#else
+		/*pcap_t *pcap_open_live(const char *device, int snaplen,
+               int promisc, int to_ms, char *errbuf)*/
+		if ( (adhandle= pcap_open_live(
+			currentdev->name, // name of the device
+            65536,            // portion of the packet to capture
+                              // 65536 = whole packet 
+            true,    // promiscuous mode
+            -1,             // read timeout
+            errbuf            // error buffer
+            ) ) == NULL)
+
+#endif        
+        {
+				LOG_MSG("\nUnable to open the interface: %s.", errbuf);
+        	pcap_freealldevs(alldevs);
+			load_success = false;
+			return;
+		}
+		pcap_freealldevs(alldevs);
+#ifndef WIN32
+		pcap_setnonblock(adhandle,1,errbuf);
+#endif
+		// create the bochs NIC class
+		theNE2kDevice = new bx_ne2k_c ();
+		memcpy(theNE2kDevice->s.physaddr, mac, 6);
+		theNE2kDevice->init();
+
+		theNE2kDevice->s.base_address=base;
+		theNE2kDevice->s.base_irq=irq;
+
+		// install I/O-handlers and timer
+		for(Bitu i = 0; i < 0x20; i++) {
+			ReadHandler8[i].Install((i+theNE2kDevice->s.base_address),
+				dosbox_read,IO_MB|IO_MW);
+			WriteHandler8[i].Install((i+theNE2kDevice->s.base_address),
+				dosbox_write,IO_MB|IO_MW);
+		}
+		TIMER_AddTickHandler(NE2000_Poller);
+	}	
+	
+	~NE2K() {
+		if(adhandle) pcap_close(adhandle);
+		adhandle=0;
+		if(theNE2kDevice != 0) delete theNE2kDevice;
+		theNE2kDevice=0;
+		TIMER_DelTickHandler(NE2000_Poller);
+		PIC_RemoveEvents(NE2000_TX_Event);
+	}	
+};
+
+static NE2K* test;
+void NE2K_ShutDown(Section* sec) {
+	if(test) delete test;	
+	test=0;
+}
+
+void NE2K_Init(Section* sec) {
+	test = new NE2K(sec);
+	sec->AddDestroyFunction(&NE2K_ShutDown,true);
+	if(!test->load_success) {
+		delete test;
+		test=0;
+	}
+}
+
+#endif // C_NE2000
diff -urN dosbox-0.73/src/hardware/parport/directlpt_linux.cpp dosboxcvs/src/hardware/parport/directlpt_linux.cpp
--- dosbox-0.73/src/hardware/parport/directlpt_linux.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/directlpt_linux.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,178 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "config.h"
+#include "setup.h"
+
+#if C_DIRECTLPT
+
+/* Linux version */
+#if defined (LINUX)
+
+#include "parport.h"
+#include "directlpt_linux.h"
+#include "callback.h"
+#include <linux/ppdev.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <SDL.h>
+
+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = false;
+	interruptflag=true; // interrupt disabled
+
+	std::string str;
+
+	if(!cmd->FindStringBegin("realport:",str,false)) {
+		LOG_MSG("parallel%d: realport parameter missing.",nr+1);
+		return;
+	}
+	porthandle = open(str.c_str(), O_RDWR );
+	if(porthandle == -1) {
+		LOG_MSG("parallel%d: Could not open port %s.",nr+1,str.c_str());
+		if (errno == 2) LOG_MSG ("The specified port does not exist.");
+		else if(errno==EBUSY) LOG_MSG("The specified port is already in use.");
+		else if(errno==EACCES) LOG_MSG("You are not allowed to access this port.");
+		else LOG_MSG("Errno %d occurred.",errno);
+		return;
+	}
+
+	if(ioctl( porthandle, PPCLAIM, NULL ) == -1) {
+		LOG_MSG("parallel%d: failed to claim port.",nr+1);
+		return;
+	}
+	// TODO check return value
+	
+	// go for it
+	ack_polarity=false;
+	initialize();
+
+	InstallationSuccessful = true;
+}
+
+CDirectLPT::~CDirectLPT () {
+	if(porthandle > 0) close(porthandle);
+}
+
+bool CDirectLPT::Putchar(Bit8u val)
+{	
+	//LOG_MSG("putchar: %x",val);
+	Write_CON(0xD4);
+
+	// check if printer online and not busy
+	// PE and Selected: no printer attached
+	Bit8u sr=Read_SR();
+	//LOG_MSG("SR: %x",sr);
+	if((sr&0x30)==0x30)
+	{
+		LOG_MSG("putchar: no printer");
+		return false;
+	}
+	// error
+	if(sr&0x20)
+	{
+		LOG_MSG("putchar: paper out");
+		return false;
+	}
+	if((sr&0x08)==0)
+	{
+		LOG_MSG("putchar: printer error");
+		return false;
+	}
+	// busy
+	Bitu timeout = 10000;
+	Bitu time = timeout+SDL_GetTicks();
+	
+	while(((sr&0x80)==0)&&(SDL_GetTicks()<time))
+	{// wait for the printer to get ready
+		CALLBACK_Idle();
+		sr=Read_SR();
+	}
+	if(SDL_GetTicks()>=time)
+	{
+		LOG_MSG("putchar: busy timeout");
+		return false;
+	}
+	// strobe data out
+	Write_PR(val);
+	//bool wasbusy;
+	
+	// I hope this creates a sufficient long pulse...
+	// (I/O-Bus at 7.15 MHz will give some delay)
+	for(int i = 0; i < 10; i++)
+		Write_CON(0xD5); // strobe pulse
+
+	Write_CON(0xD4); // strobe off
+
+	// wait some time for ack
+	/*
+	Bitu z = 0;
+	bool prevAck=false;
+	while(z<1000)
+	{
+		if((READ_SR()&0x40)==0) prevAck=true;
+		else 
+	}
+	*/
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+	return true;
+}
+Bitu CDirectLPT::Read_PR() {
+	Bitu retval;
+	ioctl(porthandle, PPRDATA, &retval);
+	return retval;
+}
+Bitu CDirectLPT::Read_COM() {
+	Bitu retval;
+	ioctl(porthandle, PPRCONTROL, &retval);
+	return retval;
+}
+Bitu CDirectLPT::Read_SR() {
+	Bitu retval;
+	ioctl(porthandle, PPRSTATUS, &retval);
+	return retval;
+}
+
+void CDirectLPT::Write_PR(Bitu val){
+	ioctl(porthandle, PPWDATA, &val); 
+}
+void CDirectLPT::Write_CON(Bitu val) {
+	ioctl(porthandle, PPWCONTROL, &val); 
+}
+void CDirectLPT::Write_IOSEL(Bitu val) {
+	// switches direction old-style TODO
+	if((val==0xAA)||(val==0x55)) LOG_MSG("TODO implement IBM-style direction switch");
+}
+void CDirectLPT::Timer2(void)
+{
+
+}
+
+
+
+#endif
+#endif
diff -urN dosbox-0.73/src/hardware/parport/directlpt_linux.h dosboxcvs/src/hardware/parport/directlpt_linux.h
--- dosbox-0.73/src/hardware/parport/directlpt_linux.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/directlpt_linux.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,60 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_DIRECTLPT_LINUX_H
+#define DOSBOX_DIRECTLPT_LINUX_H
+
+#include "config.h"
+
+#if C_DIRECTLPT
+#ifdef LINUX
+
+#define DIRECTLPT_AVAILIBLE
+#include "parport.h"
+
+
+class CDirectLPT : public CParallel {
+public:
+	CDirectLPT(Bitu nr, Bit8u initIrq, CommandLine* cmd);
+	
+
+	~CDirectLPT();
+
+	int porthandle;
+	
+	bool interruptflag;
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void Timer2(void);
+};
+
+#endif	// WIN32
+#endif	// C_DIRECTLPT
+#endif	// include guard
diff -urN dosbox-0.73/src/hardware/parport/directlpt_win32.cpp dosboxcvs/src/hardware/parport/directlpt_win32.cpp
--- dosbox-0.73/src/hardware/parport/directlpt_win32.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/directlpt_win32.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,258 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#if C_DIRECTLPT
+
+/* Windows version */
+#if defined (WIN32)
+
+#include "parport.h"
+#include "../../libs/porttalk/porttalk.h"
+#include "directlpt_win32.h"
+#include "callback.h"
+#include <SDL.h> 
+#include "setup.h"
+
+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = false;
+	interruptflag=true; // interrupt disabled
+	realbaseaddress = 0x378;
+
+	std::string str;
+	if(cmd->FindStringBegin("realbase:",str,false)) {
+		if(sscanf(str.c_str(), "%x",&realbaseaddress)!=1) {
+			LOG_MSG("parallel%d: Invalid realbase parameter.",nr);
+			return;
+		} 
+	}
+
+	if(realbaseaddress>=0x10000) {
+		LOG_MSG("Error: Invalid base address.");
+		return;
+	}
+	
+	if(!initPorttalk()) {
+		LOG_MSG("Error: could not open PortTalk driver.");
+		return;
+	}
+	// make sure the user doesn't touch critical I/O-ports
+	if((realbaseaddress<0x100) || (realbaseaddress&0x3) ||		// sanity + mainboard res.
+		((realbaseaddress>=0x1f0)&&(realbaseaddress<=0x1f7)) ||	// prim. HDD controller
+		((realbaseaddress>=0x170)&&(realbaseaddress<=0x177)) ||	// sek. HDD controller
+		((realbaseaddress>=0x3f0)&&(realbaseaddress<=0x3f7)) ||	// floppy + prim. HDD
+		((realbaseaddress>=0x370)&&(realbaseaddress<=0x377))) {	// sek. hdd
+		LOG_MSG("Parallel Port: Invalid base address.");
+		return;
+	}
+	/*	
+	if(realbase!=0x378 && realbase!=0x278 && realbase != 0x3bc)
+	{
+		// TODO PCI ECP ports can be on funny I/O-port-addresses
+		LOG_MSG("Parallel Port: Invalid base address.");
+		return;
+	}*/
+
+	// 0x3bc cannot be a ECP port
+	isECP= ((realbaseaddress&0x7)==0);
+		
+	// add the standard parallel port registers
+	addIOPermission((Bit16u)realbaseaddress);
+	addIOPermission((Bit16u)realbaseaddress+1);
+	addIOPermission((Bit16u)realbaseaddress+2);
+	
+	// if it could be a ECP port: make the extended control register accessible
+	if(isECP)addIOPermission((Bit16u)realbaseaddress+0x402);
+	
+	// bail out if porttalk fails
+	if(!setPermissionList())
+	{
+		LOG_MSG("ERROR SET PERMLIST");
+		return;
+	}
+	if(isECP) {
+		// check if there is a ECP port (try to set bidir)
+		originalECPControlReg = inportb(realbaseaddress+0x402);
+		Bit8u new_bidir = originalECPControlReg&0x1F;
+		new_bidir|=0x20;
+
+		outportb(realbaseaddress+0x402,new_bidir);
+		if(inportb(realbaseaddress+0x402)!=new_bidir) {
+			// this is not a ECP port
+			outportb(realbaseaddress+0x402,originalECPControlReg);
+			isECP=false;
+		}
+	}
+	// check if there is a parallel port at all: the autofeed bit
+	Bit8u controlreg=inportb(realbaseaddress+2);
+	outportb(realbaseaddress+2,controlreg|2);
+	if(!(inportb(realbaseaddress+2)&0x2))
+	{
+		LOG_MSG("No parallel port detected at 0x%x!",realbaseaddress);
+		// cannot remember 1
+		return;
+	}
+	
+	// check 0
+	outportb(realbaseaddress+2,controlreg & ~2);
+	if(inportb(realbaseaddress+2)&0x2)
+	{
+		LOG_MSG("No parallel port detected at 0x%x!",realbaseaddress);
+		// cannot remember 0
+		return;
+	}
+	outportb(realbaseaddress+2,controlreg);
+	
+	if(isECP) LOG_MSG("The port at 0x%x was detected as ECP port.",realbaseaddress);
+	else LOG_MSG("The port at 0x%x is not a ECP port.",realbaseaddress);
+	
+	/*
+	// bidir test
+	outportb(realbase+2,0x20);
+	for(int i = 0; i < 256; i++) {
+		outportb(realbase, i);
+		if(inportb(realbase)!=i) LOG_MSG("NOT %x", i);
+	}
+	*/
+
+	// go for it
+	ack_polarity=false;
+	initialize();
+
+	InstallationSuccessful = true;
+	//LOG_MSG("InstSuccess");
+}
+
+CDirectLPT::~CDirectLPT () {
+	if(InstallationSuccessful && isECP)
+		outportb(realbaseaddress+0x402,originalECPControlReg);
+}
+
+bool CDirectLPT::Putchar(Bit8u val)
+{	
+	//LOG_MSG("putchar: %x",val);
+	Write_CON(0xD4);
+
+	// check if printer online and not busy
+	// PE and Selected: no printer attached
+	Bit8u sr=Read_SR();
+	//LOG_MSG("SR: %x",sr);
+	if((sr&0x30)==0x30)
+	{
+		LOG_MSG("putchar: no printer");
+		return false;
+	}
+	// error
+	if(sr&0x20)
+	{
+		LOG_MSG("putchar: paper out");
+		return false;
+	}
+	if((sr&0x08)==0)
+	{
+		LOG_MSG("putchar: printer error");
+		return false;
+	}
+	// busy
+	Bitu timeout = 10000;
+	Bitu time = timeout+SDL_GetTicks();
+
+	for(int i = 0; i < 150; i++) {
+		// do NOT run into callback_idle unless we have to (speeds things up)
+		sr=Read_SR();
+		if(sr&0x80) break;
+	}
+	
+	while(((sr&0x80)==0)&&(SDL_GetTicks()<time)) {
+		// wait for the printer to get ready
+		CALLBACK_Idle();
+		sr=Read_SR();
+	}
+	if(SDL_GetTicks()>=time) {
+		LOG_MSG("putchar: busy timeout");
+		return false;
+	}
+	// strobe data out
+	Write_PR(val);
+	
+	// I hope this creates a sufficient long pulse...
+	// (I/O-Bus at 7.15 MHz will give some delay)
+	
+	for(int i = 0; i < 8; i++) Write_CON(0xD5); // strobe on
+	Write_CON(0xD4); // strobe off
+
+	// wait some time for ack
+	/*
+	Bitu z = 0;
+	bool prevAck=false;
+	while(z<1000)
+	{
+		if((READ_SR()&0x40)==0) prevAck=true;
+		else 
+	}
+	*/
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+
+	return true;
+}
+Bitu CDirectLPT::Read_PR()
+{
+	return inportb(realbaseaddress);
+}
+Bitu CDirectLPT::Read_COM()
+{
+	Bit8u retval=inportb(realbaseaddress+2);
+	if(!interruptflag)// interrupt activated
+	retval&=~0x10;
+	return retval;
+}
+Bitu CDirectLPT::Read_SR()
+{
+	return inportb(realbaseaddress+1);
+}
+
+void CDirectLPT::Write_PR(Bitu val)
+{
+	//LOG_MSG("%c,%x",(Bit8u)val,val);
+	outportb(realbaseaddress,val);
+}
+void CDirectLPT::Write_CON(Bitu val)
+{
+	//do not activate interrupt
+	interruptflag = (val&0x10)!=0;
+	outportb(realbaseaddress+2,val|0x10);
+}
+void CDirectLPT::Write_IOSEL(Bitu val)
+{
+	outportb(realbaseaddress+1,val);
+}
+void CDirectLPT::Timer2(void)
+{
+
+}
+
+
+
+#endif
+#endif
diff -urN dosbox-0.73/src/hardware/parport/directlpt_win32.h dosboxcvs/src/hardware/parport/directlpt_win32.h
--- dosbox-0.73/src/hardware/parport/directlpt_win32.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/directlpt_win32.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_DIRECTLPT_WIN32_H
+#define DOSBOX_DIRECTLPT_WIN32_H
+
+#include "config.h"
+#include "setup.h"
+
+#if C_DIRECTLPT
+#ifdef WIN32
+
+
+
+#define DIRECTLPT_AVAILIBLE
+#include "parport.h"
+//#include <windows.h>
+
+
+class CDirectLPT : public CParallel {
+public:
+	//HANDLE driverHandle;
+	Bit32u realbaseaddress;
+	Bit8u originalECPControlReg;
+	
+	CDirectLPT(
+			Bitu nr,
+			Bit8u initIrq,
+			CommandLine* cmd
+            );
+	
+
+	~CDirectLPT();
+	
+	bool interruptflag;
+	bool isECP;
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void Timer2(void);
+};
+
+#endif	// WIN32
+#endif	// C_DIRECTLPT
+#endif	// include guard
diff -urN dosbox-0.73/src/hardware/parport/filelpt.cpp dosboxcvs/src/hardware/parport/filelpt.cpp
--- dosbox-0.73/src/hardware/parport/filelpt.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/filelpt.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,138 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#if C_DIRECTLPT
+
+/* Windows version */
+#if defined (WIN32)
+
+#include "parport.h"
+#include "filelpt.h"
+#include "callback.h"
+#include <SDL.h>
+
+CFileLPT::CFileLPT (Bitu nr, Bit8u initIrq, const char* path, CommandLine* cmd)
+                              :CParallel (cmd, nr,initIrq) {
+	InstallationSuccessful = false;
+	InstallationSuccessful = true;
+	//LOG_MSG("InstSuccess");
+}
+
+CFileLPT::~CFileLPT () {
+	// close file
+}
+
+bool CFileLPT::Putchar(Bit8u val)
+{	
+	//LOG_MSG("putchar: %x",val);
+	Write_CON(0xD4);
+
+	// check if printer online and not busy
+	// PE and Selected: no printer attached
+	Bit8u sr=Read_SR();
+	//LOG_MSG("SR: %x",sr);
+	if((sr&0x30)==0x30)
+	{
+		LOG_MSG("putchar: no printer");
+		return false;
+	}
+	// error
+	if(sr&0x20)
+	{
+		LOG_MSG("putchar: paper out");
+		return false;
+	}
+	if((sr&0x08)==0)
+	{
+		LOG_MSG("putchar: printer error");
+		return false;
+	}
+	// busy
+	Bitu timeout = 10000;
+	Bitu time = timeout+SDL_GetTicks();
+	
+	while(((sr&0x80)==0)&&(SDL_GetTicks()<time))
+	{// wait for the printer to get ready
+		CALLBACK_Idle();
+		sr=Read_SR();
+	}
+	if(SDL_GetTicks()>=time)
+	{
+		LOG_MSG("putchar: busy timeout");
+		return false;
+	}
+	// strobe data out
+	Write_PR(val);
+	//bool wasbusy;
+	
+	// I hope this creates a sufficient long pulse...
+	// (I/O-Bus at 7.15 MHz will give some delay)
+	for(int i = 0; i < 10; i++)
+		Write_CON(0xD5); // strobe pulse
+
+	Write_CON(0xD4); // strobe off
+
+	// wait some time for ack
+	/*
+	Bitu z = 0;
+	bool prevAck=false;
+	while(z<1000)
+	{
+		if((READ_SR()&0x40)==0) prevAck=true;
+		else 
+	}
+	*/
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+	return true;
+}
+Bitu CFileLPT::Read_PR()
+{
+	return 0;
+}
+Bitu CFileLPT::Read_COM()
+{
+	return 0;
+}
+Bitu CFileLPT::Read_SR()
+{
+	return 0;
+}
+
+void CFileLPT::Write_PR(Bitu val) {
+	datareg = (Bit8u)val;
+}
+void CFileLPT::Write_CON(Bitu val) {
+
+}
+void CFileLPT::Write_IOSEL(Bitu val) {
+
+}
+void CFileLPT::Timer2(void)
+{
+
+}
+
+#endif
+#endif
diff -urN dosbox-0.73/src/hardware/parport/filelpt.h dosboxcvs/src/hardware/parport/filelpt.h
--- dosbox-0.73/src/hardware/parport/filelpt.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/filelpt.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,56 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+// include guard
+#ifndef DOSBOX_FILELPT_H
+#define DOSBOX_FILELPT_H
+
+#include "dosbox.h"
+#include "parport.h"
+
+class CFileLPT : public CParallel {
+public:
+	CFileLPT(
+			Bitu nr,
+			Bit8u initIrq,
+            const char* path,
+			CommandLine* cmd
+            );
+	
+
+	~CFileLPT();
+	
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	bool ack_polarity;
+
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	Bit8u datareg;
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void Timer2(void);
+};
+
+#endif	// include guard
diff -urN dosbox-0.73/src/hardware/parport/Makefile.am dosboxcvs/src/hardware/parport/Makefile.am
--- dosbox-0.73/src/hardware/parport/Makefile.am	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,10 @@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+
+noinst_LIBRARIES = libparallel.a
+
+libparallel_a_SOURCES = parport.cpp \
+			directlpt_win32.cpp directlpt_win32.h \
+			directlpt_linux.cpp directlpt_linux.h \
+			printer_redir.cpp printer_redir.h printer_if.h \
+			printer.cpp printer.h printer_charmaps.h \
+			filelpt.cpp filelpt.h
diff -urN dosbox-0.73/src/hardware/parport/Makefile.in dosboxcvs/src/hardware/parport/Makefile.in
--- dosbox-0.73/src/hardware/parport/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -0,0 +1,421 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/hardware/parport
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libparallel_a_AR = $(AR) $(ARFLAGS)
+libparallel_a_LIBADD =
+am_libparallel_a_OBJECTS = parport.$(OBJEXT) directlpt_win32.$(OBJEXT) \
+	directlpt_linux.$(OBJEXT) printer_redir.$(OBJEXT) \
+	printer.$(OBJEXT) filelpt.$(OBJEXT)
+libparallel_a_OBJECTS = $(am_libparallel_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libparallel_a_SOURCES)
+DIST_SOURCES = $(libparallel_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WINDRES = @WINDRES@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+noinst_LIBRARIES = libparallel.a
+libparallel_a_SOURCES = parport.cpp \
+			directlpt_win32.cpp directlpt_win32.h \
+			directlpt_linux.cpp directlpt_linux.h \
+			printer_redir.cpp printer_redir.h printer_if.h \
+			printer.cpp printer.h printer_charmaps.h \
+			filelpt.cpp filelpt.h
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/hardware/parport/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/hardware/parport/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libparallel.a: $(libparallel_a_OBJECTS) $(libparallel_a_DEPENDENCIES) 
+	-rm -f libparallel.a
+	$(libparallel_a_AR) libparallel.a $(libparallel_a_OBJECTS) $(libparallel_a_LIBADD)
+	$(RANLIB) libparallel.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directlpt_linux.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directlpt_win32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/filelpt.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parport.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printer.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/printer_redir.Po@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dosbox-0.73/src/hardware/parport/parport.cpp dosboxcvs/src/hardware/parport/parport.cpp
--- dosbox-0.73/src/hardware/parport/parport.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/parport.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,343 @@
+/*
+ *  Copyright (C) 2002-2006  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <string.h>
+#include <ctype.h>
+
+#include "dosbox.h"
+
+#include "support.h"
+#include "inout.h"
+#include "pic.h"
+#include "setup.h"
+#include "timer.h"
+#include "bios.h"					// SetLPTPorts(..)
+#include "hardware.h"				// OpenCaptureFile
+
+#include "parport.h"
+#include "directlpt_win32.h"
+#include "directlpt_linux.h"
+#include "printer_redir.h"
+#include "filelpt.h"
+#include "dos_inc.h"
+
+bool device_LPT::Read(Bit8u * data,Bit16u * size) {
+	*size=0;
+	LOG(LOG_DOSMISC,LOG_NORMAL)("LPTDEVICE:Read called");
+	return true;
+}
+
+
+bool device_LPT::Write(Bit8u * data,Bit16u * size) {
+	for (Bit16u i=0; i<*size; i++)
+	{
+		if(!pportclass->Putchar(data[i])) return false;
+	}
+	return true;
+}
+
+bool device_LPT::Seek(Bit32u * pos,Bit32u type) {
+	*pos = 0;
+	return true;
+}
+
+bool device_LPT::Close() {
+	return false;
+}
+
+Bit16u device_LPT::GetInformation(void) {
+	return 0x80A0;
+};
+const char* lptname[]={"LPT1","LPT2","LPT3"};
+device_LPT::device_LPT(Bit8u num, class CParallel* pp) {
+	pportclass = pp;
+	SetName(lptname[num]);
+	this->num = num;
+}
+
+device_LPT::~device_LPT() {
+	//LOG_MSG("del");
+}
+
+static Bitu PARALLEL_Read (Bitu port, Bitu iolen) {
+	for(Bitu i = 0; i < 3; i++) {
+		if(parallel_baseaddr[i]==(port&0xfffc) && (parallelPortObjects[i]!=0)) {
+			Bitu retval=0xff;
+			switch (port & 0x7) {
+				case 0:
+					retval = parallelPortObjects[i]->Read_PR();
+					break;
+				case 1:
+					retval = parallelPortObjects[i]->Read_SR();
+					break;
+				case 2:
+					retval = parallelPortObjects[i]->Read_COM();
+					break;
+			}
+
+#if PARALLEL_DEBUG
+			const char* const dbgtext[]= {"DAT","STA","COM","???"};
+			parallelPortObjects[i]->log_par(parallelPortObjects[i]->dbg_cregs,
+				"read  0x%2x from %s.",retval,dbgtext[port&3]);
+#endif
+			return retval;	
+		}
+	}
+	return 0xff;
+}
+
+static void PARALLEL_Write (Bitu port, Bitu val, Bitu) {
+	for(Bitu i = 0; i < 4; i++) {
+		if(parallel_baseaddr[i]==(port&0xfffc) && parallelPortObjects[i]) {
+#if PARALLEL_DEBUG
+			const char* const dbgtext[]={"DAT","IOS","CON","???"};
+			parallelPortObjects[i]->log_par(parallelPortObjects[i]->dbg_cregs,
+				"write 0x%2x to %s.",val,dbgtext[port&3]);
+			if(parallelPortObjects[i]->dbg_plaindr &&!(port & 0x3)) {
+				fprintf(parallelPortObjects[i]->debugfp,"%c",val);
+			}
+#endif
+			switch (port & 0x3) {
+				case 0:
+					parallelPortObjects[i]->Write_PR (val);
+					return;
+				case 1:
+					parallelPortObjects[i]->Write_IOSEL (val);
+					return;
+				case 2:
+					parallelPortObjects[i]->Write_CON (val);
+					return;
+			}
+		}
+	}
+}
+
+//The Functions
+
+void CParallel::Timer (void) {
+	Timer2();
+}
+
+#if PARALLEL_DEBUG
+#include <stdarg.h>
+void CParallel::log_par(bool active, char const* format,...) {
+	if(active) {
+		// copied from DEBUG_SHOWMSG
+		char buf[512];
+		buf[0]=0;
+		sprintf(buf,"%12.3f ",PIC_FullIndex());
+		va_list msg;
+		va_start(msg,format);
+		vsprintf(buf+strlen(buf),format,msg);
+		va_end(msg);
+		// Add newline if not present
+		Bitu len=strlen(buf);
+		if(buf[len-1]!='\n') strcat(buf,"\r\n");
+		fputs(buf,debugfp);
+	}
+}
+#endif
+
+// Initialisation
+CParallel::CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq) {
+	base = parallel_baseaddr[portnr];
+	irq = initirq;
+
+#if PARALLEL_DEBUG
+	dbg_data	= cmd->FindExist("dbgdata", false);
+	dbg_putchar = cmd->FindExist("dbgput", false);
+	dbg_cregs	= cmd->FindExist("dbgregs", false);
+	dbg_plainputchar = cmd->FindExist("dbgputplain", false);
+	dbg_plaindr = cmd->FindExist("dbgdataplain", false);
+	
+	if(cmd->FindExist("dbgall", false)) {
+		dbg_data= 
+		dbg_putchar=
+		dbg_cregs=true;
+		dbg_plainputchar=dbg_plaindr=false;
+	}
+
+	if(dbg_data||dbg_putchar||dbg_cregs||dbg_plainputchar||dbg_plaindr)
+		debugfp=OpenCaptureFile("parlog",".parlog.txt");
+	else debugfp=0;
+
+	if(debugfp == 0) {
+		dbg_data= 
+		dbg_putchar=dbg_plainputchar=
+		dbg_cregs=false;
+	} else {
+		std::string cleft;
+		cmd->GetStringRemain(cleft);
+
+		log_par(true,"Parallel%d: BASE %xh, initstring \"%s\"\r\n\r\n",
+			portnr+1,base,cleft.c_str());
+	}
+#endif
+
+	for (Bitu i = 0; i < 3; i++) {
+		WriteHandler[i].Install (i + base, PARALLEL_Write, IO_MB);
+		ReadHandler[i].Install (i + base, PARALLEL_Read, IO_MB);
+	}
+	mydosdevice=new device_LPT(portnr, this);
+	DOS_AddDevice(mydosdevice);
+};
+
+CParallel::~CParallel(void) {
+	if(mydosdevice) DOS_DelDevice(mydosdevice);
+};
+
+Bit8u CParallel::getPrinterStatus()
+{
+	/*	7      not busy
+		6      acknowledge
+		5      out of paper
+		4      selected
+		3      I/O error
+		2-1    unused
+		0      timeout  */
+	Bit8u statusreg=Read_SR();
+
+	//LOG_MSG("get printer status: %x",statusreg);
+	statusreg^=0x48;
+	return statusreg&~0x7;
+}
+
+#include "callback.h"
+
+void RunIdleTime(Bitu milliseconds)
+{
+	Bitu time=SDL_GetTicks()+milliseconds;
+	while(SDL_GetTicks()<time)
+		CALLBACK_Idle();
+}
+
+void CParallel::initialize()
+{
+	Write_IOSEL(0x55); // output mode
+	Write_CON(0xD0); // init on
+	Write_PR(0);
+	RunIdleTime(10);
+	Write_CON(0xD4); // init off
+	RunIdleTime(500);
+	//LOG_MSG("printer init");
+}
+
+
+
+CParallel* parallelPortObjects[3];
+class PARPORTS:public Module_base {
+public:
+	
+	PARPORTS (Section * configuration):Module_base (configuration) {
+
+#if C_PRINTER
+		bool printer_used = false;
+#endif
+
+		// default ports & interrupts
+		Bit8u defaultirq[] = { 7, 5, 12};
+		Bit16u biosParameter[3] = { 0, 0, 0};
+		Section_prop *section = static_cast <Section_prop*>(configuration);
+		
+		char pname[]="parallelx";
+		// iterate through all 3 lpt ports
+		for (Bitu i = 0; i < 3; i++) {
+			pname[8] = '1' + i;
+			CommandLine cmd(0,section->Get_string(pname));
+
+			std::string str;
+			cmd.FindCommand(1,str);
+#ifdef C_DIRECTLPT			
+			if(str=="reallpt") {
+				CDirectLPT* cdlpt= new CDirectLPT(i, defaultirq[i],&cmd);
+				if(cdlpt->InstallationSuccessful)
+					parallelPortObjects[i]=cdlpt;
+				else {
+					delete cdlpt;
+					parallelPortObjects[i]=0;
+				}
+			}
+			else 
+#endif
+	/*		else if(!str.compare("filelpt")) {
+				const char* path;
+				if(cmd->FindStringBegin("file:",str,false)) {
+					path = str.c_str();
+				 
+				} else continue;
+
+				CFileLPT* cflpt= new CFileLPT(parallelReadHandlers[i], 
+						parallelWriteHandlers[i],parallelTimerHandlers[i],
+						baseAddress,defaultirq[i], i,path);
+				if(cflpt->InstallationSuccessful)
+					parallelPortObjects[i]=cflpt;
+				else {
+					delete cflpt;
+					parallelPortObjects[i]=0;
+				}
+			}
+			else */
+#if C_PRINTER
+			if(str=="printer") {
+				if(printer_used) {
+					
+				}; // only one parallel port with printer
+				CPrinterRedir* cprd = new CPrinterRedir(i,defaultirq[i],&cmd);
+				if(cprd->InstallationSuccessful) {
+					parallelPortObjects[i]=cprd;
+					printer_used=true;
+				} else {
+					LOG_MSG("Error: printer is not enabled.");
+					delete cprd;
+					parallelPortObjects[i]=0;
+				}
+			} else
+#endif				
+			if(str=="disabled") {
+				parallelPortObjects[i] = 0;
+			} else {
+				LOG_MSG ("Invalid type for LPT%d.", i + 1);
+				parallelPortObjects[i] = 0;
+			}
+			if(parallelPortObjects[i]) biosParameter[i] = parallel_baseaddr[i];
+		} // for lpt 1-3
+		BIOS_SetLPTPorts (biosParameter);
+	}
+
+	~PARPORTS () {
+		for (Bitu i = 0; i < 3; i++)
+			if (parallelPortObjects[i]) {
+				delete parallelPortObjects[i];
+				parallelPortObjects[i] = 0;
+			}
+	}
+};
+
+static PARPORTS *testParallelPortsBaseclass;
+
+void PARALLEL_Destroy (Section * sec) {
+	delete testParallelPortsBaseclass;
+	testParallelPortsBaseclass = NULL;
+}
+
+void PARALLEL_Init (Section * sec) {
+	// should never happen
+	if (testParallelPortsBaseclass) delete testParallelPortsBaseclass;
+	testParallelPortsBaseclass = new PARPORTS (sec);
+	sec->AddDestroyFunction (&PARALLEL_Destroy, true);
+}
diff -urN dosbox-0.73/src/hardware/parport/printer_charmaps.h dosboxcvs/src/hardware/parport/printer_charmaps.h
--- dosbox-0.73/src/hardware/parport/printer_charmaps.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer_charmaps.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,289 @@
+// Various ASCII codepage to unicode maps
+
+static const Bit16u cp437Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00a2,0x00a3,0x00a5,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp737Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0391,0x0392,0x0393,0x0394,0x0395,0x0396,0x0397,0x0398,0x0399,0x039a,0x039b,0x039c,0x039d,0x039e,0x039f,0x03a0,
+0x03a1,0x03a3,0x03a4,0x03a5,0x03a6,0x03a7,0x03a8,0x03a9,0x03b1,0x03b2,0x03b3,0x03b4,0x03b5,0x03b6,0x03b7,0x03b8,
+0x03b9,0x03ba,0x03bb,0x03bc,0x03bd,0x03be,0x03bf,0x03c0,0x03c1,0x03c3,0x03c2,0x03c4,0x03c5,0x03c6,0x03c7,0x03c8,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03c9,0x03ac,0x03ad,0x03ae,0x03ca,0x03af,0x03cc,0x03cd,0x03cb,0x03ce,0x0386,0x0388,0x0389,0x038a,0x038c,0x038e,
+0x038f,0x00b1,0x2265,0x2264,0x03aa,0x03ab,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp775Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0106,0x00fc,0x00e9,0x0101,0x00e4,0x0123,0x00e5,0x0107,0x0142,0x0113,0x0156,0x0157,0x012b,0x0179,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x014d,0x00f6,0x0122,0x00a2,0x015a,0x015b,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x00d7,0x00a4,
+0x0100,0x012a,0x00f3,0x017b,0x017c,0x017a,0x201d,0x00a6,0x00a9,0x00ae,0x00ac,0x00bd,0x00bc,0x0141,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x0104,0x010c,0x0118,0x0116,0x2563,0x2551,0x2557,0x255d,0x012e,0x0160,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x0172,0x016a,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x017d,
+0x0105,0x010d,0x0119,0x0117,0x012f,0x0161,0x0173,0x016b,0x017e,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x00d3,0x00df,0x014c,0x0143,0x00f5,0x00d5,0x00b5,0x0144,0x0136,0x0137,0x013b,0x013c,0x0146,0x0112,0x0145,0x2019,
+0x00ad,0x00b1,0x201c,0x00be,0x00b6,0x00a7,0x00f7,0x201e,0x00b0,0x2219,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp850Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x00d7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x00ae,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x00c0,0x00a9,0x2563,0x2551,0x2557,0x255d,0x00a2,0x00a5,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x00e3,0x00c3,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x00f0,0x00d0,0x00ca,0x00cb,0x00c8,0x0131,0x00cd,0x00ce,0x00cf,0x2518,0x250c,0x2588,0x2584,0x00a6,0x00cc,0x2580,
+0x00d3,0x00df,0x00d4,0x00d2,0x00f5,0x00d5,0x00b5,0x00fe,0x00de,0x00da,0x00db,0x00d9,0x00fd,0x00dd,0x00af,0x00b4,
+0x00ad,0x00b1,0x2017,0x00be,0x00b6,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp852Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x016f,0x0107,0x00e7,0x0142,0x00eb,0x0150,0x0151,0x00ee,0x0179,0x00c4,0x0106,
+0x00c9,0x0139,0x013a,0x00f4,0x00f6,0x013d,0x013e,0x015a,0x015b,0x00d6,0x00dc,0x0164,0x0165,0x0141,0x00d7,0x010d,
+0x00e1,0x00ed,0x00f3,0x00fa,0x0104,0x0105,0x017d,0x017e,0x0118,0x0119,0x00ac,0x017a,0x010c,0x015f,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x011a,0x015e,0x2563,0x2551,0x2557,0x255d,0x017b,0x017c,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x0102,0x0103,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x0111,0x0110,0x010e,0x00cb,0x010f,0x0147,0x00cd,0x00ce,0x011b,0x2518,0x250c,0x2588,0x2584,0x0162,0x016e,0x2580,
+0x00d3,0x00df,0x00d4,0x0143,0x0144,0x0148,0x0160,0x0161,0x0154,0x00da,0x0155,0x0170,0x00fd,0x00dd,0x0163,0x00b4,
+0x00ad,0x02dd,0x02db,0x02c7,0x02d8,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x02d9,0x0171,0x0158,0x0159,0x25a0,0x00a0
+};
+
+static const Bit16u cp855Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0452,0x0402,0x0453,0x0403,0x0451,0x0401,0x0454,0x0404,0x0455,0x0405,0x0456,0x0406,0x0457,0x0407,0x0458,0x0408,
+0x0459,0x0409,0x045a,0x040a,0x045b,0x040b,0x045c,0x040c,0x045e,0x040e,0x045f,0x040f,0x044e,0x042e,0x044a,0x042a,
+0x0430,0x0410,0x0431,0x0411,0x0446,0x0426,0x0434,0x0414,0x0435,0x0415,0x0444,0x0424,0x0433,0x0413,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x0445,0x0425,0x0438,0x0418,0x2563,0x2551,0x2557,0x255d,0x0439,0x0419,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x043a,0x041a,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x043b,0x041b,0x043c,0x041c,0x043d,0x041d,0x043e,0x041e,0x043f,0x2518,0x250c,0x2588,0x2584,0x041f,0x044f,0x2580,
+0x042f,0x0440,0x0420,0x0441,0x0421,0x0442,0x0422,0x0443,0x0423,0x0436,0x0416,0x0432,0x0412,0x044c,0x042c,0x2116,
+0x00ad,0x044b,0x042b,0x0437,0x0417,0x0448,0x0428,0x044d,0x042d,0x0449,0x0429,0x0447,0x0427,0x00a7,0x25a0,0x00a0
+};
+
+static const Bit16u cp857Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x0131,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x0130,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x015e,0x015f,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x011e,0x011f,0x00bf,0x00ae,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x00c1,0x00c2,0x00c0,0x00a9,0x2563,0x2551,0x2557,0x255d,0x00a2,0x00a5,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x00e3,0x00c3,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x00a4,
+0x00ba,0x00aa,0x00ca,0x00cb,0x00c8,0x0000,0x00cd,0x00ce,0x00cf,0x2518,0x250c,0x2588,0x2584,0x00a6,0x00cc,0x2580,
+0x00d3,0x00df,0x00d4,0x00d2,0x00f5,0x00d5,0x00b5,0x0000,0x00d7,0x00da,0x00db,0x00d9,0x00ec,0x00ff,0x00af,0x00b4,
+0x00ad,0x00b1,0x0000,0x00be,0x00b6,0x00a7,0x00f7,0x00b8,0x00b0,0x00a8,0x00b7,0x00b9,0x00b3,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp860Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e3,0x00e0,0x00c1,0x00e7,0x00ea,0x00ca,0x00e8,0x00cd,0x00d4,0x00ec,0x00c3,0x00c2,
+0x00c9,0x00c0,0x00c8,0x00f4,0x00f5,0x00f2,0x00da,0x00f9,0x00cc,0x00d5,0x00dc,0x00a2,0x00a3,0x00d9,0x20a7,0x00d3,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x00d2,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp861Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00d0,0x00f0,0x00de,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00fe,0x00fb,0x00dd,0x00fd,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00c1,0x00cd,0x00d3,0x00da,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp862Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x05d0,0x05d1,0x05d2,0x05d3,0x05d4,0x05d5,0x05d6,0x05d7,0x05d8,0x05d9,0x05da,0x05db,0x05dc,0x05dd,0x05de,0x05df,
+0x05e0,0x05e1,0x05e2,0x05e3,0x05e4,0x05e5,0x05e6,0x05e7,0x05e8,0x05e9,0x05ea,0x00a2,0x00a3,0x00a5,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp863Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00c2,0x00e0,0x00b6,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x2017,0x00c0,0x00a7,
+0x00c9,0x00c8,0x00ca,0x00f4,0x00cb,0x00cf,0x00fb,0x00f9,0x00a4,0x00d4,0x00dc,0x00a2,0x00a3,0x00d9,0x00db,0x0192,
+0x00a6,0x00b4,0x00f3,0x00fa,0x00a8,0x00b8,0x00b3,0x00af,0x00ce,0x2310,0x00ac,0x00bd,0x00bc,0x00be,0x00ab,0x00bb,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp864Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x066a,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00b0,0x00b7,0x2219,0x221a,0x2592,0x2500,0x2502,0x253c,0x2524,0x252c,0x251c,0x2534,0x2510,0x250c,0x2514,0x2518,
+0x03b2,0x221e,0x03c6,0x00b1,0x00bd,0x00bc,0x2248,0x00ab,0x00bb,0xfef7,0xfef8,0x0000,0x0000,0xfefb,0xfefc,0x0000,
+0x00a0,0x00ad,0xfe82,0x00a3,0x00a4,0xfe84,0x0000,0x0000,0xfe8e,0xfe8f,0xfe95,0xfe99,0x060c,0xfe9d,0xfea1,0xfea5,
+0x0660,0x0661,0x0662,0x0663,0x0664,0x0665,0x0666,0x0667,0x0668,0x0669,0xfed1,0x061b,0xfeb1,0xfeb5,0xfeb9,0x061f,
+0x00a2,0xfe80,0xfe81,0xfe83,0xfe85,0xfeca,0xfe8b,0xfe8d,0xfe91,0xfe93,0xfe97,0xfe9b,0xfe9f,0xfea3,0xfea7,0xfea9,
+0xfeab,0xfead,0xfeaf,0xfeb3,0xfeb7,0xfebb,0xfebf,0xfec1,0xfec5,0xfecb,0xfecf,0x00a6,0x00ac,0x00f7,0x00d7,0xfec9,
+0x0640,0xfed3,0xfed7,0xfedb,0xfedf,0xfee3,0xfee7,0xfeeb,0xfeed,0xfeef,0xfef3,0xfebd,0xfecc,0xfece,0xfecd,0xfee1,
+0xfe7d,0x0651,0xfee5,0xfee9,0xfeec,0xfef0,0xfef2,0xfed0,0xfed5,0xfef5,0xfef6,0xfedd,0xfed9,0xfef1,0x25a0,
+};
+
+static const Bit16u cp865Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x00c7,0x00fc,0x00e9,0x00e2,0x00e4,0x00e0,0x00e5,0x00e7,0x00ea,0x00eb,0x00e8,0x00ef,0x00ee,0x00ec,0x00c4,0x00c5,
+0x00c9,0x00e6,0x00c6,0x00f4,0x00f6,0x00f2,0x00fb,0x00f9,0x00ff,0x00d6,0x00dc,0x00f8,0x00a3,0x00d8,0x20a7,0x0192,
+0x00e1,0x00ed,0x00f3,0x00fa,0x00f1,0x00d1,0x00aa,0x00ba,0x00bf,0x2310,0x00ac,0x00bd,0x00bc,0x00a1,0x00ab,0x00a4,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x03b1,0x00df,0x0393,0x03c0,0x03a3,0x03c3,0x00b5,0x03c4,0x03a6,0x0398,0x03a9,0x03b4,0x221e,0x03c6,0x03b5,0x2229,
+0x2261,0x00b1,0x2265,0x2264,0x2320,0x2321,0x00f7,0x2248,0x00b0,0x2219,0x00b7,0x221a,0x207f,0x00b2,0x25a0,0x00a0
+};
+
+static const Bit16u cp866Map[256] = {
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,
+0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041a,0x041b,0x041c,0x041d,0x041e,0x041f,
+0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042a,0x042b,0x042c,0x042d,0x042e,0x042f,
+0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043a,0x043b,0x043c,0x043d,0x043e,0x043f,
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,
+0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044a,0x044b,0x044c,0x044d,0x044e,0x044f,
+0x0401,0x0451,0x0404,0x0454,0x0407,0x0457,0x040e,0x045e,0x00b0,0x2219,0x00b7,0x221a,0x2116,0x00a4,0x25a0,0x00a0
+};
+
+static const Bit16u codepages[15] = {0, 437, 932, 850, 851, 853, 855, 860, 863, 865, 852, 857, 862, 864, 866};
+
+// TODO: Implement all international charsets
+static const Bit16u intCharSets[15][12] =
+{
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e}, // USA
+	{0x0023, 0x0024, 0x00e0, 0x00ba, 0x00e7, 0x00a7, 0x005e, 0x0060, 0x00e9, 0x00f9, 0x00e8, 0x00a8}, // France
+	{0x0023, 0x0024, 0x00a7, 0x00c4, 0x00d6, 0x00dc, 0x005e, 0x0060, 0x00e4, 0x00f6, 0x00fc, 0x00df}, // Germany
+	{0x00a3, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e}, // UK
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x0040, 0x005b, 0x005c, 0x005d, 0x005e, 0x0060, 0x007b, 0x007c, 0x007d, 0x007e},
+	{0x0023, 0x0024, 0x00a7, 0x00c4, 0x0027, 0x0022, 0x00b6, 0x0060, 0x00a9, 0x00ae, 0x2020, 0x2122} // Legal
+};
diff -urN dosbox-0.73/src/hardware/parport/printer.cpp dosboxcvs/src/hardware/parport/printer.cpp
--- dosbox-0.73/src/hardware/parport/printer.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,2099 @@
+/*
+ *  Copyright (C) 2002-2004  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "printer.h"
+
+#if C_PRINTER
+
+#include <math.h>
+#include "setup.h"
+#include "mapper.h"
+#include "printer_if.h"
+#include "support.h"
+
+#include "pic.h" // for timeout
+
+extern void GFX_CaptureMouse(void);
+extern bool mouselocked;
+
+static CPrinter* defaultPrinter = NULL;
+
+#define PARAM16(I) (params[I+1]*256+params[I])
+#define PIXX ((Bitu)floor(curX*dpi+0.5))
+#define PIXY ((Bitu)floor(curY*dpi+0.5))
+
+static Bit16u confdpi, confwidth, confheight;
+static Bitu printer_timout;
+static bool timeout_dirty;
+static const char* document_path;
+//static const char* font_path;
+static char confoutputDevice[50];
+static bool confmultipageOutput;
+
+#include "printer_charmaps.h"
+
+void CPrinter::FillPalette(Bit8u redmax, Bit8u greenmax, Bit8u bluemax, Bit8u colorID, SDL_Palette* pal)
+{
+	float red=redmax/30.9;
+	float green=greenmax/30.9;
+	float blue=bluemax/30.9;
+
+	Bit8u colormask=colorID<<=5;
+
+	for(int i = 0; i < 32;i++) {
+		pal->colors[i+colormask].r=255-(red*(float)i);
+		pal->colors[i+colormask].g=255-(green*(float)i);
+		pal->colors[i+colormask].b=255-(blue*(float)i);
+	}
+}
+
+CPrinter::CPrinter(Bit16u dpi, Bit16u width, Bit16u height, char* output, bool multipageOutput) 
+{
+	if (FT_Init_FreeType(&FTlib))
+	{
+		LOG(LOG_MISC,LOG_ERROR)("PRINTER: Unable to init Freetype2. Printing disabled");
+		page = NULL;
+	}
+	else
+	{
+		this->dpi = dpi;
+		this->output = output;
+		this->multipageOutput = multipageOutput;
+
+		defaultPageWidth = (Real64)width/(Real64)10;
+		defaultPageHeight = (Real64)height/(Real64)10;
+
+		// Create page
+		page = SDL_CreateRGBSurface(
+						SDL_SWSURFACE, 
+						(Bitu)(defaultPageWidth*dpi), 
+						(Bitu)(defaultPageHeight*dpi), 
+						8, 
+						0, 
+						0, 
+						0, 
+						0);
+
+		// Set a grey palette
+		SDL_Palette* palette = page->format->palette;
+		
+		for (Bitu i=0; i<32; i++)
+		{
+			palette->colors[i].r =255;
+			palette->colors[i].g =255;
+			palette->colors[i].b =255;
+		}
+		// 0 = all white needed for logic 000
+		FillPalette(  0,   0,   0, 1, palette);
+		// 1 = magenta* 001
+		FillPalette(  0, 255,   0, 1, palette);
+		// 2 = cyan*    010
+		FillPalette(255,   0,   0, 2, palette);
+		// 3 = "violet" 011
+		FillPalette(255, 255,   0, 3, palette);
+		// 4 = yellow*  100
+		FillPalette(  0,   0, 255, 4, palette);
+		// 5 = red      101
+		FillPalette(  0, 255, 255, 5, palette);
+		// 6 = green    110
+		FillPalette(255,   0, 255, 6, palette);
+		// 7 = black    111
+		FillPalette(255, 255, 255, 7, palette);
+
+		// yyyxxxxx bit pattern: yyy=color xxxxx = intensity: 31=max
+		// Printing colors on top of each other ORs them and gets the
+		// correct resulting color.
+		// i.e. magenta on blank page yyy=001
+		// then yellow on magenta 001 | 100 = 101 = red
+		
+		color=COLOR_BLACK;
+		
+		curFont = NULL;
+		charRead = false;
+		autoFeed = false;
+		outputHandle = NULL;
+
+		resetPrinter();
+
+		if (strcasecmp(output, "printer") == 0)
+		{
+#if defined (WIN32)
+			// Show Print dialog to obtain a printer device context
+
+			PRINTDLG pd;
+			pd.lStructSize = sizeof(PRINTDLG); 
+			pd.hDevMode = (HANDLE) NULL; 
+			pd.hDevNames = (HANDLE) NULL; 
+			pd.Flags = PD_RETURNDC; 
+			pd.hwndOwner = NULL; 
+			pd.hDC = (HDC) NULL; 
+			pd.nFromPage = 1; 
+			pd.nToPage = 1; 
+			pd.nMinPage = 0; 
+			pd.nMaxPage = 0; 
+			pd.nCopies = 1; 
+			pd.hInstance = NULL; 
+			pd.lCustData = 0L; 
+			pd.lpfnPrintHook = (LPPRINTHOOKPROC) NULL; 
+			pd.lpfnSetupHook = (LPSETUPHOOKPROC) NULL; 
+			pd.lpPrintTemplateName = (LPSTR) NULL; 
+			pd.lpSetupTemplateName = (LPSTR)  NULL; 
+			pd.hPrintTemplate = (HANDLE) NULL; 
+			pd.hSetupTemplate = (HANDLE) NULL; 
+			PrintDlg(&pd);
+			// TODO: what if user presses cancel?
+			printerDC = pd.hDC;
+#endif
+		}
+		LOG(LOG_MISC,LOG_NORMAL)("PRINTER: Enabled");
+	}
+};
+
+void CPrinter::resetPrinterHard()
+{
+	charRead = false;
+	resetPrinter();
+}
+
+void CPrinter::resetPrinter()
+{
+		color=COLOR_BLACK;
+		curX = curY = 0.0;
+		ESCSeen = false;
+		FSSeen = false;
+		ESCCmd = 0;
+		numParam = neededParam = 0;
+		topMargin = 0.0;
+		leftMargin = 0.0;
+		rightMargin = pageWidth = defaultPageWidth;
+		bottomMargin = pageHeight = defaultPageHeight;
+		lineSpacing = (Real64)1/6;
+		cpi = 10.0;
+		curCharTable = 1;
+		style = 0;
+		extraIntraSpace = 0.0;
+		printUpperContr = true;
+		bitGraph.remBytes = 0;
+		densk = 0;
+		densl = 1;
+		densy = 2;
+		densz = 3;
+		charTables[0] = 0; // Italics
+		charTables[1] = charTables[2] = charTables[3] = 437;
+		definedUnit = -1;
+		multipoint = false;
+		multiPointSize = 0.0;
+		multicpi = 0.0;
+		hmi = -1.0;
+		msb = 255;
+		numPrintAsChar = 0;
+		LQtypeFace = roman;
+
+		selectCodepage(charTables[curCharTable]);
+
+		updateFont();
+
+		newPage(false,true);
+
+		// Default tabs => Each eight characters
+		for (Bitu i=0;i<32;i++)
+			horiztabs[i] = i*8*(1/(Real64)cpi);
+		numHorizTabs = 32;
+
+		numVertTabs = 255;
+}
+
+
+CPrinter::~CPrinter(void)
+{
+	finishMultipage();
+	if (page != NULL)
+	{
+		SDL_FreeSurface(page);
+		page = NULL;
+		FT_Done_FreeType(FTlib);
+	}
+#if defined (WIN32)
+	DeleteDC(printerDC);
+#endif
+};
+
+void CPrinter::selectCodepage(Bit16u cp)
+{
+	Bit16u *mapToUse = NULL;
+
+	switch(cp)
+	{
+	case 0: // Italics, use cp437
+	case 437:
+		mapToUse = (Bit16u*)&cp437Map;
+		break;
+	case 737:
+		mapToUse = (Bit16u*)&cp737Map;
+		break;
+	case 775:
+		mapToUse = (Bit16u*)&cp775Map;
+		break;
+	case 850:
+		mapToUse = (Bit16u*)&cp850Map;
+		break;
+	case 852:
+		mapToUse = (Bit16u*)&cp852Map;
+		break;
+	case 855:
+		mapToUse = (Bit16u*)&cp855Map;
+		break;
+	case 857:
+		mapToUse = (Bit16u*)&cp857Map;
+		break;
+	case 860:
+		mapToUse = (Bit16u*)&cp860Map;
+		break;
+	case 861:
+		mapToUse = (Bit16u*)&cp861Map;
+		break;
+	case 863:
+		mapToUse = (Bit16u*)&cp863Map;
+		break;
+	case 864:
+		mapToUse = (Bit16u*)&cp864Map;
+		break;
+	case 865:
+		mapToUse = (Bit16u*)&cp865Map;
+		break;
+	case 866:
+		mapToUse = (Bit16u*)&cp866Map;
+		break;
+	default:
+		LOG(LOG_MISC,LOG_WARN)("Unsupported codepage %i. Using CP437 instead.", cp);
+		mapToUse = (Bit16u*)&cp437Map;
+	}
+
+	for (int i=0; i<256; i++)
+		curMap[i] = mapToUse[i];
+}
+
+void CPrinter::updateFont()
+{
+	//	char buffer[1000]; 
+
+	if (curFont != NULL)
+		FT_Done_Face(curFont);
+
+	const char* fontName;
+
+	switch (LQtypeFace)
+	{
+	case roman:
+		fontName = "roman.ttf";
+		break;
+	case sansserif:
+		fontName = "sansserif.ttf";
+		break;
+	case courier:
+		fontName = "courier.ttf";
+		break;
+	case script:
+		fontName = "script.ttf";
+		break;
+	case ocra:
+	case ocrb:
+		fontName = "ocra.ttf";
+		break;
+	default:
+		fontName = "roman.ttf";
+	}
+	
+	if (FT_New_Face(FTlib, fontName, 0, &curFont))
+	{
+		//LOG(LOG_MISC,LOG_ERROR)("Unable to load font %s", fontName);
+		LOG_MSG("Unable to load font %s", fontName);
+		curFont = NULL;
+	}
+
+	Real64 horizPoints = 10.5;
+	Real64 vertPoints = 10.5;
+
+	if (!multipoint)
+	{
+		actcpi = cpi;
+	
+		if (cpi != 10 && !(style & STYLE_CONDENSED))
+		{
+			horizPoints *= (Real64)10/(Real64)cpi;
+			vertPoints *= (Real64)10/(Real64)cpi;
+		}
+
+		if (!style & STYLE_PROP)
+		{
+			if (cpi == 10 && (style & STYLE_CONDENSED))
+			{
+				actcpi = 17.14;
+				horizPoints *= (Real64)10/(Real64)17.14;
+				vertPoints *= (Real64)10/(Real64)17.14;
+			}
+		
+			if (cpi == 12 && (style & STYLE_CONDENSED))
+			{
+				actcpi = 20.0;
+				horizPoints *= (Real64)10/(Real64)20.0;
+				vertPoints *= (Real64)10/(Real64)20.0;
+			}	
+		}
+
+		if (style & (STYLE_PROP | STYLE_CONDENSED))
+		{
+			horizPoints /= (Real64)2.0;
+			vertPoints /= (Real64)2.0;
+		}
+
+		if ((style & STYLE_DOUBLEWIDTH) || (style & STYLE_DOUBLEWIDTHONELINE))
+		{
+			actcpi /= 2;
+			horizPoints *= (Real64)2.0;
+		}
+
+		if (style & STYLE_DOUBLEHEIGHT)
+			vertPoints *= (Real64)2.0;
+	}
+	else
+	{
+		actcpi = multicpi;
+		horizPoints = vertPoints = multiPointSize;
+	}
+
+	if ((style & STYLE_SUPERSCRIPT) || (style & STYLE_SUBSCRIPT))
+	{
+		horizPoints *= (Real64)2/(Real64)3;
+		vertPoints *= (Real64)2/(Real64)3;
+		actcpi /= (Real64)2/(Real64)3;
+	}
+
+
+	FT_Set_Char_Size(curFont, (Bit16u)horizPoints*64, (Bit16u)vertPoints*64, dpi, dpi);
+	
+	if (style & STYLE_ITALICS || charTables[curCharTable] == 0)
+	{
+		FT_Matrix  matrix;
+		matrix.xx = 0x10000L;
+		matrix.xy = (FT_Fixed)(0.20 * 0x10000L);
+		matrix.yx = 0;
+		matrix.yy = 0x10000L;
+		FT_Set_Transform(curFont, &matrix, 0);
+	}
+}
+
+bool CPrinter::processCommandChar(Bit8u ch)
+{
+	if (ESCSeen || FSSeen)
+	{
+		ESCCmd = ch;
+		if(FSSeen) ESCCmd |= 0x800;
+		ESCSeen = FSSeen = false;
+		numParam = 0;
+
+		switch (ESCCmd) {
+		case 0x02: // Undocumented
+		case 0x0a: // Reverse line feed											(ESC LF)
+		case 0x0c: // Return to top of current page								(ESC FF)
+		case 0x0e: // Select double-width printing (one line)					(ESC SO)		
+		case 0x0f: // Select condensed printing									(ESC SI)
+		case 0x23: // Cancel MSB control										(ESC #)
+		case 0x30: // Select 1/8-inch line spacing								(ESC 0)
+		case 0x31: // Select 7/60-inch line spacing								(ESC 1)
+		case 0x32: // Select 1/6-inch line spacing								(ESC 2)
+		case 0x34: // Select italic font										(ESC 4)
+		case 0x35: // Cancel italic font										(ESC 5)
+		case 0x36: // Enable printing of upper control codes					(ESC 6)
+		case 0x37: // Enable upper control codes								(ESC 7)
+		case 0x38: // Disable paper-out detector								(ESC 8)
+		case 0x39: // Enable paper-out detector									(ESC 9)
+		case 0x3c: // Unidirectional mode (one line)							(ESC <)
+		case 0x3d: // Set MSB to 0												(ESC =)
+		case 0x3e: // Set MSB to 1												(ESC >)
+		case 0x40: // Initialize printer										(ESC @)
+		case 0x45: // Select bold font											(ESC E)
+		case 0x46: // Cancel bold font											(ESC F)
+		case 0x47: // Select double-strike printing								(ESC G)
+		case 0x48: // Cancel double-strike printing								(ESC H)
+		case 0x4d: // Select 10.5-point, 12-cpi									(ESC M)
+		case 0x4f: // Cancel bottom margin [conflict]							(ESC O)
+		case 0x50: // Select 10.5-point, 10-cpi									(ESC P)
+		case 0x54: // Cancel superscript/subscript printing						(ESC T)
+		case 0x5e: // Enable printing of all character codes on next character	(ESC ^)
+		case 0x67: // Select 10.5-point, 15-cpi									(ESC g)
+
+		case 0x834: // Select italic font								(FS 4)	(= ESC 4)
+		case 0x835: // Cancel italic font								(FS 5)	(= ESC 5)
+		case 0x846: // Select forward feed mode							(FS F)
+		case 0x852: // Select reverse feed mode							(FS R)
+			neededParam = 0;
+			break;
+		case 0x19: // Control paper loading/ejecting							(ESC EM)
+		case 0x20: // Set intercharacter space									(ESC SP)
+		case 0x21: // Master select												(ESC !)
+		case 0x2b: // Set n/360-inch line spacing								(ESC +)
+		case 0x2d: // Turn underline on/off										(ESC -)
+		case 0x2f: // Select vertical tab channel								(ESC /)
+		case 0x33: // Set n/180-inch line spacing								(ESC 3)
+		case 0x41: // Set n/60-inch line spacing								(ESC A)
+		case 0x43: // Set page length in lines									(ESC C)
+		case 0x49: // Select character type and print pitch						(ESC I)
+		case 0x4a: // Advance print position vertically							(ESC J)
+		case 0x4e: // Set bottom margin											(ESC N)
+		case 0x51: // Set right margin											(ESC Q)
+		case 0x52: // Select an international character set						(ESC R)
+		case 0x53: // Select superscript/subscript printing						(ESC S)
+		case 0x55: // Turn unidirectional mode on/off							(ESC U)
+		//case 0x56: // Repeat data												(ESC V)
+		case 0x57: // Turn double-width printing on/off							(ESC W)
+		case 0x61: // Select justification										(ESC a)
+		case 0x66: // Absolute horizontal tab in columns [conflict]				(ESC f)
+		case 0x68: // Select double or quadruple size							(ESC h)
+		case 0x69: // Immediate print											(ESC i)
+		case 0x6a: // Reverse paper feed										(ESC j)
+		case 0x6b: // Select typeface											(ESC k)
+		case 0x6c: // Set left margin											(ESC 1)
+		case 0x70: // Turn proportional mode on/off								(ESC p)
+		case 0x72: // Select printing color										(ESC r)
+		case 0x73: // Low-speed mode on/off										(ESC s)
+		case 0x74: // Select character table									(ESC t)
+		case 0x77: // Turn double-height printing on/off						(ESC w)
+		case 0x78: // Select LQ or draft										(ESC x)
+		case 0x7e: // Select/Deselect slash zero								(ESC ~)
+
+		case 0x832: // Select 1/6-inch line spacing						(FS 2)	(= ESC 2)
+		case 0x833: // Set n/360-inch line spacing						(FS 3)	(= ESC +)
+		case 0x841: // Set n/60-inch line spacing						(FS A)	(= ESC A)
+		case 0x843:	// Select LQ type style								(FS C)	(= ESC k)
+		case 0x845: // Select character width							(FS E)
+		case 0x849: // Select character table							(FS I)	(= ESC t)
+		case 0x853: // Select High Speed/High Density elite pitch		(FS S)
+		case 0x856: // Turn double-height printing on/off				(FS V)	(= ESC w)
+			neededParam = 1;
+			break;
+		case 0x24: // Set absolute horizontal print position					(ESC $)
+		case 0x3f: // Reassign bit-image mode									(ESC ?)
+		case 0x4b: // Select 60-dpi graphics									(ESC K)
+		case 0x4c: // Select 120-dpi graphics									(ESC L)
+		case 0x59: // Select 120-dpi, double-speed graphics						(ESC Y)
+		case 0x5a: // Select 240-dpi graphics									(ESC Z)
+		case 0x5c: // Set relative horizontal print position					(ESC \)
+		case 0x63: // Set horizontal motion index (HMI)	[conflict]				(ESC c)
+		case 0x65: // Set vertical tab stops every n lines						(ESC e)
+		case 0x85a: // Print 24-bit hex-density graphics						(FS Z)
+			neededParam = 2;
+			break;
+		case 0x2a: // Select bit image											(ESC *)
+		case 0x58: // Select font by pitch and point [conflict]					(ESC X)
+			neededParam = 3;
+			break;
+		case 0x5b: // Select character height, width, line spacing
+			neededParam = 7;
+			break;
+		case 0x62: // Set vertical tabs in VFU channels							(ESC b) 
+		case 0x42: // Set vertical tabs											(ESC B)
+			numVertTabs = 0;
+			return true;
+		case 0x44: // Set horizontal tabs										(ESC D)
+			numHorizTabs = 0;
+			return true;
+		case 0x25: // Select user-defined set									(ESC %)
+		case 0x26: // Define user-defined characters							(ESC &)
+		case 0x3a: // Copy ROM to RAM											(ESC :)
+			LOG(LOG_MISC,LOG_ERROR)("User-defined characters not supported!");
+			return true;
+		case 0x28: // Two bytes sequence
+			return true;
+		default:
+			LOG_MSG("PRINTER: Unknown command %c (%02Xh) %c , unable to skip parameters.",
+				(ESCCmd & 0x800)?"FS":"ESC",ESCCmd, ESCCmd);
+			
+			neededParam = 0;
+			ESCCmd = 0;
+			return true;
+		}
+
+		if (neededParam > 0)
+			return true;
+	}
+
+	// Two bytes sequence
+	if (ESCCmd == 0x28)
+	{
+		ESCCmd = 0x200 + ch;
+
+		switch (ESCCmd)
+		{
+		case 0x242: // Bar code setup and print (ESC (B)
+		case 0x25e: // Print data as characters (ESC (^)
+			neededParam = 2;
+			break;
+		case 0x255: // Set unit (ESC (U)
+			neededParam = 3;
+			break;
+		case 0x243: // Set page length in defined unit (ESC (C)
+		case 0x256: // Set absolute vertical print position (ESC (V)
+		case 0x276: // Set relative vertical print position (ESC (v)
+			neededParam = 4;
+			break;
+		case 0x228: // Assign character table (ESC (t)
+		case 0x22d: // Select line/score (ESC (-)
+			neededParam = 5;
+			break;
+		case 0x263: // Set page format (ESC (c)
+			neededParam = 6;
+			break;
+		default:
+			// ESC ( commands are always followed by a "number of parameters" word parameter
+			//LOG(LOG_MISC,LOG_ERROR)
+				LOG_MSG("PRINTER: Skipping unsupported command ESC ( %c (%02X).", ESCCmd, ESCCmd);
+			neededParam = 2;
+			ESCCmd = 0x101;
+			return true;
+		}
+
+		if (neededParam > 0)
+			return true;
+	}
+
+	// Ignore VFU channel setting
+	if (ESCCmd == 0x62) {
+		ESCCmd = 0x42;
+		return true;
+	}
+
+	// Collect vertical tabs
+	if (ESCCmd == 0x42) {
+		if (ch == 0 || (numVertTabs>0 && verttabs[numVertTabs-1] > (Real64)ch*lineSpacing)) // Done
+			ESCCmd = 0;
+		else
+			if (numVertTabs < 16)
+				verttabs[numVertTabs++] = (Real64)ch*lineSpacing;
+	}
+
+	// Collect horizontal tabs
+	if (ESCCmd == 0x44) 
+	{
+		if (ch == 0 || (numHorizTabs>0 && horiztabs[numHorizTabs-1] > (Real64)ch*(1/(Real64)cpi))) // Done
+			ESCCmd = 0;
+		else
+			if (numHorizTabs < 32)
+				horiztabs[numHorizTabs++] = (Real64)ch*(1/(Real64)cpi);
+	}
+
+	if (numParam < neededParam)
+	{
+		params[numParam++] = ch;
+
+		if (numParam < neededParam)
+			return true;
+	}
+
+	if (ESCCmd != 0)
+	{
+		switch (ESCCmd)
+		{
+		case 0x02: // Undocumented
+			// Ignore
+			break;
+		case 0x0e: // Select double-width printing (one line) (ESC SO)		
+			if (!multipoint)
+			{
+				hmi = -1;
+				style |= STYLE_DOUBLEWIDTHONELINE;
+				updateFont();
+			}
+			break;
+		case 0x0f: // Select condensed printing (ESC SI)
+			if (!multipoint)
+			{
+				hmi = -1;
+				style |= STYLE_CONDENSED;
+				updateFont();
+			}
+			break;
+		case 0x19: // Control paper loading/ejecting (ESC EM)
+			// We are not really loading paper, so most commands can be ignored
+			if (params[0] == 'R')
+				newPage(true,false); // TODO resetx?
+			break;
+		case 0x20: // Set intercharacter space (ESC SP)
+			if (!multipoint)
+			{
+				extraIntraSpace = (Real64)params[0] / (printQuality==QUALITY_DRAFT?120:180);
+				hmi = -1;
+				updateFont();
+			}
+			break;
+		case 0x21: // Master select (ESC !)
+			cpi = params[0] & 0x01 ? 12:10;
+
+			// Reset first seven bits
+			style &= 0xFF80;
+			if (params[0] & 0x02)
+				style |= STYLE_PROP;
+			if (params[0] & 0x04)
+ 				style |= STYLE_CONDENSED;
+			if (params[0] & 0x08)
+ 				style |= STYLE_BOLD;
+			if (params[0] & 0x10)
+ 				style |= STYLE_DOUBLESTRIKE;
+			if (params[0] & 0x20)
+ 				style |= STYLE_DOUBLEWIDTH;
+			if (params[0] & 0x40)
+ 				style |= STYLE_ITALICS;
+			if (params[0] & 0x80)
+			{
+				score = SCORE_SINGLE;
+ 				style |= STYLE_UNDERLINE;
+			}
+
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x23: // Cancel MSB control (ESC #)
+			msb = 255;
+			break;
+		case 0x24: // Set absolute horizontal print position (ESC $)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)60.0;
+
+				Real64 newX = leftMargin + ((Real64)PARAM16(0)/unitSize);
+				if (newX <= rightMargin)
+					curX = newX;
+			}
+			break;
+		case 0x85a: // Print 24-bit hex-density graphics (FS Z)
+			setupBitImage(40, PARAM16(0));
+			break;
+		case 0x2a: // Select bit image (ESC *)
+			setupBitImage(params[0], PARAM16(1));
+			break;
+		case 0x2b: // Set n/360-inch line spacing (ESC +)
+		case 0x833: // Set n/360-inch line spacing (FS 3)
+			lineSpacing = (Real64)params[0]/360;
+			break;
+		case 0x2d: // Turn underline on/off (ESC -)
+			if (params[0] == 0 || params[0] == 48)
+				style &= ~STYLE_UNDERLINE;
+			if (params[0] == 1 || params[0] == 49)
+			{
+				style |= STYLE_UNDERLINE;
+				score = SCORE_SINGLE;
+			}
+			updateFont();
+			break;
+		case 0x2f: // Select vertical tab channel (ESC /)
+			// Ignore
+			break;
+		case 0x30: // Select 1/8-inch line spacing (ESC 0)
+			lineSpacing = (Real64)1/8;
+			break;
+		case 0x32: // Select 1/6-inch line spacing (ESC 2)
+			lineSpacing = (Real64)1/6;
+			break;
+		case 0x33: // Set n/180-inch line spacing (ESC 3)
+			lineSpacing = (Real64)params[0]/180;
+			break;
+		case 0x34: // Select italic font (ESC 4)
+			style |= STYLE_ITALICS;
+			updateFont();
+			break;
+		case 0x35: // Cancel italic font (ESC 5)
+			style &= ~STYLE_ITALICS;
+			updateFont();
+			break;
+		case 0x36: // Enable printing of upper control codes (ESC 6)
+			printUpperContr = true;
+			break;
+		case 0x37: // Enable upper control codes (ESC 7)
+			printUpperContr = false;
+			break;
+		case 0x3c: // Unidirectional mode (one line) (ESC <)
+			// We don't have a print head, so just ignore this
+			break;
+		case 0x3d: // Set MSB to 0 (ESC =)
+			msb = 0;
+			break;
+		case 0x3e: // Set MSB to 1 (ESC >)
+			msb = 1;
+			break;
+		case 0x3f: // Reassign bit-image mode (ESC ?)
+			if (params[0] == 75)
+				densk = params[1];
+			if (params[0] == 76)
+				densl = params[1];
+			if (params[0] == 89)
+				densy = params[1];
+			if (params[0] == 90)
+				densz = params[1];
+			break;
+		case 0x40: // Initialize printer (ESC @)
+			resetPrinter();
+			break;
+		case 0x41: // Set n/60-inch line spacing
+		case 0x841:
+			lineSpacing = (Real64)params[0]/60;
+			break;
+		case 0x43: // Set page length in lines (ESC C)
+			if (params[0] != 0)
+				pageHeight = bottomMargin = (Real64)params[0] * lineSpacing;
+			else // == 0 => Set page length in inches
+			{
+				neededParam = 1;
+				numParam = 0;
+				ESCCmd = 0x100;
+				return true;
+			}
+			break;
+		case 0x45: // Select bold font (ESC E)
+			style |= STYLE_BOLD;
+			updateFont();
+			break;
+		case 0x46: // Cancel bold font (ESC F)
+			style &= ~STYLE_BOLD;
+			updateFont();
+			break;
+		case 0x47: // Select dobule-strike printing (ESC G)
+			style |= STYLE_DOUBLESTRIKE;
+			break;
+		case 0x48: // Cancel double-strike printing (ESC H)
+			style &= ~STYLE_DOUBLESTRIKE;
+			break;
+		case 0x4a: // Advance print position vertically (ESC J n)
+			curY += (Real64)((Real64)params[0] / 180);
+			if (curY > bottomMargin)
+				newPage(true,false);
+			break;
+		case 0x4b: // Select 60-dpi graphics (ESC K)
+			setupBitImage(densk, PARAM16(0));
+			break;
+		case 0x4c: // Select 120-dpi graphics (ESC L)
+			setupBitImage(densl, PARAM16(0));
+			break;
+		case 0x4d: // Select 10.5-point, 12-cpi (ESC M)
+			cpi = 12;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x4e: // Set bottom margin (ESC N)
+			topMargin = 0.0;
+			bottomMargin = (Real64)params[0] * lineSpacing; 
+			break;
+		case 0x4f: // Cancel bottom (and top) margin
+			topMargin = 0.0;
+			bottomMargin = pageHeight;
+			break;
+		case 0x50: // Select 10.5-point, 10-cpi (ESC P)
+			cpi = 10;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x51: // Set right margin
+			rightMargin = (Real64)(params[0]-1.0) / (Real64)cpi;
+			break;
+		case 0x52: // Select an international character set (ESC R)
+			if (params[0] <= 13 || params[0] == 64)
+			{
+				if (params[0] == 64)
+					params[0] = 14;
+
+				curMap[0x23] = intCharSets[params[0]][0];
+				curMap[0x24] = intCharSets[params[0]][1];
+				curMap[0x40] = intCharSets[params[0]][2];
+				curMap[0x5b] = intCharSets[params[0]][3];
+				curMap[0x5c] = intCharSets[params[0]][4];
+				curMap[0x5d] = intCharSets[params[0]][5];
+				curMap[0x5e] = intCharSets[params[0]][6];
+				curMap[0x60] = intCharSets[params[0]][7];
+				curMap[0x7b] = intCharSets[params[0]][8];
+				curMap[0x7c] = intCharSets[params[0]][9];
+				curMap[0x7d] = intCharSets[params[0]][10];
+				curMap[0x7e] = intCharSets[params[0]][11];
+			}
+			break;
+		case 0x53: // Select superscript/subscript printing (ESC S)
+			if (params[0] == 0 || params[0] == 48)
+				style |= STYLE_SUBSCRIPT;
+			if (params[0] == 1 || params[1] == 49)
+				style |= STYLE_SUPERSCRIPT;
+			updateFont();
+			break;
+		case 0x54: // Cancel superscript/subscript printing (ESC T)
+			style &= 0xFFFF - STYLE_SUPERSCRIPT - STYLE_SUBSCRIPT;
+			updateFont();
+			break;
+		case 0x55: // Turn unidirectional mode on/off (ESC U)
+			// We don't have a print head, so just ignore this
+			break;
+		case 0x57: // Turn double-width printing on/off (ESC W)
+			if (!multipoint)
+			{
+				hmi = -1;
+				if (params[0] == 0 || params[0] == 48)
+					style &= ~STYLE_DOUBLEWIDTH;
+				if (params[0] == 1 || params[0] == 49)
+					style |= STYLE_DOUBLEWIDTH;
+				updateFont();
+			}
+			break;
+		case 0x58: // Select font by pitch and point (ESC X)
+			multipoint = true;
+			// Copy currently non-multipoint CPI if no value was set so far
+			if (multicpi == 0)
+				multicpi = cpi;
+			if (params[0] > 0)  // Set CPI
+			{
+				if (params[0] == 1) // Proportional spacing
+					style |= STYLE_PROP;
+				else if (params[0] >= 5)
+					multicpi = (Real64)360 / (Real64)params[0];
+			}
+			if (multiPointSize == 0)
+				multiPointSize = (Real64)10.5;
+			if (PARAM16(1) > 0) // Set points
+				multiPointSize = ((Real64)PARAM16(1)) / 2;			
+			updateFont();
+			break;
+		case 0x59: // Select 120-dpi, double-speed graphics (ESC Y)
+			setupBitImage(densy, PARAM16(0));
+			break;
+		case 0x5a: // Select 240-dpi graphics (ESC Z)
+			setupBitImage(densz, PARAM16(0));
+			break;
+		case 0x5c: // Set relative horizontal print position (ESC \)
+			{
+				Bit16s toMove = PARAM16(0);
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)(printQuality==QUALITY_DRAFT?120.0:180.0);
+				curX += (Real64)((Real64)toMove / unitSize);
+			}
+			break;
+		case 0x61: // Select justification (ESC a)
+			// Ignore
+			break;
+		case 0x63: // Set horizontal motion index (HMI) (ESC c)
+			hmi = (Real64)PARAM16(0) / (Real64)360.0;
+			extraIntraSpace = 0.0;
+			break;
+		case 0x67: // Select 10.5-point, 15-cpi (ESC g)
+			cpi = 15;
+			hmi = -1;
+			multipoint = false;
+			updateFont();
+			break;
+		case 0x846: // Select forward feed mode (FS F) - set reverse not implemented yet
+			if(lineSpacing < 0) lineSpacing *= -1;
+			break;
+		case 0x6a: // Reverse paper feed (ESC j)
+			{
+				Real64 reverse = (Real64)PARAM16(0) / (Real64)216.0;
+				reverse = curY - reverse;
+				if(reverse < leftMargin) curY = leftMargin;
+				else curY = reverse;
+				break;
+			}
+		case 0x6b: // Select typeface (ESC k)
+			if (params[0] <= 11 || params[0] == 30 || params[0] == 31) 
+				LQtypeFace = (Typeface)params[0];
+			updateFont();
+			break;
+		case 0x6c: // Set left margin (ESC l)
+			leftMargin =  (Real64)(params[0]-1.0) / (Real64)cpi;
+			if (curX < leftMargin)
+				curX = leftMargin;
+			break;
+		case 0x70: // Turn proportional mode on/off (ESC p)
+			if (params[0] == 0 || params[0] == 48)
+				style &= (0xffff - STYLE_PROP);
+			if (params[0] == 1 || params[0] == 49)
+			{
+				style |= STYLE_PROP;
+				printQuality = QUALITY_LQ;
+			}
+			multipoint = false;
+			hmi = -1;
+			updateFont();
+			break;
+		case 0x72: // Select printing color (ESC r)
+			
+			if(params[0]==0 || params[0] > 6) color = COLOR_BLACK;
+			else color = params[0]<<5;       
+			break;
+		case 0x73: // Select low-speed mode (ESC s)
+			// Ignore
+			break;
+		case 0x74: // Select character table (ESC t)
+		case 0x849: // Select character table (FS I)
+			if (params[0] < 4)
+				curCharTable = params[0];
+			if (params[0] >= 48 && params[0] <= 51)
+				curCharTable = params[0] - 48;
+			selectCodepage(charTables[curCharTable]);
+			updateFont();
+			break;
+		case 0x77: // Turn double-height printing on/off (ESC w)
+			if (!multipoint)
+			{
+				if (params[0] == 0 || params[0] == 48)
+					style &= ~STYLE_DOUBLEHEIGHT;
+				if (params[0] == 1 || params[0] == 49)
+					style |= STYLE_DOUBLEHEIGHT;
+				updateFont();
+			}
+			break;
+		case 0x78: // Select LQ or draft (ESC x)
+			if (params[0] == 0 || params[0] == 48)
+				printQuality = QUALITY_DRAFT;
+			if (params[0] == 1 || params[0] == 49)
+				printQuality = QUALITY_LQ;
+			break;
+		case 0x100: // Set page length in inches (ESC C NUL)
+			pageHeight = (Real64)params[0];
+			bottomMargin = pageHeight;
+			topMargin = 0.0;
+			break;
+		case 0x101: // Skip unsupported ESC ( command
+			neededParam = PARAM16(0);
+			numParam = 0;
+			break;
+		case 0x228: // Assign character table (ESC (t)
+			if (params[2] < 4 && params[3] < 16)
+			{
+				charTables[params[2]] = codepages[params[3]];
+				if (params[2] == curCharTable)
+					selectCodepage(charTables[curCharTable]);
+			}
+			break;
+		case 0x22d: // Select line/score (ESC (-) 
+			style &= ~(STYLE_UNDERLINE | STYLE_STRIKETHROUGH | STYLE_OVERSCORE);
+			score = params[4];
+			if (score)
+			{
+				if (params[3] == 1)
+					style |= STYLE_UNDERLINE;
+				if (params[3] == 2)
+					style |= STYLE_STRIKETHROUGH;
+				if (params[3] == 3)
+					style |= STYLE_OVERSCORE;
+			}
+			updateFont();
+			break;
+		case 0x242: // Bar code setup and print (ESC (B)
+			LOG(LOG_MISC,LOG_ERROR)("PRINTER: Bardcode printing not supported");
+			// Find out how many bytes to skip
+			neededParam = PARAM16(0);
+			numParam = 0;
+			break;
+		case 0x243: // Set page length in defined unit (ESC (C)
+			if (params[0] != 0 && definedUnit > 0)
+			{
+				pageHeight = bottomMargin = ((Real64)PARAM16(2)) * definedUnit;
+				topMargin = 0.0;
+			}
+			break;
+		case 0x255: // Set unit (ESC (U)
+			definedUnit = (Real64)params[2] / (Real64)3600;
+			break;
+		case 0x256: // Set absolute vertical print position (ESC (V)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)360.0;
+				Real64 newPos = topMargin + (((Real64)PARAM16(2)) * unitSize);
+				if (newPos > bottomMargin)
+					newPage(true,false);
+				else
+					curY = newPos;
+			}
+			break;
+		case 0x25e: // Print data as characters (ESC (^)
+			numPrintAsChar = PARAM16(0);
+			break;
+		case 0x263: // Set page format (ESC (c)
+			if (definedUnit > 0)
+			{
+				Real64 newTop, newBottom;
+				newTop = ((Real64)PARAM16(2)) * definedUnit;
+				newBottom = ((Real64)PARAM16(4)) * definedUnit;
+				if(newTop >= newBottom) break;
+				if(newTop < pageHeight) topMargin = newTop;
+				if(newBottom < pageHeight) bottomMargin = newBottom;
+				if(topMargin > curY) curY = topMargin;
+				//LOG_MSG("du %d, p1 %d, p2 %d, newtop %f, newbott %f, nt %f, nb %f, ph %f",
+				//	(Bitu)definedUnit,PARAM16(2),PARAM16(4),topMargin,bottomMargin,
+				//	newTop,newBottom,pageHeight);
+			}
+			break;
+		case 0x276: // Set relative vertical print position (ESC (v)
+			{
+				Real64 unitSize = definedUnit;
+				if (unitSize < 0)
+					unitSize = (Real64)360.0;
+				Real64 newPos = curY + ((Real64)((Bit16s)PARAM16(2)) * unitSize);
+				if (newPos > topMargin)
+				{
+					if (newPos > bottomMargin)
+						newPage(true,false);
+					else
+						curY = newPos;	
+				}
+			}
+			break;
+		default:
+			if (ESCCmd < 0x100)
+				//LOG(LOG_MISC,LOG_WARN)
+				LOG_MSG("PRINTER: Skipped unsupported command ESC %c (%02X)", ESCCmd, ESCCmd);
+			else
+				//LOG(LOG_MISC,LOG_WARN)
+				LOG_MSG("PRINTER: Skipped unsupported command ESC ( %c (%02X)", ESCCmd-0x200, ESCCmd-0x200);
+		}
+
+		ESCCmd = 0;
+		return true;
+	}
+
+	switch (ch)
+	{
+	case 0x00:  // NUL is ignored by the printer
+		return true;
+	case 0x07:  // Beeper (BEL)
+		// BEEEP!
+		return true;
+	case 0x08:	// Backspace (BS)
+		{
+			Real64 newX = curX - (1/(Real64)actcpi);
+			if (hmi > 0)
+				newX = curX - hmi;
+			if (newX >= leftMargin)
+				curX = newX;
+		}
+		return true;
+	case 0x09:	// Tab horizontally (HT)
+		{
+			// Find tab right to current pos
+			Real64 moveTo = -1;
+			for (Bit8u i=0; i<numHorizTabs; i++)
+				if (horiztabs[i] > curX)
+					moveTo = horiztabs[i];
+			// Nothing found => Ignore
+			if (moveTo > 0 && moveTo < rightMargin)
+				curX = moveTo;
+		}
+		return true;
+	case 0x0b:	// Tab vertically (VT)
+		if (numVertTabs == 0) // All tabs cancelled => Act like CR
+			curX = leftMargin;
+		else if (numVertTabs == 255) // No tabs set since reset => Act like LF
+		{
+			curX = leftMargin;
+			curY += lineSpacing;
+			if (curY > bottomMargin)
+				newPage(true,false);
+		}
+		else
+		{
+			// Find tab below current pos
+			Real64 moveTo = -1;
+			for (Bit8u i=0; i<numVertTabs; i++)
+				if (verttabs[i] > curY)
+					moveTo = verttabs[i];
+
+			// Nothing found => Act like FF
+			if (moveTo > bottomMargin || moveTo < 0)
+				newPage(true,false);
+			else
+				curY = moveTo;
+		}
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		return true;
+	case 0x0c:		// Form feed (FF)
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		newPage(true,true);
+		return true;
+	case 0x0d:		// Carriage Return (CR)
+		curX = leftMargin;
+		if (!autoFeed)
+			return true;
+	case 0x0a:		// Line feed
+		if (style & STYLE_DOUBLEWIDTHONELINE)
+		{
+			style &= 0xFFFF - STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		curX = leftMargin;
+		curY += lineSpacing;
+		if (curY > bottomMargin)
+			newPage(true,false);
+		return true;
+	case 0x0e:		//Select Real64-width printing (one line) (SO)
+		if (!multipoint)
+		{
+			hmi = -1;
+			style |= STYLE_DOUBLEWIDTHONELINE;
+			updateFont();
+		}
+		return true;
+	case 0x0f:		// Select condensed printing (SI)
+		if (!multipoint)
+		{
+			hmi = -1;
+			style |= STYLE_CONDENSED;
+			updateFont();
+		}
+		return true;
+	case 0x11:		// Select printer (DC1)
+		// Ignore
+		return true;
+	case 0x12:		// Cancel condensed printing (DC2)
+		hmi = -1;
+		style &= ~STYLE_CONDENSED;
+		updateFont();
+		return true;
+	case 0x13:		// Deselect printer (DC3)
+		// Ignore
+		return true;
+	case 0x14:		// Cancel double-width printing (one line) (DC4)
+		hmi = -1;
+		style &= ~STYLE_DOUBLEWIDTHONELINE;
+		updateFont();
+		return true;
+	case 0x18:		// Cancel line (CAN)
+		return true;
+	case 0x1b:		// ESC
+		ESCSeen = true;
+		return true;
+	case 0x1c:		// FS (IBM commands)
+		FSSeen = true;
+		return true;
+	default:
+		return false;
+	}
+
+	return false;
+}
+
+static void PRINTER_EventHandler(Bitu param);
+
+void CPrinter::newPage(bool save, bool resetx)
+{
+	PIC_RemoveEvents(PRINTER_EventHandler);
+	if(printer_timout) timeout_dirty=false;
+
+	if (save)
+		outputPage();
+
+	if(resetx) curX=leftMargin;
+	curY = topMargin;
+
+	SDL_Rect rect;
+	rect.x = 0;
+	rect.y = 0;
+	rect.w = page->w;
+	rect.h = page->h;
+	SDL_FillRect(page, &rect, SDL_MapRGB(page->format, 255, 255, 255));
+
+	/*for(int i = 0; i < 256; i++)
+	{
+        *((Bit8u*)page->pixels+i)=i;
+	}*/
+}
+
+void CPrinter::printChar(Bit8u ch)
+{
+	charRead = true;
+	if (page == NULL) return;
+
+	// Don't think that DOS programs uses this but well: Apply MSB if desired
+	if (msb != 255) {
+		if (msb == 0) ch &= 0x7F;
+		if (msb == 1) ch |= 0x80;
+	}
+
+	// Are we currently printing a bit graphic?
+	if (bitGraph.remBytes > 0) {
+		printBitGraph(ch);
+		return;
+	}
+
+	// Print everything?
+	if (numPrintAsChar > 0) numPrintAsChar--;
+	else if (processCommandChar(ch)) return;
+
+	// Do not print if no font is available
+	if (!curFont) return;
+
+	if(ch==0x1) ch=0x20;
+	
+	// Find the glyph for the char to render
+	FT_UInt index = FT_Get_Char_Index(curFont, curMap[ch]);
+	
+	// Load the glyph 
+	FT_Load_Glyph(curFont, index, FT_LOAD_DEFAULT);
+
+	// Render a high-quality bitmap
+	FT_Render_Glyph(curFont->glyph, FT_RENDER_MODE_NORMAL);
+
+	Bit16u penX = PIXX + curFont->glyph->bitmap_left;
+	Bit16u penY = PIXY - curFont->glyph->bitmap_top + curFont->size->metrics.ascender/64;
+
+	if (style & STYLE_SUBSCRIPT) penY += curFont->glyph->bitmap.rows / 2;
+
+	// Copy bitmap into page
+	SDL_LockSurface(page);
+
+	blitGlyph(curFont->glyph->bitmap, penX, penY, false);
+	blitGlyph(curFont->glyph->bitmap, penX+1, penY, true);
+
+	// Doublestrike => Print the glyph a second time one pixel below
+	if (style & STYLE_DOUBLESTRIKE) {
+		blitGlyph(curFont->glyph->bitmap, penX, penY+1, true);
+		blitGlyph(curFont->glyph->bitmap, penX+1, penY+1, true);
+	}
+
+	// Bold => Print the glyph a second time one pixel to the right
+	// or be a bit more bold...
+	if (style & STYLE_BOLD) {
+		blitGlyph(curFont->glyph->bitmap, penX+1, penY, true);
+		blitGlyph(curFont->glyph->bitmap, penX+2, penY, true);
+		blitGlyph(curFont->glyph->bitmap, penX+3, penY, true);
+	}
+	SDL_UnlockSurface(page);
+
+	// For line printing
+	Bit16u lineStart = PIXX;
+
+	// advance the cursor to the right
+	Real64 x_advance;
+	if (style &	STYLE_PROP)
+		x_advance = (Real64)((Real64)(curFont->glyph->advance.x)/(Real64)(dpi*64));
+	else {
+		if (hmi < 0) x_advance = 1/(Real64)actcpi;
+		else x_advance = hmi;
+	}
+	x_advance += extraIntraSpace;
+    curX += x_advance;
+
+	// Draw lines if desired
+	if ((score != SCORE_NONE) && (style & 
+		(STYLE_UNDERLINE|STYLE_STRIKETHROUGH|STYLE_OVERSCORE)))
+	{
+		// Find out where to put the line
+		Bit16u lineY = PIXY;
+		double height = (curFont->size->metrics.height>>6); // TODO height is fixed point madness...
+
+		if (style & STYLE_UNDERLINE) lineY = PIXY + (Bit16u)(height*0.9);
+		else if (style & STYLE_STRIKETHROUGH) lineY = PIXY + (Bit16u)(height*0.45);
+		else if (style & STYLE_OVERSCORE)
+			lineY = PIXY - (((score == SCORE_DOUBLE)||(score == SCORE_DOUBLEBROKEN))?5:0);
+
+		drawLine(lineStart, PIXX, lineY, score==SCORE_SINGLEBROKEN || score==SCORE_DOUBLEBROKEN);
+
+		// draw second line if needed
+		if ((score == SCORE_DOUBLE)||(score == SCORE_DOUBLEBROKEN))
+			drawLine(lineStart, PIXX, lineY + 5, score==SCORE_SINGLEBROKEN || score==SCORE_DOUBLEBROKEN);
+	}
+	// If the next character would go beyond the right margin, line-wrap.
+	if((curX + x_advance) > rightMargin) {
+		curX = leftMargin;
+		curY += lineSpacing;
+		if (curY > bottomMargin) newPage(true,false);
+	}
+}
+
+void CPrinter::blitGlyph(FT_Bitmap bitmap, Bit16u destx, Bit16u desty, bool add) {
+	for (Bitu y=0; y<bitmap.rows; y++) {
+		for (Bitu x=0; x<bitmap.width; x++) {
+			// Read pixel from glyph bitmap
+			Bit8u source = *(bitmap.buffer + x + y*bitmap.pitch);
+
+			// Ignore background and don't go over the border
+			if (source > 0 && (destx+x < page->w) && (desty+y < page->h) ) {
+				Bit8u* target = (Bit8u*)page->pixels + (x+destx) + (y+desty)*page->pitch;
+				source>>=3;
+				
+				if (add) {
+					if (((*target)&0x1f )+ source > 31) *target |= (color|0x1f);
+					else {
+						*target += source;
+						*target |= color;
+					}
+				}
+				else *target = source|color;
+			}
+		}
+	}
+}
+
+void CPrinter::drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken)
+{
+	SDL_LockSurface(page);
+
+	Bitu breakmod = dpi / 15;
+	Bitu gapstart = (breakmod * 4)/5;
+
+	// Draw anti-aliased line
+	for (Bitu x=fromx; x<=tox; x++)
+	{
+		// Skip parts if broken line or going over the border
+		if ((!broken || (x%breakmod <= gapstart)) && (x < page->w))
+		{
+			if (y > 0 && (y-1) < page->h)
+				*((Bit8u*)page->pixels + x + (y-1)*page->pitch) = 240;
+			if (y < page->h)
+				*((Bit8u*)page->pixels + x + y*page->pitch) = !broken?255:240;
+			if (y+1 < page->h)
+				*((Bit8u*)page->pixels + x + (y+1)*page->pitch) = 240;
+		}
+	}
+	SDL_UnlockSurface(page);
+}
+
+void CPrinter::setAutofeed(bool feed) {
+	autoFeed = feed;
+}
+
+bool CPrinter::getAutofeed() {
+	return autoFeed;
+}
+
+bool CPrinter::isBusy() {
+	// We're never busy
+	return false;
+}
+
+bool CPrinter::ack() {
+	// Acknowledge last char read
+	if(charRead) {
+		charRead=false;
+		return true;
+	}
+	return false;
+}
+
+void CPrinter::setupBitImage(Bit8u dens, Bit16u numCols) {
+	switch (dens)
+	{
+	case 0:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 1:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 2:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 3:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 240;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 4:
+		bitGraph.horizDens = 80;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 6:
+		bitGraph.horizDens = 90;
+		bitGraph.vertDens = 60;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 1;
+		break;
+	case 32:
+		bitGraph.horizDens = 60;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 33:
+		bitGraph.horizDens = 120;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 38:
+		bitGraph.horizDens = 90;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 39:
+		bitGraph.horizDens = 180;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 40:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 180;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 3;
+		break;
+	case 71:
+		bitGraph.horizDens = 180;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 6;
+		break;
+	case 72:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = false;
+		bitGraph.bytesColumn = 6;
+		break;
+	case 73:
+		bitGraph.horizDens = 360;
+		bitGraph.vertDens = 360;
+		bitGraph.adjacent = true;
+		bitGraph.bytesColumn = 6;
+		break;
+	default:
+		LOG(LOG_MISC,LOG_ERROR)("PRINTER: Unsupported bit image density %i", dens);
+	}
+
+	bitGraph.remBytes = numCols * bitGraph.bytesColumn;
+	bitGraph.readBytesColumn = 0;
+}
+
+void CPrinter::printBitGraph(Bit8u ch)
+{
+	bitGraph.column[bitGraph.readBytesColumn++] = ch;
+	bitGraph.remBytes--;
+
+	// Only print after reading a full column
+	if (bitGraph.readBytesColumn < bitGraph.bytesColumn)
+		return;
+
+	Real64 oldY = curY;
+
+	SDL_LockSurface(page);
+
+	// When page dpi is greater than graphics dpi, the drawn pixels get "bigger"
+	Bitu pixsizeX=1; 
+	Bitu pixsizeY=1;
+	if(bitGraph.adjacent) {
+		pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
+		pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
+	}
+	// TODO figure this out for 360dpi mode in windows
+
+//	Bitu pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
+//	Bitu pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
+
+	for (Bitu i=0; i<bitGraph.bytesColumn; i++) // for each byte
+	{
+		for (Bitu j=128; j!=0; j>>=1) { // for each bit
+			if (bitGraph.column[i] & j) {
+				for (Bitu xx=0; xx<pixsizeX; xx++)
+					for (Bitu yy=0; yy<pixsizeY; yy++) {
+						if (((PIXX + xx) < page->w) && ((PIXY + yy) < page->h))
+							*((Bit8u*)page->pixels + (PIXX+xx) + (PIXY+yy)*page->pitch) |= (color|0x1F);
+					}
+			} // else white pixel
+
+			curY += (Real64)1/(Real64)bitGraph.vertDens; // TODO line wrap?
+		}
+	}
+
+	SDL_UnlockSurface(page);
+
+	curY = oldY;
+
+	bitGraph.readBytesColumn = 0;
+
+	// Advance to the left
+	curX += (Real64)1/(Real64)bitGraph.horizDens;
+}
+
+void CPrinter::formFeed()
+{
+	// Don't output blank pages
+	newPage(!isBlank(),true);
+
+	finishMultipage();
+}
+
+static void findNextName(const char* front, const char* ext, char* fname)
+{
+	Bitu i = 1;
+	Bitu slen = strlen(document_path);
+	if(slen>(200-15)) {
+		fname[0]=0;
+		return;
+	}
+	FILE *test = NULL;
+	do
+	{
+		strcpy(fname, document_path);
+#ifdef WIN32
+		const char* const pathstring = "\\%s%d%s";
+#else 
+		const char* const pathstring = "/%s%d%s";
+#endif
+		sprintf(fname+strlen(fname), pathstring, front,i++,ext);
+		test = fopen(fname, "rb");
+		if (test != NULL)
+			fclose(test);
+	}
+	while (test != NULL );
+}
+
+void CPrinter::outputPage() 
+{
+	char fname[200]; 
+
+	if (strcasecmp(output, "printer") == 0)
+	{
+#if defined (WIN32)
+		// You'll need the mouse for the print dialog
+		if(mouselocked)
+			 GFX_CaptureMouse();
+
+		Bit16u physW = GetDeviceCaps(printerDC, PHYSICALWIDTH);
+		Bit16u physH = GetDeviceCaps(printerDC, PHYSICALHEIGHT);
+
+		Real64 scaleW, scaleH;
+
+		if (page->w > physW) 
+	        scaleW = (Real64)page->w / (Real64)physW;
+	    else 
+			scaleW = (Real64)physW / (Real64)page->w; 
+ 
+		if (page->h > physH) 
+	        scaleH = (Real64)page->h / (Real64)physH;
+	    else 
+			scaleH = (Real64)physH / (Real64)page->h; 
+
+		HDC memHDC = CreateCompatibleDC(printerDC);
+		HBITMAP bitmap = CreateCompatibleBitmap(memHDC, page->w, page->h);
+		SelectObject(memHDC, bitmap);
+
+		// Start new printer job?
+		if (outputHandle == NULL)
+		{
+			DOCINFO docinfo;
+			docinfo.cbSize = sizeof(docinfo);
+			docinfo.lpszDocName = "DOSBOX Printer";
+			docinfo.lpszOutput = NULL;
+			docinfo.lpszDatatype = NULL;
+			docinfo.fwType = 0;
+
+			StartDoc(printerDC, &docinfo);
+			multiPageCounter = 1;
+		}
+
+		StartPage(printerDC);
+		SDL_LockSurface(page);
+
+		SDL_Palette* sdlpal = page->format->palette;
+
+		for (Bit16u y=0; y<page->h; y++)
+		{
+			for (Bit16u x=0; x<page->w; x++)
+			{
+				Bit8u pixel = *((Bit8u*)page->pixels + x + (y*page->pitch));
+				Bit32u color = 0;
+				color |= sdlpal->colors[pixel].r;
+				color |= ((Bit32u)sdlpal->colors[pixel].g) << 8;
+				color |= ((Bit32u)sdlpal->colors[pixel].b) << 16;
+				SetPixel(memHDC, x, y, color);
+			}
+		}
+
+		SDL_UnlockSurface(page);
+	
+		StretchBlt(printerDC, 0, 0, physW, physH, memHDC, 0, 0, page->w, page->h, SRCCOPY);
+
+		EndPage(printerDC);
+
+		if (multipageOutput)
+		{
+			multiPageCounter++;
+			outputHandle = printerDC;
+		}
+		else
+		{
+			EndDoc(printerDC);
+			outputHandle = NULL;
+		}
+		DeleteObject(bitmap);
+		DeleteDC(memHDC);
+#else
+		LOG_MSG("PRINTER: Direct printing not supported under this OS");
+#endif
+	}
+#ifdef C_LIBPNG
+	else if (strcasecmp(output, "png") == 0)
+	{
+		// Find a page that does not exists
+		findNextName("page", ".png", &fname[0]);
+	
+		png_structp png_ptr;
+		png_infop info_ptr;
+		png_bytep * row_pointers;
+		png_color palette[256];
+		Bitu i;
+
+		/* Open the actual file */
+		FILE * fp=fopen(fname,"wb");
+		if (!fp) 
+		{
+			LOG(LOG_MISC,LOG_ERROR)("PRINTER: Can't open file %s for printer output", fname);
+			return;
+		}
+
+		/* First try to alloacte the png structures */
+		png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,NULL, NULL);
+		if (!png_ptr) return;
+		info_ptr = png_create_info_struct(png_ptr);
+		if (!info_ptr) {
+			png_destroy_write_struct(&png_ptr,(png_infopp)NULL);
+			return;
+		}
+
+		/* Finalize the initing of png library */
+		png_init_io(png_ptr, fp);
+		png_set_compression_level(png_ptr,Z_BEST_COMPRESSION);
+		
+		/* set other zlib parameters */
+		png_set_compression_mem_level(png_ptr, 8);
+		png_set_compression_strategy(png_ptr,Z_DEFAULT_STRATEGY);
+		png_set_compression_window_bits(png_ptr, 15);
+		png_set_compression_method(png_ptr, 8);
+		png_set_compression_buffer_size(png_ptr, 8192);
+
+		
+		png_set_IHDR(png_ptr, info_ptr, page->w, page->h,
+			8, PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,
+			PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
+		for (i=0;i<256;i++) 
+		{
+			palette[i].red = page->format->palette->colors[i].r;
+			palette[i].green = page->format->palette->colors[i].g;
+			palette[i].blue = page->format->palette->colors[i].b;
+		}
+		png_set_PLTE(png_ptr, info_ptr, palette,256);
+		
+		SDL_LockSurface(page);
+
+		// Allocate an array of scanline pointers
+		row_pointers = (png_bytep*)malloc(page->h*sizeof(png_bytep));
+		for (i=0; i<page->h; i++) 
+			row_pointers[i] = ((Bit8u*)page->pixels+(i*page->pitch));
+
+		// tell the png library what to encode.
+		png_set_rows(png_ptr, info_ptr, row_pointers);
+		
+		// Write image to file
+		png_write_png(png_ptr, info_ptr, 0, NULL);
+
+		SDL_UnlockSurface(page);
+		
+		/*close file*/
+		fclose(fp);
+	
+		/*Destroy PNG structs*/
+		png_destroy_write_struct(&png_ptr, &info_ptr);
+		
+		/*clean up dynamically allocated RAM.*/
+		free(row_pointers);
+	}
+#endif
+	else if (strcasecmp(output, "ps") == 0)
+	{
+		FILE* psfile = NULL;
+		
+		// Continue postscript file?
+		if (outputHandle != NULL)
+			psfile = (FILE*)outputHandle;
+
+		// Create new file?
+		if (psfile == NULL)
+		{
+			if (!multipageOutput)
+				findNextName("page", ".ps", &fname[0]);
+			else
+				findNextName("doc", ".ps", &fname[0]);
+
+			psfile = fopen(fname, "wb");
+			if (!psfile) 
+			{
+				LOG(LOG_MISC,LOG_ERROR)("PRINTER: Can't open file %s for printer output", fname);
+				return;
+			}
+
+			// Print header
+			fprintf(psfile, "%%!PS-Adobe-3.0\n");
+			fprintf(psfile, "%%%%Pages: (atend)\n");
+			fprintf(psfile, "%%%%BoundingBox: 0 0 %i %i\n", (Bit16u)(defaultPageWidth*74), (Bit16u)(defaultPageHeight*74));
+			fprintf(psfile, "%%%%Creator: DOSBOX Virtual Printer\n");
+			fprintf(psfile, "%%%%DocumentData: Clean7Bit\n");
+			fprintf(psfile, "%%%%LanguageLevel: 2\n");
+			fprintf(psfile, "%%%%EndComments\n");
+			multiPageCounter = 1;
+		}
+
+		fprintf(psfile, "%%%%Page: %i %i\n", multiPageCounter, multiPageCounter);
+		fprintf(psfile, "%i %i scale\n", (Bit16u)(defaultPageWidth*74), (Bit16u)(defaultPageHeight*74));
+		fprintf(psfile, "%i %i 8 [%i 0 0 -%i 0 %i]\n", page->w, page->h, page->w, page->h, page->h);
+		fprintf(psfile, "currentfile\n");
+		fprintf(psfile, "/ASCII85Decode filter\n");
+		fprintf(psfile, "/RunLengthDecode filter\n");
+		fprintf(psfile, "image\n");
+
+		SDL_LockSurface(page);
+
+		Bit32u pix = 0;
+		Bit32u numpix = page->h*page->w;
+		ASCII85BufferPos = ASCII85CurCol = 0;
+
+		while (pix < numpix)
+		{
+			// Compress data using RLE
+
+			if ((pix < numpix-2) && (getPixel(pix) == getPixel(pix+1)) && (getPixel(pix) == getPixel(pix+2)))
+			{
+				// Found three or more pixels with the same color
+				Bit8u sameCount = 3;
+				Bit8u col = getPixel(pix);
+				while (sameCount < 128 && sameCount+pix < numpix && col == getPixel(pix+sameCount))
+					sameCount++;
+
+				fprintASCII85(psfile, 257-sameCount);
+				fprintASCII85(psfile, 255-col);
+
+				// Skip ahead
+				pix += sameCount;
+			}
+			else
+			{
+				// Find end of heterogenous area
+				Bit8u diffCount = 1;
+				while (diffCount < 128 && diffCount+pix < numpix && 
+					(
+						   (diffCount+pix < numpix-2)
+						|| (getPixel(pix+diffCount) != getPixel(pix+diffCount+1))
+						|| (getPixel(pix+diffCount) != getPixel(pix+diffCount+2))
+					))
+					diffCount++;
+
+				fprintASCII85(psfile, diffCount-1);
+				for (Bit8u i=0; i<diffCount; i++)
+					fprintASCII85(psfile, 255-getPixel(pix++));
+			}
+		}
+
+		// Write EOD for RLE and ASCII85
+		fprintASCII85(psfile, 128);
+		fprintASCII85(psfile, 256);
+
+		SDL_UnlockSurface(page);
+
+		fprintf(psfile, "showpage\n");
+
+		if (multipageOutput)
+		{
+			multiPageCounter++;
+			outputHandle = psfile;
+		}
+		else
+		{
+			fprintf(psfile, "%%%%Pages: 1\n");
+			fprintf(psfile, "%%%%EOF\n");
+			fclose(psfile);
+			outputHandle = NULL;
+		}
+	}
+	else
+	{	
+		// Find a page that does not exists
+		findNextName("page", ".bmp", &fname[0]);
+		SDL_SaveBMP(page, fname);
+	}
+}
+
+void CPrinter::fprintASCII85(FILE* f, Bit16u b)
+{
+	if (b != 256)
+	{
+		if (b < 256)
+			ASCII85Buffer[ASCII85BufferPos++] = (Bit8u)b;
+
+		if (ASCII85BufferPos == 4 || b == 257)
+		{
+			Bit32u num = (Bit32u)ASCII85Buffer[0] << 24 | (Bit32u)ASCII85Buffer[1] << 16 | (Bit32u)ASCII85Buffer[2] << 8 | (Bit32u)ASCII85Buffer[3];
+
+			// Deal with special case
+			if (num == 0 && b != 257)
+			{
+				fprintf(f, "z");
+				if (++ASCII85CurCol >= 79)
+				{
+					ASCII85CurCol = 0;
+					fprintf(f, "\n");
+				}
+			}
+			else
+			{
+				char buffer[5];
+				for (Bit8s i=4; i>=0; i--)
+				{
+					buffer[i] = (Bit8u)((Bit32u)num % (Bit32u)85);
+					buffer[i] += 33;
+					num /= (Bit32u)85;
+				}
+
+				// Make sure a line never starts with a % (which may be mistaken as start of a comment)
+				if (ASCII85CurCol == 0 && buffer[0] == '%')
+					fprintf(f, " ");
+				
+				for (int i=0; i<((b != 257)?5:ASCII85BufferPos+1); i++)
+				{
+					fprintf(f, "%c", buffer[i]);
+					if (++ASCII85CurCol >= 79)
+					{
+						ASCII85CurCol = 0;
+						fprintf(f, "\n");
+					}
+				}
+			}
+
+			ASCII85BufferPos = 0;
+		}
+
+	}
+	else // Close string
+	{
+		// Partial tupel if there are still bytes in the buffer
+		if (ASCII85BufferPos > 0)
+		{
+			for (Bit8u i = ASCII85BufferPos; i < 4; i++)
+				ASCII85Buffer[i] = 0;
+
+			fprintASCII85(f, 257);
+		}
+
+		fprintf(f, "~");
+		fprintf(f, ">\n");
+	}
+}
+
+void CPrinter::finishMultipage()
+{
+	if (outputHandle != NULL)
+	{
+		if (strcasecmp(output, "ps") == 0)
+		{
+			FILE* psfile = (FILE*)outputHandle;
+			fprintf(psfile, "%%%%Pages: %i\n", multiPageCounter);
+			fprintf(psfile, "%%%%EOF\n");
+			fclose(psfile);
+		}
+		else if (strcasecmp(output, "printer") == 0)
+		{
+#if defined (WIN32)
+			EndDoc(printerDC);
+#endif
+		}
+		outputHandle = NULL;
+	}
+}
+
+bool CPrinter::isBlank() {
+	bool blank = true;
+
+	SDL_LockSurface(page);
+
+	for (Bit16u y=0; y<page->h; y++)
+		for (Bit16u x=0; x<page->w; x++)
+			if (*((Bit8u*)page->pixels + x + (y*page->pitch)) != 0)
+				blank = false;
+
+	SDL_UnlockSurface(page);
+	return blank;
+}
+
+Bit8u CPrinter::getPixel(Bit32u num) {
+	// Respect the pitch
+	return *((Bit8u*)page->pixels + (num % page->w) + ((num / page->w) * page->pitch));
+}
+
+static Bit8u dataregister; // contents of the parallel port data register
+
+Bitu PRINTER_readdata(Bitu port,Bitu iolen) {
+	return dataregister;
+}
+
+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen) {
+	dataregister=val;
+}
+Bit8u controlreg = 0x04;
+
+Bitu PRINTER_readstatus(Bitu port,Bitu iolen) {
+	//LOG_MSG("PRINTER_readstatus CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// Don't create a CPrinter unless the program really wants to print
+	// Return standard: No error, printer online, no ack and not busy
+	if (!defaultPrinter)
+		return 0xDF;
+
+	// Printer is always online and never reports an error
+	Bit8u status =0x1f;// 0x18;
+
+//	if (controlreg&0x08==0)
+//		status |= 0x10;
+
+	if (!defaultPrinter->isBusy())
+		status |= 0x80;
+
+	if (!defaultPrinter->ack())
+		status |= 0x40;
+
+	return status;
+}
+
+static void FormFeed(bool pressed) {
+	if(pressed)
+		if (defaultPrinter) {
+			PIC_RemoveEvents(PRINTER_EventHandler);
+			if(printer_timout) timeout_dirty=false;
+
+			defaultPrinter->formFeed();
+		}
+}
+
+
+static void PRINTER_EventHandler(Bitu param) {
+	//LOG_MSG("printerevent");
+	if(timeout_dirty) { // add another
+		PIC_AddEvent(PRINTER_EventHandler,(float)printer_timout,0);
+		//LOG_MSG("timeout renew");
+		timeout_dirty=false;
+	} else {
+		timeout_dirty=false;
+		FormFeed(true);
+	}
+}
+
+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen)
+{
+	//LOG_MSG("PRINTER_writecontrol CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// init printer if bit 4 is switched on
+	if ((val & 0x04) && defaultPrinter && (!(controlreg & 0x04)))
+		defaultPrinter->resetPrinterHard();
+
+	// data is strobed to the parallel printer on the falling edge of strobe bit
+	if(!(val&0x1) && (controlreg & 0x1)) {
+		if (!defaultPrinter)
+		defaultPrinter = new CPrinter(confdpi, confwidth,
+									confheight, confoutputDevice,
+									confmultipageOutput);
+		defaultPrinter->printChar(dataregister);
+		if(!timeout_dirty) {
+			PIC_AddEvent(PRINTER_EventHandler,(float)printer_timout,0);
+			timeout_dirty=true;
+		}
+	}
+
+	controlreg=val;
+	if (defaultPrinter)
+		defaultPrinter->setAutofeed((val & 0x02)>0);
+}
+
+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen)
+{
+	//LOG_MSG("PRINTER_readcontrol CS:IP %8x:%8x",SegValue(cs),reg_eip);
+	// Don't create a CPrinter unless the program really wants to print
+	if (!defaultPrinter)
+		return 0xe0|controlreg;//0xe8;
+
+	return 0xe0|(defaultPrinter->getAutofeed()?0x02:0x00) | (controlreg&0xfd);
+}
+
+void PRINTER_Shutdown(Section* sec)
+{
+	if (defaultPrinter)
+	{
+		delete defaultPrinter;
+		defaultPrinter = NULL;
+	}
+}
+
+bool inited = false;
+bool PRINTER_isInited() {
+	return inited;
+}
+
+void PRINTER_Init(Section* sec) 
+{
+	Section_prop * section=static_cast<Section_prop *>(sec);
+	section->AddDestroyFunction(&PRINTER_Shutdown);
+
+	// Set base address of LPT1 in the BIOS variable segment
+	//real_writew(0x0040, 0x0008, LPTPORT);
+
+	if(!section->Get_bool("printer"))
+		return;
+	inited = true;
+	document_path = section->Get_string("docpath");
+	//font_path = section->Get_string("fontpath");
+	confdpi = section->Get_int("dpi");
+	confwidth = section->Get_int("width");
+	confheight = section->Get_int("height");
+	printer_timout = section->Get_int("timeout");
+	if(!printer_timout) timeout_dirty = true; // this will lock up the timeout
+	else timeout_dirty = false;
+	strcpy(&confoutputDevice[0], section->Get_string("printoutput"));
+	confmultipageOutput = section->Get_bool("multipage");
+
+	//IO_RegisterWriteHandler(LPTPORT,PRINTER_writedata,IO_MB);
+	//IO_RegisterReadHandler(LPTPORT,PRINTER_readdata,IO_MB);
+	
+	//IO_RegisterReadHandler(LPTPORT+1,PRINTER_readstatus,IO_MB);
+	//IO_RegisterWriteHandler(LPTPORT+2,PRINTER_writecontrol,IO_MB);
+	//IO_RegisterReadHandler(LPTPORT+2,PRINTER_readcontrol,IO_MB);
+
+	MAPPER_AddHandler(FormFeed,MK_f2,MMOD1,"ejectpage","formfeed");
+}
+
+#endif
diff -urN dosbox-0.73/src/hardware/parport/printer.h dosboxcvs/src/hardware/parport/printer.h
--- dosbox-0.73/src/hardware/parport/printer.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,246 @@
+/*
+ *  Copyright (C) 2002-2004  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+//#include <dosbox.h>
+#include "config.h"
+
+#if C_PRINTER
+
+#if !defined __PRINTER_H
+#define __PRINTER_H
+
+#ifdef C_LIBPNG
+#include <png.h>
+#endif
+
+#include "SDL.h"
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#if defined (WIN32)
+#include <windows.h>
+#include <winspool.h>
+#endif
+
+#define STYLE_PROP 0x01
+#define STYLE_CONDENSED 0x02
+#define STYLE_BOLD 0x04
+#define STYLE_DOUBLESTRIKE 0x08
+#define STYLE_DOUBLEWIDTH 0x10
+#define STYLE_ITALICS 0x20
+#define STYLE_UNDERLINE 0x40
+#define STYLE_SUPERSCRIPT 0x80
+#define STYLE_SUBSCRIPT 0x100
+#define STYLE_STRIKETHROUGH 0x200
+#define STYLE_OVERSCORE 0x400
+#define STYLE_DOUBLEWIDTHONELINE 0x800
+#define STYLE_DOUBLEHEIGHT 0x1000
+
+#define SCORE_NONE 0x00
+#define SCORE_SINGLE 0x01
+#define SCORE_DOUBLE 0x02
+#define SCORE_SINGLEBROKEN 0x05
+#define SCORE_DOUBLEBROKEN 0x06
+
+#define QUALITY_DRAFT 0x01
+#define QUALITY_LQ 0x02
+
+#define COLOR_BLACK 7<<5
+
+enum Typeface
+{
+	roman = 0,
+	sansserif,
+	courier,
+	prestige,
+	script,
+	ocrb,
+	ocra,
+	orator,
+	orators,
+	scriptc,
+	romant,
+	sansserifh,
+	svbusaba = 30,
+	svjittra = 31
+};
+
+
+class CPrinter {
+public:
+
+	CPrinter (Bit16u dpi, Bit16u width, Bit16u height, char* output, bool multipageOutput);
+	virtual ~CPrinter();
+
+	// Process one character sent to virtual printer
+	void printChar(Bit8u ch);
+
+	// Hard Reset (like switching printer off and on)
+	void resetPrinterHard();
+
+	// Set Autofeed value 
+	void setAutofeed(bool feed);
+
+	// Get Autofeed value
+	bool getAutofeed();
+
+	// True if printer is unable to process more data right now (do not use printChar)
+	bool isBusy();
+
+	// True if the last sent character was received 
+	bool ack();
+
+	// Manual formfeed
+	void formFeed();
+
+	// Returns true if the current page is blank
+	bool isBlank();
+
+private:
+
+	// used to fill the color "sub-pallettes"
+	void FillPalette(Bit8u redmax, Bit8u greenmax, Bit8u bluemax, Bit8u colorID,
+							SDL_Palette* pal);
+
+    // Checks if given char belongs to a command and process it. If false, the character
+	// should be printed
+	bool processCommandChar(Bit8u ch);
+
+	// Resets the printer to the factory settings
+	void resetPrinter();
+
+	// Reload font. Must be called after changing dpi, style or cpi
+	void updateFont();
+
+	// Clears page. If save is true, saves the current page to a bitmap
+	void newPage(bool save, bool resetx);
+
+	// Blits the given glyph on the page surface. If add is true, the values of bitmap are
+	// added to the values of the pixels in the page
+	void blitGlyph(FT_Bitmap bitmap, Bit16u destx, Bit16u desty, bool add);
+
+	// Draws an anti-aliased line from (fromx, y) to (tox, y). If broken is true, gaps are included
+	void drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken);
+
+	// Setup the bitGraph structure
+	void setupBitImage(Bit8u dens, Bit16u numCols);
+
+	// Process a character that is part of bit image. Must be called iff bitGraph.remBytes > 0.
+	void printBitGraph(Bit8u ch);
+
+	// Copies the codepage mapping from the constant array to CurMap
+	void selectCodepage(Bit16u cp);
+
+	// Output current page 
+	void outputPage();
+
+	// Prints out a byte using ASCII85 encoding (only outputs something every four bytes). When b>255, closes the ASCII85 string
+	void fprintASCII85(FILE* f, Bit16u b);
+
+	// Closes a multipage document
+	void finishMultipage();
+
+	// Returns value of the num-th pixel (couting left-right, top-down) in a safe way
+	Bit8u getPixel(Bit32u num);
+
+	FT_Library FTlib;					// FreeType2 library used to render the characters
+
+	SDL_Surface* page;					// Surface representing the current page
+	FT_Face curFont;					// The font currently used to render characters
+	Bit8u color;
+
+	Real64 curX, curY;					// Position of the print head (in inch)
+
+	Bit16u dpi;							// dpi of the page
+	Bit16u ESCCmd;						// ESC-command that is currently processed
+	bool ESCSeen;						// True if last read character was an ESC (0x1B)
+	bool FSSeen;						// True if last read character was an FS (0x1C) (IBM commands)
+
+	Bit8u numParam, neededParam;		// Numbers of parameters already read/needed to process command
+
+	Bit8u params[20];					// Buffer for the read params
+	Bit16u style;						// Style of font (see STYLE_* constants)
+	Real64 cpi, actcpi;					// CPI value set by program and the actual one (taking in account font types)
+	Bit8u score;						// Score for lines (see SCORE_* constants)
+
+	Real64 topMargin, bottomMargin, rightMargin, leftMargin;	// Margins of the page (in inch)
+	Real64 pageWidth, pageHeight;								// Size of page (in inch)
+	Real64 defaultPageWidth, defaultPageHeight;					// Default size of page (in inch)
+	Real64 lineSpacing;											// Size of one line (in inch)
+
+	Real64 horiztabs[32];				// Stores the set horizontal tabs (in inch)
+	Bit8u numHorizTabs;					// Number of configured tabs
+
+	Real64 verttabs[16];				// Stores the set vertical tabs (in inch)
+	Bit8u numVertTabs;					// Number of configured tabs
+
+	Bit8u curCharTable;					// Currently used char table und charset
+	Bit8u printQuality;					// Print quality (see QUALITY_* constants)
+
+	Typeface LQtypeFace;				// Typeface used in LQ printing mode
+
+	Real64 extraIntraSpace;				// Extra space between two characters (set by program, in inch)
+
+	bool charRead;						// True if a character was read since the printer was last initialized
+	bool autoFeed;						// True if a LF should automatically added after a CR
+	bool printUpperContr;				// True if the upper command characters should be printed
+
+	struct bitGraphicParams				// Holds information about printing bit images
+	{
+		Bit16u horizDens, vertDens;		// Density of image to print (in dpi)
+		bool adjacent;					// Print adjacent pixels? (ignored)
+		Bit8u bytesColumn;				// Bytes per column
+		Bit16u remBytes;				// Bytes left to read before image is done
+		Bit8u column[6];				// Bytes of the current and last column
+		Bit8u readBytesColumn;			// Bytes read so far for the current column
+	} bitGraph;
+
+	Bit8u densk, densl, densy, densz;	// Image density modes used in ESC K/L/Y/Z commands
+
+	Bit16u curMap[256];					// Currently used ASCII => Unicode mapping
+	Bit16u charTables[4];				// Charactertables
+
+	Real64 definedUnit;					// Unit used by some ESC/P2 commands (negative => use default)
+
+	bool multipoint;					// If multipoint mode is enabled
+	Real64 multiPointSize;				// Point size of font in multipoint mode
+	Real64 multicpi;					// CPI used in multipoint mode
+
+	Real64 hmi;							// Horizontal motion index (in inch; overrides CPI settings)
+
+	Bit8u msb;							// MSB mode
+	Bit16u numPrintAsChar;				// Number of bytes to print as characters (even when normally control codes)
+
+#if defined (WIN32)
+	HDC printerDC;						// Win32 printer device
+#endif
+
+	char* output;						// Output method selected by user
+	void* outputHandle;					// If not null, additional pages will be appended to the given handle
+	bool multipageOutput;				// If true, all pages are combined to one file/print job etc. until the "eject page" button is pressed
+	Bit16u multiPageCounter;			// Current page (when printing multipages)
+
+	Bit8u ASCII85Buffer[4];				// Buffer used in ASCII85 encoding
+	Bit8u ASCII85BufferPos;				// Position in ASCII85 encode buffer
+	Bit8u ASCII85CurCol;				// Columns printed so far in the current lines
+};
+
+#endif
+
+#endif
diff -urN dosbox-0.73/src/hardware/parport/printer_if.h dosboxcvs/src/hardware/parport/printer_if.h
--- dosbox-0.73/src/hardware/parport/printer_if.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer_if.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,11 @@
+
+#ifndef PRINTER_IF
+#define PRINTER_IF
+Bitu PRINTER_readdata(Bitu port,Bitu iolen);
+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen);
+Bitu PRINTER_readstatus(Bitu port,Bitu iolen);
+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen);
+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen);
+
+bool PRINTER_isInited();
+#endif
diff -urN dosbox-0.73/src/hardware/parport/printer_redir.cpp dosboxcvs/src/hardware/parport/printer_redir.cpp
--- dosbox-0.73/src/hardware/parport/printer_redir.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer_redir.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,73 @@
+/*
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "dosbox.h"
+
+#if C_PRINTER
+
+#include "parport.h"
+//#include "callback.h"
+#include "printer_redir.h"
+
+// Purpose of this is to pass LPT register access to the virtual printer 
+
+CPrinterRedir::CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd)
+                              :CParallel (cmd, nr, initIrq) {
+	InstallationSuccessful = PRINTER_isInited();
+}
+
+CPrinterRedir::~CPrinterRedir () {
+	// close file
+}
+
+bool CPrinterRedir::Putchar(Bit8u val)
+{	
+	Write_CON(0xD4);
+	// strobe data out
+	Write_PR(val);
+	Write_CON(0xD5); // strobe pulse
+	Write_CON(0xD4); // strobe off
+
+#if PARALLEL_DEBUG
+	log_par(dbg_putchar,"putchar  0x%2x",val);
+	if(dbg_plainputchar) fprintf(debugfp,"%c",val);
+#endif
+
+	return true;
+}
+Bitu CPrinterRedir::Read_PR() {
+	return PRINTER_readdata(0,1);
+}
+Bitu CPrinterRedir::Read_COM() {
+	return PRINTER_readcontrol(0,1);
+}
+Bitu CPrinterRedir::Read_SR() {
+	return PRINTER_readstatus(0,1);
+}
+void CPrinterRedir::Write_PR(Bitu val) {
+	PRINTER_writedata(0,val,1);
+}
+void CPrinterRedir::Write_CON(Bitu val) {
+	PRINTER_writecontrol(0,val,1);
+}
+void CPrinterRedir::Write_IOSEL(Bitu val) {
+	// nothing
+}
+void CPrinterRedir::Timer2(void) {
+}
+
+#endif // C_PRINTER
diff -urN dosbox-0.73/src/hardware/parport/printer_redir.h dosboxcvs/src/hardware/parport/printer_redir.h
--- dosbox-0.73/src/hardware/parport/printer_redir.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/parport/printer_redir.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,31 @@
+
+// include guard
+#ifndef DOSBOX_PRREDIR_H
+#define DOSBOX_PRREDIR_H
+
+#include "dosbox.h"
+#include "parport.h"
+#include "printer_if.h"
+
+class CPrinterRedir : public CParallel {
+public:
+	CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd);
+	
+
+	~CPrinterRedir();
+	
+	bool InstallationSuccessful;	// check after constructing. If
+									// something was wrong, delete it right away.
+	Bitu Read_PR();
+	Bitu Read_COM();
+	Bitu Read_SR();
+
+	void Write_PR(Bitu);
+	void Write_CON(Bitu);
+	void Write_IOSEL(Bitu);
+	bool Putchar(Bit8u);
+
+	void Timer2(void);
+};
+
+#endif	// include guard
diff -urN dosbox-0.73/src/hardware/pic.cpp dosboxcvs/src/hardware/pic.cpp
--- dosbox-0.73/src/hardware/pic.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/pic.cpp	2009-07-08 20:43:44.000000000 +0300
@@ -510,11 +510,25 @@
 	firstticker=newticker;
 }
 
+extern void GFX_SetTitle(Bit32s cycles, Bits frameskip,bool paused);
+extern Bitu cycle_count;
+extern Bitu frames;
+
 void TIMER_AddTick(void) {
 	/* Setup new amount of cycles for PIC */
+	PIC_Ticks++;
+	if ((PIC_Ticks&0x1ff) == 0) {
+	    CPU_CyclesCur=(cycle_count-CPU_CyclesCur) >> 9;
+	    frames*=1.953125;		// compensate for 512ms interval
+	    if(CPU_CycleAutoAdjust)
+		GFX_SetTitle(CPU_CyclePercUsed,-1,false);
+	    else
+		GFX_SetTitle(CPU_CycleMax,-1,false);
+	    CPU_CyclesCur=cycle_count;
+	    frames=0;
+	}
 	CPU_CycleLeft=CPU_CycleMax;
 	CPU_Cycles=0;
-	PIC_Ticks++;
 	/* Go through the list of scheduled events and lower their index with 1000 */
 	PICEntry * entry=pic_queue.next_entry;
 	while (entry) {
diff -urN dosbox-0.73/src/hardware/sblaster.cpp dosboxcvs/src/hardware/sblaster.cpp
--- dosbox-0.73/src/hardware/sblaster.cpp	2009-05-25 21:44:46.000000000 +0300
+++ dosboxcvs/src/hardware/sblaster.cpp	2009-07-08 20:44:45.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: sblaster.cpp,v 1.73 2009/04/25 07:02:28 qbix79 Exp $ */
+/* $Id: sblaster.cpp,v 1.76 2009/06/10 17:44:59 c2woody Exp $ */
 
 #include <iomanip>
 #include <sstream>
@@ -62,7 +62,7 @@
 #define SB_SH	14
 #define SB_SH_MASK	((1 << SB_SH)-1)
 
-enum {DSP_S_RESET,DSP_S_NORMAL,DSP_S_HIGHSPEED};
+enum {DSP_S_RESET,DSP_S_RESET_WAIT,DSP_S_NORMAL,DSP_S_HIGHSPEED};
 enum SB_TYPES {SBT_NONE=0,SBT_1=1,SBT_PRO1=2,SBT_2=3,SBT_PRO2=4,SBT_16=6};
 enum SB_IRQS {SB_IRQ_8,SB_IRQ_16,SB_IRQ_MPU};
 
@@ -117,6 +117,7 @@
 		Bit8u cmd_in_pos;
 		Bit8u cmd_in[DSP_BUFSIZE];
 		struct {
+			Bit8u lastval;
 			Bit8u data[DSP_BUFSIZE];
 			Bitu pos,used;
 		} in,out;
@@ -145,7 +146,7 @@
 	struct {
 		Bitu base;
 		Bitu irq;
-		Bitu dma8,dma16;
+		Bit8u dma8,dma16;
 	} hw;
 	struct {
 		Bits value;
@@ -246,13 +247,22 @@
 
 static INLINE void SB_RaiseIRQ(SB_IRQS type) {
 	LOG(LOG_SB,LOG_NORMAL)("Raising IRQ");
-	PIC_ActivateIRQ(sb.hw.irq);
 	switch (type) {
 	case SB_IRQ_8:
+		if (sb.irq.pending_8bit) {
+			LOG_MSG("SB: 8bit irq pending");
+			//return;
+		}
 		sb.irq.pending_8bit=true;
+		PIC_ActivateIRQ(sb.hw.irq);
 		break;
 	case SB_IRQ_16:
+		if (sb.irq.pending_16bit) {
+			LOG_MSG("SB: 16bit irq pending");
+			//return;
+		}
 		sb.irq.pending_16bit=true;
+		PIC_ActivateIRQ(sb.hw.irq);
 		break;
 	default:
 		break;
@@ -316,7 +326,7 @@
 	Bits ref = reference + scaleMap[samp];
 	if (ref > 0xff) reference = 0xff;
 	else if (ref < 0x00) reference = 0x00;
-	else reference = ref;
+	else reference = (Bit8u)(ref&0xff);
 	scale = (scale + adjustMap[samp]) & 0xff;
 	
 	return reference;
@@ -345,7 +355,7 @@
 	Bits ref = reference + scaleMap[samp];
 	if (ref > 0xff) reference = 0xff;
 	else if (ref < 0x00) reference = 0x00;
-	else reference = ref;
+	else reference = (Bit8u)(ref&0xff);
 	scale = (scale + adjustMap[samp]) & 0xff;
 
 	return reference;
@@ -377,7 +387,7 @@
 	Bits ref = reference + scaleMap[samp];
 	if (ref > 0xff) reference = 0xff;
 	else if (ref < 0x00) reference = 0x00;
-	else reference = ref;
+	else reference = (Bit8u)(ref&0xff);
 	scale = (scale + adjustMap[samp]) & 0xff;
 
 	return reference;
@@ -573,7 +583,7 @@
 	sb.mode=mode;
 }
 
-static void DSP_RaiseIRQEvent(Bitu val) {
+static void DSP_RaiseIRQEvent(Bitu /*val*/) {
 	SB_RaiseIRQ(SB_IRQ_8);
 }
 
@@ -678,13 +688,24 @@
 }
 
 
+static void DSP_FinishReset(Bitu /*val*/) {
+	DSP_FlushData();
+	DSP_AddData(0xaa);
+	sb.dsp.state=DSP_S_NORMAL;
+}
+
 static void DSP_Reset(void) {
 	LOG(LOG_SB,LOG_ERROR)("DSP:Reset");
 	PIC_DeActivateIRQ(sb.hw.irq);
+
 	DSP_ChangeMode(MODE_NONE);
+	DSP_FlushData();
 	sb.dsp.cmd_len=0;
 	sb.dsp.in.pos=0;
+	sb.dsp.out.pos=0;
 	sb.dsp.write_busy=0;
+	PIC_RemoveEvents(DSP_FinishReset);
+
 	sb.dma.left=0;
 	sb.dma.total=0;
 	sb.dma.stereo=false;
@@ -693,6 +714,7 @@
 	sb.dma.mode=DSP_DMA_NONE;
 	sb.dma.remain_size=0;
 	if (sb.dma.chan) sb.dma.chan->Clear_Request();
+
 	sb.freq=22050;
 	sb.time_constant=45;
 	sb.dac.used=0;
@@ -706,29 +728,28 @@
 	PIC_RemoveEvents(END_DMA_Event);
 }
 
-
 static void DSP_DoReset(Bit8u val) {
-	if ((val&1)!=0) {
+	if (((val&1)!=0) && (sb.dsp.state!=DSP_S_RESET)) {
 //TODO Get out of highspeed mode
 		DSP_Reset();
 		sb.dsp.state=DSP_S_RESET;
-	} else {
-		DSP_FlushData();
-		DSP_AddData(0xaa);
-		sb.dsp.state=DSP_S_NORMAL;
+	} else if (((val&1)==0) && (sb.dsp.state==DSP_S_RESET)) {	// reset off
+		sb.dsp.state=DSP_S_RESET_WAIT;
+		PIC_RemoveEvents(DSP_FinishReset);
+		PIC_AddEvent(DSP_FinishReset,20.0f/1000.0f,0);	// 20 microseconds
 	}
 }
 
-static void DSP_E2_DMA_CallBack(DmaChannel * chan, DMAEvent event) {
+static void DSP_E2_DMA_CallBack(DmaChannel * /*chan*/, DMAEvent event) {
 	if (event==DMA_UNMASKED) {
-		Bit8u val=sb.e2.value;
+		Bit8u val=(Bit8u)(sb.e2.value&0xff);
 		DmaChannel * chan=GetDMAChannel(sb.hw.dma8);
 		chan->Register_Callback(0);
 		chan->Write(1,&val);
 	}
 }
 
-static void DSP_ADC_CallBack(DmaChannel * chan, DMAEvent event) {
+static void DSP_ADC_CallBack(DmaChannel * /*chan*/, DMAEvent event) {
 	if (event!=DMA_UNMASKED) return;
 	Bit8u val=128;
 	DmaChannel * ch=GetDMAChannel(sb.hw.dma8);
@@ -1047,14 +1068,13 @@
 
 static Bit8u DSP_ReadData(void) {
 /* Static so it repeats the last value on succesive reads (JANGLE DEMO) */
-	static Bit8u data = 0;
 	if (sb.dsp.out.used) {
-		data=sb.dsp.out.data[sb.dsp.out.pos];
+		sb.dsp.out.lastval=sb.dsp.out.data[sb.dsp.out.pos];
 		sb.dsp.out.pos++;
 		if (sb.dsp.out.pos>=DSP_BUFSIZE) sb.dsp.out.pos-=DSP_BUFSIZE;
 		sb.dsp.out.used--;
 	}
-	return data;
+	return sb.dsp.out.lastval;
 }
 
 //The soundblaster manual says 2.0 Db steps but we'll go for a bit less
@@ -1337,7 +1357,7 @@
 }
 
 
-static Bitu read_sb(Bitu port,Bitu iolen) {
+static Bitu read_sb(Bitu port,Bitu /*iolen*/) {
 	switch (port-sb.hw.base) {
 	case MIXER_INDEX:
 		return sb.mixer.index;
@@ -1360,6 +1380,7 @@
 			if (sb.dsp.write_busy & 8) return 0xff;
 			return 0x7f;
 		case DSP_S_RESET:
+		case DSP_S_RESET_WAIT:
 			return 0xff;
 		}
 		return 0xff;
@@ -1372,19 +1393,20 @@
 	return 0xff;
 }
 
-static void write_sb(Bitu port,Bitu val,Bitu iolen) {
+static void write_sb(Bitu port,Bitu val,Bitu /*iolen*/) {
+	Bit8u val8=(Bit8u)(val&0xff);
 	switch (port-sb.hw.base) {
 	case DSP_RESET:
-		DSP_DoReset(val);
+		DSP_DoReset(val8);
 		break;
 	case DSP_WRITE_DATA:
-		DSP_DoWrite(val);
+		DSP_DoWrite(val8);
 		break;
 	case MIXER_INDEX:
-		sb.mixer.index=val;
+		sb.mixer.index=val8;
 		break;
 	case MIXER_DATA:
-		CTMIXER_Write(val);
+		CTMIXER_Write(val8);
 		break;
 	default:
 		LOG(LOG_SB,LOG_NORMAL)("Unhandled write to SB Port %4X",port);
@@ -1392,8 +1414,21 @@
 	}
 }
 
-static void adlib_gusforward(Bitu port,Bitu val,Bitu iolen) {
-	adlib_commandreg=val;
+static void adlib_gusforward(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
+	adlib_commandreg=(Bit8u)(val&0xff);
+}
+
+bool SB_Get_Address(Bitu& sbaddr, Bitu& sbirq, Bitu& sbdma) {
+	sbaddr=0;
+	sbirq =0;
+	sbdma =0;
+	if (sb.type == SBT_NONE) return false;
+	else {
+		sbaddr=sb.hw.base;
+		sbirq =sb.hw.irq;
+		sbdma = sb.hw.dma8;
+		return true;
+	}
 }
 
 static void SBLASTER_CallBack(Bitu len) {
@@ -1422,6 +1457,9 @@
 		break;
 	}
 }
+
+extern void HARDOPL_Init(Bitu hardwareaddr, Bitu sbbase);
+
 class SBLASTER: public Module_base {
 private:
 	/* Data */
@@ -1452,6 +1490,7 @@
 		else if (!strcasecmp(omode,"opl2")) opl_mode=OPL_opl2;
 		else if (!strcasecmp(omode,"dualopl2")) opl_mode=OPL_dualopl2;
 		else if (!strcasecmp(omode,"opl3")) opl_mode=OPL_opl3;
+		else if (!strcasecmp(omode,"hardware")) opl_mode=OPL_hardware;
 		/* Else assume auto */
 		else {
 			switch (type) {
@@ -1469,10 +1508,16 @@
 	SBLASTER(Section* configuration):Module_base(configuration) {
 		Bitu i;
 		Section_prop * section=static_cast<Section_prop *>(configuration);
+
 		sb.hw.base=section->Get_hex("sbbase");
 		sb.hw.irq=section->Get_int("irq");
-		sb.hw.dma8=section->Get_int("dma");
-		sb.hw.dma16=section->Get_int("hdma");
+		Bitu dma8bit=section->Get_int("dma");
+		if (dma8bit>0xff) dma8bit=0xff;
+		sb.hw.dma8=(Bit8u)(dma8bit&0xff);
+		Bitu dma16bit=section->Get_int("hdma");
+		if (dma16bit>0xff) dma16bit=0xff;
+		sb.hw.dma16=(Bit8u)(dma16bit&0xff);
+
 		sb.mixer.enabled=section->Get_bool("sbmixer");
 		sb.mixer.stereo=false;
 		OPL_Mode opl_mode = OPL_none;
@@ -1492,10 +1537,17 @@
 		case OPL_opl3:
 			OPL_Init(section,opl_mode);
 			break;
+		case OPL_hardware:
+			Bitu base = section->Get_hex("hardwarebase");
+			HARDOPL_Init(base,sb.hw.base);
+			break;
 		}
+
 		if (sb.type==SBT_NONE) return;
+
 		sb.chan=MixerChan.Install(&SBLASTER_CallBack,22050,"SB");
 		sb.dsp.state=DSP_S_NORMAL;
+		sb.dsp.out.lastval=0xaa;
 		sb.dma.chan=NULL;
 
 		for (i=4;i<=0xf;i++) {
@@ -1508,8 +1560,10 @@
 		for (i=0;i<256;i++) ASP_regs[i] = 0;
 		ASP_regs[5] = 0x01;
 		ASP_regs[9] = 0xf8;
+
 		DSP_Reset();
 		CTMIXER_Reset();
+
 		// The documentation does not specify if SB gets initialized with the speaker enabled
 		// or disabled. Real SBPro2 has it disabled. 
 		sb.speaker=false;
@@ -1520,8 +1574,8 @@
 		// Create set blaster line
 		ostringstream temp;
 		temp << "SET BLASTER=A" << setw(3)<< hex << sb.hw.base
-		     << " I" << dec << sb.hw.irq << " D"<< sb.hw.dma8;
-		if (sb.type==SBT_16) temp << " H" << sb.hw.dma16;
+		     << " I" << dec << (Bitu)sb.hw.irq << " D" << (Bitu)sb.hw.dma8;
+		if (sb.type==SBT_16) temp << " H" << (Bitu)sb.hw.dma16;
 		temp << " T" << static_cast<unsigned int>(sb.type) << ends;
 
 		autoexecline.Install(temp.str());
@@ -1557,9 +1611,11 @@
 	}	
 }; //End of SBLASTER class
 
+extern void HWOPL_Cleanup();
 
 static SBLASTER* test;
-void SBLASTER_ShutDown(Section* sec) {
+void SBLASTER_ShutDown(Section* /*sec*/) {
+	HWOPL_Cleanup();
 	delete test;	
 }
 
diff -urN dosbox-0.73/src/hardware/serialport/.cvsignore dosboxcvs/src/hardware/serialport/.cvsignore
--- dosbox-0.73/src/hardware/serialport/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/.cvsignore	2005-07-30 17:41:31.000000000 +0300
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/hardware/serialport/directserial.cpp dosboxcvs/src/hardware/serialport/directserial.cpp
--- dosbox-0.73/src/hardware/serialport/directserial.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/directserial.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,317 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* $Id: directserial_win32.cpp,v 1.5 2007/01/13 08:35:49 qbix79 Exp $ */
+
+#include "dosbox.h"
+
+#if C_DIRECTSERIAL
+
+#include "serialport.h"
+#include "directserial.h"
+#include "misc_util.h"
+#include "pic.h"
+
+#include "libserial.h"
+
+/* This is a serial passthrough class.  Its amazingly simple to */
+/* write now that the serial ports themselves were abstracted out */
+
+CDirectSerial::CDirectSerial (Bitu id, CommandLine* cmd)
+					:CSerial (id, cmd) {
+	InstallationSuccessful = false;
+	comport = 0;
+
+	rx_retry = 0;
+    rx_retry_max = 0;
+
+	std::string tmpstring;
+	if(!cmd->FindStringBegin("realport:",tmpstring,false)) return;
+
+	LOG_MSG ("Serial%d: Opening %s", COMNUMBER, tmpstring.c_str());
+	if(!SERIAL_open(tmpstring.c_str(), &comport)) {
+		char errorbuffer[256];
+		SERIAL_getErrorString(errorbuffer, sizeof(errorbuffer));
+		LOG_MSG("Serial%d: Serial Port \"%s\" could not be opened.",
+			COMNUMBER, tmpstring.c_str());
+		LOG_MSG("%s",errorbuffer);
+		return;
+	}
+
+#if SERIAL_DEBUG
+	dbgmsg_poll_block=false;
+	dbgmsg_rx_block=false;
+#endif
+
+	// rxdelay: How many milliseconds to wait before causing an
+	// overflow when the application is unresponsive.
+	if(getBituSubstring("rxdelay:", &rx_retry_max, cmd)) {
+		if(!(rx_retry_max<=10000)) {
+			rx_retry_max=0;
+		}
+	}
+
+	CSerial::Init_Registers();
+	InstallationSuccessful = true;
+	rx_state = D_RX_IDLE;
+	setEvent(SERIAL_POLLING_EVENT, 1); // millisecond receive tick
+}
+
+CDirectSerial::~CDirectSerial () {
+	if(comport) SERIAL_close(comport);
+	// We do not use own events so we don't have to clear them.
+}
+
+// CanReceive: true:UART part has room left
+// doReceive:  true:there was really a byte to receive
+// rx_retry is incremented in polling events
+
+// in POLLING_EVENT: always add new polling event
+// D_RX_IDLE + CanReceive + doReceive		-> D_RX_WAIT   , add RX_EVENT
+// D_RX_IDLE + CanReceive + not doReceive	-> D_RX_IDLE
+// D_RX_IDLE + not CanReceive				-> D_RX_BLOCKED, add RX_EVENT
+
+// D_RX_BLOCKED + CanReceive + doReceive	-> D_RX_FASTWAIT, rem RX_EVENT
+//											   rx_retry=0   , add RX_EVENT
+// D_RX_BLOCKED + CanReceive + !doReceive	-> D_RX_IDLE,     rem RX_EVENT
+//											   rx_retry=0
+// D_RX_BLOCKED + !CanReceive + doReceive + retry < max	-> D_RX_BLOCKED, rx_retry++ 
+// D_RX_BLOCKED + !CanReceive + doReceive + retry >=max	-> rx_retry=0 	
+
+// to be continued...
+
+void CDirectSerial::handleUpperEvent(Bit16u type) {
+	switch(type) {
+		case SERIAL_POLLING_EVENT: {
+			setEvent(SERIAL_POLLING_EVENT, 1.0f);
+			// update Modem input line states
+			switch(rx_state) {
+				case D_RX_IDLE:
+					if(CanReceiveByte()) {
+						if(doReceive()) {
+							// a byte was received
+							rx_state=D_RX_WAIT;
+							setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+						} // else still idle
+					} else {
+#if SERIAL_DEBUG
+						if(!dbgmsg_poll_block) {
+							log_ser(dbg_aux,"Directserial: block on polling.");
+							dbgmsg_poll_block=true;
+						}
+#endif
+						rx_state=D_RX_BLOCKED;
+						// have both delays (1ms + bytetime)
+						setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+					}
+					break;
+				case D_RX_BLOCKED:
+                    // one timeout tick
+					if(!CanReceiveByte()) {
+						rx_retry++;
+						if(rx_retry>=rx_retry_max) {
+							// it has timed out:
+							rx_retry=0;
+							removeEvent(SERIAL_RX_EVENT);
+							if(doReceive()) {
+								// read away everything
+								// this will set overrun errors
+								while(doReceive());
+								rx_state=D_RX_WAIT;
+								setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+							} else {
+								// much trouble about nothing
+                                rx_state=D_RX_IDLE;
+							}
+						} // else wait further
+					} else {
+						// good: we can receive again
+#if SERIAL_DEBUG
+						dbgmsg_poll_block=false;
+						dbgmsg_rx_block=false;
+#endif
+						removeEvent(SERIAL_RX_EVENT);
+						rx_retry=0;
+						if(doReceive()) {
+							rx_state=D_RX_FASTWAIT;
+							setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+						} else {
+							// much trouble about nothing
+							rx_state=D_RX_IDLE;
+						}
+					}
+					break;
+
+				case D_RX_WAIT:
+				case D_RX_FASTWAIT:
+					break;
+			}
+			updateMSR();
+			break;
+		}
+		case SERIAL_RX_EVENT: {
+			switch(rx_state) {
+				case D_RX_IDLE:
+					LOG_MSG("internal error in directserial");
+					break;
+
+				case D_RX_BLOCKED: // try to receive
+				case D_RX_WAIT:
+				case D_RX_FASTWAIT:
+					if(CanReceiveByte()) {
+						// just works or unblocked
+						rx_retry=0; // not waiting anymore
+						if(doReceive()) {
+							if(rx_state==D_RX_WAIT) setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+							else {
+								// maybe unblocked
+								rx_state=D_RX_FASTWAIT;
+								setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+							}
+						} else {
+							// didn't receive anything
+							rx_state=D_RX_IDLE;
+						}
+					} else {
+						// blocking now or still blocked
+#if SERIAL_DEBUG
+						if(rx_state==D_RX_BLOCKED) {
+							if(!dbgmsg_rx_block) {
+                                log_ser(dbg_aux,"Directserial: rx still blocked (retry=%d)",rx_retry);
+								dbgmsg_rx_block=true;
+							}
+						}
+
+
+
+
+
+
+						else log_ser(dbg_aux,"Directserial: block on continued rx (retry=%d).",rx_retry);
+#endif
+						setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+						rx_state=D_RX_BLOCKED;
+					}
+
+					break;
+			}
+			break;
+		}
+		case SERIAL_TX_EVENT: {
+			// Maybe echo cirquit works a bit better this way
+			if(rx_state==D_RX_IDLE && CanReceiveByte()) {
+				if(doReceive()) {
+					// a byte was received
+					rx_state=D_RX_WAIT;
+					setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+				}
+			}
+			ByteTransmitted();
+			break;
+		}
+		case SERIAL_THR_EVENT: {
+			ByteTransmitting();
+			setEvent(SERIAL_TX_EVENT,bytetime*1.1f);
+			break;				   
+		}
+	}
+}
+
+bool CDirectSerial::doReceive() {
+	int value = SERIAL_getextchar(comport);
+	if(value) {
+		receiveByteEx((Bit8u)(value&0xff),(Bit8u)((value&0xff00)>>8));
+		return true;
+	}
+	return false;
+}
+
+// updatePortConfig is called when emulated app changes the serial port
+// parameters baudrate, stopbits, number of databits, parity.
+void CDirectSerial::updatePortConfig (Bit16u divider, Bit8u lcr) {
+	Bit8u parity = 0;
+
+	switch ((lcr & 0x38)>>3) {
+	case 0x1: parity='o'; break;
+	case 0x3: parity='e'; break;
+	case 0x5: parity='m'; break;
+	case 0x7: parity='s'; break;
+	default: parity='n'; break;
+	}
+
+	Bit8u bytelength = (lcr & 0x3)+5;
+
+	// baudrate
+	Bitu baudrate;
+	if(divider==0) baudrate=115200;
+	else baudrate = 115200 / divider;
+
+	// stopbits
+	Bit8u stopbits;
+	if (lcr & 0x4) {
+		if (bytelength == 5) stopbits = SERIAL_15STOP;
+		else stopbits = SERIAL_2STOP;
+	} else stopbits = SERIAL_1STOP;
+
+	if(!SERIAL_setCommParameters(comport, baudrate, parity, stopbits, bytelength)) {
+#if SERIAL_DEBUG
+		log_ser(dbg_aux,"Serial port settings not supported by host." );
+#endif
+		LOG_MSG ("Serial%d: Desired serial mode not supported (%d,%d,%c,%d",
+			COMNUMBER, baudrate,bytelength,parity,stopbits);
+	}
+	CDirectSerial::setRTSDTR(getRTS(), getDTR());
+}
+
+void CDirectSerial::updateMSR () {
+	int new_status = SERIAL_getmodemstatus(comport);
+
+	setCTS(new_status&SERIAL_CTS? true:false);
+	setDSR(new_status&SERIAL_DSR? true:false);
+	setRI(new_status&SERIAL_RI? true:false);
+	setCD(new_status&SERIAL_CD? true:false);
+}
+
+void CDirectSerial::transmitByte (Bit8u val, bool first) {
+	if(!SERIAL_sendchar(comport, val))
+		LOG_MSG("Serial%d: COM port error: write failed!", COMNUMBER);
+	if(first) setEvent(SERIAL_THR_EVENT, bytetime/8);
+	else setEvent(SERIAL_TX_EVENT, bytetime);
+}
+
+
+// setBreak(val) switches break on or off
+void CDirectSerial::setBreak (bool value) {
+	SERIAL_setBREAK(comport,value);
+}
+
+// updateModemControlLines(mcr) sets DTR and RTS. 
+void CDirectSerial::setRTSDTR(bool rts, bool dtr) {
+	SERIAL_setRTS(comport,rts);
+	SERIAL_setDTR(comport,dtr);
+}
+
+void CDirectSerial::setRTS(bool val) {
+	SERIAL_setRTS(comport,val);
+}
+
+void CDirectSerial::setDTR(bool val) {
+	SERIAL_setDTR(comport,val);
+}
+
+#endif
diff -urN dosbox-0.73/src/hardware/serialport/directserial.h dosboxcvs/src/hardware/serialport/directserial.h
--- dosbox-0.73/src/hardware/serialport/directserial.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/directserial.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,71 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/* $Id: directserial_win32.h,v 1.5 2007/05/23 08:05:22 qbix79 Exp $ */
+
+// include guard
+#ifndef DOSBOX_DIRECTSERIAL_WIN32_H
+#define DOSBOX_DIRECTSERIAL_WIN32_H
+
+#include "dosbox.h"
+
+#if C_DIRECTSERIAL
+
+#define DIRECTSERIAL_AVAILIBLE
+#include "serialport.h"
+
+#include "libserial.h"
+
+class CDirectSerial : public CSerial {
+public:
+	CDirectSerial(Bitu id, CommandLine* cmd);
+	~CDirectSerial();
+
+	void updatePortConfig(Bit16u divider, Bit8u lcr);
+	void updateMSR();
+	void transmitByte(Bit8u val, bool first);
+	void setBreak(bool value);
+	
+	void setRTSDTR(bool rts, bool dtr);
+	void setRTS(bool val);
+	void setDTR(bool val);
+	void handleUpperEvent(Bit16u type);
+
+private:
+	COMPORT comport;
+
+	Bitu rx_state;
+#define D_RX_IDLE		0
+#define D_RX_WAIT		1
+#define D_RX_BLOCKED	2
+#define D_RX_FASTWAIT	3
+
+	Bitu rx_retry;		// counter of retries (every millisecond)
+	Bitu rx_retry_max;	// how many POLL_EVENTS to wait before causing
+						// an overrun error.
+	bool doReceive();
+
+#if SERIAL_DEBUG
+	bool dbgmsg_poll_block;
+	bool dbgmsg_rx_block;
+#endif
+
+};
+
+#endif	// C_DIRECTSERIAL
+#endif	// include guard
diff -urN dosbox-0.73/src/hardware/serialport/directserial_os2.cpp dosboxcvs/src/hardware/serialport/directserial_os2.cpp
--- dosbox-0.73/src/hardware/serialport/directserial_os2.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/directserial_os2.cpp	1970-01-01 02:00:00.000000000 +0200
@@ -1,515 +0,0 @@
-/*
- *  Copyright (C) 2002-2009  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: directserial_os2.cpp,v 1.5 2009/05/27 09:15:41 qbix79 Exp $ */
-
-#include "dosbox.h"
-
-#if C_DIRECTSERIAL
-
-
-#if defined(OS2)
-#include "serialport.h"
-#include "directserial_os2.h"
-#include "misc_util.h"
-#include "pic.h"
-
-// OS/2 related headers
-#define INCL_DOSFILEMGR
-#define INCL_DOSERRORS
-#define INCL_DOSDEVICES
-#define INCL_DOSDEVIOCTL
-#define INCL_DOSPROCESS
-#include <os2.h>
-
-/* This is a serial passthrough class.  Its amazingly simple to */
-/* write now that the serial ports themselves were abstracted out */
-
-CDirectSerial::CDirectSerial (Bitu id, CommandLine *cmd)
-	: CSerial(id, cmd) {
-	InstallationSuccessful = false;
-
-
-	rx_retry = 0;
-	rx_retry_max = 0;
-
-	std::string tmpstring;
-
-	if (!cmd->FindStringBegin("realport:", tmpstring, false))
-	{
-		return;
-	}
-#if SERIAL_DEBUG
-	if (dbg_modemcontrol)
-	{
-		fprintf(debugfp, "%12.3f Port type directserial realport %s\r\n", PIC_FullIndex(), tmpstring.c_str());
-	}
-#endif
-
-
-	// rxdelay: How many milliseconds to wait before causing an
-	// overflow when the application is unresponsive.
-	if(getBituSubstring("rxdelay:", &rx_retry_max, cmd)) {
-		if(!(rx_retry_max<=10000)) {
-			rx_retry_max=0;
-		}
-	}
-
-	const char* tmpchar=tmpstring.c_str();
-
-	LOG_MSG ("Serial%d: Opening %s", COMNUMBER, tmpstring.c_str());
-
-	ULONG ulAction = 0;
-	APIRET rc = DosOpen((unsigned char*)tmpstring.c_str(), &hCom, &ulAction, 0L, FILE_NORMAL, FILE_OPEN,
-			OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYNONE | OPEN_FLAGS_SEQUENTIAL, 0L);
-	if (rc != NO_ERROR)
-	{
-		LOG_MSG ("Serial%d: Serial port \"%s\" could not be opened.", COMNUMBER, tmpstring.c_str());
-		if (rc == 2) {
-			LOG_MSG ("The specified port does not exist.");
-		} else if (rc == 99) {
-			LOG_MSG ("The specified port is already in use.");
-		} else {
-			LOG_MSG ("OS/2 error %d occurred.", rc);
-		}
-
-		hCom = 0;
-		return;
-	}
-
-	DCBINFO dcb;
-	ULONG ulParmLen = sizeof(DCBINFO);
-	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETDCBINFO, 0, 0, 0, &dcb, ulParmLen, &ulParmLen);
-	if ( rc != NO_ERROR)
-	{
-		LOG_MSG("GetCommState failed with error %d.\n", rc);
-		DosClose(hCom);
-		hCom = 0;
-		return;
-	}
-
-	dcb.usWriteTimeout = 0;
-	dcb.usReadTimeout = 0; //65535;
-	dcb.fbCtlHndShake = dcb.fbFlowReplace = 0;
-	dcb.fbTimeout = 6;
-	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETDCBINFO, &dcb, ulParmLen, &ulParmLen, 0, 0, 0);
-	if ( rc != NO_ERROR)
-	{
-		LOG_MSG("SetDCBInfo failed with error %d.\n", rc);
-		DosClose(hCom);
-		hCom = 0;
-		return;
-	}
-
-
-	struct {
-		ULONG baud;
-		BYTE fraction;
-	} setbaud;
-	setbaud.baud = 9600;
-	setbaud.fraction = 0;
-	ulParmLen = sizeof(setbaud);
-	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_EXTSETBAUDRATE, &setbaud, ulParmLen, &ulParmLen, 0, 0, 0);
-	if (rc != NO_ERROR)
-	{
-		LOG_MSG("ExtSetBaudrate failed with error %d.\n", rc);
-		DosClose (hCom);
-		hCom = 0;
-		return;
-}
-
-	struct {
-		UCHAR data;
-		UCHAR parity;
-		UCHAR stop;
-	} paramline;
-
-	// byte length
-	paramline.data = 8;
-	paramline.parity = 0;
-	paramline.stop = 0;
-	ulParmLen = sizeof(paramline);
-	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETLINECTRL, &paramline, ulParmLen, &ulParmLen, 0, 0, 0);
-	if ( rc != NO_ERROR)
-	{
-		LOG_MSG ("SetLineCtrl failed with error %d.\n", rc);
-		}
-
-	CSerial::Init_Registers();
-	InstallationSuccessful = true;
-	receiveblock = false;
-
-	// Clears comm errors
-	USHORT errors = 0;
-	ulParmLen = sizeof(errors);
-	DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETCOMMERROR, 0, 0, 0, &errors, ulParmLen, &ulParmLen);
-	setEvent(SERIAL_POLLING_EVENT, 1);
-	}
-
-CDirectSerial::~CDirectSerial () {
-	if (hCom != 0)
-		DosClose (hCom);
-}
-
-
-
-/*****************************************************************************/
-/* updatePortConfig is called when emulated app changes the serial port     **/
-/* parameters baudrate, stopbits, number of databits, parity.               **/
-/*****************************************************************************/
-void CDirectSerial::updatePortConfig (Bit16u divider, Bit8u lcr) {
-	Bit8u parity = 0;
-	Bit8u bytelength = 0;
-	struct {
-		ULONG baud;
-		BYTE fraction;
-	} setbaud;
-
-	// baud
-	if (divider <= 0x1)
-		setbaud.baud = 115200;
-	else if (divider <= 0x2)
-		setbaud.baud = 57600;
-	else if (divider <= 0x3)
-		setbaud.baud = 38400;
-	else if (divider <= 0x6)
-		setbaud.baud = 19200;
-	else if (divider <= 0xc)
-		setbaud.baud = 9600;
-	else if (divider <= 0x18)
-		setbaud.baud = 4800;
-	else if (divider <= 0x30)
-		setbaud.baud = 2400;
-	else if (divider <= 0x60)
-		setbaud.baud = 1200;
-	else if (divider <= 0xc0)
-		setbaud.baud = 600;
-	else if (divider <= 0x180)
-		setbaud.baud = 300;
-	else if (divider <= 0x417)
-		setbaud.baud = 110;
-
-	// I read that windows can handle nonstandard baudrates:
-	else
-		setbaud.baud = 115200 / divider;
-
-
-	setbaud.fraction = 0;
-	ULONG ulParmLen = sizeof(setbaud);
-	APIRET rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_EXTSETBAUDRATE, &setbaud, ulParmLen, &ulParmLen, 0, 0, 0);
-	if (rc != NO_ERROR)
-	{
-		LOG_MSG("Serial%d: Desired serial mode not supported (Baud: %d, %d, Error: %d)",
-			COMNUMBER, setbaud.baud, divider, rc);
-	}
-
-
-	struct {
-		UCHAR data;
-		UCHAR parity;
-		UCHAR stop;
-	} paramline;
-
-	// byte length
-	bytelength = lcr & 0x3;
-	bytelength += 5;
-	paramline.data = bytelength;
-
-	// parity
-	parity = lcr & 0x38;
-	parity = parity >> 3;
-	switch (parity) {
-	case 0x1:
-		paramline.parity = 1;
-		break;
-	case 0x3:
-		paramline.parity = 2;
-		break;
-	case 0x5:
-		paramline.parity = 3;
-		break;
-	case 0x7:
-		paramline.parity = 4;
-		break;
-	default:
-		paramline.parity = 0;
-		break;
-	}
-
-	// stopbits
-	if (lcr & 0x4) {
-		if (bytelength == 5)
-			paramline.stop = 1;
-		else
-			paramline.stop = 2;
-	} else {
-		paramline.stop = 0;
-	}
-
-
-#ifdef SERIAL_DEBUG
-	LOG_MSG("_____________________________________________________");
-	LOG_MSG("Serial%d, new baud rate: %d", COMNUMBER, setbaud.baud);
-	LOG_MSG("Serial%d: new bytelen: %d", COMNUMBER, paramline.data);
-	LOG_MSG("Serial%d: new parity: %d", COMNUMBER, paramline.parity);
-	LOG_MSG("Serial%d: new stopbits: %d", COMNUMBER, paramline.stop);
-#endif
-
-	ulParmLen = sizeof(paramline);
-	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETLINECTRL, &paramline, ulParmLen, &ulParmLen, 0, 0, 0);
-	if ( rc != NO_ERROR)
-	{
-#ifdef SERIAL_DEBUG
-		if (dbg_modemcontrol)
-		{
-			fprintf(debugfp, "%12.3f serial mode not supported: rate=%d, LCR=%x.\r\n", PIC_FullIndex(), setbaud.baud, lcr);
-	}
-#endif
-		LOG_MSG("Serial%d: Desired serial mode not supported (%d,%d,%d,%d)",
-			COMNUMBER, setbaud.baud, paramline.data, paramline.parity, lcr);
-	}
-
-
-}
-
-void CDirectSerial::updateMSR () {
-	Bit8u newmsr = 0;
-	UCHAR dptr = 0;
-	ULONG ulParmLen = sizeof(dptr);
-
-	APIRET rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETMODEMINPUT, 0, 0, 0, &dptr, ulParmLen, &ulParmLen);
-	if (rc != NO_ERROR) {
-	     LOG_MSG ("Serial port at %x: GetModemInput failed with %d !", idnumber, dptr);
-	}
-	setCTS( (dptr & 16) != 0);
-	setDSR( (dptr & 32) != 0);
-	setRI( (dptr & 64) != 0);
-	setCD( (dptr & 128) != 0);
-}
-
-void CDirectSerial::transmitByte (Bit8u val, bool first) {
-	ULONG bytesWritten = 0;
-	APIRET rc = DosWrite (hCom, &val, 1, &bytesWritten);
-	if (rc == NO_ERROR && bytesWritten > 0) {
-		//LOG_MSG("UART 0x%x: TX 0x%x", base,val);
-	} else {
-		LOG_MSG ("Serial%d: NO BYTE WRITTEN!", idnumber);
-	}
-	if (first)
-	{
-		setEvent(SERIAL_THR_EVENT, bytetime / 8);
-	} else {
-		setEvent(SERIAL_TX_EVENT, bytetime);
-	}
-}
-
-/*****************************************************************************/
-/* setBreak(val) switches break on or off                                   **/
-/*****************************************************************************/
-
-void CDirectSerial::setBreak (bool value) {
-	USHORT error;
-	ULONG ulParmLen = sizeof(error);
-	if (value)
-		DosDevIOCtl (hCom, IOCTL_ASYNC, ASYNC_SETBREAKON, 0,0,0, &error, ulParmLen, &ulParmLen);
-	else
-		DosDevIOCtl (hCom, IOCTL_ASYNC, ASYNC_SETBREAKOFF, 0,0,0, &error, ulParmLen, &ulParmLen);
-}
-
-/*****************************************************************************/
-/* updateModemControlLines(mcr) sets DTR and RTS.                           **/
-/*****************************************************************************/
-void CDirectSerial::setRTSDTR(bool rts, bool dtr)
-{
-	bool change = false;
-	DCBINFO dcb;
-	ULONG ulParmLen = sizeof(dcb);
-
-	DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETDCBINFO, 0, 0, 0, &dcb, ulParmLen, &ulParmLen);
-
-		/*** DTR ***/
-	if (dtr) {			// DTR on
-		if (dcb.fbCtlHndShake && 3 == 0) { // DTR disabled
-			dcb.fbCtlHndShake |= 1;
-			change = true;
-		}
-	} else {
-		if (dcb.fbCtlHndShake && 3 == 1) { // DTR enabled
-			dcb.fbCtlHndShake &= ~3;
-			change = true;
-		}
-	}
-		/*** RTS ***/
-	if (rts) {			// RTS on
-		if (dcb.fbFlowReplace && 192 == 0) { //RTS disabled
-			dcb.fbFlowReplace |= 64;
-			change = true;
-		}
-	} else {
-		if (dcb.fbFlowReplace && 192 == 1) { // RTS enabled
-			dcb.fbFlowReplace &= ~192;
-			change = true;
-		}
-	}
-	if (change)
-		DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETDCBINFO, &dcb, ulParmLen, &ulParmLen, 0, 0, 0);
-}
-
-void CDirectSerial::setRTS(bool val)
-{
-	bool change = false;
-	DCBINFO dcb;
-	ULONG ulParmLen = sizeof(dcb);
-
-	DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETDCBINFO, 0, 0, 0, &dcb, ulParmLen, &ulParmLen);
-
-		/*** RTS ***/
-	if (val) {			// RTS on
-		if (dcb.fbFlowReplace && 192 == 0) { //RTS disabled
-			dcb.fbFlowReplace |= 64;
-			change = true;
-			}
-		} else {
-		if (dcb.fbFlowReplace && 192 == 1) { // RTS enabled
-			dcb.fbFlowReplace &= ~192;
-			change = true;
-				}
-			}
-	if (change)
-		DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETDCBINFO, &dcb, ulParmLen, &ulParmLen, 0, 0, 0);
-		}
-
-void CDirectSerial::setDTR(bool val)
-{
-	bool change = false;
-	DCBINFO dcb;
-	ULONG ulParmLen = sizeof(dcb);
-
-	DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETDCBINFO, 0, 0, 0, &dcb, ulParmLen, &ulParmLen);
-
-		/*** DTR ***/
-	if (val) {			// DTR on
-		if (dcb.fbCtlHndShake && 3 == 0) { // DTR disabled
-			dcb.fbCtlHndShake |= 1;
-			change = true;
-		}
-	} else {
-		if (dcb.fbCtlHndShake && 3 == 1) { // DTR enabled
-			dcb.fbCtlHndShake &= ~3;
-			change = true;
-		}
-	}
-	if (change)
-		DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETDCBINFO, &dcb, ulParmLen, &ulParmLen, 0, 0, 0);
-	}
-
-
-void CDirectSerial::handleUpperEvent(Bit16u type)
-	{
-		switch(type) {
-		case SERIAL_POLLING_EVENT: {
-			ULONG dwRead = 0;
-			ULONG errors = 0;
-			Bit8u chRead = 0;
-
-			setEvent(SERIAL_POLLING_EVENT, 1);
-			if(!receiveblock) {
-				if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-				{
-					  rx_retry=0;
-					  if (DosRead (hCom, &chRead, 1, &dwRead) == NO_ERROR) {
-					          if (dwRead) {
-					                  receiveByte (chRead);
-					                  setEvent(40, bytetime-0.03f); // receive timing
-					                  receiveblock=true;
-		}
-		}
-				} else rx_retry++;
-			}
-			// check for errors
-			CheckErrors();
-			// update Modem input line states
-			updateMSR ();
-			break;
-	}
-		case 40: {
-		// receive time is up
-			ULONG dwRead = 0;
-			Bit8u chRead = 0;
-			receiveblock=false;
-			// check if there is something to receive
-			if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-	{
-				rx_retry=0;
-				if (DosRead (hCom, &chRead, 1, &dwRead) == NO_ERROR) {
-					  if (dwRead) {
-					          receiveByte (chRead);
-					          setEvent(40, bytetime-0.03f); // receive timing
-					          receiveblock=true;
-					  }
-		}
-			} else rx_retry++;
-			break;
-	}
-		case SERIAL_TX_EVENT: {
-			ULONG dwRead = 0;
-			Bit8u chRead = 0;
-			if(!receiveblock) {
-				if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-	{
-					  rx_retry=0;
-					  if (DosRead (hCom, &chRead, 1, &dwRead) == NO_ERROR) {
-					          if (dwRead) {
-					                  receiveByte (chRead);
-					                  setEvent(40, bytetime-0.03f); // receive timing
-					                  receiveblock=true;
-					          }
-					  }
-				} else rx_retry++;
-			}
-			ByteTransmitted();
-			break;
-		}
-		case SERIAL_THR_EVENT: {
-			ByteTransmitting();
-			setEvent(SERIAL_TX_EVENT,bytetime+0.03f);
-			break;
-		}
-	}
-
-}
-
-void CDirectSerial::CheckErrors() {
-
-	USHORT errors = 0, event = 0;
-	ULONG ulParmLen = sizeof(errors);
-	DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETCOMMEVENT, 0, 0, 0, &event, ulParmLen, &ulParmLen);
-	if (event & (64 + 128) ) { // Break (Bit 6) or Frame or Parity (Bit 7) error
-		Bit8u errreg = 0;
-		if (event & 64) errreg |= LSR_RX_BREAK_MASK;
-		if (event & 128) {
-			DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETCOMMERROR, 0, 0, 0, &errors, ulParmLen, &ulParmLen);
-			if (errors & 8) errreg |= LSR_FRAMING_ERROR_MASK;
-			if (errors & 4) errreg |= LSR_PARITY_ERROR_MASK;
-		}
-		receiveError (errreg);
-	}
-}
-
-#endif
-#endif
diff -urN dosbox-0.73/src/hardware/serialport/directserial_os2.h dosboxcvs/src/hardware/serialport/directserial_os2.h
--- dosbox-0.73/src/hardware/serialport/directserial_os2.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/directserial_os2.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,82 +0,0 @@
-/*
- *  Copyright (C) 2002-2009  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: directserial_os2.h,v 1.5 2009/05/27 09:15:41 qbix79 Exp $ */
-
-// include guard
-#ifndef DOSBOX_DIRECTSERIAL_OS2_H
-#define DOSBOX_DIRECTSERIAL_OS2_H
-
-#include "dosbox.h"
-
-#if C_DIRECTSERIAL
-#if defined(OS2)
-#define DIRECTSERIAL_AVAILIBLE
-#include "serialport.h"
-#define INCL_DOSFILEMGR
-#define INCL_DOSERRORS
-#define INCL_DOSDEVICES
-#define INCL_DOSDEVIOCTL
-#define INCL_DOSPROCESS
-#include <os2.h>
-
-class CDirectSerial : public CSerial {
-public:
-	HFILE hCom;
-	BOOL fSuccess;
-
-	CDirectSerial(Bitu id, CommandLine* cmd);
-	~CDirectSerial();
-	
-	
-	//Bitu lastChance;		// If there is no space for new
-							// received data, it gets a little chance
-	//Bit8u ChanceChar;
-
-	//bool CanRecv(void);
-	//bool CanSend(void);
-
-
-	//void RXBufferEmpty();
-	bool receiveblock;
-	Bitu rx_retry;
-	Bitu rx_retry_max;
-
-	void CheckErrors();
-	
-	void updatePortConfig(Bit16u divider, Bit8u lcr);
-	void updateMSR();
-	void transmitByte(Bit8u val, bool first);
-	void setBreak(bool value);
-
-	void setRTSDTR(bool rts, bool dtr);
-	void setRTS(bool val);
-	void setDTR(bool val);
-	void handleUpperEvent(Bit16u type);
-
-
-	//void updateModemControlLines(/*Bit8u mcr*/);
-	//void Timer2(void);
-	
-		
-};
-#endif	// IFDEF
-
-#endif	// C_DIRECTSERIAL
-#endif	// include guard
-
diff -urN dosbox-0.73/src/hardware/serialport/directserial_posix.cpp dosboxcvs/src/hardware/serialport/directserial_posix.cpp
--- dosbox-0.73/src/hardware/serialport/directserial_posix.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/directserial_posix.cpp	1970-01-01 02:00:00.000000000 +0200
@@ -1,361 +0,0 @@
-/*
- *  Copyright (C) 2002-2009  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: directserial_posix.cpp,v 1.4 2009/05/27 09:15:41 qbix79 Exp $ */
-
-#include "dosbox.h"
-
-#if C_DIRECTSERIAL
-
-// Posix version
-#if defined (LINUX) || defined (MACOSX) || defined (BSD)
-
-#include "serialport.h"
-#include "directserial_posix.h"
-#include "pic.h"
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-
-#include <errno.h>
-#include <fcntl.h>
-
-/* This is a serial passthrough class.  Its amazingly simple to */
-/* write now that the serial ports themselves were abstracted out */
-
-CDirectSerial::CDirectSerial (Bitu id, CommandLine* cmd)
-					:CSerial (id, cmd) {
-	InstallationSuccessful = false;
-
-	rx_retry = 0;
-	rx_retry_max = 0;
-
-	std::string prefix="/dev/";
-	std::string tmpstring;
-	if(!cmd->FindStringBegin("realport:",tmpstring,false)) return;
-
-#if SERIAL_DEBUG
-		if(dbg_modemcontrol)
-			fprintf(debugfp,"%12.3f Port type directserial realport %s\r\n",
-				PIC_FullIndex(),tmpstring.c_str());
-#endif
-
-	prefix.append(tmpstring);	
-
-	// rxdelay: How many milliseconds to wait before causing an
-	// overflow when the application is unresponsive.
-	if(getBituSubstring("rxdelay:", &rx_retry_max, cmd)) {
-		if(!(rx_retry_max<=10000)) rx_retry_max=0;
-	}
-
-	const char* tmpchar=prefix.c_str();
-
-	LOG_MSG ("Serial%d: Opening %s", COMNUMBER, tmpchar);
-	
-	fileHandle = open (tmpchar, O_RDWR | O_NOCTTY | O_NONBLOCK);
-	
-	if (fileHandle < 0) {
-		LOG_MSG ("Serial%d: Serial Port \"%s\" could not be opened.",
-			COMNUMBER, tmpchar);
-		if (errno == 2) {
-			LOG_MSG ("The specified port does not exist.");
-		} else if (errno == EBUSY) {
-			LOG_MSG ("The specified port is already in use.");
-		} else {
-			LOG_MSG ("Errno %d occurred.", errno);
-		}
-		return;
-	}
-
-	int result = tcgetattr(fileHandle, &termInfo);
-
-	
-	if (result==-1) {
-		// Handle the error.
-		LOG_MSG ("tcgetattr failed with error %d.\n", errno);
-		return;
-	}
-
-	// save it here to restore in destructor
-	tcgetattr(fileHandle,&backup);
-
-	// initialize the port
-	termInfo.c_cflag = CS8 | CREAD | CLOCAL; // noparity, 1 stopbit
-	termInfo.c_iflag = PARMRK | INPCK;
-	termInfo.c_oflag = 0;
-	termInfo.c_lflag = 0;
-
-	cfsetospeed (&termInfo, B9600);
-	cfsetispeed (&termInfo, B9600);
-
-	termInfo.c_cc[VMIN] = 0;
-	termInfo.c_cc[VTIME] = 0;
-
-	tcflush (fileHandle, TCIFLUSH);
-	tcsetattr (fileHandle, TCSANOW, &termInfo);
-
-	//initialise base class
-	CSerial::Init_Registers();
-	InstallationSuccessful = true;
-	receiveblock=false;
-
-	setEvent(SERIAL_POLLING_EVENT, 1); // millisecond tick
-}
-
-CDirectSerial::~CDirectSerial () {
-	if (fileHandle >= 0) 
-	{
-		tcsetattr(fileHandle, TCSANOW, &backup);
-		close(fileHandle);
-	}
-	// We do not use own events so we don't have to clear them.
-}
-
-void CDirectSerial::handleUpperEvent(Bit16u type) {
-	
-	switch(type) {
-		case SERIAL_POLLING_EVENT: {
-			setEvent(SERIAL_POLLING_EVENT, 1);
-			if(!receiveblock) {
-				if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-				{
-					ReadCharacter();
-				} else rx_retry++;
-			}
-			// check for errors
-			CheckErrors();
-			// update Modem input line states
-			updateMSR ();
-			break;
-		}
-		case 40: {
-		// receive time is up
-			receiveblock=false;
-			// check if there is something to receive
-			if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-			{
-				ReadCharacter();
-			} else rx_retry++;
-			break;
-		}
-		case SERIAL_TX_EVENT: {
-			if(!receiveblock) {
-				if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max ))
-				{
-					ReadCharacter();
-				} else rx_retry++;
-			}
-			ByteTransmitted();
-			break;
-		}
-		case SERIAL_THR_EVENT: {
-			ByteTransmitting();
-			setEvent(SERIAL_TX_EVENT,bytetime+0.03f);
-			break;				   
-		}
-	}
-}
-
-void CDirectSerial::ReadCharacter()
-{
-	Bit8u chRead = 0;
-	int dwRead = 0;
-	rx_retry=0;
-
-	dwRead=read(fileHandle,&chRead,1);
-	if (dwRead==1) {
-		if(chRead==0xff) // error escape
-		{
-			dwRead=read(fileHandle,&chRead,1);
-			if(chRead==0x00) // an error 
-			{
-				dwRead=read(fileHandle,&chRead,1);
-				if(chRead==0x0)receiveError(LSR_RX_BREAK_MASK);
-				else receiveError(LSR_PARITY_ERROR_MASK);
-			}
-		}
-		receiveByte (chRead);
-		setEvent(40, bytetime-0.03f); // receive timing
-		receiveblock=true;
-	}
-}
-
-void CDirectSerial::CheckErrors() {
-
-}
-
-/*****************************************************************************/
-/* updatePortConfig is called when emulated app changes the serial port     **/
-/* parameters baudrate, stopbits, number of databits, parity.               **/
-/*****************************************************************************/
-void CDirectSerial::updatePortConfig (Bit16u divider, Bit8u lcr) {
-	Bit8u parity = 0;
-	Bit8u bytelength = 0;
-	int baudrate=0;
-	
-	// baud
-	termInfo.c_cflag = CREAD | CLOCAL;
-
-	if (divider == 0x1)	baudrate = B115200;
-	else if (divider == 0x2) baudrate = B57600;
-	else if (divider == 0x3) baudrate = B38400;
-	else if (divider == 0x6) baudrate = B19200;
-	else if (divider == 0xc) baudrate = B9600;
-	else if (divider == 0x18) baudrate = B4800;
-	else if (divider == 0x30) baudrate = B2400;
-	else if (divider == 0x60) baudrate = B1200;
-	else if (divider == 0xc0) baudrate = B600;
-	else if (divider == 0x180) baudrate = B300;
-	else if (divider == 0x417) baudrate = B110;
-
-	// Don't think termios supports nonstandard baudrates
-	else baudrate = B9600;
-
-	// byte length
-	bytelength = lcr & 0x3;
-	bytelength += 5;
-
-	switch (bytelength) {
-	case 5:
-		termInfo.c_cflag |= CS5;
-		break;
-
-	case 6:
-		termInfo.c_cflag |= CS6;
-		break;
-
-	case 7:
-		termInfo.c_cflag |= CS7;
-		break;
-
-	case 8:
-	default:
-		termInfo.c_cflag |= CS8;
-		break;
-	}
-
-	// parity
-	parity = lcr & 0x38;
-	parity >>= 3;
-	switch (parity) {
-	case 0x1:
-		termInfo.c_cflag |= PARODD;
-		termInfo.c_cflag |= PARENB;
-		break;
-	case 0x3:
-		termInfo.c_cflag |= PARENB;
-		break;
-	case 0x5:
-
-// "works on many systems"
-#define CMSPAR 010000000000
-
-		termInfo.c_cflag |= PARODD;
-		termInfo.c_cflag |= PARENB;
-		termInfo.c_cflag |= CMSPAR;	
-		//LOG_MSG("Serial%d: Mark parity not supported.", COMNUMBER);	
-		break;
-	case 0x7:
-		termInfo.c_cflag |= PARENB;
-		termInfo.c_cflag |= CMSPAR;
-		//LOG_MSG("Serial%d: Space parity not supported.", COMNUMBER);	
-		break;
-	default: // no parity
-		break;
-	}
-
-	// stopbits
-	if (lcr & 0x4) termInfo.c_cflag |= CSTOPB;
-	
-	cfsetospeed (&termInfo, baudrate);
-	cfsetispeed (&termInfo, baudrate);
-
-	int retval = tcsetattr(fileHandle, TCSANOW, &termInfo);
-
-	if(retval==-1)
-		LOG_MSG ("Serial%d: Desired serial mode not supported", COMNUMBER);
-
-}
-
-void CDirectSerial::updateMSR () {
-	long flags = 0;
-	ioctl (fileHandle, TIOCMGET, &flags);
-
-	if (flags & TIOCM_CTS) setCTS(true);
-	else setCTS(false);
-
-	if (flags & TIOCM_DSR) setDSR(true);
-	else setDSR(false);
-
-	if (flags & TIOCM_RI) setRI(true);
-	else setRI(false);
-
-	if (flags & TIOCM_CD) setCD(true);
-	else setCD(false);
-}
-
-void CDirectSerial::transmitByte (Bit8u val, bool first) {
-	if((LCR&LCR_BREAK_MASK) == 0) {
-		
-		int bytesWritten = write(fileHandle, &val, 1);
-		if (bytesWritten != 1)
-			LOG_MSG ("Serial%d: COM port error: write failed!", idnumber);
-	}
-	if(first) setEvent(SERIAL_THR_EVENT, bytetime/8);
-	else setEvent(SERIAL_TX_EVENT, bytetime);
-}
-
-/*****************************************************************************/
-/* setBreak(val) switches break on or off                                   **/
-/*****************************************************************************/
-void CDirectSerial::setBreak (bool value) {
-	if (value) ioctl (fileHandle, TIOCSBRK);
-	else ioctl (fileHandle, TIOCCBRK);
-}
-
-/*****************************************************************************/
-/* updateModemControlLines(mcr) sets DTR and RTS.                           **/
-/*****************************************************************************/
-void CDirectSerial::setRTSDTR(bool rts, bool dtr) {
-	
-	long setflags = 0;
-	long clearflags = 0;
-	
-	if(rts) setflags |= TIOCM_RTS;
-	else clearflags |= TIOCM_RTS;
-	
-	if(dtr) setflags |= TIOCM_DTR;
-	else clearflags |= TIOCM_DTR;
-	
-	if(setflags) ioctl (fileHandle, TIOCMBIS, &setflags);
-	if(clearflags) ioctl (fileHandle, TIOCMBIC, &clearflags);
-}
-void CDirectSerial::setRTS(bool val) {
-	long flag = TIOCM_RTS;
-	if(val) ioctl(fileHandle, TIOCMBIS, &flag);
-	else ioctl(fileHandle, TIOCMBIC, &flag);
-}
-void CDirectSerial::setDTR(bool val) {
-	long flag = TIOCM_DTR;
-	if(val) ioctl(fileHandle, TIOCMBIS, &flag);
-	else ioctl(fileHandle, TIOCMBIC, &flag);
-}
-
-#endif
-#endif
diff -urN dosbox-0.73/src/hardware/serialport/directserial_posix.h dosboxcvs/src/hardware/serialport/directserial_posix.h
--- dosbox-0.73/src/hardware/serialport/directserial_posix.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/directserial_posix.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,69 +0,0 @@
-/*
- *  Copyright (C) 2002-2009  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: directserial_posix.h,v 1.4 2009/05/27 09:15:41 qbix79 Exp $ */
-
-// include guard
-#ifndef DOSBOX_DIRECTSERIAL_POSIX_H
-#define DOSBOX_DIRECTSERIAL_POSIX_H
-
-#include "dosbox.h"
-
-#if C_DIRECTSERIAL
-#if defined (LINUX) || defined (MACOSX) || defined (BSD)
-
-
-
-#define DIRECTSERIAL_AVAILIBLE
-#include "serialport.h"
-#include <termios.h>
-#include <unistd.h>
-
-class CDirectSerial : public CSerial {
-public:
-	termios termInfo;
-	termios backup;
-	int fileHandle;
-
-	CDirectSerial(Bitu id, CommandLine* cmd);
-	~CDirectSerial();
-	bool receiveblock;		// It's not a block of data it rather blocks
-
-	Bitu rx_retry;		// counter of retries
-
-	Bitu rx_retry_max;	// how many POLL_EVENTS to wait before causing
-						// a overrun error.
-
-	void ReadCharacter();
-	void CheckErrors();
-	
-	void updatePortConfig(Bit16u divider, Bit8u lcr);
-	void updateMSR();
-	void transmitByte(Bit8u val, bool first);
-	void setBreak(bool value);
-	
-	void setRTSDTR(bool rts, bool dtr);
-	void setRTS(bool val);
-	void setDTR(bool val);
-	void handleUpperEvent(Bit16u type);
-		
-};
-
-#endif	// WIN32
-#endif	// C_DIRECTSERIAL
-#endif	// include guard
diff -urN dosbox-0.73/src/hardware/serialport/directserial_win32.h dosboxcvs/src/hardware/serialport/directserial_win32.h
--- dosbox-0.73/src/hardware/serialport/directserial_win32.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/directserial_win32.h	1970-01-01 02:00:00.000000000 +0200
@@ -1,69 +0,0 @@
-/*
- *  Copyright (C) 2002-2009  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-/* $Id: directserial_win32.h,v 1.6 2009/05/27 09:15:41 qbix79 Exp $ */
-
-// include guard
-#ifndef DOSBOX_DIRECTSERIAL_WIN32_H
-#define DOSBOX_DIRECTSERIAL_WIN32_H
-
-#include "dosbox.h"
-
-#if C_DIRECTSERIAL
-#ifdef WIN32
-
-
-
-#define DIRECTSERIAL_AVAILIBLE
-#include "serialport.h"
-#include <winsock2.h> //To prevent compilation problems with windows.h including winsock.h
-#include <windows.h>
-
-class CDirectSerial : public CSerial {
-public:
-	HANDLE hCom;
-	DCB dcb;
-	BOOL fSuccess;
-
-	CDirectSerial(Bitu id, CommandLine* cmd/*const char* configstring*/);
-	~CDirectSerial();
-	bool receiveblock;		// It's not a block of data it rather blocks
-
-	Bitu rx_retry;		// counter of retries
-
-	Bitu rx_retry_max;	// how many POLL_EVENTS to wait before causing
-						// a overrun error.
-
-
-	void CheckErrors();
-	
-	void updatePortConfig(Bit16u divider, Bit8u lcr);
-	void updateMSR();
-	void transmitByte(Bit8u val, bool first);
-	void setBreak(bool value);
-	
-	void setRTSDTR(bool rts, bool dtr);
-	void setRTS(bool val);
-	void setDTR(bool val);
-	void handleUpperEvent(Bit16u type);
-		
-};
-
-#endif	// WIN32
-#endif	// C_DIRECTSERIAL
-#endif	// include guard
diff -urN dosbox-0.73/src/hardware/serialport/libserial.cpp dosboxcvs/src/hardware/serialport/libserial.cpp
--- dosbox-0.73/src/hardware/serialport/libserial.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/libserial.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,696 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include "libserial.h"
+
+#include "config.h"
+
+#ifdef WIN32
+
+#include <windows.h>
+
+struct _COMPORT {
+	HANDLE porthandle;
+	bool breakstatus;
+	DCB orig_dcb;
+};
+
+bool SERIAL_open(const char* portname, COMPORT* port) {
+	// allocate COMPORT structure
+	COMPORT cp = (_COMPORT*)malloc(sizeof(_COMPORT));
+	if(cp == NULL) return false;
+	
+	cp->breakstatus=false;
+
+	// open the port in NT object space (recommended by Microsoft)
+	// allows the user to open COM10+ and custom port names.
+	int len = strlen(portname);
+	if(len > 240) {
+		SetLastError(ERROR_BUFFER_OVERFLOW);
+		return false;
+	}
+	char extended_portname[256] = "\\\\.\\";
+	memcpy(extended_portname+4,portname,len);
+	
+	cp->porthandle = CreateFile (extended_portname,
+					   GENERIC_READ | GENERIC_WRITE, 0,
+									  // must be opened with exclusive-access
+	                   NULL,          // no security attributes
+	                   OPEN_EXISTING, // must use OPEN_EXISTING
+	                   0,             // non overlapped I/O
+	                   NULL           // hTemplate must be NULL for comm devices
+	                  );
+
+	if (cp->porthandle == INVALID_HANDLE_VALUE) goto cleanup_error;
+	
+	cp->orig_dcb.DCBlength=sizeof(DCB);
+
+	if(!GetCommState(cp->porthandle, &cp->orig_dcb)) {
+		goto cleanup_error;
+	}
+
+	// configure the port for polling
+	DCB newdcb;
+	memcpy(&newdcb,&cp->orig_dcb,sizeof(DCB));
+
+	newdcb.fBinary=true;
+	newdcb.fParity=true;
+	newdcb.fOutxCtsFlow=false;
+	newdcb.fOutxDsrFlow=false;
+	newdcb.fDtrControl=DTR_CONTROL_DISABLE;
+	newdcb.fDsrSensitivity=false;
+	
+	newdcb.fOutX=false;
+	newdcb.fInX=false;
+	newdcb.fErrorChar=0;
+	newdcb.fNull=false;
+	newdcb.fRtsControl=RTS_CONTROL_DISABLE;
+	newdcb.fAbortOnError=false;
+
+	if(!SetCommState(cp->porthandle, &newdcb)) goto cleanup_error;
+
+	// Configure timeouts to effectively use polling
+	COMMTIMEOUTS ct;
+	ct.ReadIntervalTimeout = MAXDWORD;
+	ct.ReadTotalTimeoutConstant = 0;
+	ct.ReadTotalTimeoutMultiplier = 0;
+	ct.WriteTotalTimeoutConstant = 0;
+	ct.WriteTotalTimeoutMultiplier = 0;
+	if(!SetCommTimeouts(cp->porthandle, &ct)) goto cleanup_error;
+	if(!ClearCommBreak(cp->porthandle)) goto cleanup_error;
+	DWORD errors;
+	if(!ClearCommError(cp->porthandle, &errors, NULL)) goto cleanup_error;
+
+	*port = cp;
+	return true;
+
+cleanup_error:
+	if (cp->porthandle != INVALID_HANDLE_VALUE) CloseHandle(cp->porthandle);
+	free(cp);
+	return false;
+}
+
+void SERIAL_close(COMPORT port) {
+	// restore original DCB, close handle, free the COMPORT struct
+	if (port->porthandle != INVALID_HANDLE_VALUE) {
+		SetCommState(port->porthandle, &port->orig_dcb);
+		CloseHandle(port->porthandle);
+	}
+	free(port);
+}
+
+void SERIAL_getErrorString(char* buffer, int length) {
+	int error = GetLastError();
+	if(length < 50) return;
+	memset(buffer,0,length);
+	// get the error message text from the operating system
+	LPVOID sysmessagebuffer;
+	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+		NULL,
+		error,
+		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+		(LPTSTR) &sysmessagebuffer,
+		0,NULL);
+
+	const char* err5text = "The specified port is already in use.\n";
+	const char* err2text = "The specified port does not exist.\n";
+
+	int sysmsg_offset = 0;
+
+	if(error == 5) {
+		sysmsg_offset = strlen(err5text);
+		memcpy(buffer,err5text,sysmsg_offset);
+
+	} else if(error == 2) {
+		sysmsg_offset = strlen(err2text);
+		memcpy(buffer,err2text,sysmsg_offset);
+	}
+
+	if((length - sysmsg_offset - strlen((const char*)sysmessagebuffer)) >= 0)
+		memcpy(buffer + sysmsg_offset, sysmessagebuffer,
+		strlen((const char*)sysmessagebuffer));
+		
+	LocalFree(sysmessagebuffer);
+}
+
+
+void SERIAL_setDTR(COMPORT port, bool value) {
+	EscapeCommFunction(port->porthandle, value ? SETDTR:CLRDTR);
+}
+
+void SERIAL_setRTS(COMPORT port, bool value) {
+	EscapeCommFunction(port->porthandle, value ? SETRTS:CLRRTS);
+}
+
+void SERIAL_setBREAK(COMPORT port, bool value) {
+	EscapeCommFunction(port->porthandle, value ? SETBREAK:CLRBREAK);
+	port->breakstatus = value;
+}
+
+int SERIAL_getmodemstatus(COMPORT port) {
+	DWORD retval = 0;
+	GetCommModemStatus (port->porthandle, &retval);
+	return (int)retval;
+}
+
+bool SERIAL_sendchar(COMPORT port, char data) {
+	DWORD bytesWritten;
+
+	// mean bug: with break = 1, WriteFile will never return.
+	if(port->breakstatus) return true; // true or false?!
+
+	WriteFile (port->porthandle, &data, 1, &bytesWritten, NULL);
+	if(bytesWritten==1) return true;
+	else return false;
+}
+
+// 0-7 char data, higher=flags
+int SERIAL_getextchar(COMPORT port) {
+	DWORD errors = 0;	// errors from API
+	DWORD dwRead = 0;	// Number of chars read
+	char chRead;
+
+	int retval = 0;
+	// receive a byte; TODO communicate faliure
+	if (ReadFile (port->porthandle, &chRead, 1, &dwRead, NULL)) {
+		if (dwRead) {
+			// check for errors
+			ClearCommError(port->porthandle, &errors, NULL);
+			// mask bits are identical
+			errors &= CE_BREAK|CE_FRAME|CE_RXPARITY|CE_OVERRUN;
+			retval |= (errors<<8);
+			retval |= (chRead & 0xff);
+			retval |= 0x10000; 
+		}
+	}
+	return retval;
+}
+
+bool SERIAL_setCommParameters(COMPORT port,
+			int baudrate, char parity, int stopbits, int length) {
+	
+	DCB dcb;
+	dcb.DCBlength=sizeof(dcb);
+	GetCommState(port->porthandle,&dcb);
+
+	// parity
+	switch (parity) {
+	case 'n': dcb.Parity = NOPARITY; break;
+	case 'o': dcb.Parity = ODDPARITY; break;
+	case 'e': dcb.Parity = EVENPARITY; break;
+	case 'm': dcb.Parity = MARKPARITY; break;
+	case 's': dcb.Parity = SPACEPARITY;	break;
+	default:
+		SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+
+	// stopbits
+	switch(stopbits) {
+	case SERIAL_1STOP: dcb.StopBits = ONESTOPBIT; break;
+	case SERIAL_2STOP: dcb.StopBits = TWOSTOPBITS; break;
+	case SERIAL_15STOP: dcb.StopBits = ONE5STOPBITS; break;
+	default:
+		SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+
+	// byte length
+	if(length > 8 || length < 5) {
+		SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+	dcb.ByteSize = length;
+	dcb.BaudRate = baudrate;
+
+	if (!SetCommState (port->porthandle, &dcb)) return false;
+	return true;
+}
+#endif
+
+#if defined (LINUX) || defined (MACOSX)
+
+#include <memory.h> // strlen
+#include <malloc.h>
+
+#include <termios.h>
+#include <unistd.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h> // sprinf
+
+struct _COMPORT {
+	int porthandle;
+	bool breakstatus;
+	termios backup;
+};
+
+bool SERIAL_open(const char* portname, COMPORT* port) {
+	int result;
+	// allocate COMPORT structure
+	COMPORT cp = (_COMPORT*)malloc(sizeof(_COMPORT));
+	if(cp == NULL) return false;
+
+	cp->breakstatus=false;
+
+	int len = strlen(portname);
+	if(len > 240) {
+		///////////////////////////////////SetLastError(ERROR_BUFFER_OVERFLOW);
+		return false;
+	}
+	char extended_portname[256] = "/dev/";
+	memcpy(extended_portname+5,portname,len);
+
+	cp->porthandle = open (extended_portname, O_RDWR | O_NOCTTY | O_NONBLOCK);
+	if (cp->porthandle < 0) goto cleanup_error;
+
+	result = tcgetattr(cp->porthandle,&cp->backup);
+	if (result==-1) goto cleanup_error;
+
+	// get port settings
+	termios termInfo;
+	memcpy(&termInfo,&cp->backup,sizeof(termios));
+
+	// initialize the port
+	termInfo.c_cflag = CS8 | CREAD | CLOCAL; // noparity, 1 stopbit
+	termInfo.c_iflag = PARMRK | INPCK;
+	termInfo.c_oflag = 0;
+	termInfo.c_lflag = 0;
+	termInfo.c_cc[VMIN] = 0;
+	termInfo.c_cc[VTIME] = 0;
+
+	tcflush (cp->porthandle, TCIFLUSH);
+	tcsetattr (cp->porthandle, TCSANOW, &termInfo);
+
+	*port = cp;
+	return true;
+
+cleanup_error:
+	if (cp->porthandle != 0) close(cp->porthandle);
+	free(cp);
+	return false;
+}
+
+void SERIAL_close(COMPORT port) {
+	// restore original termios, close handle, free the COMPORT struct
+	if (port->porthandle >= 0) {
+		tcsetattr(port->porthandle, TCSANOW, &port->backup);
+		close(port->porthandle);
+	}
+	free(port);
+}
+
+void SERIAL_getErrorString(char* buffer, int length) {
+	int error = errno;
+	if(length < 50) return;
+	memset(buffer,0,length);
+	// get the error message text from the operating system
+	// TODO (or not)
+	
+	const char* err5text = "The specified port is already in use.\n";
+	const char* err2text = "The specified port does not exist.\n";
+	
+	int sysmsg_offset = 0;
+
+	if(error == EBUSY) {
+		sysmsg_offset = strlen(err5text);
+		memcpy(buffer,err5text,sysmsg_offset);
+
+	} else if(error == 2) {
+		sysmsg_offset = strlen(err2text);
+		memcpy(buffer,err2text,sysmsg_offset);
+	}
+	
+	sprintf(buffer + sysmsg_offset, "System error %d.",error);
+	
+}
+
+int SERIAL_getmodemstatus(COMPORT port) {
+	long flags = 0;
+	ioctl (port->porthandle, TIOCMGET, &flags);
+	int retval = 0;
+	if (flags & TIOCM_CTS) retval |= SERIAL_CTS;
+	if (flags & TIOCM_DSR) retval |= SERIAL_DSR;
+	if (flags & TIOCM_RI) retval |= SERIAL_RI;
+	if (flags & TIOCM_CD) retval |= SERIAL_CD;
+	return retval;
+}
+
+bool SERIAL_sendchar(COMPORT port, char data) {
+	if(port->breakstatus) return true; // true or false?!; Does POSIX need this check?
+	int bytesWritten = write(port->porthandle, &data, 1);
+	if(bytesWritten==1) return true;
+	else return false;
+}
+
+int SERIAL_getextchar(COMPORT port) {
+	unsigned char chRead = 0;
+	int dwRead = 0;
+	unsigned char error = 0;
+	int retval = 0;
+
+	dwRead=read(port->porthandle,&chRead,1);
+	if (dwRead==1) {
+		if(chRead==0xff) // error escape
+		{
+			dwRead=read(port->porthandle,&chRead,1);
+			if(chRead==0x00) // an error 
+			{
+				dwRead=read(port->porthandle,&chRead,1);
+				if(chRead==0x0) error=SERIAL_BREAK_ERR;
+				else error=SERIAL_FRAMING_ERR;
+			}
+		}
+		retval |= (error<<8);
+		retval |= chRead;
+		retval |= 0x10000; 
+	}
+	return retval;
+}
+
+bool SERIAL_setCommParameters(COMPORT port,
+			int baudrate, char parity, int stopbits, int length) {
+	
+	termios termInfo;
+	int result = tcgetattr(port->porthandle, &termInfo);
+	if (result==-1) return false;
+	termInfo.c_cflag = CREAD | CLOCAL;
+
+	// parity
+	// "works on many systems"
+	#define CMSPAR 010000000000
+	switch (parity) {
+	case 'n': break;
+	case 'o': termInfo.c_cflag |= (PARODD | PARENB); break;
+	case 'e': termInfo.c_cflag |= PARENB; break;
+	case 'm': termInfo.c_cflag |= (PARENB | CMSPAR | PARODD); break;
+	case 's': termInfo.c_cflag |= (PARENB | CMSPAR); break;
+	default:
+		return false;
+	}
+	// stopbits
+	switch(stopbits) {
+	case SERIAL_1STOP: break;
+	case SERIAL_2STOP: 
+	case SERIAL_15STOP: termInfo.c_cflag |= CSTOPB; break;
+	default:
+		return false;
+	}
+	// byte length
+	if(length > 8 || length < 5) return false;
+	switch (length) {
+	case 5: termInfo.c_cflag |= CS5; break;
+	case 6: termInfo.c_cflag |= CS6; break;
+	case 7: termInfo.c_cflag |= CS7; break;
+	case 8: termInfo.c_cflag |= CS8; break;
+	}
+	// baudrate
+	int posix_baudrate=0;
+	switch(baudrate) {
+		case 115200: posix_baudrate = B115200; break;
+		case  57600: posix_baudrate = B57600; break;
+		case  38400: posix_baudrate = B38400; break;
+		case  19200: posix_baudrate = B19200; break;
+		case   9600: posix_baudrate = B9600; break;
+		case   4800: posix_baudrate = B4800; break;
+		case   2400: posix_baudrate = B2400; break;
+		case   1200: posix_baudrate = B1200; break;
+		case    600: posix_baudrate = B600; break;
+		case    300: posix_baudrate = B300; break;
+		case    110: posix_baudrate = B110; break;
+		default: return false;
+	}
+	cfsetospeed (&termInfo, posix_baudrate);
+	cfsetispeed (&termInfo, posix_baudrate);
+
+	int retval = tcsetattr(port->porthandle, TCSANOW, &termInfo);
+	if(retval==-1) return false;
+	return true;
+}
+
+void SERIAL_setBREAK(COMPORT port, bool value) {
+	ioctl(port->porthandle, value?TIOCSBRK:TIOCCBRK);
+}
+
+void SERIAL_setDTR(COMPORT port, bool value) {
+	long flag = TIOCM_DTR;
+	ioctl(port->porthandle, value?TIOCMBIS:TIOCMBIC, &flag);
+}
+
+void SERIAL_setRTS(COMPORT port, bool value) {
+	long flag = TIOCM_RTS;
+	ioctl(port->porthandle, value?TIOCMBIS:TIOCMBIC, &flag);
+}
+#endif
+
+#ifdef OS2
+// OS/2 related headers
+#define INCL_DOSFILEMGR
+#define INCL_DOSERRORS
+#define INCL_DOSDEVICES
+#define INCL_DOSDEVIOCTL
+#define INCL_DOSPROCESS
+#include <os2.h>
+
+struct _COMPORT {
+	HFILE porthandle;
+	bool breakstatus;
+	DCBINFO backup;
+};
+// TODO: THIS IS INCOMPLETE and UNTESTED.
+
+bool SERIAL_open(const char* portname, COMPORT* port) {
+	// allocate COMPORT structure
+	COMPORT cp = (_COMPORT*)malloc(sizeof(_COMPORT));
+	if(cp == NULL) return false;
+	cp->porthandle=0;
+	cp->breakstatus=false;
+
+	ULONG ulAction = 0;
+	APIRET rc = DosOpen(portname, &cp->porthandle,
+		&ulAction, 0L, FILE_NORMAL, FILE_OPEN,
+		OPEN_ACCESS_READWRITE | OPEN_SHARE_DENYNONE | OPEN_FLAGS_SEQUENTIAL, 0L);
+	if (rc != NO_ERROR) {
+		goto cleanup_error;
+	}
+
+	ULONG ulParmLen = sizeof(DCBINFO);
+	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETDCBINFO,
+		0, 0, 0, &cp->orig_dcb, ulParmLen, &ulParmLen);
+	if ( rc != NO_ERROR) {
+		goto cleanup_error;
+	}
+	// configure the port for polling
+	DCBINFO newdcb;
+	memcpy(&newdcb,&cp->orig_dcb,sizeof(DCBINFO));
+
+	newdcb.usWriteTimeout = 0;
+	newdcb.usReadTimeout = 0; //65535;
+	newdcb.fbCtlHndShake = dcb.fbFlowReplace = 0;
+	newdcb.fbTimeout = 6;
+
+	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETDCBINFO,
+		&newdcb, ulParmLen, &ulParmLen, 0, 0, 0);
+	if ( rc != NO_ERROR) {
+		goto cleanup_error;
+	}
+
+	USHORT errors = 0;
+	ulParmLen = sizeof(errors);
+	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_GETCOMMERROR,
+		0, 0, 0, &errors, ulParmLen, &ulParmLen);
+	if ( rc != NO_ERROR) {
+		goto cleanup_error;
+	}
+
+	*port = cp;
+	return true;
+
+cleanup_error:
+	// TODO error string - rc value
+	if (cp->porthandle != 0) CloseHandle(cp->porthandle);
+	free(cp);
+	return false;
+}
+
+void SERIAL_getErrorString(char* buffer, int length) {
+	sprintf(buffer, "TODO: error handling is not fun");
+}
+void SERIAL_close(COMPORT port) {
+	ULONG ulParmLen = sizeof(DCBINFO);
+	// restore original DCB, close handle, free the COMPORT struct
+	if (port->porthandle != 0) {
+		DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_SETDCBINFO,
+			&port->orig_dcb, ulParmLen, &ulParmLen,	0, 0, 0);
+		SetCmmState(port->porthandle, &port->orig_dcb);
+		DosClose (port->porthandle);
+	}
+	free(port);
+}
+bool SERIAL_sendchar(COMPORT port, char data) {
+	ULONG bytesWritten = 0;
+	if(port->breakstatus) return true; // does OS/2 need this?
+
+	APIRET rc = DosWrite(port->porthandle, &data, 1, &bytesWritten);
+	if (rc == NO_ERROR && bytesWritten > 0) return true;
+	else return false;
+}
+
+void SERIAL_setBREAK(COMPORT port, bool value) {
+	USHORT error;
+	ULONG ulParmLen = sizeof(error);
+	DosDevIOCtl(port->porthandle, IOCTL_ASYNC,
+		value? ASYNC_SETBREAKON:ASYNC_SETBREAKOFF,
+		0,0,0, &error, ulParmLen, &ulParmLen);
+}
+
+int SERIAL_getextchar(COMPORT port) {
+	ULONG dwRead = 0;	// Number of chars read
+	char chRead;
+
+	int retval = 0;
+	// receive a byte; TODO communicate faliure
+	if (DosRead(port->porthandle, &chRead, 1, &dwRead) == NO_ERROR) {
+		if (dwRead) {
+			// check for errors; will OS/2 clear the error on reading its data?
+			// if yes then this is in wrong order
+			USHORT errors = 0, event = 0;
+			ULONG ulParmLen = sizeof(errors);
+			DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_GETCOMMEVENT,
+				0, 0, 0, &event, ulParmLen, &ulParmLen);
+			if (event & (64 + 128) ) { // Break (Bit 6) or Frame or Parity (Bit 7) error
+				Bit8u errreg = 0;
+				if (event & 64) retval |= SERIAL_BREAK_ERR;
+				if (event & 128) {
+					DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_GETCOMMERROR,
+						0, 0, 0, &errors, ulParmLen, &ulParmLen);
+					if (errors & 8) retval |= SERIAL_FRAMING_ERR;
+					if (errors & 4) retval |= SERIAL_PARITY_ERR;
+				}
+			}
+			retval |= (chRead & 0xff);
+			retval |= 0x10000; 
+		}
+	}
+	return retval;
+}
+
+
+int SERIAL_getmodemstatus(COMPORT port) {
+	UCHAR dptr = 0;
+	ULONG ulParmLen = sizeof(dptr);
+	DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_GETMODEMINPUT,
+		0, 0, 0, &dptr, ulParmLen, &ulParmLen);
+	// bits are the same as return value
+	return (int)dptr;
+}
+void SERIAL_setDTR(COMPORT port, bool value) {
+	UCHAR masks[2];
+	ULONG ulParmLen = sizeof(masks);
+	if(value) {
+		masks[0]=0x01;
+		masks[1]=0xFF;
+	} else {
+		masks[0]=0x00;
+		masks[1]=0xFE;
+	}
+	DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_SETMODEMCTRL,
+		0,0,0, &masks, ulParmLen, &ulParmLen);
+}
+
+void SERIAL_setRTS(COMPORT port, bool value) {
+	UCHAR masks[2];
+	ULONG ulParmLen = sizeof(masks);
+	if(value) {
+		masks[0]=0x02;
+		masks[1]=0xFF;
+	} else {
+		masks[0]=0x00;
+		masks[1]=0xFD;
+	}
+	DosDevIOCtl(port->porthandle, IOCTL_ASYNC, ASYNC_SETMODEMCTRL,
+		0,0,0, &masks, ulParmLen, &ulParmLen);
+}
+
+
+
+bool SERIAL_setCommParameters(COMPORT port,
+			int baudrate, char parity, int stopbits, int length) {
+	// baud
+	struct {
+		ULONG baud;
+		BYTE fraction;
+	} setbaud;
+
+	setbaud.baud = baudrate;
+	setbaud.fraction = 0;
+	ULONG ulParmLen = sizeof(setbaud);
+	APIRET rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_EXTSETBAUDRATE,
+		&setbaud, ulParmLen, &ulParmLen, 0, 0, 0);
+	if (rc != NO_ERROR) {
+		return false;
+	}
+
+	struct {
+		UCHAR data;
+		UCHAR parity;
+		UCHAR stop;
+	} paramline;
+
+	// byte length
+	if(length > 8 || length < 5) {
+		// TODO SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+	paramline.data = length;
+
+	// parity
+	switch (parity) {
+	case 'n': paramline.parity = 0; break;
+	case 'o': paramline.parity = 1; break;
+	case 'e': paramline.parity = 2; break;
+	case 'm': paramline.parity = 3; break;
+	case 's': paramline.parity = 4; break;
+	default:
+		// TODO SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+	// stopbits
+	switch(stopbits) {
+	case SERIAL_1STOP: paramline.stop = 0; break;
+	case SERIAL_2STOP: paramline.stop = 2; break;
+	case SERIAL_15STOP: paramline.stop = 1; break;
+	default:
+		// TODO SetLastError(ERROR_INVALID_PARAMETER);
+		return false;
+	}
+	// set it
+	ulParmLen = sizeof(paramline);
+	rc = DosDevIOCtl(hCom, IOCTL_ASYNC, ASYNC_SETLINECTRL,
+		&paramline, ulParmLen, &ulParmLen, 0, 0, 0);
+	if ( rc != NO_ERROR)
+		return false;
+	return true;
+}
+#endif
diff -urN dosbox-0.73/src/hardware/serialport/libserial.h dosboxcvs/src/hardware/serialport/libserial.h
--- dosbox-0.73/src/hardware/serialport/libserial.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/libserial.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,38 @@
+
+
+typedef struct _COMPORT *COMPORT;
+
+bool SERIAL_open(const char* portname, COMPORT* port);
+void SERIAL_close(COMPORT port);
+void SERIAL_getErrorString(char* buffer, int length);
+
+#define SERIAL_1STOP 1
+#define SERIAL_2STOP 2
+#define SERIAL_15STOP 0
+
+// parity: n, o, e, m, s
+
+bool SERIAL_setCommParameters(COMPORT port,
+			int baudrate, char parity, int stopbits, int length);
+
+void SERIAL_setDTR(COMPORT port, bool value);
+void SERIAL_setRTS(COMPORT port, bool value);
+void SERIAL_setBREAK(COMPORT port, bool value);
+
+#define SERIAL_CTS 0x10
+#define SERIAL_DSR 0x20
+#define SERIAL_RI 0x40
+#define SERIAL_CD 0x80
+
+int SERIAL_getmodemstatus(COMPORT port);
+bool SERIAL_setmodemcontrol(COMPORT port, int flags);
+
+bool SERIAL_sendchar(COMPORT port, char data);
+
+// 0-7 char data, higher=flags
+#define SERIAL_BREAK_ERR 0x10
+#define SERIAL_FRAMING_ERR 0x08
+#define SERIAL_PARITY_ERR 0x04
+#define SERIAL_OVERRUN_ERR 0x02
+
+int SERIAL_getextchar(COMPORT port);
diff -urN dosbox-0.73/src/hardware/serialport/Makefile.am dosboxcvs/src/hardware/serialport/Makefile.am
--- dosbox-0.73/src/hardware/serialport/Makefile.am	2007-01-13 10:35:49.000000000 +0200
+++ dosboxcvs/src/hardware/serialport/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -2,9 +2,8 @@
 
 noinst_LIBRARIES = libserial.a
 
-libserial_a_SOURCES = directserial_win32.cpp directserial_win32.h \
-                      serialdummy.cpp serialdummy.h serialport.cpp \
-		      softmodem.cpp softmodem.h misc_util.cpp misc_util.h \
-		      directserial_os2.h directserial_os2.cpp \
-		      directserial_posix.h directserial_posix.cpp \
-		      nullmodem.cpp nullmodem.h
+libserial_a_SOURCES =	directserial.cpp directserial.h \
+						libserial.cpp libserial.h \
+						serialdummy.cpp serialdummy.h serialport.cpp \
+						softmodem.cpp softmodem.h misc_util.cpp misc_util.h \
+						nullmodem.cpp nullmodem.h
diff -urN dosbox-0.73/src/hardware/serialport/Makefile.in dosboxcvs/src/hardware/serialport/Makefile.in
--- dosbox-0.73/src/hardware/serialport/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -48,12 +52,11 @@
 ARFLAGS = cru
 libserial_a_AR = $(AR) $(ARFLAGS)
 libserial_a_LIBADD =
-am_libserial_a_OBJECTS = directserial_win32.$(OBJEXT) \
+am_libserial_a_OBJECTS = directserial.$(OBJEXT) libserial.$(OBJEXT) \
 	serialdummy.$(OBJEXT) serialport.$(OBJEXT) softmodem.$(OBJEXT) \
-	misc_util.$(OBJEXT) directserial_os2.$(OBJEXT) \
-	directserial_posix.$(OBJEXT) nullmodem.$(OBJEXT)
+	misc_util.$(OBJEXT) nullmodem.$(OBJEXT)
 libserial_a_OBJECTS = $(am_libserial_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -73,6 +76,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -84,6 +89,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -94,8 +100,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -105,7 +112,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -123,12 +129,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -140,51 +149,39 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libserial.a
-libserial_a_SOURCES = directserial_win32.cpp directserial_win32.h \
-                      serialdummy.cpp serialdummy.h serialport.cpp \
-		      softmodem.cpp softmodem.h misc_util.cpp misc_util.h \
-		      directserial_os2.h directserial_os2.cpp \
-		      directserial_posix.h directserial_posix.cpp \
-		      nullmodem.cpp nullmodem.h
+libserial_a_SOURCES = directserial.cpp directserial.h \
+						libserial.cpp libserial.h \
+						serialdummy.cpp serialdummy.h serialport.cpp \
+						softmodem.cpp softmodem.h misc_util.cpp misc_util.h \
+						nullmodem.cpp nullmodem.h
 
 all: all-am
 
@@ -233,9 +230,8 @@
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directserial_os2.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directserial_posix.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directserial_win32.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directserial.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libserial.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/misc_util.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nullmodem.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/serialdummy.Po@am__quote@
@@ -243,26 +239,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/softmodem.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -274,8 +271,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -285,12 +282,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -304,21 +302,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -379,20 +378,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -412,22 +403,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/hardware/serialport/nullmodem.cpp dosboxcvs/src/hardware/serialport/nullmodem.cpp
--- dosbox-0.73/src/hardware/serialport/nullmodem.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/nullmodem.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -36,7 +36,8 @@
 	clientport = 0;
 
 	rx_retry = 0;
-	rx_retry_max = 100;
+	rx_retry_max = 20;
+	rx_state=N_RX_DISC;
 
 	tx_gather = 12;
 	
@@ -51,7 +52,7 @@
 	// usedtr: The nullmodem will
 	// 1) when it is client connect to the server not immediately but
 	//    as soon as a modem-aware application is started (DTR is switched on).
-	// 2) only transfer data when DTR is on.
+	// 2) only receive data when DTR is on.
 	if(getBituSubstring("usedtr:", &bool_temp, cmd)) {
 		if(bool_temp==1) {
 			dtrrespect=true;
@@ -105,6 +106,9 @@
 					clientsocket = new TCPClientSocket(sock);
 					if(!clientsocket->isopen) {
 						LOG_MSG("Serial%d: Connection failed.",COMNUMBER);
+#if SERIAL_DEBUG
+						log_ser(dbg_aux,"Nullmodem: Connection failed.");
+#endif
 						delete clientsocket;
 						clientsocket=0;
 						return;
@@ -115,6 +119,9 @@
 					if(!transparent) setRTSDTR(getRTS(), getDTR());
 
 					LOG_MSG("Serial%d: Connected to %s",COMNUMBER,peernamebuf);
+#if SERIAL_DEBUG
+					log_ser(dbg_aux,"Nullmodem: Connected to %s",peernamebuf);
+#endif
 					setEvent(SERIAL_POLLING_EVENT, 1);
 
 					CSerial::Init_Registers ();
@@ -204,7 +211,7 @@
 		if(rxchar==0xff) return rxchar; // 0xff 0xff -> 0xff was meant
 		rxchar&0x1? setCTS(true) : setCTS(false);
 		rxchar&0x2? setDSR(true) : setDSR(false);
-		if(rxchar&0x4) receiveError(0x10);
+		if(rxchar&0x4) receiveByteEx(0x0,0x10);
 		return -1;	// no "payload" received
 	} else return rxchar;
 }
@@ -223,14 +230,16 @@
 	clientsocket->GetRemoteAddressString(peernamebuf);
 	// transmit the line status
 	if(!transparent) setRTSDTR(getRTS(), getDTR());
-
+	rx_state=N_RX_IDLE;
 	LOG_MSG("Serial%d: Connected to %s",idnumber+1,peernamebuf);
 	setEvent(SERIAL_POLLING_EVENT, 1);
 }
 
 void CNullModem::Disconnect() {
+	removeEvent(SERIAL_POLLING_EVENT);
+	removeEvent(SERIAL_RX_EVENT);
 	// it was disconnected; free the socket and restart the server socket
-	LOG_MSG("Serial%d: Disconnected.",idnumber+1);
+	LOG_MSG("Serial%d: Disconnected.",COMNUMBER);
 	delete clientsocket;
 	clientsocket=0;
 	setDSR(false);
@@ -249,48 +258,115 @@
 		case SERIAL_POLLING_EVENT: {
 			// periodically check if new data arrived, disconnect
 			// if required. Add it back.
-			if(!receiveblock && clientsocket) {
-				if(((!(LSR&LSR_RX_DATA_READY_MASK)) || rx_retry>=rx_retry_max )
-					&&(!dtrrespect | (dtrrespect&& getDTR()) )) {
-					rx_retry=0;
-					Bits rxchar = readChar();
-					if(rxchar>=0) {
-						receiveblock=true;
-						setEvent(SERIAL_RX_EVENT, bytetime-0.01f);
-						receiveByte((Bit8u)rxchar);
+			setEvent(SERIAL_POLLING_EVENT, 1.0f);
+			// update Modem input line states
+			updateMSR();
+			switch(rx_state) {
+				case N_RX_IDLE:
+					if(CanReceiveByte()) {
+						if(doReceive()) {
+							// a byte was received
+							rx_state=N_RX_WAIT;
+							setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+						} // else still idle
+					} else {
+#if SERIAL_DEBUG
+						log_ser(dbg_aux,"Nullmodem: block on polling.");
+#endif
+						rx_state=N_RX_BLOCKED;
+						// have both delays (1ms + bytetime)
+						setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
 					}
-					else if(rxchar==-2) Disconnect();
-					else setEvent(SERIAL_POLLING_EVENT, 1);
-				} else {
-					rx_retry++;
-					setEvent(SERIAL_POLLING_EVENT, 1);
-				}
-			} 
+					break;
+				case N_RX_BLOCKED:
+                    // one timeout tick
+					if(!CanReceiveByte()) {
+						rx_retry++;
+						if(rx_retry>=rx_retry_max) {
+							// it has timed out:
+							rx_retry=0;
+							removeEvent(SERIAL_RX_EVENT);
+							if(doReceive()) {
+								// read away everything
+								while(doReceive());
+								rx_state=N_RX_WAIT;
+								setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+							} else {
+								// much trouble about nothing
+                                rx_state=N_RX_IDLE;
+#if SERIAL_DEBUG
+								log_ser(dbg_aux,"Nullmodem: unblock due to no more data",rx_retry);
+#endif
+							}
+						} // else wait further
+					} else {
+						// good: we can receive again
+						removeEvent(SERIAL_RX_EVENT);
+						rx_retry=0;
+						if(doReceive()) {
+							rx_state=N_RX_FASTWAIT;
+							setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+						} else {
+							// much trouble about nothing
+							rx_state=N_RX_IDLE;
+						}
+					}
+					break;
+
+				case N_RX_WAIT:
+				case N_RX_FASTWAIT:
+					break;
+			}
 			break;
 		}
 		case SERIAL_RX_EVENT: {
-			// receive time is up, try to receive another byte.
-			receiveblock=false;
-			
-			if((!(LSR&LSR_RX_DATA_READY_MASK) || rx_retry>=rx_retry_max)
-				&&(!dtrrespect | (dtrrespect&& getDTR()) )
-				) {
-				rx_retry=0;
-				Bits rxchar = readChar();
-				if(rxchar>=0) {
-					receiveblock=true;
-					setEvent(SERIAL_RX_EVENT, bytetime-0.01f);
-					receiveByte((Bit8u)rxchar);
-				}
-				else if(rxchar==-2) Disconnect();
-				else setEvent(SERIAL_POLLING_EVENT, 1);
-			} else {
-				setEvent(SERIAL_POLLING_EVENT, 1);
-				rx_retry++;
+			switch(rx_state) {
+				case N_RX_IDLE:
+					LOG_MSG("internal error in nullmodem");
+					break;
+
+				case N_RX_BLOCKED: // try to receive
+				case N_RX_WAIT:
+				case N_RX_FASTWAIT:
+					if(CanReceiveByte()) {
+						// just works or unblocked
+						if(doReceive()) {
+							rx_retry=0; // not waiting anymore
+							if(rx_state==N_RX_WAIT) setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+							else {
+								// maybe unblocked
+								rx_state=N_RX_FASTWAIT;
+								setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+							}
+						} else {
+							// didn't receive anything
+							rx_retry=0;
+							rx_state=N_RX_IDLE;
+						}
+					} else {
+						// blocking now or still blocked
+#if SERIAL_DEBUG
+						if(rx_state==N_RX_BLOCKED)
+							log_ser(dbg_aux,"Nullmodem: rx still blocked (retry=%d)",rx_retry);
+						else log_ser(dbg_aux,"Nullmodem: block on continued rx (retry=%d).",rx_retry);
+#endif
+						setEvent(SERIAL_RX_EVENT, bytetime*0.65f);
+						rx_state=N_RX_BLOCKED;
+					}
+
+					break;
 			}
 			break;
 		}
 		case SERIAL_TX_EVENT: {
+			// Maybe echo cirquit works a bit better this way
+			if(rx_state==N_RX_IDLE && CanReceiveByte() && clientsocket) {
+				if(doReceive()) {
+					// a byte was received
+					rx_state=N_RX_WAIT;
+					setEvent(SERIAL_RX_EVENT, bytetime*0.9f);
+				}
+			}
 			ByteTransmitted();
 			break;
 		}
@@ -301,15 +377,19 @@
 			break;				   
 		}
 		case SERIAL_SERVER_POLLING_EVENT: {
-			// As long as nothing is connected to out server poll the
+			// As long as nothing is connected to our server poll the
 			// connection.
 			clientsocket=serversocket->Accept();
 			if(clientsocket) {
 				Bit8u peeripbuf[16];
 				clientsocket->GetRemoteAddressString(peeripbuf);
-				LOG_MSG("Serial%d: A client (%s) has connected.",idnumber+1,peeripbuf);
-				// new socket found...
+				LOG_MSG("Serial%d: A client (%s) has connected.",COMNUMBER,peeripbuf);
+#if SERIAL_DEBUG
+				log_ser(dbg_aux,"Nullmodem: A client (%s) has connected.",
+					COMNUMBER,peeripbuf);
+#endif// new socket found...
 				clientsocket->SetSendBufferSize(256);
+				rx_state=N_RX_IDLE;
 				setEvent(SERIAL_POLLING_EVENT, 1);
 				
 				// we don't accept further connections
@@ -350,15 +430,23 @@
 	
 }
 
+bool CNullModem::doReceive () {
+		Bits rxchar = readChar();
+		if(rxchar>=0) {
+			receiveByteEx((Bit8u)rxchar,0);
+			return true;
+		}
+		else if(rxchar==-2) {
+			Disconnect();
+		}
+		return false;
+}
+ 
 void CNullModem::transmitByte (Bit8u val, bool first) {
+ 	// transmit it later in THR_Event
+	if(first) setEvent(SERIAL_THR_EVENT, bytetime/8);
+	else setEvent(SERIAL_TX_EVENT, bytetime);
 
-	// transmit it later in THR_Event
-	if(first) {
-		setEvent(SERIAL_THR_EVENT, bytetime/8);
-	} else {
-		//if(clientsocket) clientsocket->Putchar(val);
-		setEvent(SERIAL_TX_EVENT, bytetime);
-	}
 	// disable 0xff escaping when transparent mode is enabled
 	if (!transparent && (val==0xff)) WriteChar(0xff);
 	
diff -urN dosbox-0.73/src/hardware/serialport/nullmodem.h dosboxcvs/src/hardware/serialport/nullmodem.h
--- dosbox-0.73/src/hardware/serialport/nullmodem.h	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/nullmodem.h	2009-07-08 20:43:08.000000000 +0300
@@ -57,6 +57,14 @@
 	void setDTR(bool val);
 	void handleUpperEvent(Bit16u type);
 
+	Bitu rx_state;
+#define N_RX_IDLE		0
+#define N_RX_WAIT		1
+#define N_RX_BLOCKED	2
+#define N_RX_FASTWAIT	3
+#define N_RX_DISC		4
+
+	bool doReceive();
 	void ClientConnect();
     void Disconnect();
 	Bits readChar();
diff -urN dosbox-0.73/src/hardware/serialport/serialport.cpp dosboxcvs/src/hardware/serialport/serialport.cpp
--- dosbox-0.73/src/hardware/serialport/serialport.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/serialport.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -30,16 +30,13 @@
 #include "callback.h"				// CALLBACK_Idle
 
 #include "serialport.h"
-#include "directserial_win32.h"
-#include "directserial_posix.h"
-#include "directserial_os2.h"
+#include "directserial.h"
 #include "serialdummy.h"
 #include "softmodem.h"
 #include "nullmodem.h"
 
 #include "cpu.h"
 
-
 bool device_COM::Read(Bit8u * data,Bit16u * size) {
 	// DTR + RTS on
 	sclass->Write_MCR(0x03);
@@ -98,97 +95,140 @@
 CSerial* serialports[4] ={0,0,0,0};
 
 static Bitu SERIAL_Read (Bitu port, Bitu iolen) {
-	for(Bitu i = 0; i < 4; i++) {
-		if(serial_baseaddr[i]==(port&0xfff8) && (serialports[i]!=0)) {
-			Bitu retval=0xff;
-			switch (port & 0x7) {
-				case RHR_OFFSET:
-					retval = serialports[i]->Read_RHR();
-					break;
-				case IER_OFFSET:
-					retval = serialports[i]->Read_IER();
-					break;
-				case ISR_OFFSET:
-					retval = serialports[i]->Read_ISR();
-					break;
-				case LCR_OFFSET:
-					retval = serialports[i]->Read_LCR();
-					break;
-				case MCR_OFFSET:
-					retval = serialports[i]->Read_MCR();
-					break;
-				case LSR_OFFSET:
-					retval = serialports[i]->Read_LSR();
-					break;
-				case MSR_OFFSET:
-					retval = serialports[i]->Read_MSR();
-					break;
-				case SPR_OFFSET:
-					retval = serialports[i]->Read_SPR();
-					break;
-			}
+	Bitu i;
+	Bitu retval;
+	Bitu index = port & 0x7;
+	switch(port&0xff8) {
+		case 0x3f8: i=0; break;
+		case 0x2f8: i=1; break;
+		case 0x3e8: i=2; break;
+		case 0x2e8: i=3; break;
+		default: return 0xff;
+	}
+	if(serialports[i]==0) return 0xff;
+
+	switch (index) {
+		case RHR_OFFSET:
+			retval = serialports[i]->Read_RHR();
+			break;
+		case IER_OFFSET:
+			retval = serialports[i]->Read_IER();
+			break;
+		case ISR_OFFSET:
+			retval = serialports[i]->Read_ISR();
+			break;
+		case LCR_OFFSET:
+			retval = serialports[i]->Read_LCR();
+			break;
+		case MCR_OFFSET:
+			retval = serialports[i]->Read_MCR();
+			break;
+		case LSR_OFFSET:
+			retval = serialports[i]->Read_LSR();
+			break;
+		case MSR_OFFSET:
+			retval = serialports[i]->Read_MSR();
+			break;
+		case SPR_OFFSET:
+			retval = serialports[i]->Read_SPR();
+			break;
+	}
 
 #if SERIAL_DEBUG
-			const char* const dbgtext[]=
-				{"RHR","IER","ISR","LCR","MCR","LSR","MSR","SPR"};
-			if(serialports[i]->dbg_register)
-				fprintf(serialports[i]->debugfp,"%12.3f read 0x%x from %s.\r\n",
-					PIC_FullIndex(),retval,dbgtext[port&0x7]);
-#endif
-
-			return retval;	
-		}
+	const char* const dbgtext[]=
+		{"RHR","IER","ISR","LCR","MCR","LSR","MSR","SPR","DLL","DLM"};
+	if(serialports[i]->dbg_register) {
+		if((index<2) && ((serialports[i]->LCR)&LCR_DIVISOR_Enable_MASK))
+			index += 8;
+		serialports[i]->log_ser(serialports[i]->dbg_register,
+			"read  0x%2x from %s.",retval,dbgtext[index]);
 	}
-	return 0xff;
+#endif
+	return retval;	
 }
 static void SERIAL_Write (Bitu port, Bitu val, Bitu) {
+	Bitu i;
+	Bitu index = port & 0x7;
+	switch(port&0xff8) {
+		case 0x3f8: i=0; break;
+		case 0x2f8: i=1; break;
+		case 0x3e8: i=2; break;
+		case 0x2e8: i=3; break;
+		default: return;
+	}
+	if(serialports[i]==0) return;
 	
-	for(Bitu i = 0; i < 4; i++) {
-		if(serial_baseaddr[i]==(port&0xfff8) && serialports[i]) {
-
 #if SERIAL_DEBUG
-		const char* const dbgtext[]={"THR","IER","FCR","LCR","MCR","!LSR","MSR","SPR"};
-		if(serialports[i]->dbg_register)
-			fprintf(serialports[i]->debugfp,"%12.3f write 0x%x to %s.\r\n",
-				PIC_FullIndex(),val,dbgtext[port&0x7]);
-#endif
-
-			switch (port & 0x7) {
-				case THR_OFFSET:
-					serialports[i]->Write_THR (val);
-					return;
-				case IER_OFFSET:
-					serialports[i]->Write_IER (val);
-					return;
-				case FCR_OFFSET:
-					serialports[i]->Write_FCR (val);
-					return;
-				case LCR_OFFSET:
-					serialports[i]->Write_LCR (val);
-					return;
-				case MCR_OFFSET:
-					serialports[i]->Write_MCR (val);
-					return;
-				case MSR_OFFSET:
-					serialports[i]->Write_MSR (val);
-					return;
-				case SPR_OFFSET:
-					serialports[i]->Write_SPR (val);
-					return;
-				default:
-					serialports[i]->Write_reserved (val, port & 0x7);
-			}
-		}
+		const char* const dbgtext[]={"THR","IER","FCR",
+			"LCR","MCR","!LSR","MSR","SPR","DLL","DLM"};
+		if(serialports[i]->dbg_register) {
+			Bitu debugindex=index;
+			if((index<2) && ((serialports[i]->LCR)&LCR_DIVISOR_Enable_MASK))
+				debugindex += 8;
+			serialports[i]->log_ser(serialports[i]->dbg_register,
+				"write 0x%2x to %s.",val,dbgtext[debugindex]);
+		}
+#endif
+	switch (index) {
+		case THR_OFFSET:
+			serialports[i]->Write_THR (val);
+			return;
+		case IER_OFFSET:
+			serialports[i]->Write_IER (val);
+			return;
+		case FCR_OFFSET:
+			serialports[i]->Write_FCR (val);
+			return;
+		case LCR_OFFSET:
+			serialports[i]->Write_LCR (val);
+			return;
+		case MCR_OFFSET:
+			serialports[i]->Write_MCR (val);
+			return;
+		case MSR_OFFSET:
+			serialports[i]->Write_MSR (val);
+			return;
+		case SPR_OFFSET:
+			serialports[i]->Write_SPR (val);
+			return;
+		default:
+			serialports[i]->Write_reserved (val, port & 0x7);
 	}
 }
+#if SERIAL_DEBUG
+void CSerial::log_ser(bool active, char const* format,...) {
+	if(active) {
+		// copied from DEBUG_SHOWMSG
+		char buf[512];
+		buf[0]=0;
+		sprintf(buf,"%12.3f ",PIC_FullIndex());
+		va_list msg;
+		va_start(msg,format);
+		vsprintf(buf+strlen(buf),format,msg);
+		va_end(msg);
+		// Add newline if not present
+		Bitu len=strlen(buf);
+		if(buf[len-1]!='\n') strcat(buf,"\r\n");
+		fputs(buf,debugfp);
+	}
+}
+#endif
 
 void CSerial::changeLineProperties() {
 	// update the event wait time
+	float bitlen;
 
-	float bitlen = (1000.0f/115200.0f)*(float)baud_divider;
+	if(baud_divider==0) bitlen=(1000.0f/115200.0f);
+	else bitlen = (1000.0f/115200.0f)*(float)baud_divider;
 	bytetime=bitlen*(float)(1+5+1);		// startbit + minimum length + stopbit
 	bytetime+= bitlen*(float)(LCR&0x3); // databits
 	if(LCR&0x4) bytetime+=bitlen;		// stopbit
+
+#if SERIAL_DEBUG
+	const char* const dbgtext[]={"none","odd","none","even","none","mark","none","space"};
+	log_ser(dbg_serialtraffic,"New COM parameters: baudrate %5.0f, parity %s, wordlen %d, stopbits %d",
+		1.0/bitlen*1000.0f,dbgtext[(LCR&0x38)>>3],(LCR&0x3)+5,((LCR&0x4)>>2)+1);
+#endif	
 	updatePortConfig (baud_divider, LCR);
 }
 
@@ -212,35 +252,38 @@
 		case SERIAL_TX_LOOPBACK_EVENT: {
 
 #if SERIAL_DEBUG
-			if(dbg_serialtraffic)
-				fprintf(debugfp,loopback_data<0x10? "%12.3f tx 0x%02x (%u) (loopback)\r\n":
-												    "%12.3f tx 0x%02x (%c) (loopback)\r\n",
-					PIC_FullIndex(),loopback_data,
-					loopback_data);
+			log_ser(dbg_serialtraffic,loopback_data<0x10?
+				"tx 0x%02x (%u) (loopback)":"tx 0x%02x (%c) (loopback)",
+				loopback_data, loopback_data);
 #endif
-
 			receiveByte (loopback_data);
 			ByteTransmitted ();
 			break;
 		}
 		case SERIAL_THR_LOOPBACK_EVENT: {
+			loopback_data=txfifo->probeByte();
 			ByteTransmitting();
-			loopback_data=THR;
 			setEvent(SERIAL_TX_LOOPBACK_EVENT,bytetime);	
 			break;
 		}
 		case SERIAL_ERRMSG_EVENT: {
-			LOG_MSG("Serial%d: Errors occured: "\
-				"Framing %d, Parity %d, Overrun %d (IF0:%d), Break %d", COMNUMBER,
-				framingErrors, parityErrors, overrunErrors, overrunIF0, breakErrors);
+			LOG_MSG("Serial%d: Errors: "\
+				"Framing %d, Parity %d, Overrun RX:%d (IF0:%d), TX:%d, Break %d",
+				COMNUMBER, framingErrors, parityErrors, overrunErrors,
+				overrunIF0,txOverrunErrors, breakErrors);
 			errormsg_pending=false;
 			framingErrors=0;
 			parityErrors=0;
 			overrunErrors=0;
+			txOverrunErrors=0;
 			overrunIF0=0;
 			breakErrors=0;
 			break;					  
 		}
+		case SERIAL_RX_TIMEOUT_EVENT: {
+			rise(TIMEOUT_PRIORITY);
+			break;
+		}
 		default: handleUpperEvent(type);
 	}
 }
@@ -250,20 +293,14 @@
 /*****************************************************************************/
 void CSerial::rise (Bit8u priority) {
 #if SERIAL_DEBUG
-	if(dbg_interrupt)
-	{
-		if(priority&TX_PRIORITY && !(waiting_interrupts&TX_PRIORITY))
-			fprintf(debugfp,"%12.3f tx interrupt on.\r\n",PIC_FullIndex());
-
-		if(priority&RX_PRIORITY && !(waiting_interrupts&RX_PRIORITY))
-			fprintf(debugfp,"%12.3f rx interrupt on.\r\n",PIC_FullIndex());
-
-		if(priority&MSR_PRIORITY && !(waiting_interrupts&MSR_PRIORITY))
-			fprintf(debugfp,"%12.3f msr interrupt on.\r\n",PIC_FullIndex());
-
-		if(priority&ERROR_PRIORITY && !(waiting_interrupts&ERROR_PRIORITY))
-			fprintf(debugfp,"%12.3f error interrupt on.\r\n",PIC_FullIndex());
-	}
+	if(priority&TX_PRIORITY && !(waiting_interrupts&TX_PRIORITY))
+		log_ser(dbg_interrupt,"tx interrupt on.");
+	if(priority&RX_PRIORITY && !(waiting_interrupts&RX_PRIORITY))
+		log_ser(dbg_interrupt,"rx interrupt on.");
+	if(priority&MSR_PRIORITY && !(waiting_interrupts&MSR_PRIORITY))
+		log_ser(dbg_interrupt,"msr interrupt on.");
+	if(priority&TIMEOUT_PRIORITY && !(waiting_interrupts&TIMEOUT_PRIORITY))
+		log_ser(dbg_interrupt,"fifo rx timeout interrupt on.");
 #endif
 	
 	waiting_interrupts |= priority;
@@ -274,23 +311,15 @@
 void CSerial::clear (Bit8u priority) {
 	
 #if SERIAL_DEBUG
-	if(dbg_interrupt)
-	{
-		if(priority&TX_PRIORITY && (waiting_interrupts&TX_PRIORITY))
-			fprintf(debugfp,"%12.3f tx interrupt off.\r\n",PIC_FullIndex());
-
-		if(priority&RX_PRIORITY && (waiting_interrupts&RX_PRIORITY))
-			fprintf(debugfp,"%12.3f rx interrupt off.\r\n",PIC_FullIndex());
-
-		if(priority&MSR_PRIORITY && (waiting_interrupts&MSR_PRIORITY))
-			fprintf(debugfp,"%12.3f msr interrupt off.\r\n",PIC_FullIndex());
-
-		if(priority&ERROR_PRIORITY && (waiting_interrupts&ERROR_PRIORITY))
-			fprintf(debugfp,"%12.3f error interrupt off.\r\n",PIC_FullIndex());
-	}
+	if(priority&TX_PRIORITY && (waiting_interrupts&TX_PRIORITY))
+		log_ser(dbg_interrupt,"tx interrupt off.");
+	if(priority&RX_PRIORITY && (waiting_interrupts&RX_PRIORITY))
+		log_ser(dbg_interrupt,"rx interrupt off.");
+	if(priority&MSR_PRIORITY && (waiting_interrupts&MSR_PRIORITY))
+		log_ser(dbg_interrupt,"msr interrupt off.");
+	if(priority&ERROR_PRIORITY && (waiting_interrupts&ERROR_PRIORITY))
+		log_ser(dbg_interrupt,"error interrupt off.");
 #endif
-	
-	
 	waiting_interrupts &= (~priority);
 	ComputeInterrupts();
 }
@@ -299,29 +328,26 @@
 
 	Bitu val = IER & waiting_interrupts;
 
-	if (val & ERROR_PRIORITY)	 ISR = ISR_ERROR_VAL;
-	else if (val & RX_PRIORITY)	 ISR = ISR_RX_VAL;
-	else if (val & TX_PRIORITY)	 ISR = ISR_TX_VAL;
-	else if (val & MSR_PRIORITY) ISR = ISR_MSR_VAL;
+	if (val & ERROR_PRIORITY)			ISR = ISR_ERROR_VAL;
+	else if (val & TIMEOUT_PRIORITY)	ISR = ISR_FIFOTIMEOUT_VAL;
+	else if (val & RX_PRIORITY)			ISR = ISR_RX_VAL;
+	else if (val & TX_PRIORITY)			ISR = ISR_TX_VAL;
+	else if (val & MSR_PRIORITY)		ISR = ISR_MSR_VAL;
 	else ISR = ISR_CLEAR_VAL;
 
-	if(val && !irq_active) {
+	if(val && !irq_active) 
+	{
 		irq_active=true;
 		PIC_ActivateIRQ(irq);
-
 #if SERIAL_DEBUG
-		if(dbg_interrupt)
-			fprintf(debugfp,"%12.3f IRQ%d on.\r\n",PIC_FullIndex(),irq);
+		log_ser(dbg_interrupt,"IRQ%d on.",irq);
 #endif
 	}
-
-	if(!val && irq_active) {
+	if((val==0) && irq_active) {
 		irq_active=false;
 		PIC_DeActivateIRQ(irq);
-
 #if SERIAL_DEBUG
-		if(dbg_interrupt)
-			fprintf(debugfp,"%12.3f IRQ%d off.\r\n",PIC_FullIndex(),irq);
+		log_ser(dbg_interrupt,"IRQ%d off.",irq);
 #endif
 	}
 }
@@ -330,108 +356,98 @@
 /* Can a byte be received?                                                  **/
 /*****************************************************************************/
 bool CSerial::CanReceiveByte() {
-	return (LSR & LSR_RX_DATA_READY_MASK) == 0;
+	return !rxfifo->isFull();
 }
 
 /*****************************************************************************/
 /* A byte was received                                                      **/
 /*****************************************************************************/
-void CSerial::receiveByte (Bit8u data) {
-
+void CSerial::receiveByteEx (Bit8u data, Bit8u error) {
 #if SERIAL_DEBUG
-	if(dbg_serialtraffic)
-		fprintf(debugfp,loopback_data<0x10? "%12.3f rx 0x%02x (%u)\r\n":
-											"%12.3f rx 0x%02x (%c)\r\n",
-			PIC_FullIndex(), data, data);
+	log_ser(dbg_serialtraffic,data<0x10 ? "\t\t\t\trx 0x%02x (%u)":
+		"\t\t\t\trx 0x%02x (%c)", data, data);
 #endif
-
-	if (LSR & LSR_RX_DATA_READY_MASK) {	// Overrun error ;o
+	if (!(rxfifo->addb(data))) {
+		// Overrun error ;o
+		error |= LSR_OVERRUN_ERROR_MASK;
+	}
+	removeEvent(SERIAL_RX_TIMEOUT_EVENT);
+	if(rxfifo->getUsage()==rx_interrupt_threshold) rise (RX_PRIORITY);
+	else setEvent(SERIAL_RX_TIMEOUT_EVENT,bytetime*4.0f);
+
+	if(error) {
+		// A lot of UART chips generate a framing error too when receiving break
+		if(error&LSR_RX_BREAK_MASK) error |= LSR_FRAMING_ERROR_MASK;
+#if SERIAL_DEBUG
+		log_ser(dbg_serialtraffic,"with error: framing=%d,overrun=%d,break=%d,parity=%d",
+			(error&LSR_FRAMING_ERROR_MASK)>0,(error&LSR_OVERRUN_ERROR_MASK)>0,
+			(error&LSR_RX_BREAK_MASK)>0,(error&LSR_PARITY_ERROR_MASK)>0);
+#endif
+		if(FCR&FCR_ACTIVATE) {
+			// error and FIFO active
+			if(!errorfifo->isFull()) {
+				errors_in_fifo++;
+				errorfifo->addb(error);
+			}
+			else {
+				Bit8u toperror=errorfifo->getTop();
+				if(!toperror) errors_in_fifo++;
+				errorfifo->addb(error|toperror);
+			}
+			if(errorfifo->probeByte()) {
+				// the next byte in the error fifo has an error
+				rise (ERROR_PRIORITY);
+				LSR |= error;
+			}
+		} else {
+			// error and FIFO inactive
+			rise (ERROR_PRIORITY);
+			LSR |= error;
+		};
+        if(error&LSR_PARITY_ERROR_MASK) {
+			parityErrors++;
+		};
+		if(error&LSR_OVERRUN_ERROR_MASK) {
+			overrunErrors++;
+			if(!GETFLAG(IF)) overrunIF0++;
+#if SERIAL_DEBUG
+			log_ser(dbg_serialtraffic,"rx overrun (IF=%d)", GETFLAG(IF)>0);
+#endif
+		};
+		if(error&LSR_FRAMING_ERROR_MASK) {
+			framingErrors++;
+		}
+		if(error&LSR_RX_BREAK_MASK) {
+			breakErrors++;
+		}
+		// trigger status window error notification
 		if(!errormsg_pending) {
 			errormsg_pending=true;
 			setEvent(SERIAL_ERRMSG_EVENT,1000);
 		}
-		overrunErrors++;
-		Bitu iflag= GETFLAG(IF);
-		if(!iflag)overrunIF0++;
-
-#if SERIAL_DEBUG
-		if(dbg_serialtraffic)
-			fprintf(debugfp, "%12.3f rx overrun (IF=%d)\r\n",
-				PIC_FullIndex(), iflag);
-#endif
-
-		LSR |= LSR_OVERRUN_ERROR_MASK;
-		rise (ERROR_PRIORITY);
 	} else {
-		RHR = data;
-		LSR |= LSR_RX_DATA_READY_MASK;
-		rise (RX_PRIORITY);
+		// no error
+		if(FCR&FCR_ACTIVATE) {
+			errorfifo->addb(error);
+		}
 	}
 }
 
-/*****************************************************************************/
-/* A line error was received                                                **/
-/*****************************************************************************/
-void CSerial::receiveError (Bit8u errorword) {
-	
-	if(!errormsg_pending) {
-			errormsg_pending=true;
-			setEvent(SERIAL_ERRMSG_EVENT,1000);
-	}
-	if(errorword&LSR_PARITY_ERROR_MASK) {
-		parityErrors++;
-
-#if SERIAL_DEBUG
-		if(dbg_serialtraffic)
-			fprintf(debugfp, "%12.3f parity error\r\n",
-				PIC_FullIndex());
-#endif
-
-	}
-	if(errorword&LSR_FRAMING_ERROR_MASK) {
-		framingErrors++;
-
-#if SERIAL_DEBUG
-		if(dbg_serialtraffic)
-			fprintf(debugfp, "%12.3f framing error\r\n",
-				PIC_FullIndex());
-#endif
-
-	}
-	if(errorword&LSR_RX_BREAK_MASK) {
-		breakErrors++;
-
-#if SERIAL_DEBUG
-		if(dbg_serialtraffic)
-			fprintf(debugfp, "%12.3f break received\r\n",
-				PIC_FullIndex());
-#endif
-
-	}
-	LSR |= errorword;
-
-	rise (ERROR_PRIORITY);
+void CSerial::receiveByte (Bit8u data) {
+	receiveByteEx(data,0);
 }
 
 /*****************************************************************************/
 /* ByteTransmitting: Byte has made it from THR to TX.                       **/
 /*****************************************************************************/
 void CSerial::ByteTransmitting() {
-	switch(LSR&(LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK))
-	{
-		case LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK:
-			// bad case there must have been one
-		case LSR_TX_HOLDING_EMPTY_MASK:
-		case LSR_TX_EMPTY_MASK: // holding full but workreg empty impossible
-			LOG_MSG("Internal error in serial port(1)(0x%x).",LSR);
-			break;
-		case 0: // THR is empty now.
-			LSR |= LSR_TX_HOLDING_EMPTY_MASK;
-			
-			// trigger interrupt
-			rise (TX_PRIORITY);
-			break;
-	}
+	if(sync_guardtime) {
+		//LOG_MSG("byte transmitting after guard");
+		//if(txfifo->isEmpty()) LOG_MSG("Serial port: FIFO empty when it should not");
+		sync_guardtime=false;
+		txfifo->getb();
+	} //else LOG_MSG("byte transmitting");
+	if(txfifo->isEmpty())rise (TX_PRIORITY);
 }
 
 
@@ -439,39 +455,23 @@
 /* ByteTransmitted: When a byte was sent, notify here.                      **/
 /*****************************************************************************/
 void CSerial::ByteTransmitted () {
-	switch(LSR&(LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK))
-	{
-		case LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK:
-			// bad case there must have been one
-		case LSR_TX_EMPTY_MASK: // holding full but workreg empty impossible
-			LOG_MSG("Internal error in serial port(2).");
-			break;
-		
-		case LSR_TX_HOLDING_EMPTY_MASK: // now both are empty
-			LSR |= LSR_TX_EMPTY_MASK;
-			break;
-
-		case 0: // now one is empty, send the other one
-			LSR |= LSR_TX_HOLDING_EMPTY_MASK;
-			if (loopback) {
-				loopback_data=THR;
-				setEvent(SERIAL_TX_LOOPBACK_EVENT, bytetime);
-			}
-			else {
+	if(!txfifo->isEmpty()) {
+		// there is more data
+		Bit8u data = txfifo->getb();
+#if SERIAL_DEBUG
+		log_ser(dbg_serialtraffic,data<0x10?
+			"\t\t\t\t\ttx 0x%02x (%u) (from buffer)":
+			"\t\t\t\t\ttx 0x%02x (%c) (from buffer)",data,data);
+#endif
+		if (loopback) setEvent(SERIAL_TX_LOOPBACK_EVENT, bytetime);
+		else transmitByte(data,false);
+		if(txfifo->isEmpty())rise (TX_PRIORITY);
 
-		#if SERIAL_DEBUG
-				if(dbg_serialtraffic)
-					fprintf(debugfp,THR<0x10? "%12.3f tx 0x%02x (%u) (from THR)\r\n":
-														"%12.3f tx 0x%02x (%c) (from THR)\r\n",
-						PIC_FullIndex(),THR,
-						THR);
-		#endif
-
-				transmitByte(THR,false);
-			}
-			// It's ok here.
-			rise (TX_PRIORITY);
-			break;
+	} else {
+#if SERIAL_DEBUG
+		log_ser(dbg_serialtraffic,"tx buffer empty.");
+#endif
+		LSR |= LSR_TX_EMPTY_MASK;
 	}
 }
 
@@ -488,51 +488,43 @@
 		changeLineProperties();
 	} else {
 		// write to THR
-		clear (TX_PRIORITY);
+        clear (TX_PRIORITY);
 
-		switch(LSR&(LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK))
-		{
-			case 0: // both full - overflow
-#if SERIAL_DEBUG
-				if(dbg_serialtraffic) fprintf(debugfp, "%12.3f tx overflow\r\n",
-					PIC_FullIndex());
-#endif
-				// overwrite THR
-				THR = data;
-				break;
-		
-			case LSR_TX_EMPTY_MASK: // holding full but workreg empty impossible
-				LOG_MSG("Internal error in serial port(3).");
-				break;
-		
-			case LSR_TX_HOLDING_EMPTY_MASK: // now both are full
-				LSR &= (~LSR_TX_HOLDING_EMPTY_MASK);
-				THR = data;
-				break;
-
-			case LSR_TX_HOLDING_EMPTY_MASK|LSR_TX_EMPTY_MASK:
-				// both are full until the first delay has passed
-				THR=data;
-				LSR &= (~LSR_TX_EMPTY_MASK);
-				LSR &= (~LSR_TX_HOLDING_EMPTY_MASK);
-				if(loopback) setEvent(SERIAL_THR_LOOPBACK_EVENT, bytetime/10);
-				else {
+		if((LSR & LSR_TX_EMPTY_MASK))
+		{	// we were idle before
+			//LOG_MSG("starting new transmit cycle");
+			//if(sync_guardtime) LOG_MSG("Serial port internal error 1");
+			//if(!(LSR & LSR_TX_EMPTY_MASK)) LOG_MSG("Serial port internal error 2");
+			//if(txfifo->getUsage()) LOG_MSG("Serial port internal error 3");
 			
+			// need "warming up" time
+			sync_guardtime=true;
+			// block the fifo so it returns THR full (or not in case of FIFO on)
+			txfifo->addb(data); 
+			// transmit shift register is busy
+			LSR &= (~LSR_TX_EMPTY_MASK);
+			if(loopback) setEvent(SERIAL_THR_LOOPBACK_EVENT, bytetime/10);
+			else {
 #if SERIAL_DEBUG
-					if(dbg_serialtraffic)
-						fprintf(debugfp,data<0x10? "%12.3f tx 0x%02x (%u)\r\n":
-												   "%12.3f tx 0x%02x (%c)\r\n",
-							PIC_FullIndex(),data,
-							data);
-#endif	
-							
-					transmitByte (data,true);
+				log_ser(dbg_serialtraffic,data<0x10?
+					"\t\t\t\t\ttx 0x%02x (%u) [FIFO=%2d]":
+					"\t\t\t\t\ttx 0x%02x (%c) [FIFO=%2d]",data,data,txfifo->getUsage());
+#endif
+				transmitByte (data,true);
+			}
+		} else {
+			//  shift register is transmitting
+			if(!txfifo->addb(data)) {
+				// TX overflow
+#if SERIAL_DEBUG
+				log_ser(dbg_serialtraffic,"tx overflow");
+#endif
+				txOverrunErrors++;
+				if(!errormsg_pending) {
+					errormsg_pending=true;
+					setEvent(SERIAL_ERRMSG_EVENT,1000);
 				}
-				
-				// triggered
-				// when holding gets empty
-				// rise (TX_PRIORITY);
-				break;
+			}
 		}
 	}
 }
@@ -545,9 +537,26 @@
 	// 0-7 received data
 	if ((LCR & LCR_DIVISOR_Enable_MASK)) return baud_divider&0xff;
 	else {
-		clear (RX_PRIORITY);
-		LSR &= (~LSR_RX_DATA_READY_MASK);
-		return RHR;
+		Bit8u data=rxfifo->getb();
+		if(FCR&FCR_ACTIVATE) {
+			Bit8u error=errorfifo->getb();
+			if(error) errors_in_fifo--;
+			// new error
+			if(!rxfifo->isEmpty()) {
+				error=errorfifo->probeByte();
+				if(error) {
+					LSR |= error;
+					rise(ERROR_PRIORITY);
+				}
+			}
+		}
+		// Reading RHR resets the FIFO timeout
+		clear (TIMEOUT_PRIORITY);
+		// RX int. is cleared if the buffer holds less data than the threshold
+		if(rxfifo->getUsage()<rx_interrupt_threshold)clear(RX_PRIORITY);
+		removeEvent(SERIAL_RX_TIMEOUT_EVENT);
+		if(!rxfifo->isEmpty()) setEvent(SERIAL_RX_TIMEOUT_EVENT,bytetime*4.0f);
+		return data;
 	}
 }
 
@@ -564,7 +573,7 @@
 	// 4-7	0
 
 	if (LCR & LCR_DIVISOR_Enable_MASK) return baud_divider>>8;
-	else return IER;
+	else return IER&0x0f;
 }
 
 void CSerial::Write_IER (Bit8u data) {
@@ -573,11 +582,12 @@
 		baud_divider |= ((Bit16u)data)<<8;
 		changeLineProperties();
 	} else {
-
-		IER = data&0xF;
-		if ((LSR & LSR_TX_HOLDING_EMPTY_MASK) && (IER&TX_PRIORITY))
+		// Retrigger TX interrupt
+		if (txfifo->isEmpty()&& (data&TX_PRIORITY))
 			waiting_interrupts |= TX_PRIORITY;
 		
+		IER = data&0xF;
+		if((FCR&FCR_ACTIVATE)&&data&RX_PRIORITY) IER |= TIMEOUT_PRIORITY; 
 		ComputeInterrupts();
 	}
 }
@@ -593,6 +603,7 @@
 	// 1-3	identification
 	//      011 LSR
 	//		010 RXRDY
+	//		110 RX_TIMEOUT
 	//		001 TXRDY
 	//		000 MSR
 	// 4-7	0
@@ -601,14 +612,44 @@
 	Bit8u retval = ISR;
 
 	// clear changes ISR!! mean..
-	if(ISR==ISR_TX_VAL) clear (TX_PRIORITY);
+	if(ISR==ISR_TX_VAL) clear(TX_PRIORITY);
+	if(FCR&FCR_ACTIVATE) retval |= FIFO_STATUS_ACTIVE;
+
 	return retval;
 }
 
+#define BIT_CHANGE_H(oldv,newv,bitmask) (!(oldv&bitmask) && (newv&bitmask))
+#define BIT_CHANGE_L(oldv,newv,bitmask) ((oldv&bitmask) && !(newv&bitmask))
+
 void CSerial::Write_FCR (Bit8u data) {
-	if((!fifo_warn) && (data&0x1)) {
-		fifo_warn=true;
-		LOG_MSG("Serial%d: Warning: Tried to activate FIFO.",COMNUMBER);
+	if(BIT_CHANGE_H(FCR,data,FCR_ACTIVATE)) {
+		// FIFO was switched on
+		errors_in_fifo=0; // should already be 0
+		errorfifo->setSize(fifosize);
+		rxfifo->setSize(fifosize);
+		txfifo->setSize(fifosize);
+	} else if(BIT_CHANGE_L(FCR,data,FCR_ACTIVATE)) {
+		// FIFO was switched off
+		errors_in_fifo=0;
+		errorfifo->setSize(1);
+		rxfifo->setSize(1);
+		txfifo->setSize(1);
+		rx_interrupt_threshold=1;
+	}
+	FCR=data&0xCF;
+	if(FCR&FCR_CLEAR_RX) {
+		errors_in_fifo=0;
+		errorfifo->clear();
+		rxfifo->clear();
+	}
+	if(FCR&FCR_CLEAR_TX) txfifo->clear();
+	if(FCR&FCR_ACTIVATE) {
+		switch(FCR>>6) {
+			case 0: rx_interrupt_threshold=1; break;
+			case 1: rx_interrupt_threshold=4; break;
+			case 2: rx_interrupt_threshold=8; break;
+			case 3: rx_interrupt_threshold=14; break;
+		}
 	}
 }
 
@@ -643,10 +684,8 @@
 			// TODO: set loopback break event to reveiveError after
 		}
 #if SERIAL_DEBUG
-		if(dbg_serialtraffic)
-			fprintf(debugfp,((LCR & LCR_BREAK_MASK)!=0)?
-						"%12.3f break on.\r\n":
-						"%12.3f break off.\r\n", PIC_FullIndex());
+		log_ser(dbg_serialtraffic,((LCR & LCR_BREAK_MASK)!=0) ?
+			"break on.":"break off.");
 #endif
 	}
 }
@@ -675,7 +714,7 @@
 
 void CSerial::Write_MCR (Bit8u data) {
 	// WARNING: At the time setRTSDTR is called rts and dsr members are still wrong.
-
+	if(data&FIFO_FLOWCONTROL) LOG_MSG("Warning: tried to activate hardware handshake.");
 	bool temp_dtr = data & MCR_DTR_MASK? true:false;
 	bool temp_rts = data & MCR_RTS_MASK? true:false;
 	bool temp_op1 = data & MCR_OP1_MASK? true:false;
@@ -718,30 +757,22 @@
 				// both difference
 
 #if SERIAL_DEBUG
-			if(dbg_modemcontrol)
-			{
-				fprintf(debugfp,temp_rts?"%12.3f RTS on.\r\n":
-									"%12.3f RTS off.\r\n", PIC_FullIndex());
-				fprintf(debugfp,temp_dtr?"%12.3f DTR on.\r\n":
-									"%12.3f DTR off.\r\n", PIC_FullIndex());
-			}
+				log_ser(dbg_modemcontrol,"RTS %x.",temp_rts);
+				log_ser(dbg_modemcontrol,"DTR %x.",temp_dtr);
 #endif
 				setRTSDTR(temp_rts, temp_dtr);
 			} else {
 				// only RTS
 
 #if SERIAL_DEBUG
-			if(dbg_modemcontrol)
-				fprintf(debugfp,temp_rts?"%12.3f RTS on.\r\n":"%12.3f RTS off.\r\n", PIC_FullIndex());
+				log_ser(dbg_modemcontrol,"RTS %x.",temp_rts);
 #endif
-
 				setRTS(temp_rts);
 			}
 		} else if(temp_dtr!=dtr) {
 			// only DTR
 #if SERIAL_DEBUG
-			if(dbg_modemcontrol)
-				fprintf(debugfp,temp_dtr?"%12.3f DTR on.\r\n":"%12.3f DTR off.\r\n", PIC_FullIndex());
+				log_ser(dbg_modemcontrol,"%DTR %x.",temp_dtr);
 #endif
 			setDTR(temp_dtr);
 		}
@@ -761,7 +792,10 @@
 // - event from real serial port
 // - loopback
 Bitu CSerial::Read_LSR () {
-	Bitu retval = LSR;
+	Bitu retval = LSR & (LSR_ERROR_MASK|LSR_TX_EMPTY_MASK);
+	if(txfifo->isEmpty()) retval |= LSR_TX_HOLDING_EMPTY_MASK;
+	if(!(rxfifo->isEmpty()))retval |= LSR_RX_DATA_READY_MASK;
+	if(errors_in_fifo) retval |= FIFO_ERROR;
 	LSR &= (~LSR_ERROR_MASK);			// clear error bits on read
 	clear (ERROR_PRIORITY);
 	return retval;
@@ -872,8 +906,7 @@
 	if (value != ri) {
 
 #if SERIAL_DEBUG
-		if(dbg_modemcontrol)
-			fprintf(debugfp,value?"%12.3f RI  on.\r\n":"%12.3f RI  off.\r\n", PIC_FullIndex());
+		log_ser(dbg_modemcontrol,"%RI  %x.",value);
 #endif
 		// don't change delta when in loopback mode
 		ri=value;
@@ -887,8 +920,7 @@
 void CSerial::setDSR (bool value) {
 	if (value != dsr) {
 #if SERIAL_DEBUG
-		if(dbg_modemcontrol)
-			fprintf(debugfp,value?"%12.3f DSR on.\r\n":"%12.3f DSR off.\r\n", PIC_FullIndex());
+		log_ser(dbg_modemcontrol,"DSR %x.",value);
 #endif
 		// don't change delta when in loopback mode
 		dsr=value;
@@ -902,8 +934,7 @@
 void CSerial::setCD (bool value) {
 	if (value != cd) {
 #if SERIAL_DEBUG
-		if(dbg_modemcontrol)
-			fprintf(debugfp,value?"%12.3f CD  on.\r\n":"%12.3f CD  off.\r\n", PIC_FullIndex());
+		log_ser(dbg_modemcontrol,"CD  %x.",value);
 #endif
 		// don't change delta when in loopback mode
 		cd=value;
@@ -917,8 +948,7 @@
 void CSerial::setCTS (bool value) {
 	if (value != cts) {
 #if SERIAL_DEBUG
-		if(dbg_modemcontrol)
-			fprintf(debugfp,value?"%12.3f CTS on.\r\n":"%12.3f CTS off.\r\n", PIC_FullIndex());
+		log_ser(dbg_modemcontrol,"CTS %x.",value);
 #endif
 		// don't change delta when in loopback mode
 		cts=value;
@@ -945,8 +975,6 @@
 	Bit8u lcrresult = 0;
 	Bit16u baudresult = 0;
 
-	RHR = 0;
-	THR = 0;
 	IER = 0;
 	ISR = 0x1;
 	LCR = 0;
@@ -957,6 +985,10 @@
 	op1=true;
 	op2=true;
 
+	sync_guardtime=false;
+	FCR=0xff;
+	Write_FCR(0x00);
+
 
 	LSR = 0x60;
 	d_cts = true;	
@@ -1023,6 +1055,12 @@
 }
 
 CSerial::CSerial(Bitu id, CommandLine* cmd) {
+	idnumber=id;
+	Bit16u base = serial_baseaddr[id];
+
+	irq = serial_defaultirq[id];
+	getBituSubstring("irq:",&irq, cmd);
+	if (irq < 2 || irq > 15) irq = serial_defaultirq[id];
 
 #if SERIAL_DEBUG
 	dbg_serialtraffic = cmd->FindExist("dbgtr", false);
@@ -1031,43 +1069,53 @@
 	dbg_interrupt     = cmd->FindExist("dbgirq", false);
 	dbg_aux			  = cmd->FindExist("dbgaux", false);
 
+	if(cmd->FindExist("dbgall", false)) {
+		dbg_serialtraffic= 
+		dbg_modemcontrol= 
+		dbg_register=
+		dbg_interrupt=
+		dbg_aux= true;
+	}
 
 	if(dbg_serialtraffic|dbg_modemcontrol|dbg_register|dbg_interrupt|dbg_aux)
 		debugfp=OpenCaptureFile("serlog",".serlog.txt");
 	else debugfp=0;
 
-#endif
+	if(debugfp == 0) {
+		dbg_serialtraffic= 
+		dbg_modemcontrol= 
+		dbg_register=
+		dbg_interrupt=
+		dbg_aux= false;
+	} else {
+		std::string cleft;
+		cmd->GetStringRemain(cleft);
 
+		log_ser(true,"Serial%d: BASE %3x, IRQ %d, initstring \"%s\"\r\n\r\n",
+			COMNUMBER,base,irq,cleft.c_str());
+	}
+#endif
+	fifosize=16;
 
+	errorfifo = new MyFifo(fifosize);
+	rxfifo = new MyFifo(fifosize);
+	txfifo = new MyFifo(fifosize);
 
-	idnumber=id;
 	mydosdevice=new device_COM(this);
 	DOS_AddDevice(mydosdevice);
-	Bit16u base = serial_baseaddr[id];
-	fifo_warn=false;
 
 	errormsg_pending=false;
 	framingErrors=0;
 	parityErrors=0;
 	overrunErrors=0;
+	txOverrunErrors=0;
 	overrunIF0=0;
 	breakErrors=0;
 	
-	// find the IRQ
-	irq = serial_defaultirq[id];
-	getBituSubstring("irq:",&irq, cmd);
-	if (irq < 2 || irq > 15) irq = serial_defaultirq[id];
-
-
 	for (Bitu i = 0; i <= 7; i++) {
 		WriteHandler[i].Install (i + base, SERIAL_Write, IO_MB);
 		ReadHandler[i].Install (i + base, SERIAL_Read, IO_MB);
 	}
-
-#if SERIAL_DEBUG
-	if(debugfp) fprintf(debugfp,"COM%d: BASE %3x, IRQ %d\r\n\r\n",
-		COMNUMBER,base,irq);
-#endif
 }
 
 bool CSerial::getBituSubstring(const char* name,Bitu* data, CommandLine* cmd) {
@@ -1084,17 +1132,14 @@
 		removeEvent(i);
 }
 bool CSerial::Getchar(Bit8u* data, Bit8u* lsr, bool wait_dsr, Bitu timeout) {
-	
 	double starttime=PIC_FullIndex();
-	// wait for it to become empty
 	// wait for DSR on
 	if(wait_dsr) {
 		while((!(Read_MSR()&0x20))&&(starttime>PIC_FullIndex()-timeout))
 			CALLBACK_Idle();
 		if(!(starttime>PIC_FullIndex()-timeout)) {
-			#if SERIAL_DEBUG
-if(dbg_aux)
-		fprintf(debugfp,"%12.3f Getchar status timeout: MSR 0x%x\r\n", PIC_FullIndex(),Read_MSR());
+#if SERIAL_DEBUG
+			log_ser(dbg_aux,"Getchar status timeout: MSR 0x%x",Read_MSR());
 #endif
 			return false;
 		}
@@ -1104,21 +1149,16 @@
 		CALLBACK_Idle();
 	
 	if(!(starttime>PIC_FullIndex()-timeout)) {
-		#if SERIAL_DEBUG
-if(dbg_aux)
-		fprintf(debugfp,"%12.3f Getchar data timeout: MSR 0x%x\r\n", PIC_FullIndex(),Read_MSR());
+#if SERIAL_DEBUG
+		log_ser(dbg_aux,"Getchar data timeout: MSR 0x%x",Read_MSR());
 #endif
 		return false;
 	}
-
-
 	*data=Read_RHR();
 
 #if SERIAL_DEBUG
-	if(dbg_aux)
-		fprintf(debugfp,"%12.3f API read success: 0x%x\r\n", PIC_FullIndex(),*data);
+	log_ser(dbg_aux,"Getchar read 0x%x",*data);
 #endif
-
 	return true;
 }
 
@@ -1126,9 +1166,8 @@
 bool CSerial::Putchar(Bit8u data, bool wait_dsr, bool wait_cts, Bitu timeout) {
 	
 	double starttime=PIC_FullIndex();
-	//Bit16u starttime=
 	// wait for it to become empty
-	while(!(LSR&0x20)) {
+	while(!(Read_LSR()&0x20)) {
 		CALLBACK_Idle();
 	}
 	// wait for DSR+CTS on
@@ -1142,13 +1181,10 @@
 		} else if(wait_cts) {
 			while(!(Read_MSR()&0x10)&&(starttime>PIC_FullIndex()-timeout))
 				CALLBACK_Idle();
-
 		} 
 		if(!(starttime>PIC_FullIndex()-timeout)) {
 #if SERIAL_DEBUG
-			if(dbg_aux)
-				fprintf(debugfp,"%12.3f Putchar timeout: MSR 0x%x\r\n",
-					PIC_FullIndex(),Read_MSR());
+			log_ser(dbg_aux,"Putchar timeout: MSR 0x%x",Read_MSR());
 #endif
 			return false;
 		}
@@ -1156,8 +1192,7 @@
 	Write_THR(data);
 
 #if SERIAL_DEBUG
-	if(dbg_aux)
-		fprintf(debugfp,"%12.3f API write success: 0x%x\r\n", PIC_FullIndex(),data);
+	log_ser(dbg_aux,"Putchar 0x%x",data);
 #endif
 
 	return true;
diff -urN dosbox-0.73/src/hardware/serialport/softmodem.h dosboxcvs/src/hardware/serialport/softmodem.h
--- dosbox-0.73/src/hardware/serialport/softmodem.h	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/hardware/serialport/softmodem.h	2009-07-08 20:43:08.000000000 +0300
@@ -92,7 +92,7 @@
 			static Bits lcount=0;
 			if (lcount<1000) {
 				lcount++;
-				LOG_MSG("MODEM: FIFO Overflow! (adds len %d)",_len);
+				LOG_MSG("MODEM: FIFO Overflow! (adds len %u)",_len);
 			}
 			return;
 		}
diff -urN dosbox-0.73/src/hardware/tandy_sound.cpp dosboxcvs/src/hardware/tandy_sound.cpp
--- dosbox-0.73/src/hardware/tandy_sound.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/hardware/tandy_sound.cpp	2009-06-23 20:46:05.000000000 +0300
@@ -27,10 +27,10 @@
 #include "setup.h"
 #include "pic.h"
 #include "dma.h"
+#include "hardware.h"
 #include <cstring>
 #include <math.h>
 
-#define DAC_CLOCK 3570000
 #define MAX_OUTPUT 0x7fff
 #define STEP 0x10000
 
@@ -56,8 +56,7 @@
 #define NG_PRESET 0x0f35
 
 
-struct SN76496
-{
+struct SN76496 {
 	int SampleRate;
 	unsigned int UpdateStep;
 	int VolTable[16];	/* volume table         */
@@ -72,18 +71,36 @@
 };
 
 static struct SN76496 sn;
+
+#define TDAC_DMA_BUFSIZE 1024
+
 static struct {
 	MixerChannel * chan;
 	bool enabled;
 	Bitu last_write;
 	struct {
-		bool playing;
-		Bitu rate;
+		MixerChannel * chan;
+		bool enabled;
+		struct {
+			Bitu base;
+			Bit8u irq,dma;
+		} hw;
+		struct {
+			Bitu rate;
+			Bit8u buf[TDAC_DMA_BUFSIZE];
+			Bit8u last_sample;
+			DmaChannel * chan;
+			bool transfer_done;
+		} dma;
+		Bit8u mode,control;
+		Bit16u frequency;
+		Bit8u amplitude;
+		bool irq_activated;
 	} dac;
 } tandy;
 
 
-static void SN76496Write(Bitu port,Bitu data,Bitu iolen) {
+static void SN76496Write(Bitu /*port*/,Bitu data,Bitu /*iolen*/) {
 	struct SN76496 *R = &sn;
 
 	tandy.last_write=PIC_Ticks;
@@ -160,8 +177,7 @@
 	}
 }
 
-static void SN76496Update(Bitu length)
-{
+static void SN76496Update(Bitu length) {
 	if ((tandy.last_write+5000)<PIC_Ticks) {
 		tandy.enabled=false;
 		tandy.chan->Enable(false);
@@ -250,7 +266,7 @@
 
 		if (out > MAX_OUTPUT * STEP) out = MAX_OUTPUT * STEP;
 
-		*(buffer++) = out / STEP;
+		*(buffer++) = (Bit16s)(out / STEP);
 
 		count--;
 	}
@@ -259,11 +275,9 @@
 
 
 
-static void SN76496_set_clock(int clock)
-{
+static void SN76496_set_clock(int clock) {
 	struct SN76496 *R = &sn;
 
-
 	/* the base clock for the tone generators is the chip clock divided by 16; */
 	/* for the noise generator, it is clock / 256. */
 	/* Here we calculate the number of steps which happen during one sample */
@@ -274,20 +288,11 @@
 }
 
 
-static void TandyDACWrite(Bitu port,Bitu data,Bitu iolen) {
-	LOG_MSG("Write tandy dac %X val %X",port,data);
-
-
-}
-
-
-static void SN76496_set_gain(int gain)
-{
+static void SN76496_set_gain(int gain) {
 	struct SN76496 *R = &sn;
 	int i;
 	double out;
 
-
 	gain &= 0xff;
 
 	/* increase max output basing on gain (0.2 dB per step) */
@@ -308,14 +313,185 @@
 }
 
 
+
+bool TS_Get_Address(Bitu& tsaddr, Bitu& tsirq, Bitu& tsdma) {
+	tsaddr=0;
+	tsirq =0;
+	tsdma =0;
+	if (tandy.dac.enabled) {
+		tsaddr=tandy.dac.hw.base;
+		tsirq =tandy.dac.hw.irq;
+		tsdma =tandy.dac.hw.dma;
+		return true;
+	}
+	return false;
+}
+
+
+static void TandyDAC_DMA_CallBack(DmaChannel * /*chan*/, DMAEvent event) {
+	if (event == DMA_REACHED_TC) {
+		tandy.dac.dma.transfer_done=true;
+		PIC_ActivateIRQ(tandy.dac.hw.irq);
+	}
+}
+
+static void TandyDACModeChanged(void) {
+	switch (tandy.dac.mode&3) {
+	case 0:
+		// joystick mode
+		break;
+	case 1:
+		break;
+	case 2:
+		// recording
+		break;
+	case 3:
+		// playback
+		tandy.dac.chan->FillUp();
+		if (tandy.dac.frequency!=0) {
+			float freq=3579545.0f/((float)tandy.dac.frequency);
+			tandy.dac.chan->SetFreq((Bitu)freq);
+			float vol=((float)tandy.dac.amplitude)/7.0f;
+			tandy.dac.chan->SetVolume(vol,vol);
+			if ((tandy.dac.mode&0x0c)==0x0c) {
+				tandy.dac.dma.transfer_done=false;
+				tandy.dac.dma.chan=GetDMAChannel(tandy.dac.hw.dma);
+				if (tandy.dac.dma.chan) {
+					tandy.dac.dma.chan->Register_Callback(TandyDAC_DMA_CallBack);
+					tandy.dac.chan->Enable(true);
+//					LOG_MSG("Tandy DAC: playback started with freqency %f, volume %f",freq,vol);
+				}
+			}
+		}
+		break;
+	}
+}
+
+static void TandyDACDMAEnabled(void) {
+	TandyDACModeChanged();
+}
+
+static void TandyDACDMADisabled(void) {
+}
+
+static void TandyDACWrite(Bitu port,Bitu data,Bitu /*iolen*/) {
+	switch (port) {
+	case 0xc4: {
+		Bitu oldmode = tandy.dac.mode;
+		tandy.dac.mode = (Bit8u)(data&0xff);
+		if ((data&3)!=(oldmode&3)) {
+			TandyDACModeChanged();
+		}
+		if (((data&0x0c)==0x0c) && ((oldmode&0x0c)!=0x0c)) {
+			TandyDACDMAEnabled();
+		} else if (((data&0x0c)!=0x0c) && ((oldmode&0x0c)==0x0c)) {
+			TandyDACDMADisabled();
+		}
+		}
+		break;
+	case 0xc5:
+		switch (tandy.dac.mode&3) {
+		case 0:
+			// joystick mode
+			break;
+		case 1:
+			tandy.dac.control = (Bit8u)(data&0xff);
+			break;
+		case 2:
+			break;
+		case 3:
+			// direct output
+			break;
+		}
+		break;
+	case 0xc6:
+		tandy.dac.frequency = tandy.dac.frequency & 0xf00 | (Bit8u)(data&0xff);
+		switch (tandy.dac.mode&3) {
+		case 0:
+			// joystick mode
+			break;
+		case 1:
+		case 2:
+		case 3:
+			TandyDACModeChanged();
+			break;
+		}
+		break;
+	case 0xc7:
+		tandy.dac.frequency = tandy.dac.frequency & 0x00ff | (((Bit8u)(data&0xf))<<8);
+		tandy.dac.amplitude = (Bit8u)(data>>5);
+		switch (tandy.dac.mode&3) {
+		case 0:
+			// joystick mode
+			break;
+		case 1:
+		case 2:
+		case 3:
+			TandyDACModeChanged();
+			break;
+		}
+		break;
+	}
+}
+
+static Bitu TandyDACRead(Bitu port,Bitu /*iolen*/) {
+	switch (port) {
+	case 0xc4:
+		return (tandy.dac.mode&0x77) | (tandy.dac.irq_activated ? 0x08 : 0x00);
+	case 0xc6:
+		return (Bit8u)(tandy.dac.frequency&0xff);
+	case 0xc7:
+		return (Bit8u)(((tandy.dac.frequency>>8)&0xf) | (tandy.dac.amplitude<<5));
+	}
+	LOG_MSG("Tandy DAC: Read from unknown %X",port);
+	return 0xff;
+}
+
+static void TandyDACGenerateDMASound(Bitu length) {
+	if (length) {
+		Bitu read=tandy.dac.dma.chan->Read(length,tandy.dac.dma.buf);
+		tandy.dac.chan->AddSamples_m8(read,tandy.dac.dma.buf);
+		if (read < length) {
+			if (read>0) tandy.dac.dma.last_sample=tandy.dac.dma.buf[read-1];
+			for (Bitu ct=read; ct < length; ct++) {
+				tandy.dac.chan->AddSamples_m8(1,&tandy.dac.dma.last_sample);
+			}
+		}
+	}
+}
+
+static void TandyDACUpdate(Bitu length) {
+	if (tandy.dac.enabled && ((tandy.dac.mode&0x0c)==0x0c)) {
+		if (!tandy.dac.dma.transfer_done) {
+			Bitu len = length;
+			TandyDACGenerateDMASound(len);
+		} else {
+			for (Bitu ct=0; ct < length; ct++) {
+				tandy.dac.chan->AddSamples_m8(1,&tandy.dac.dma.last_sample);
+			}
+		}
+	} else {
+		tandy.dac.chan->AddSilence();
+	}
+}
+
+
 class TANDYSOUND: public Module_base {
 private:
-	IO_WriteHandleObject WriteHandler[3];
+	IO_WriteHandleObject WriteHandler[4];
+	IO_ReadHandleObject ReadHandler[4];
 	MixerObject MixerChan;
+	MixerObject MixerChanDAC;
 public:
 	TANDYSOUND(Section* configuration):Module_base(configuration){
 		Section_prop * section=static_cast<Section_prop *>(configuration);
 
+		bool enable_hw_tandy_dac=true;
+		Bitu sbport, sbirq, sbdma;
+		if (SB_Get_Address(sbport, sbirq, sbdma)) {
+			enable_hw_tandy_dac=false;
+		}
+
 		real_writeb(0x40,0xd4,0x00);
 		if (IS_TANDY_ARCH) {
 			/* enable tandy sound if tandy=true/auto */
@@ -330,18 +506,47 @@
 			/* ports from second DMA controller conflict with tandy ports */
 			CloseSecondDMAController();
 
-			WriteHandler[2].Install(0x1e0,SN76496Write,IO_MB,2);
+			if (enable_hw_tandy_dac) {
+				WriteHandler[2].Install(0x1e0,SN76496Write,IO_MB,2);
+				WriteHandler[3].Install(0x1e4,TandyDACWrite,IO_MB,4);
+//				ReadHandler[3].Install(0x1e4,TandyDACRead,IO_MB,4);
+			}
 		}
-	
-		WriteHandler[0].Install(0xc0,SN76496Write,IO_MB,2);
-		WriteHandler[1].Install(0xc4,TandyDACWrite,IO_MB,4);
-	
-	
+
+
 		Bit32u sample_rate = section->Get_int("tandyrate");
 		tandy.chan=MixerChan.Install(&SN76496Update,sample_rate,"TANDY");
-	
+
+		WriteHandler[0].Install(0xc0,SN76496Write,IO_MB,2);
+
+		if (enable_hw_tandy_dac) {
+			// enable low-level Tandy DAC emulation
+			WriteHandler[1].Install(0xc4,TandyDACWrite,IO_MB,4);
+			ReadHandler[1].Install(0xc4,TandyDACRead,IO_MB,4);
+
+			tandy.dac.enabled=true;
+			tandy.dac.chan=MixerChanDAC.Install(&TandyDACUpdate,sample_rate,"TANDYDAC");
+
+			tandy.dac.hw.base=0xc4;
+			tandy.dac.hw.irq =7;
+			tandy.dac.hw.dma =1;
+		} else {
+			tandy.dac.enabled=false;
+			tandy.dac.hw.base=0;
+			tandy.dac.hw.irq =0;
+			tandy.dac.hw.dma =0;
+		}
+
+		tandy.dac.control=0;
+		tandy.dac.mode   =0;
+		tandy.dac.irq_activated=false;
+		tandy.dac.frequency=0;
+		tandy.dac.amplitude=0;
+		tandy.dac.dma.last_sample=0;
+
+
 		tandy.enabled=false;
-		real_writeb(0x40,0xd4,0xff);	/* tandy DAC initialization value */
+		real_writeb(0x40,0xd4,0xff);	/* BIOS Tandy DAC initialization value */
 
 		Bitu i;
 		struct SN76496 *R = &sn;
@@ -371,7 +576,7 @@
 
 static TANDYSOUND* test;
 
-void TANDYSOUND_ShutDown(Section* sec) {
+void TANDYSOUND_ShutDown(Section* /*sec*/) {
 	delete test;	
 }
 
diff -urN dosbox-0.73/src/hardware/vga_attr.cpp dosboxcvs/src/hardware/vga_attr.cpp
--- dosbox-0.73/src/hardware/vga_attr.cpp	2009-05-27 12:15:41.000000000 +0300
+++ dosboxcvs/src/hardware/vga_attr.cpp	2009-06-28 17:56:13.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: vga_attr.cpp,v 1.30 2009/05/27 09:15:41 qbix79 Exp $ */
+/* $Id: vga_attr.cpp,v 1.31 2009/06/28 14:56:13 c2woody Exp $ */
 
 #include "dosbox.h"
 #include "inout.h"
@@ -43,12 +43,14 @@
 	VGA_DAC_CombineColor(index,val);
 }
 
-Bitu read_p3c0(Bitu port,Bitu iolen) {
-//Wcharts
-	return 0x0;
+Bitu read_p3c0(Bitu /*port*/,Bitu /*iolen*/) {
+	// Wcharts, Win 3.11 & 95 SVGA
+	Bitu retval = attr(index) & 0x1f;
+	if (attr(enabled)) retval |= 0x20;
+	return retval;
 }
  
-void write_p3c0(Bitu port,Bitu val,Bitu iolen) {
+void write_p3c0(Bitu /*port*/,Bitu val,Bitu iolen) {
 	if (!vga.internal.attrindex) {
 		attr(index)=val & 0x1F;
 		vga.internal.attrindex=true;
@@ -67,7 +69,7 @@
 		case 0x04:		case 0x05:		case 0x06:		case 0x07:
 		case 0x08:		case 0x09:		case 0x0a:		case 0x0b:
 		case 0x0c:		case 0x0d:		case 0x0e:		case 0x0f:
-			if (!attr(enabled)) VGA_ATTR_SetPalette(attr(index),val);
+			if (!attr(enabled)) VGA_ATTR_SetPalette(attr(index),(Bit8u)val);
 			/*
 				0-5	Index into the 256 color DAC table. May be modified by 3C0h index
 				10h and 14h.
@@ -77,7 +79,7 @@
 			if (!IS_VGA_ARCH) val&=0x1f;	// not really correct, but should do it
 			if ((attr(mode_control) ^ val) & 0x80) {
 				attr(mode_control)^=0x80;
-				for (Bitu i=0;i<0x10;i++) {
+				for (Bit8u i=0;i<0x10;i++) {
 					VGA_ATTR_SetPalette(i,vga.attr.palette[i]);
 				}
 			}
@@ -85,11 +87,11 @@
 				VGA_SetBlinking(val & 0x8);
 			}
 			if ((attr(mode_control) ^ val) & 0x04) {
-				attr(mode_control)=val;
+				attr(mode_control)=(Bit8u)val;
 				VGA_DetermineMode();
 				if ((IS_VGA_ARCH) && (svgaCard==SVGA_None)) VGA_StartResize();
 			} else {
-				attr(mode_control)=val;
+				attr(mode_control)=(Bit8u)val;
 				VGA_DetermineMode();
 			}
 
@@ -111,12 +113,12 @@
 			*/
 			break;
 		case 0x11:	/* Overscan Color Register */
-			attr(overscan_color)=val;
+			attr(overscan_color)=(Bit8u)val;
 			/* 0-5  Color of screen border. Color is defined as in the palette registers. */
 			break;
 		case 0x12:	/* Color Plane Enable Register */
 			/* Why disable colour planes? */
-			attr(color_plane_enable)=val;
+			attr(color_plane_enable)=(Bit8u)val;
 			/* 
 				0	Bit plane 0 is enabled if set.
 				1	Bit plane 1 is enabled if set.
@@ -133,7 +135,7 @@
 			case M_TEXT:
 				if ((val==0x7) && (svgaCard==SVGA_None)) vga.config.pel_panning=7;
 				if (val>0x7) vga.config.pel_panning=0;
-				else vga.config.pel_panning=val+1;
+				else vga.config.pel_panning=(Bit8u)(val+1);
 				break;
 			case M_VGA:
 			case M_LIN8:
@@ -163,8 +165,8 @@
 				break;
 			}
 			if (attr(color_select) ^ val) {
-				attr(color_select)=val;
-				for (Bitu i=0;i<0x10;i++) {
+				attr(color_select)=(Bit8u)val;
+				for (Bit8u i=0;i<0x10;i++) {
 					VGA_ATTR_SetPalette(i,vga.attr.palette[i]);
 				}
 			}
@@ -187,7 +189,7 @@
 	}
 }
 
-Bitu read_p3c1(Bitu port,Bitu iolen) {
+Bitu read_p3c1(Bitu /*port*/,Bitu iolen) {
 //	vga.internal.attrindex=false;
 	switch (attr(index)) {
 			/* Palette */
diff -urN dosbox-0.73/src/hardware/vga_draw.cpp dosboxcvs/src/hardware/vga_draw.cpp
--- dosbox-0.73/src/hardware/vga_draw.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/hardware/vga_draw.cpp	2010-10-29 14:12:58.950385256 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: vga_draw.cpp,v 1.107 2009/04/11 08:02:23 qbix79 Exp $ */
+/* $Id: vga_draw.cpp,v 1.109 2009/06/29 18:43:33 c2woody Exp $ */
 
 #include <string.h>
 #include <math.h>
@@ -27,7 +27,7 @@
 #include "vga.h"
 #include "pic.h"
 
-#define VGA_PARTS 4
+#define VGA_PARTS 1
 
 typedef Bit8u * (* VGA_Line_Handler)(Bitu vidstart, Bitu line);
 
@@ -616,7 +616,7 @@
 }
 
 static void VGA_DrawSingleLine(Bitu /*blah*/) {
-	if(vga.attr.enabled || (!(vga.mode==M_VGA || vga.mode==M_EGA))) {
+	if (vga.attr.enabled) {
         Bit8u * data=VGA_DrawLine( vga.draw.address, vga.draw.address_line );	
 		RENDER_DrawLine(data);
 	} else {
@@ -1044,6 +1044,7 @@
 			clock = 14318180;
 			break;
 		}
+		vga.draw.delay.hdend = hdend*1000.0/clock; //in milliseconds
 	}
 #if C_DEBUG
 	LOG(LOG_VGA,LOG_NORMAL)("h total %d end %d blank (%d/%d) retrace (%d/%d)",
diff -urN dosbox-0.73/src/hardware/vga_other.cpp dosboxcvs/src/hardware/vga_other.cpp
--- dosbox-0.73/src/hardware/vga_other.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/hardware/vga_other.cpp	2009-06-29 21:43:33.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: vga_other.cpp,v 1.25 2009/01/25 12:00:51 c2woody Exp $ */
+/* $Id: vga_other.cpp,v 1.27 2009/06/29 18:43:33 c2woody Exp $ */
 
 #include <string.h>
 #include <math.h>
@@ -28,57 +28,57 @@
 #include "render.h"
 #include "mapper.h"
 
-static void write_crtc_index_other(Bitu port,Bitu val,Bitu iolen) {
-	vga.other.index=val;
+static void write_crtc_index_other(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
+	vga.other.index=(Bit8u)val;
 }
 
-static Bitu read_crtc_index_other(Bitu port,Bitu iolen) {
+static Bitu read_crtc_index_other(Bitu /*port*/,Bitu /*iolen*/) {
 	return vga.other.index;
 }
 
-static void write_crtc_data_other(Bitu port,Bitu val,Bitu iolen) {
+static void write_crtc_data_other(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
 	switch (vga.other.index) {
 	case 0x00:		//Horizontal total
 		if (vga.other.htotal ^ val) VGA_StartResize();
-		vga.other.htotal=val;
+		vga.other.htotal=(Bit8u)val;
 		break;
 	case 0x01:		//Horizontal displayed chars
 		if (vga.other.hdend ^ val) VGA_StartResize();
-		vga.other.hdend=val;
+		vga.other.hdend=(Bit8u)val;
 		break;
 	case 0x02:		//Horizontal sync position
-		vga.other.hsyncp=val;
+		vga.other.hsyncp=(Bit8u)val;
 		break;
 	case 0x03:		//Horizontal and vertical sync width
-		vga.other.syncw=val;
+		vga.other.syncw=(Bit8u)val;
 		break;
 	case 0x04:		//Vertical total
 		if (vga.other.vtotal ^ val) VGA_StartResize();
-		vga.other.vtotal=val;
+		vga.other.vtotal=(Bit8u)val;
 		break;
 	case 0x05:		//Vertical display adjust
 		if (vga.other.vadjust ^ val) VGA_StartResize();
-		vga.other.vadjust=val;
+		vga.other.vadjust=(Bit8u)val;
 		break;
 	case 0x06:		//Vertical rows
 		if (vga.other.vdend ^ val) VGA_StartResize();
-		vga.other.vdend=val;
+		vga.other.vdend=(Bit8u)val;
 		break;
 	case 0x07:		//Vertical sync position
-		vga.other.vsyncp=val;
+		vga.other.vsyncp=(Bit8u)val;
 		break;
 	case 0x09:		//Max scanline
 		if (vga.other.max_scanline ^ val) VGA_StartResize();
-		vga.other.max_scanline=val;
+		vga.other.max_scanline=(Bit8u)val;
 		break;
 	case 0x0A:	/* Cursor Start Register */
-		vga.other.cursor_start = val & 0x3f;
-		vga.draw.cursor.sline = val&0x1f;
+		vga.other.cursor_start = (Bit8u)(val & 0x3f);
+		vga.draw.cursor.sline = (Bit8u)(val&0x1f);
 		vga.draw.cursor.enabled = ((val & 0x60) != 0x20);
 		break;
 	case 0x0B:	/* Cursor End Register */
-		vga.other.cursor_end = val&0x1f;
-		vga.draw.cursor.eline = val&0x1f;
+		vga.other.cursor_end = (Bit8u)(val&0x1f);
+		vga.draw.cursor.eline = (Bit8u)(val&0x1f);
 		break;
 	case 0x0C:	/* Start Address High Register */
 		vga.config.display_start=(vga.config.display_start & 0x00FF) | (val << 8);
@@ -88,23 +88,25 @@
 		break;
 	case 0x0E:	/*Cursor Location High Register */
 		vga.config.cursor_start&=0x00ff;
-		vga.config.cursor_start|=val << 8;
+		vga.config.cursor_start|=((Bit8u)val) << 8;
 		break;
 	case 0x0F:	/* Cursor Location Low Register */
 		vga.config.cursor_start&=0xff00;
-		vga.config.cursor_start|=val;
+		vga.config.cursor_start|=(Bit8u)val;
 		break;
 	case 0x10:	/* Light Pen High */
-		vga.other.lpen_high = val & 0x1f;		//only 6 bits
+		vga.other.lightpen &= 0xff;
+		vga.other.lightpen |= (val & 0x3f)<<8;		// only 6 bits
 		break;
 	case 0x11:	/* Light Pen Low */
-		vga.other.lpen_low = val;
+		vga.other.lightpen &= 0xff00;
+		vga.other.lightpen |= (Bit8u)val;
 		break;
 	default:
 		LOG(LOG_VGAMISC,LOG_NORMAL)("MC6845:Write %X to illegal index %x",val,vga.other.index);
 	}
 }
-static Bitu read_crtc_data_other(Bitu port,Bitu iolen) {
+static Bitu read_crtc_data_other(Bitu /*port*/,Bitu /*iolen*/) {
 	switch (vga.other.index) {
 	case 0x00:		//Horizontal total
 		return vga.other.htotal;
@@ -129,21 +131,21 @@
 	case 0x0B:	/* Cursor End Register */
 		return vga.other.cursor_end;
 	case 0x0C:	/* Start Address High Register */
-		return vga.config.display_start >> 8;
+		return (Bit8u)(vga.config.display_start >> 8);
 	case 0x0D:	/* Start Address Low Register */
-		return vga.config.display_start;
+		return (Bit8u)(vga.config.display_start & 0xff);
 	case 0x0E:	/*Cursor Location High Register */
-		return vga.config.cursor_start>>8;
+		return (Bit8u)(vga.config.cursor_start >> 8);
 	case 0x0F:	/* Cursor Location Low Register */
-		return vga.config.cursor_start;
+		return (Bit8u)(vga.config.cursor_start & 0xff);
 	case 0x10:	/* Light Pen High */
-		return vga.other.lpen_high;
+		return (Bit8u)(vga.other.lightpen >> 8);
 	case 0x11:	/* Light Pen Low */
-		return vga.other.lpen_low;
+		return (Bit8u)(vga.other.lightpen & 0xff);
 	default:
 		LOG(LOG_VGAMISC,LOG_NORMAL)("MC6845:Read from illegal index %x",vga.other.index);
 	}
-	return ~0;
+	return (Bitu)(~0);
 }
 
 static double hue_offset = 0.0;
@@ -206,7 +208,7 @@
 			G = Y - 0.272*I - 0.647*Q; if (G < 0.0) G = 0.0; if (G > 1.0) G = 1.0;
 			B = Y - 1.105*I + 1.702*Q; if (B < 0.0) B = 0.0; if (B > 1.0) B = 1.0;
 
-			RENDER_SetPal(index,static_cast<Bit8u>(R*baseR),static_cast<Bit8u>(G*baseG),static_cast<Bit8u>(B*baseB));
+			RENDER_SetPal((Bit8u)index,static_cast<Bit8u>(R*baseR),static_cast<Bit8u>(G*baseG),static_cast<Bit8u>(B*baseB));
 		}
 	}
 }
@@ -303,7 +305,7 @@
 		vga.tandy.line_shift = 13;
 		vga.tandy.addr_mask = (1 << 13) - 1;
 	} else {
-		vga.tandy.addr_mask = ~0;
+		vga.tandy.addr_mask = (Bitu)(~0);
 		vga.tandy.line_shift = 0;
 	}
 }
@@ -352,10 +354,10 @@
 	}
 }
 
-static void write_cga(Bitu port,Bitu val,Bitu iolen) {
+static void write_cga(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3d8:
-		vga.tandy.mode_control=val;
+		vga.tandy.mode_control=(Bit8u)val;
 		if (vga.tandy.mode_control & 0x2) {
 			if (vga.tandy.mode_control & 0x10) {
 				if (!(val & 0x4) && machine==MCH_CGA) {
@@ -371,36 +373,48 @@
 		VGA_SetBlinking(val & 0x20);
 		break;
 	case 0x3d9:
-		write_color_select(val);
+		write_color_select((Bit8u)val);
 		break;
 	}
 }
 
-static void write_tandy(Bitu port,Bitu val,Bitu iolen) {
+static void write_tandy(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3d8:
-		vga.tandy.mode_control=val;
+		vga.tandy.mode_control=(Bit8u)val;
 		TandyCheckLineMask();
 		VGA_SetBlinking(val & 0x20);
 		TANDY_FindMode();
 		break;
 	case 0x3d9:
-		write_color_select(val);
+		write_color_select((Bit8u)val);
 		break;
 	case 0x3da:
-		vga.tandy.reg_index=val;
+		vga.tandy.reg_index=(Bit8u)val;
 		break;
-//	case 0x3db:	//Clear lightpen latch
+	case 0x3db:	// Clear lightpen latch
+		vga.other.lightpen_triggered = false;
 		break;
-//	case 0x3dc:	//Preset lightpen latch
+	case 0x3dc:	// Preset lightpen latch
+		if (!vga.other.lightpen_triggered) {
+			vga.other.lightpen_triggered = true; // TODO: this shows at port 3ba/3da bit 1
+			
+			double timeInFrame = PIC_FullIndex()-vga.draw.delay.framestart;
+			double timeInLine = fmod(timeInFrame,vga.draw.delay.htotal);
+			Bitu current_scanline = (Bitu)(timeInFrame / vga.draw.delay.htotal);
+			
+			vga.other.lightpen = (Bit16u)((vga.draw.address_add/2) * (current_scanline/2));
+			vga.other.lightpen += (Bit16u)((timeInLine / vga.draw.delay.hdend) *
+				((float)(vga.draw.address_add/2)));
+		}
 		break;
 //	case 0x3dd:	//Extended ram page address register:
 		break;
 	case 0x3de:
-		write_tandy_reg(val);
+		write_tandy_reg((Bit8u)val);
 		break;
 	case 0x3df:
-		vga.tandy.line_mask = val >> 6;
+		vga.tandy.line_mask = (Bit8u)(val >> 6);
 		vga.tandy.draw_bank = val & ((vga.tandy.line_mask&2) ? 0x6 : 0x7);
 		vga.tandy.mem_bank = (val >> 3) & ((vga.tandy.line_mask&2) ? 0x6 : 0x7);
 		TandyCheckLineMask();
@@ -409,18 +423,18 @@
 	}
 }
 
-static void write_pcjr(Bitu port,Bitu val,Bitu iolen) {
+static void write_pcjr(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3d9:
-		write_color_select(val);
+		write_color_select((Bit8u)val);
 		break;
 	case 0x3da:
-		if (vga.tandy.pcjr_flipflop) write_tandy_reg(val);
-		else vga.tandy.reg_index=val;
+		if (vga.tandy.pcjr_flipflop) write_tandy_reg((Bit8u)val);
+		else vga.tandy.reg_index=(Bit8u)val;
 		vga.tandy.pcjr_flipflop=!vga.tandy.pcjr_flipflop;
 		break;
 	case 0x3df:
-		vga.tandy.line_mask = val >> 6;
+		vga.tandy.line_mask = (Bit8u)(val >> 6);
 		vga.tandy.draw_bank = val & ((vga.tandy.line_mask&2) ? 0x6 : 0x7);
 		vga.tandy.mem_bank = (val >> 3) & ((vga.tandy.line_mask&2) ? 0x6 : 0x7);
 		vga.tandy.draw_base = &MemBase[vga.tandy.draw_bank * 16 * 1024];
@@ -431,7 +445,7 @@
 	}
 }
 
-static void write_hercules(Bitu port,Bitu val,Bitu iolen) {
+static void write_hercules(Bitu port,Bitu val,Bitu /*iolen*/) {
 	switch (port) {
 	case 0x3b8: {
 		// the protected bits can always be cleared but only be set if the 
@@ -466,7 +480,7 @@
 		break;
 		}
 	case 0x3bf:
-		vga.herc.enable_bits=val;
+		vga.herc.enable_bits=(Bit8u)val;
 		break;
 	}
 }
@@ -476,7 +490,7 @@
 	return 0;
 } */
 
-Bitu read_herc_status(Bitu port,Bitu iolen) {
+Bitu read_herc_status(Bitu /*port*/,Bitu /*iolen*/) {
 	// 3BAh (R):  Status Register
 	// bit   0  Horizontal sync
 	//       1  Light pen status (only some cards)
@@ -507,6 +521,8 @@
 void VGA_SetupOther(void) {
 	Bitu i;
 	memset( &vga.tandy, 0, sizeof( vga.tandy ));
+	vga.attr.enabled = true;
+
 	//Initialize values common for most machines, can be overwritten
 	vga.tandy.draw_base = vga.mem.linear;
 	vga.tandy.mem_base = vga.mem.linear;
@@ -527,6 +543,8 @@
 	if (machine==MCH_CGA) {
 		IO_RegisterWriteHandler(0x3d8,write_cga,IO_MB);
 		IO_RegisterWriteHandler(0x3d9,write_cga,IO_MB);
+		IO_RegisterWriteHandler(0x3db,write_tandy,IO_MB);
+		IO_RegisterWriteHandler(0x3dc,write_tandy,IO_MB);
 		MAPPER_AddHandler(IncreaseHue,MK_f11,MMOD2,"inchue","Inc Hue");
 		MAPPER_AddHandler(DecreaseHue,MK_f11,0,"dechue","Dec Hue");
 	}
@@ -580,4 +598,3 @@
 	}
 
 }
-
diff -urN dosbox-0.73/src/ints/bios.cpp dosboxcvs/src/ints/bios.cpp
--- dosbox-0.73/src/ints/bios.cpp	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/ints/bios.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: bios.cpp,v 1.74 2009/05/27 09:15:42 qbix79 Exp $ */
+/* $Id: bios.cpp,v 1.77 2009/06/23 17:46:05 c2woody Exp $ */
 
 #include "dosbox.h"
 #include "mem.h"
@@ -26,10 +26,14 @@
 #include "callback.h"
 #include "inout.h"
 #include "pic.h"
+#include "hardware.h"
 #include "joystick.h"
 #include "mouse.h"
 #include "setup.h"
 #include "serialport.h"
+#include "parport.h"
+#include <time.h>
+#include <sys/timeb.h>
 
 
 /* if mem_systems 0 then size_extended is reported as the real size else 
@@ -69,49 +73,40 @@
 	Bit8u irq;
 	Bit8u dma;
 } tandy_sb;
-
-static bool Tandy_ProbeSBPort(Bit16u sbport) {
-	IO_Write(sbport+0x6,1);
-	IO_Write(sbport+0x6,0);
-	while (!(IO_Read(sbport+0xe)&0x80)) ;
-	if (IO_Read(sbport+0xa)==0xaa) return true;
-	else return false;
-}
+static struct {
+	Bit16u port;
+	Bit8u irq;
+	Bit8u dma;
+} tandy_dac;
 
 static bool Tandy_InitializeSB() {
-	/* see if soundblaster module available and at what port */
-	if (Tandy_ProbeSBPort(0x220)) tandy_sb.port=0x220;
-	else if (Tandy_ProbeSBPort(0x230)) tandy_sb.port=0x230;
-	else if (Tandy_ProbeSBPort(0x210)) tandy_sb.port=0x210;
-	else if (Tandy_ProbeSBPort(0x240)) tandy_sb.port=0x240;
-	else if (Tandy_ProbeSBPort(0x250)) tandy_sb.port=0x250;
-	else if (Tandy_ProbeSBPort(0x260)) tandy_sb.port=0x260;
-	else {
+	/* see if soundblaster module available and at what port/IRQ/DMA */
+	Bitu sbport, sbirq, sbdma;
+	if (SB_Get_Address(sbport, sbirq, sbdma)) {
+		tandy_sb.port=(Bit16u)(sbport&0xffff);
+		tandy_sb.irq =(Bit8u)(sbirq&0xff);
+		tandy_sb.dma =(Bit8u)(sbdma&0xff);
+		return true;
+	} else {
 		/* no soundblaster accessible, disable Tandy DAC */
 		tandy_sb.port=0;
 		return false;
 	}
+}
 
-	/* try to detect IRQ setting */
-	IO_Write(tandy_sb.port+0x4,0x80);
-	Bit8u rval=IO_Read(tandy_sb.port+0x5);
-	if (rval && (rval!=0xff)) {
-		if (rval&1) tandy_sb.irq=0x02;
-		else if (rval&2) tandy_sb.irq=0x05;
-		else if (rval&4) tandy_sb.irq=0x07;
-		else tandy_sb.irq=0x10;
-	} else tandy_sb.irq=0x07;	/* assume irq=7 for older soundblaster settings */
-
-	/* try to detect DMA setting */
-	IO_Write(tandy_sb.port+0x4,0x81);
-	rval=IO_Read(tandy_sb.port+0x5);
-	if (rval && (rval!=0xff)) {
-		if (rval&1) tandy_sb.dma=0x00;
-		else if (rval&2) tandy_sb.dma=0x01;
-		else tandy_sb.dma=0x03;
-	} else tandy_sb.dma=0x01;	/* assume dma=1 for older soundblaster settings */
-
-	return true;
+static bool Tandy_InitializeTS() {
+	/* see if Tandy DAC module available and at what port/IRQ/DMA */
+	Bitu tsport, tsirq, tsdma;
+	if (TS_Get_Address(tsport, tsirq, tsdma)) {
+		tandy_dac.port=(Bit16u)(tsport&0xffff);
+		tandy_dac.irq =(Bit8u)(tsirq&0xff);
+		tandy_dac.dma =(Bit8u)(tsdma&0xff);
+		return true;
+	} else {
+		/* no Tandy DAC accessible */
+		tandy_dac.port=0;
+		return false;
+	}
 }
 
 /* check if Tandy DAC is still playing */
@@ -119,9 +114,13 @@
 	if (real_readw(0x40,0xd0)) return true;			/* not yet done */
 	if (real_readb(0x40,0xd4)==0xff) return false;	/* still in init-state */
 
+	Bit8u tandy_dma = 1;
+	if (tandy_sb.port) tandy_dma = tandy_sb.dma;
+	else if (tandy_dac.port) tandy_dma = tandy_dac.dma;
+
 	IO_Write(0x0c,0x00);
-	Bit16u datalen=IO_ReadB(tandy_sb.dma*2+1);
-	datalen|=(IO_ReadB(tandy_sb.dma*2+1)<<8);
+	Bit16u datalen=(Bit8u)(IO_ReadB(tandy_dma*2+1)&0xff);
+	datalen|=(IO_ReadB(tandy_dma*2+1)<<8);
 	if (datalen==0xffff) return false;	/* no DMA transfer */
 	else if ((datalen<0x10) && (real_readb(0x40,0xd4)==0x0f) && (real_readw(0x40,0xd2)==0x1c)) {
 		/* stop already requested */
@@ -134,27 +133,44 @@
 	Bitu length=real_readw(0x40,0xd0);
 	if (length==0) return;	/* nothing to do... */
 
-	if (tandy_sb.port==0) return;
+	if ((tandy_sb.port==0) && (tandy_dac.port==0)) return;
+
+	Bit8u tandy_irq = 7;
+	if (tandy_sb.port) tandy_irq = tandy_sb.irq;
+	else if (tandy_dac.port) tandy_irq = tandy_dac.irq;
+	Bit8u tandy_irq_vector = tandy_irq;
+	if (tandy_irq_vector<8) tandy_irq_vector += 8;
+	else tandy_irq_vector += (0x70-8);
 
 	/* revector IRQ-handler if necessary */
-	RealPt current_irq=RealGetVec(tandy_sb.irq+8);
+	RealPt current_irq=RealGetVec(tandy_irq_vector);
 	if (current_irq!=tandy_DAC_callback[0]->Get_RealPointer()) {
 		real_writed(0x40,0xd6,current_irq);
-		RealSetVec(tandy_sb.irq+8,tandy_DAC_callback[0]->Get_RealPointer());
+		RealSetVec(tandy_irq_vector,tandy_DAC_callback[0]->Get_RealPointer());
+	}
+
+	Bit8u tandy_dma = 1;
+	if (tandy_sb.port) tandy_dma = tandy_sb.dma;
+	else if (tandy_dac.port) tandy_dma = tandy_dac.dma;
+
+	if (tandy_sb.port) {
+		IO_Write(tandy_sb.port+0xc,0xd0);				/* stop DMA transfer */
+		IO_Write(0x21,IO_Read(0x21)&(~(1<<tandy_irq)));	/* unmask IRQ */
+		IO_Write(tandy_sb.port+0xc,0xd1);				/* turn speaker on */
+	} else {
+		IO_Write(tandy_dac.port,IO_Read(tandy_dac.port)&0x60);	/* disable DAC */
+		IO_Write(0x21,IO_Read(0x21)&(~(1<<tandy_irq)));			/* unmask IRQ */
 	}
 
-	IO_Write(tandy_sb.port+0xc,0xd0);	/* stop DMA transfer */
-	IO_Write(0x21,IO_Read(0x21)&(~(1<<tandy_sb.irq)));		/* unmask IRQ */
-	IO_Write(tandy_sb.port+0xc,0xd1);	/* turn speaker on */
-	IO_Write(0x0a,0x04|tandy_sb.dma);	/* mask DMA channel */
-	IO_Write(0x0c,0x00);				/* clear DMA flipflop */
-	if (isplayback) IO_Write(0x0b,0x48|tandy_sb.dma);
-	else IO_Write(0x0b,0x44|tandy_sb.dma);
+	IO_Write(0x0a,0x04|tandy_dma);	/* mask DMA channel */
+	IO_Write(0x0c,0x00);			/* clear DMA flipflop */
+	if (isplayback) IO_Write(0x0b,0x48|tandy_dma);
+	else IO_Write(0x0b,0x44|tandy_dma);
 	/* set physical address of buffer */
 	Bit8u bufpage=(Bit8u)((bufpt>>16)&0xff);
-	IO_Write(tandy_sb.dma*2,(Bit8u)(bufpt&0xff));
-	IO_Write(tandy_sb.dma*2,(Bit8u)((bufpt>>8)&0xff));
-	switch (tandy_sb.dma) {
+	IO_Write(tandy_dma*2,(Bit8u)(bufpt&0xff));
+	IO_Write(tandy_dma*2,(Bit8u)((bufpt>>8)&0xff));
+	switch (tandy_dma) {
 		case 0: IO_Write(0x87,bufpage); break;
 		case 1: IO_Write(0x83,bufpage); break;
 		case 2: IO_Write(0x81,bufpage); break;
@@ -169,32 +185,48 @@
 	tlength--;
 
 	/* set transfer size */
-	IO_Write(tandy_sb.dma*2+1,(Bit8u)(tlength&0xff));
-	IO_Write(tandy_sb.dma*2+1,(Bit8u)((tlength>>8)&0xff));
-	IO_Write(0x0a,tandy_sb.dma);	/* enable DMA channel */
-
-	Bitu delay=real_readw(0x40,0xd2)&0xfff;
-	/* set frequency */
-	IO_Write(tandy_sb.port+0xc,0x40);
-	IO_Write(tandy_sb.port+0xc,256-delay*100/358);
-	/* set playback type to 8bit */
-	if (isplayback) IO_Write(tandy_sb.port+0xc,0x14);
-	else IO_Write(tandy_sb.port+0xc,0x24);
-	/* set transfer size */
-	IO_Write(tandy_sb.port+0xc,(Bit8u)(tlength&0xff));
-	IO_Write(tandy_sb.port+0xc,(Bit8u)((tlength>>8)&0xff));
+	IO_Write(tandy_dma*2+1,(Bit8u)(tlength&0xff));
+	IO_Write(tandy_dma*2+1,(Bit8u)((tlength>>8)&0xff));
+
+	Bit16u delay=(Bit16u)(real_readw(0x40,0xd2)&0xfff);
+	Bit8u amplitude=(Bit8u)((real_readw(0x40,0xd2)>>13)&0x7);
+	if (tandy_sb.port) {
+		IO_Write(0x0a,tandy_dma);	/* enable DMA channel */
+		/* set frequency */
+		IO_Write(tandy_sb.port+0xc,0x40);
+		IO_Write(tandy_sb.port+0xc,256-delay*100/358);
+		/* set playback type to 8bit */
+		if (isplayback) IO_Write(tandy_sb.port+0xc,0x14);
+		else IO_Write(tandy_sb.port+0xc,0x24);
+		/* set transfer size */
+		IO_Write(tandy_sb.port+0xc,(Bit8u)(tlength&0xff));
+		IO_Write(tandy_sb.port+0xc,(Bit8u)((tlength>>8)&0xff));
+	} else {
+		if (isplayback) IO_Write(tandy_dac.port,(IO_Read(tandy_dac.port)&0x7c) | 0x03);
+		else IO_Write(tandy_dac.port,(IO_Read(tandy_dac.port)&0x7c) | 0x02);
+		IO_Write(tandy_dac.port+2,(Bit8u)(delay&0xff));
+		IO_Write(tandy_dac.port+3,(Bit8u)(((delay>>8)&0xf) | (amplitude<<5)));
+		if (isplayback) IO_Write(tandy_dac.port,(IO_Read(tandy_dac.port)&0x7c) | 0x1f);
+		else IO_Write(tandy_dac.port,(IO_Read(tandy_dac.port)&0x7c) | 0x1e);
+		IO_Write(0x0a,tandy_dma);	/* enable DMA channel */
+	}
 
 	if (!isplayback) {
 		/* mark transfer as recording operation */
-		real_writew(0x40,0xd2,delay|0x1000);
+		real_writew(0x40,0xd2,(Bit16u)(delay|0x1000));
 	}
 }
 
 static Bitu IRQ_TandyDAC(void) {
+	if (tandy_dac.port) {
+		IO_Read(tandy_dac.port);
+	}
 	if (real_readw(0x40,0xd0)) {	/* play/record next buffer */
 		/* acknowledge IRQ */
 		IO_Write(0x20,0x20);
-		IO_Read(tandy_sb.port+0xe);
+		if (tandy_sb.port) {
+			IO_Read(tandy_sb.port+0xe);
+		}
 
 		/* buffer starts at the next page */
 		Bit8u npage=real_readb(0x40,0xd4)+1;
@@ -210,11 +242,20 @@
 			Tandy_SetupTransfer(npage<<16,true);
 		}
 	} else {	/* playing/recording is finished */
-		RealSetVec(tandy_sb.irq+8,real_readd(0x40,0xd6));
+		Bit8u tandy_irq = 7;
+		if (tandy_sb.port) tandy_irq = tandy_sb.irq;
+		else if (tandy_dac.port) tandy_irq = tandy_dac.irq;
+		Bit8u tandy_irq_vector = tandy_irq;
+		if (tandy_irq_vector<8) tandy_irq_vector += 8;
+		else tandy_irq_vector += (0x70-8);
+
+		RealSetVec(tandy_irq_vector,real_readd(0x40,0xd6));
 
 		/* turn off speaker and acknowledge soundblaster IRQ */
-		IO_Write(tandy_sb.port+0xc,0xd3);
-		IO_Read(tandy_sb.port+0xe);
+		if (tandy_sb.port) {
+			IO_Write(tandy_sb.port+0xc,0xd3);
+			IO_Read(tandy_sb.port+0xe);
+		}
 
 		/* issue BIOS tandy sound device busy callout */
 		SegSet16(cs, RealSeg(tandy_DAC_callback[1]->Get_RealPointer()));
@@ -224,10 +265,14 @@
 }
 
 static void TandyDAC_Handler(Bit8u tfunction) {
-	if (!tandy_sb.port) return;
+	if ((!tandy_sb.port) && (!tandy_dac.port)) return;
 	switch (tfunction) {
 	case 0x81:	/* Tandy sound system check */
-		reg_ax=0xc4;
+		if (tandy_dac.port) {
+			reg_ax=tandy_dac.port;
+		} else {
+			reg_ax=0xc4;
+		}
 		CALLBACK_SCF(Tandy_TransferInProgress());
 		break;
 	case 0x82:	/* Tandy sound system start recording */
@@ -256,6 +301,9 @@
 		CALLBACK_SCF(false);
 		break;
 	case 0x85:	/* Tandy sound system reset */
+		if (tandy_dac.port) {
+			IO_Write(tandy_dac.port,(Bit8u)(IO_Read(tandy_dac.port)&0xe0));
+		}
 		reg_ah=0x00;
 		CALLBACK_SCF(false);
 		break;
@@ -267,7 +315,8 @@
 	case 0x00:	/* Get System time */
 		{
 			Bit32u ticks=mem_readd(BIOS_TIMER);
-			reg_al=0;		/* Midnight never passes :) */
+			reg_al=mem_readb(BIOS_24_HOURS_FLAG);
+			mem_writeb(BIOS_24_HOURS_FLAG,0); // reset the "flag"
 			reg_cx=(Bit16u)(ticks >> 16);
 			reg_dx=(Bit16u)(ticks & 0xffff);
 			break;
@@ -327,31 +376,69 @@
 #ifndef DOSBOX_CLOCKSYNC
 #define DOSBOX_CLOCKSYNC 0
 #endif
+
+static void BIOS_HostTimeSync() {
+	/* Setup time and date */
+	struct timeb timebuffer;
+	ftime(&timebuffer);
+	
+	struct tm *loctime;
+	loctime = localtime (&timebuffer.time);
+
+	/*
+	loctime->tm_hour = 23;
+	loctime->tm_min = 59;
+	loctime->tm_sec = 45;
+	loctime->tm_mday = 28;
+	loctime->tm_mon = 2-1;
+	loctime->tm_year = 2007 - 1900;
+	*/
+
+	dos.date.day=(Bit8u)loctime->tm_mday;
+	dos.date.month=(Bit8u)loctime->tm_mon+1;
+	dos.date.year=(Bit16u)loctime->tm_year+1900;
+
+	Bit32u ticks=(Bit32u)(((double)(
+		loctime->tm_hour*3600*1000+
+		loctime->tm_min*60*1000+
+		loctime->tm_sec*1000+
+		timebuffer.millitm))*(((double)PIT_TICK_RATE/65536.0)/1000.0));
+	mem_writed(BIOS_TIMER,ticks);
+}
+
 static Bitu INT8_Handler(void) {
-	/* Increase the bios tick counter */
-	Bit32u value = mem_readd(BIOS_TIMER) + 1;
+	if(dos.hostdate) BIOS_HostTimeSync();
+	else {
+		/* Increase the bios tick counter */
+		Bit32u value = mem_readd(BIOS_TIMER) + 1;
+		if(value >= 0x1800B0) {
+			// time wrap at midnight
+			mem_writeb(BIOS_24_HOURS_FLAG,mem_readb(BIOS_24_HOURS_FLAG)+1);
+			value=0;
+		}
+
 #if DOSBOX_CLOCKSYNC
-	static bool check = false;
-	if((value %50)==0) {
-		if(((value %100)==0) && check) {
-			check = false;
-			time_t curtime;struct tm *loctime;
-			curtime = time (NULL);loctime = localtime (&curtime);
-			Bit32u ticksnu = (Bit32u)((loctime->tm_hour*3600+loctime->tm_min*60+loctime->tm_sec)*(float)PIT_TICK_RATE/65536.0);
-			Bit32s bios = value;Bit32s tn = ticksnu;
-			Bit32s diff = tn - bios;
-			if(diff>0) {
-				if(diff < 18) { diff  = 0; } else diff = 9;
-			} else {
-				if(diff > -18) { diff = 0; } else diff = -9;
-			}
-	     
-			value += diff;
-		} else if((value%100)==50) check = true;
-	}
+		static bool check = false;
+		if((value %50)==0) {
+			if(((value %100)==0) && check) {
+				check = false;
+				time_t curtime;struct tm *loctime;
+				curtime = time (NULL);loctime = localtime (&curtime);
+				Bit32u ticksnu = (Bit32u)((loctime->tm_hour*3600+loctime->tm_min*60+loctime->tm_sec)*(float)PIT_TICK_RATE/65536.0);
+				Bit32s bios = value;Bit32s tn = ticksnu;
+				Bit32s diff = tn - bios;
+				if(diff>0) {
+					if(diff < 18) { diff  = 0; } else diff = 9;
+				} else {
+					if(diff > -18) { diff = 0; } else diff = -9;
+				}
+		     
+				value += diff;
+			} else if((value%100)==50) check = true;
+		}
 #endif
-	mem_writed(BIOS_TIMER,value);
-
+		mem_writed(BIOS_TIMER,value);
+	}
 	/* decrease floppy motor timer */
 	Bit8u val = mem_readb(BIOS_DISK_MOTOR_TIMEOUT);
 	if (val) mem_writeb(BIOS_DISK_MOTOR_TIMEOUT,val-1);
@@ -374,12 +461,25 @@
 	LOG(LOG_BIOS,LOG_NORMAL)("INT17:Function %X",reg_ah);
 	switch(reg_ah) {
 	case 0x00:		/* PRINTER: Write Character */
-		reg_ah=1;	/* Report a timeout */
+		if(reg_dx<3)
+			if(parallelPortObjects[reg_dx]!=0) {
+				if(parallelPortObjects[reg_dx]->Putchar(reg_al))
+					reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+				else reg_ah=1;
+			}
 		break;
 	case 0x01:		/* PRINTER: Initialize port */
+		if(reg_dx<3)
+			if(parallelPortObjects[reg_dx]!= 0) {
+				parallelPortObjects[reg_dx]->initialize();
+				reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+			}
 		break;
 	case 0x02:		/* PRINTER: Get Status */
-		reg_ah=0;	
+		if(reg_dx<3)
+			if(parallelPortObjects[reg_dx] != 0)
+				reg_ah=parallelPortObjects[reg_dx]->getPrinterStatus();
+		//LOG_MSG("printer status: %x",reg_ah);
 		break;
 	case 0x20:		/* Some sort of printerdriver install check*/
 		break;
@@ -439,8 +539,8 @@
 			IO_ReadB(port+2);
 
 			// get result
-			reg_ah=IO_ReadB(port+5);
-			reg_al=IO_ReadB(port+6);
+			reg_ah=(Bit8u)(IO_ReadB(port+5)&0xff);
+			reg_al=(Bit8u)(IO_ReadB(port+6)&0xff);
 			CALLBACK_SCF(false);
 		}
 		break;
@@ -458,7 +558,7 @@
 				timeout = !serialports[reg_dx]->Putchar(reg_al,true,true,
 					mem_readb(BIOS_COM1_TIMEOUT+reg_dx)*1000);
 				// get result
-				reg_ah=IO_ReadB(port+5);
+				reg_ah=(Bit8u)(IO_ReadB(port+5)&0xff);
 				if(timeout) reg_ah |= 0x80;
 			}
 			CALLBACK_SCF(false);
@@ -479,7 +579,7 @@
 				// RTS off
 				IO_WriteB(port+4,0x1);
 				// get result
-				reg_ah=IO_ReadB(port+5);
+				reg_ah=(Bit8u)(IO_ReadB(port+5)&0xff);
 				if(timeout) reg_ah |= 0x80;
 				else reg_al=buffer;
 			}
@@ -488,8 +588,8 @@
 		}
 	case 0x03: // get status
 		{
-			reg_ah=IO_ReadB(port+5);
-			reg_al=IO_ReadB(port+6);
+			reg_ah=(Bit8u)(IO_ReadB(port+5)&0xff);
+			reg_al=(Bit8u)(IO_ReadB(port+6)&0xff);
 			CALLBACK_SCF(false);
 		}
 		break;		
@@ -498,7 +598,7 @@
 }
 
 static Bitu INT15_Handler(void) {
-	static Bitu biosConfigSeg=0;
+	static Bit16u biosConfigSeg=0;
 	switch (reg_ah) {
 	case 0x06:
 		LOG(LOG_BIOS,LOG_NORMAL)("INT15 Unkown Function 6");
@@ -767,7 +867,7 @@
 
 #define RAM_REFRESH_DELAY 16.7f
 
-static void RAMRefresh_Event(Bitu val) {
+static void RAMRefresh_Event(Bitu /*val*/) {
 	PIC_ActivateIRQ(5);
 	PIC_AddEvent(RAMRefresh_Event,RAM_REFRESH_DELAY);
 }
@@ -787,9 +887,11 @@
 		for (Bit16u i=0;i<0x200;i++) real_writeb(0x40,i,0);
 
 		/* Setup all the interrupt handlers the bios controls */
+
 		/* INT 8 Clock IRQ Handler */
-		callback[0].Install(INT8_Handler,CB_IRQ0,"Int 8 Clock");
-		callback[0].Set_RealVec(0x8);
+		Bitu call_irq0=CALLBACK_Allocate();	
+		CALLBACK_Setup(call_irq0,INT8_Handler,CB_IRQ0,Real2Phys(BIOS_DEFAULT_IRQ0_LOCATION),"IRQ 0 Clock");
+		RealSetVec(0x08,BIOS_DEFAULT_IRQ0_LOCATION);
 		// pseudocode for CB_IRQ0:
 		//	callback INT8_Handler
 		//	push ax,dx,ds
@@ -863,15 +965,12 @@
 		phys_writew(0xFFFF3,RealSeg(rptr));	// segment
 
 		/* Irq 2 */
-		RealPt irq2pt=RealMake(0xf000,0xff55);	/* Ghost busters 2 mt32 mode */
 		Bitu call_irq2=CALLBACK_Allocate();	
-		CALLBACK_Setup(call_irq2,NULL,CB_IRET_EOI_PIC1,Real2Phys(irq2pt),"irq 2 bios");
-		RealSetVec(0x0a,irq2pt);
+		CALLBACK_Setup(call_irq2,NULL,CB_IRET_EOI_PIC1,Real2Phys(BIOS_DEFAULT_IRQ2_LOCATION),"irq 2 bios");
+		RealSetVec(0x0a,BIOS_DEFAULT_IRQ2_LOCATION);
 
 		/* Some hardcoded vectors */
-		phys_writeb(0xfff53,0xcf);	/* bios default interrupt vector location */
-		phys_writeb(0xfe987,0xea);	/* original IRQ1 location (Defender booter) */
-		phys_writed(0xfe988,RealGetVec(0x09));
+		phys_writeb(Real2Phys(BIOS_DEFAULT_HANDLER_LOCATION),0xcf);	/* bios default interrupt vector location -> IRET */
 		phys_writew(Real2Phys(RealGetVec(0x12))+0x12,0x20); //Hack for Jurresic
 
 		if (machine==MCH_TANDY) phys_writeb(0xffffe,0xff)	;	/* Tandy model */
@@ -893,9 +992,17 @@
 		for(Bitu i = 0; i < strlen(b_date); i++) phys_writeb(0xffff5+i,b_date[i]);
 		phys_writeb(0xfffff,0x55); // signature
 
+		tandy_sb.port=0;
+		tandy_dac.port=0;
 		if (use_tandyDAC) {
 			/* tandy DAC sound requested, see if soundblaster device is available */
+			Bitu tandy_dac_type = 0;
 			if (Tandy_InitializeSB()) {
+				tandy_dac_type = 1;
+			} else if (Tandy_InitializeTS()) {
+				tandy_dac_type = 2;
+			}
+			if (tandy_dac_type) {
 				real_writew(0x40,0xd0,0x0000);
 				real_writew(0x40,0xd2,0x0000);
 				real_writeb(0x40,0xd4,0xff);	/* tandy DAC init value */
@@ -915,9 +1022,16 @@
 				//	pop ax
 				//	iret
 
-				RealPt current_irq=RealGetVec(tandy_sb.irq+8);
+				Bit8u tandy_irq = 7;
+				if (tandy_dac_type==1) tandy_irq = tandy_sb.irq;
+				else if (tandy_dac_type==2) tandy_irq = tandy_dac.irq;
+				Bit8u tandy_irq_vector = tandy_irq;
+				if (tandy_irq_vector<8) tandy_irq_vector += 8;
+				else tandy_irq_vector += (0x70-8);
+
+				RealPt current_irq=RealGetVec(tandy_irq_vector);
 				real_writed(0x40,0xd6,current_irq);
-				for (Bitu i=0; i<0x10; i++) phys_writeb(PhysMake(0xf000,0xa084+i),0x80);
+				for (Bit16u i=0; i<0x10; i++) phys_writeb(PhysMake(0xf000,0xa084+i),0x80);
 			} else real_writeb(0x40,0xd4,0x00);
 		}
 	
@@ -932,8 +1046,8 @@
 		mem_writeb(BIOS_COM2_TIMEOUT,1);
 		mem_writeb(BIOS_COM3_TIMEOUT,1);
 		mem_writeb(BIOS_COM4_TIMEOUT,1);
-		
-		/* detect parallel ports */
+/*
+		// detect parallel ports
 		Bitu ppindex=0; // number of lpt ports
 		if ((IO_Read(0x378)!=0xff)|(IO_Read(0x379)!=0xff)) {
 			// this is our LPT1
@@ -967,18 +1081,18 @@
 			mem_writew(BIOS_ADDRESS_LPT1,0x278);
 			ppindex++;
 		}
-
+*/
 		/* Setup equipment list */
 		// look http://www.bioscentral.com/misc/bda.htm
 		
-		//Bitu config=0x4400;	//1 Floppy, 2 serial and 1 parrallel 
-		Bitu config = 0x0;
+		//Bit16u config=0x4400;	//1 Floppy, 2 serial and 1 parallel 
+		Bit16u config = 0x0;
 		
 		// set number of parallel ports
 		// if(ppindex == 0) config |= 0x8000; // looks like 0 ports are not specified
 		//else if(ppindex == 1) config |= 0x0000;
-		if(ppindex == 2) config |= 0x4000;
-		else config |= 0xc000;	// 3 ports
+		//if(ppindex == 2) config |= 0x4000;
+		//else config |= 0xc000;	// 3 ports
 #if (C_FPU)
 		//FPU
 		config|=0x2;
@@ -1004,7 +1118,7 @@
 		// Gameport
 		config |= 0x1000;
 		mem_writew(BIOS_CONFIGURATION,config);
-		CMOS_SetRegister(0x14,config); //Should be updated on changes
+		CMOS_SetRegister(0x14,(Bit8u)(config&0xff)); //Should be updated on changes
 		/* Setup extended memory size */
 		IO_Write(0x70,0x30);
 		size_extended=IO_Read(0x71);
@@ -1012,6 +1126,7 @@
 		size_extended|=(IO_Read(0x71) << 8);
 
 		if (machine==MCH_PCJR) PIC_AddEvent(RAMRefresh_Event,RAM_REFRESH_DELAY);
+		BIOS_HostTimeSync();
 	}
 	~BIOS(){
 		/* abort DAC playing */
@@ -1024,7 +1139,14 @@
 			Bit32u orig_vector=real_readd(0x40,0xd6);
 			if (orig_vector==tandy_DAC_callback[0]->Get_RealPointer()) {
 				/* set IRQ vector to old value */
-				RealSetVec(tandy_sb.irq+8,real_readd(0x40,0xd6));
+				Bit8u tandy_irq = 7;
+				if (tandy_sb.port) tandy_irq = tandy_sb.irq;
+				else if (tandy_dac.port) tandy_irq = tandy_dac.irq;
+				Bit8u tandy_irq_vector = tandy_irq;
+				if (tandy_irq_vector<8) tandy_irq_vector += 8;
+				else tandy_irq_vector += (0x70-8);
+
+				RealSetVec(tandy_irq_vector,real_readd(0x40,0xd6));
 				real_writed(0x40,0xd6,0x00000000);
 			}
 			delete tandy_DAC_callback[0];
@@ -1055,10 +1177,33 @@
 	CMOS_SetRegister(0x14,(Bit8u)(equipmentword&0xff)); //Should be updated on changes
 }
 
+void BIOS_SetLPTPorts(Bit16u baseaddr[]) {
+	Bit8u DEFAULTPORTTIMEOUT = 10;	// 10 whatevers
+	Bit16u portcount=0;
+	Bit16u equipmentword;
+	for(Bitu i = 0; i < 3; i++) {
+		if(baseaddr[i]!=0) portcount++;
+		if(i==0) {	// lpt1
+			mem_writew(BIOS_ADDRESS_LPT1,baseaddr[i]);
+			mem_writeb(BIOS_LPT1_TIMEOUT,DEFAULTPORTTIMEOUT);
+		} else if(i==1) {
+			mem_writew(BIOS_ADDRESS_LPT2,baseaddr[i]);
+			mem_writeb(BIOS_LPT2_TIMEOUT,DEFAULTPORTTIMEOUT);
+		} else {
+			mem_writew(BIOS_ADDRESS_LPT3,baseaddr[i]);
+			mem_writeb(BIOS_LPT3_TIMEOUT,DEFAULTPORTTIMEOUT);
+		}
+	}
+	// set equipment word
+	equipmentword = mem_readw(BIOS_CONFIGURATION);
+	equipmentword &= (~0xC000);
+	equipmentword |= (portcount << 14);
+	mem_writew(BIOS_CONFIGURATION,equipmentword);
+}
 
 static BIOS* test;
 
-void BIOS_Destroy(Section* sec){
+void BIOS_Destroy(Section* /*sec*/){
 	delete test;
 }
 
diff -urN dosbox-0.73/src/ints/bios_keyboard.cpp dosboxcvs/src/ints/bios_keyboard.cpp
--- dosbox-0.73/src/ints/bios_keyboard.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/ints/bios_keyboard.cpp	2009-07-08 20:43:44.000000000 +0300
@@ -16,6 +16,8 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
+/* $Id: bios_keyboard.cpp,v 1.36 2009/06/11 16:05:17 c2woody Exp $ */
+
 #include "dosbox.h"
 #include "callback.h"
 #include "mem.h"
@@ -28,7 +30,7 @@
 /* SDL by default treats numlock and scrolllock different from all other keys.
  * Some linux distros disable this bad behaviour. (for example debian) 
  * Define the following if this is the case */
-//#define CAN_USE_LOCK 1
+#define CAN_USE_LOCK 1
 
 static Bitu call_int16,call_irq1,call_irq6;
 
@@ -382,7 +384,7 @@
 		}
 		if(flags1 &0x08) {
 			Bit8u token = mem_readb(BIOS_KEYBOARD_TOKEN);
-			token= token*10 + scan_to_scanascii[scancode].alt;
+			token = token*10 + (Bit8u)(scan_to_scanascii[scancode].alt&0xff);
 			mem_writeb(BIOS_KEYBOARD_TOKEN,token);
 		} else if (flags1 &0x04) {
 			add_key(scan_to_scanascii[scancode].control);
@@ -601,12 +603,12 @@
 
 	/* Allocate/setup a callback for int 0x16 and for standard IRQ 1 handler */
 	call_int16=CALLBACK_Allocate();	
-	CALLBACK_Setup(call_int16,&INT16_Handler,CB_INT16,"keyboard");
+	CALLBACK_Setup(call_int16,&INT16_Handler,CB_INT16,"Keyboard");
 	RealSetVec(0x16,CALLBACK_RealPointer(call_int16));
 
 	call_irq1=CALLBACK_Allocate();	
-	CALLBACK_Setup(call_irq1,&IRQ1_Handler,CB_IRQ1,"keyboard irq");
-	RealSetVec(0x9,CALLBACK_RealPointer(call_irq1));
+	CALLBACK_Setup(call_irq1,&IRQ1_Handler,CB_IRQ1,Real2Phys(BIOS_DEFAULT_IRQ1_LOCATION),"IRQ 1 Keyboard");
+	RealSetVec(0x09,BIOS_DEFAULT_IRQ1_LOCATION);
 	// pseudocode for CB_IRQ1:
 	//	push ax
 	//	in al, 0x60
diff -urN dosbox-0.73/src/ints/.cvsignore dosboxcvs/src/ints/.cvsignore
--- dosbox-0.73/src/ints/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/ints/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/ints/ems.cpp dosboxcvs/src/ints/ems.cpp
--- dosbox-0.73/src/ints/ems.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/ints/ems.cpp	2009-06-24 20:44:52.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: ems.cpp,v 1.62 2009/05/14 17:51:47 qbix79 Exp $ */
+/* $Id: ems.cpp,v 1.64 2009/06/24 17:44:52 c2woody Exp $ */
 
 #include <string.h>
 #include <stdlib.h>
@@ -43,8 +43,9 @@
 #define EMM_VERSION		0x40
 #define GEMMIS_VERSION	0x0001	// Version 1.0
 
-#define NULL_HANDLE	0xffff
-#define	NULL_PAGE	0xffff
+#define EMM_SYSTEM_HANDLE	0x0000
+#define NULL_HANDLE			0xffff
+#define	NULL_PAGE			0xffff
 
 #define ENABLE_VCPI 1
 #define ENABLE_V86_STARTUP 0
@@ -71,6 +72,25 @@
 #define EMM_MOVE_OVLAPI			0x97
 #define EMM_NOT_FOUND			0xa0
 
+
+struct EMM_Mapping {
+	Bit16u handle;
+	Bit16u page;
+};
+
+struct EMM_Handle {
+	Bit16u pages;
+	MemHandle mem;
+	char name[8];
+	bool saved_page_map;
+	EMM_Mapping page_map[EMM_MAX_PHYS];
+};
+
+static EMM_Handle emm_handles[EMM_MAX_HANDLES];
+static EMM_Mapping emm_mappings[EMM_MAX_PHYS];
+static EMM_Mapping emm_segmentmappings[0x40];
+
+
 static Bit16u GEMMIS_seg; 
 
 class device_EMM : public DOS_Device {
@@ -144,8 +164,13 @@
 			mem_writew(GEMMIS_addr+0x18d,0x0000);		// system handle
 			mem_writed(GEMMIS_addr+0x18f,0);			// handle name
 			mem_writed(GEMMIS_addr+0x193,0);			// handle name
-			mem_writew(GEMMIS_addr+0x197,0x0010);		// system handle
-			mem_writed(GEMMIS_addr+0x199,0x00110000);	// physical address
+			if (emm_handles[EMM_SYSTEM_HANDLE].pages != NULL_HANDLE) {
+				mem_writew(GEMMIS_addr+0x197,(emm_handles[EMM_SYSTEM_HANDLE].pages+3)/4);
+				mem_writed(GEMMIS_addr+0x199,emm_handles[EMM_SYSTEM_HANDLE].mem<<12);	// physical address
+			} else {
+				mem_writew(GEMMIS_addr+0x197,0x0001);		// system handle
+				mem_writed(GEMMIS_addr+0x199,0x00110000);	// physical address
+			}
 
 			/* fill buffer with import structure */
 			mem_writed(bufptr+0x00,GEMMIS_seg<<4);
@@ -163,23 +188,6 @@
 	return false;
 }
 
-struct EMM_Mapping {
-	Bit16u handle;
-	Bit16u page;
-};
-
-struct EMM_Handle {
-	Bit16u pages;
-	MemHandle mem;
-	char name[8];
-	bool saved_page_map;
-	EMM_Mapping page_map[EMM_MAX_PHYS];
-};
-
-static EMM_Handle emm_handles[EMM_MAX_HANDLES];
-static EMM_Mapping emm_mappings[EMM_MAX_PHYS];
-static EMM_Mapping emm_segmentmappings[0x40];
-
 static struct {
 	bool enabled;
 	Bit16u ems_handle;
@@ -239,7 +247,7 @@
 static Bit8u EMM_AllocateSystemHandle(Bit16u pages) {
 	/* Check for enough free pages */
 	if ((MEM_FreeTotal()/ 4) < pages) { return EMM_OUT_OF_LOG;}
-	Bit16u handle = 0;	// emm system handle (reserved for OS usage)
+	Bit16u handle = EMM_SYSTEM_HANDLE;	// emm system handle (reserved for OS usage)
 	/* Release memory if already allocated */
 	if (emm_handles[handle].pages != NULL_HANDLE) {
 		MEM_ReleasePages(emm_handles[handle].mem);
@@ -664,7 +672,7 @@
 		reg_ah=EMM_NO_ERROR;
 		break;
 	case 0x42:		/* Get number of pages */
-		reg_dx=MEM_TotalPages()/4;		//Not entirely correct but okay
+		reg_dx=(Bit16u)(MEM_TotalPages()/4);		//Not entirely correct but okay
 		reg_bx=EMM_GetFreePages();
 		reg_ah=EMM_NO_ERROR;
 		break;
@@ -1093,11 +1101,11 @@
 				}
 				break;
 			case 0xe4:		// IN AL,Ib
-				reg_al=IO_ReadB(mem_readb((v86_cs<<4)+v86_ip+1));
+				reg_al=(Bit8u)(IO_ReadB(mem_readb((v86_cs<<4)+v86_ip+1))&0xff);
 				mem_writew(SegPhys(ss)+((reg_esp+0) & cpu.stack.mask),v86_ip+2);
 				break;
 			case 0xe5:		// IN AX,Ib
-				reg_ax=IO_ReadW(mem_readb((v86_cs<<4)+v86_ip+1));
+				reg_ax=(Bit16u)(IO_ReadW(mem_readb((v86_cs<<4)+v86_ip+1))&0xffff);
 				mem_writew(SegPhys(ss)+((reg_esp+0) & cpu.stack.mask),v86_ip+2);
 				break;
 			case 0xe6:		// OUT Ib,AL
@@ -1109,11 +1117,11 @@
 				mem_writew(SegPhys(ss)+((reg_esp+0) & cpu.stack.mask),v86_ip+2);
 				break;
 			case 0xec:		// IN AL,DX
-				reg_al=IO_ReadB(reg_dx);
+				reg_al=(Bit8u)(IO_ReadB(reg_dx)&0xff);
 				mem_writew(SegPhys(ss)+((reg_esp+0) & cpu.stack.mask),v86_ip+1);
 				break;
 			case 0xed:		// IN AX,DX
-				reg_ax=IO_ReadW(reg_dx);
+				reg_ax=(Bit16u)(IO_ReadW(reg_dx)&0xffff);
 				mem_writew(SegPhys(ss)+((reg_esp+0) & cpu.stack.mask),v86_ip+1);
 				break;
 			case 0xee:		// OUT DX,AL
@@ -1167,13 +1175,16 @@
 }
 
 static void SetupVCPI() {
+	vcpi.enabled=false;
+
+	/* Allocate one EMS-page for private VCPI-data in memory beyond 1MB */
+	if (EMM_AllocateMemory(1,vcpi.ems_handle,false) != EMM_NO_ERROR) return;
+
 	vcpi.enabled=true;
 
 	vcpi.pic1_remapping=0x08;	// master PIC base
 	vcpi.pic2_remapping=0x70;	// slave PIC base
 
-	/* Allocate one EMS-page for private VCPI-data in memory beyond 1MB */
-	EMM_AllocateMemory(1,vcpi.ems_handle,false);
 	vcpi.private_area=emm_handles[vcpi.ems_handle].mem<<12;
 
 	/* GDT */
@@ -1304,7 +1315,8 @@
 			emm_segmentmappings[i].handle=NULL_HANDLE;
 		}
 
-		EMM_AllocateSystemHandle(4);	// allocate OS-dedicated handle (ems handle zero)
+		EMM_AllocateSystemHandle(4);	// allocate OS-dedicated handle (ems handle zero, 16kb)
+
 
 		if (!ENABLE_VCPI) return;
 
@@ -1315,6 +1327,8 @@
 		/* Initialize private data area and set up descriptor tables */
 		SetupVCPI();
 
+		if (!vcpi.enabled) return;
+
 		/* Install v86-callback that handles interrupts occuring
 		   in v86 mode, including protection fault exceptions */
 		call_v86mon.Install(&V86_Monitor,CB_IRET,"V86 Monitor");
@@ -1363,10 +1377,16 @@
 		char buf[32]= { 0 };
 		MEM_BlockWrite(PhysMake(emsnameseg,0),buf,32);
 		RealSetVec(0x67,old67_pointer);
+
+		/* Release memory allocated to system handle */
+		if (emm_handles[EMM_SYSTEM_HANDLE].pages != NULL_HANDLE) {
+			MEM_ReleasePages(emm_handles[EMM_SYSTEM_HANDLE].mem);
+		}
+
 		/* Clear handle and page tables */
 		//TODO
 
-		if (!ENABLE_VCPI) return;
+		if ((!ENABLE_VCPI) || (!vcpi.enabled)) return;
 
 		/* Free private data area in expanded memory */
 		EMM_ReleaseMemory(vcpi.ems_handle);
diff -urN dosbox-0.73/src/ints/int10_char.cpp dosboxcvs/src/ints/int10_char.cpp
--- dosbox-0.73/src/ints/int10_char.cpp	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/ints/int10_char.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -25,6 +25,7 @@
 #include "mem.h"
 #include "inout.h"
 #include "int10.h"
+#include "callback.h"
 
 static void CGA2_CopyRow(Bit8u cleft,Bit8u cright,Bit8u rold,Bit8u rnew,PhysPt base) { 
 	Bit8u cheight = real_readb(BIOSMEM_SEG,BIOSMEM_CHAR_HEIGHT); 
@@ -554,9 +555,19 @@
 	Bit8u cur_row=CURSOR_POS_ROW(page);
 	Bit8u cur_col=CURSOR_POS_COL(page);
 	switch (chr) {
-	case 7:
-	//TODO BEEP
-	break;
+	case 7: {
+		// set timer (this should not be needed as the timer already is programmed 
+		// with those values, but the speaker stays silent without it)
+		IO_Write(0x43,0xb6);
+		IO_Write(0x42,1320&0xff);
+		IO_Write(0x42,1320>>8);
+		// enable speaker
+		IO_Write(0x61,IO_Read(0x61)|0x3);
+		for(Bitu i=0; i < 333; i++) CALLBACK_Idle();
+		IO_Write(0x61,IO_Read(0x61)&~0x3);
+		break;
+	}
+
 	case 8:
 		if(cur_col>0) cur_col--;
 		break;
diff -urN dosbox-0.73/src/ints/int10.cpp dosboxcvs/src/ints/int10.cpp
--- dosbox-0.73/src/ints/int10.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/ints/int10.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -553,6 +553,7 @@
 		case 0x07:
 			switch (reg_bl) {
 			case 0x80:						/* Set Display Start during retrace ?? */
+				LOG(LOG_INT10,LOG_ERROR)("Unhandled VESA Function %X Subfunction %X",reg_al,reg_bh);
 			case 0x00:						/* Set display Start */
 				reg_al=0x4f;
 				reg_ah=VESA_SetDisplayStart(reg_cx,reg_dx);
diff -urN dosbox-0.73/src/ints/int10_modes.cpp dosboxcvs/src/ints/int10_modes.cpp
--- dosbox-0.73/src/ints/int10_modes.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/ints/int10_modes.cpp	2009-06-28 17:56:14.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: int10_modes.cpp,v 1.85 2009/01/25 12:00:52 c2woody Exp $ */
+/* $Id: int10_modes.cpp,v 1.86 2009/06/28 14:56:14 c2woody Exp $ */
 
 #include <string.h>
 
@@ -357,20 +357,19 @@
 
 
 static void FinishSetMode(bool clearmem) {
-	Bitu i;
 	/* Clear video memory if needs be */
 	if (clearmem) {
 		switch (CurMode->type) {
 		case M_CGA4:
 		case M_CGA2:
 		case M_TANDY16:
-			for (i=0;i<16*1024;i++) {
-				real_writew( 0xb800,i*2,0x0000);
+			for (Bit16u ct=0;ct<16*1024;ct++) {
+				real_writew( 0xb800,ct*2,0x0000);
 			}
 			break;
 		case M_TEXT: {
 			Bit16u seg = (CurMode->mode==7)?0xb000:0xb800;
-			for (i=0;i<16*1024;i++) real_writew(seg,i*2,0x0720);
+			for (Bit16u ct=0;ct<16*1024;ct++) real_writew(seg,ct*2,0x0720);
 			break;
 		}
 		case M_EGA:	
@@ -386,13 +385,13 @@
 		}
 	}
 	/* Setup the BIOS */
-	if (CurMode->mode<128) real_writeb(BIOSMEM_SEG,BIOSMEM_CURRENT_MODE,CurMode->mode);
-	else real_writeb(BIOSMEM_SEG,BIOSMEM_CURRENT_MODE,CurMode->mode-0x98);	//Looks like the s3 bios
-	real_writew(BIOSMEM_SEG,BIOSMEM_NB_COLS,CurMode->twidth);
-	real_writew(BIOSMEM_SEG,BIOSMEM_PAGE_SIZE,CurMode->plength);
+	if (CurMode->mode<128) real_writeb(BIOSMEM_SEG,BIOSMEM_CURRENT_MODE,(Bit8u)CurMode->mode);
+	else real_writeb(BIOSMEM_SEG,BIOSMEM_CURRENT_MODE,(Bit8u)(CurMode->mode-0x98));	//Looks like the s3 bios
+	real_writew(BIOSMEM_SEG,BIOSMEM_NB_COLS,(Bit16u)CurMode->twidth);
+	real_writew(BIOSMEM_SEG,BIOSMEM_PAGE_SIZE,(Bit16u)CurMode->plength);
 	real_writew(BIOSMEM_SEG,BIOSMEM_CRTC_ADDRESS,((CurMode->mode==7 )|| (CurMode->mode==0x0f)) ? 0x3b4 : 0x3d4);
-	real_writeb(BIOSMEM_SEG,BIOSMEM_NB_ROWS,CurMode->theight-1);
-	real_writew(BIOSMEM_SEG,BIOSMEM_CHAR_HEIGHT,CurMode->cheight);
+	real_writeb(BIOSMEM_SEG,BIOSMEM_NB_ROWS,(Bit8u)(CurMode->theight-1));
+	real_writew(BIOSMEM_SEG,BIOSMEM_CHAR_HEIGHT,(Bit16u)CurMode->cheight);
 	real_writeb(BIOSMEM_SEG,BIOSMEM_VIDEO_CTL,(0x60|(clearmem?0:0x80)));
 	real_writeb(BIOSMEM_SEG,BIOSMEM_SWITCHES,0x09);
 	real_writeb(BIOSMEM_SEG,BIOSMEM_MODESET_CTL,real_readb(BIOSMEM_SEG,BIOSMEM_MODESET_CTL)&0x7f);
@@ -402,11 +401,11 @@
 	real_writed(BIOSMEM_SEG,BIOSMEM_VS_POINTER,int10.rom.video_save_pointers);
 
 	// Set cursor shape
-	if(CurMode->type==M_TEXT) {
+	if (CurMode->type==M_TEXT) {
 		INT10_SetCursorShape(0x06,07);
 	}
 	// Set cursor pos for page 0..7
-	for(i=0;i<8;i++) INT10_SetCursorPos(0,0,(Bit8u)i);
+	for (Bit8u ct=0;ct<8;ct++) INT10_SetCursorPos(0,0,ct);
 	// Set active page 0
 	INT10_SetActivePage(0);
 	/* Set some interrupt vectors */
@@ -420,7 +419,6 @@
 }
 
 bool INT10_SetVideoMode_OTHER(Bitu mode,bool clearmem) {
-	Bitu i;
 	switch (machine) {
 	case MCH_CGA:
 		if (mode>6) return false;
@@ -479,9 +477,9 @@
 	}
 	IO_WriteW(crtc_base,0x09 | (scanline-1) << 8);
 	//Setup the CGA palette using VGA DAC palette
-	for (i=0;i<16;i++) VGA_DAC_SetEntry(i,cga_palette[i][0],cga_palette[i][1],cga_palette[i][2]);
+	for (Bit8u ct=0;ct<16;ct++) VGA_DAC_SetEntry(ct,cga_palette[ct][0],cga_palette[ct][1],cga_palette[ct][2]);
 	//Setup the tandy palette
-	for (i=0;i<16;i++) VGA_DAC_CombineColor(i,i);
+	for (Bit8u ct=0;ct<16;ct++) VGA_DAC_CombineColor(ct,ct);
 	//Setup the special registers for each machine type
 	Bit8u mode_control_list[0xa+1]={
 		0x2c,0x28,0x2d,0x29,	//0-3
@@ -696,9 +694,9 @@
 		seq_data[4]|=0xc;				//Graphics - odd/even - Chained
 		break;
 	}
-	for (i=0;i<SEQ_REGS;i++) {
-		IO_Write(0x3c4,i);
-		IO_Write(0x3c5,seq_data[i]);
+	for (Bit8u ct=0;ct<SEQ_REGS;ct++) {
+		IO_Write(0x3c4,ct);
+		IO_Write(0x3c5,seq_data[ct]);
 	}
 	vga.config.compatible_chain4 = true; // this may be changed by SVGA chipset emulation
 
@@ -707,19 +705,19 @@
 	IO_Write(crtc_base,0x11);
 	IO_Write(crtc_base+1,IO_Read(crtc_base+1)&0x7f);
 	/* Clear all the regs */
-	for (i=0x0;i<=0x18;i++) {
-		IO_Write(crtc_base,i);IO_Write(crtc_base+1,0);
+	for (Bit8u ct=0x0;ct<=0x18;ct++) {
+		IO_Write(crtc_base,ct);IO_Write(crtc_base+1,0);
 	}
 	Bit8u overflow=0;Bit8u max_scanline=0;
 	Bit8u ver_overflow=0;Bit8u hor_overflow=0;
 	/* Horizontal Total */
-	IO_Write(crtc_base,0x00);IO_Write(crtc_base+1,CurMode->htotal-5);
+	IO_Write(crtc_base,0x00);IO_Write(crtc_base+1,(Bit8u)(CurMode->htotal-5));
 	hor_overflow|=((CurMode->htotal-5) & 0x100) >> 8;
 	/* Horizontal Display End */
-	IO_Write(crtc_base,0x01);IO_Write(crtc_base+1,CurMode->hdispend-1);
+	IO_Write(crtc_base,0x01);IO_Write(crtc_base+1,(Bit8u)(CurMode->hdispend-1));
 	hor_overflow|=((CurMode->hdispend-1) & 0x100) >> 7;
 	/* Start horizontal Blanking */
-	IO_Write(crtc_base,0x02);IO_Write(crtc_base+1,CurMode->hdispend);
+	IO_Write(crtc_base,0x02);IO_Write(crtc_base+1,(Bit8u)CurMode->hdispend);
 	hor_overflow|=((CurMode->hdispend) & 0x100) >> 6;
 	/* End horizontal Blanking */
 	Bitu blank_end=(CurMode->htotal-2) & 0x7f;
@@ -730,7 +728,7 @@
 	if ((CurMode->special & _EGA_HALF_CLOCK) && (CurMode->type!=M_CGA2)) ret_start = (CurMode->hdispend+3);
 	else if (CurMode->type==M_TEXT) ret_start = (CurMode->hdispend+5);
 	else ret_start = (CurMode->hdispend+4);
-	IO_Write(crtc_base,0x04);IO_Write(crtc_base+1,ret_start);
+	IO_Write(crtc_base,0x04);IO_Write(crtc_base+1,(Bit8u)ret_start);
 	hor_overflow|=(ret_start & 0x100) >> 4;
 
 	/* End Horizontal Retrace */
@@ -742,10 +740,10 @@
 	} else if (CurMode->type==M_TEXT) ret_end = (CurMode->htotal-3) & 0x1f;
 	else ret_end = (CurMode->htotal-4) & 0x1f;
 	
-	IO_Write(crtc_base,0x05);IO_Write(crtc_base+1,ret_end | (blank_end & 0x20) << 2);
+	IO_Write(crtc_base,0x05);IO_Write(crtc_base+1,(Bit8u)(ret_end | (blank_end & 0x20) << 2));
 
 	/* Vertical Total */
-	IO_Write(crtc_base,0x06);IO_Write(crtc_base+1,(CurMode->vtotal-2));
+	IO_Write(crtc_base,0x06);IO_Write(crtc_base+1,(Bit8u)(CurMode->vtotal-2));
 	overflow|=((CurMode->vtotal-2) & 0x100) >> 8;
 	overflow|=((CurMode->vtotal-2) & 0x200) >> 4;
 	ver_overflow|=((CurMode->vtotal-2) & 0x400) >> 10;
@@ -770,7 +768,7 @@
 	}
 
 	/* Vertical Retrace Start */
-	IO_Write(crtc_base,0x10);IO_Write(crtc_base+1,vretrace);
+	IO_Write(crtc_base,0x10);IO_Write(crtc_base+1,(Bit8u)vretrace);
 	overflow|=(vretrace & 0x100) >> 6;
 	overflow|=(vretrace & 0x200) >> 2;
 	ver_overflow|=(vretrace & 0x400) >> 6;
@@ -779,7 +777,7 @@
 	IO_Write(crtc_base,0x11);IO_Write(crtc_base+1,(vretrace+2) & 0xF);
 
 	/* Vertical Display End */
-	IO_Write(crtc_base,0x12);IO_Write(crtc_base+1,(CurMode->vdispend-1));
+	IO_Write(crtc_base,0x12);IO_Write(crtc_base+1,(Bit8u)(CurMode->vdispend-1));
 	overflow|=((CurMode->vdispend-1) & 0x100) >> 7;
 	overflow|=((CurMode->vdispend-1) & 0x200) >> 3;
 	ver_overflow|=((CurMode->vdispend-1) & 0x400) >> 9;
@@ -804,13 +802,13 @@
 	}
 
 	/* Vertical Blank Start */
-	IO_Write(crtc_base,0x15);IO_Write(crtc_base+1,(CurMode->vdispend+vblank_trim));
+	IO_Write(crtc_base,0x15);IO_Write(crtc_base+1,(Bit8u)(CurMode->vdispend+vblank_trim));
 	overflow|=((CurMode->vdispend+vblank_trim) & 0x100) >> 5;
 	max_scanline|=((CurMode->vdispend+vblank_trim) & 0x200) >> 4;
 	ver_overflow|=((CurMode->vdispend+vblank_trim) & 0x400) >> 8;
 
 	/* Vertical Blank End */
-	IO_Write(crtc_base,0x16);IO_Write(crtc_base+1,(CurMode->vtotal-vblank_trim-2));
+	IO_Write(crtc_base,0x16);IO_Write(crtc_base+1,(Bit8u)(CurMode->vtotal-vblank_trim-2));
 
 	/* Line Compare */
 	Bitu line_compare=(CurMode->vtotal < 1024) ? 1023 : 2047;
@@ -881,7 +879,7 @@
 		/* Extended System Control 2 Register  */
 		/* This register actually has more bits but only use the extended offset ones */
 		IO_Write(crtc_base,0x51);
-		IO_Write(crtc_base + 1,(offset & 0x300) >> 4);
+		IO_Write(crtc_base + 1,(Bit8u)((offset & 0x300) >> 4));
 		/* Clear remaining bits of the display start */
 		IO_Write(crtc_base,0x69);
 		IO_Write(crtc_base + 1,0);
@@ -995,9 +993,9 @@
 		}
 		break;
 	}
-	for (i=0;i<GFX_REGS;i++) {
-		IO_Write(0x3ce,i);
-		IO_Write(0x3cf,gfx_data[i]);
+	for (Bit8u ct=0;ct<GFX_REGS;ct++) {
+		IO_Write(0x3ce,ct);
+		IO_Write(0x3cf,gfx_data[ct]);
 	}
 	Bit8u att_data[ATT_REGS];
 	memset(att_data,0,ATT_REGS);
@@ -1025,16 +1023,16 @@
 		default:
 			if ( CurMode->type == M_LIN4 )
 				goto att_text16;
-			for (i=0;i<8;i++) {
-				att_data[i]=i;
-				att_data[i+8]=i+0x10;
+			for (Bit8u ct=0;ct<8;ct++) {
+				att_data[ct]=ct;
+				att_data[ct+8]=ct+0x10;
 			}
 			break;
 		}
 		break;
 	case M_TANDY16:
 		att_data[0x10]=0x01;		//Color Graphics
-		for (i=0;i<16;i++) att_data[i]=i;
+		for (Bit8u ct=0;ct<16;ct++) att_data[ct]=ct;
 		break;
 	case M_TEXT:
 		if (machine==MCH_EGA) {
@@ -1054,9 +1052,9 @@
 				att_data[i+8]=0x18;
 			}
 		} else {
-			for (i=0;i<8;i++) {
-				att_data[i]=i;
-				att_data[i+8]=i+0x38;
+			for (Bit8u ct=0;ct<8;ct++) {
+				att_data[ct]=ct;
+				att_data[ct+8]=ct+0x38;
 			}
 			if (IS_VGA_ARCH) att_data[0x06]=0x14;		//Odd Color 6 yellow/brown.
 		}
@@ -1078,8 +1076,8 @@
 		att_data[5]=0x04;
 		att_data[6]=0x06;
 		att_data[7]=0x07;
-		for (i=0x8;i<0x10;i++) 
-			att_data[i] = i + 0x8;
+		for (Bit8u ct=0x8;ct<0x10;ct++) 
+			att_data[ct] = ct + 0x8;
 		real_writeb(BIOSMEM_SEG,BIOSMEM_CURRENT_PAL,0x30);
 		break;
 	case M_VGA:
@@ -1087,15 +1085,15 @@
 	case M_LIN15:
 	case M_LIN16:
 	case M_LIN32:
-		for (i=0;i<16;i++) att_data[i]=i;
+		for (Bit8u ct=0;ct<16;ct++) att_data[ct]=ct;
 		att_data[0x10]=0x41;		//Color Graphics 8-bit
 		break;
 	}
 	IO_Read(mono_mode ? 0x3ba : 0x3da);
 	if ((modeset_ctl & 8)==0) {
-		for (i=0;i<ATT_REGS;i++) {
-			IO_Write(0x3c0,i);
-			IO_Write(0x3c0,att_data[i]);
+		for (Bit8u ct=0;ct<ATT_REGS;ct++) {
+			IO_Write(0x3c0,ct);
+			IO_Write(0x3c0,att_data[ct]);
 		}
 		vga.config.pel_panning = 0;
 		IO_Write(0x3c0,0x20); IO_Write(0x3c0,0x00); //Disable palette access
@@ -1173,10 +1171,10 @@
 			}
 		}
 	} else {
-		for (i=0x10;i<ATT_REGS;i++) {
-			if (i==0x11) continue;	// skip overscan register
-			IO_Write(0x3c0,i);
-			IO_Write(0x3c0,att_data[i]);
+		for (Bit8u ct=0x10;ct<ATT_REGS;ct++) {
+			if (ct==0x11) continue;	// skip overscan register
+			IO_Write(0x3c0,ct);
+			IO_Write(0x3c0,att_data[ct]);
 		}
 		vga.config.pel_panning = 0;
 		IO_Write(0x3c0,0x20); //Disable palette access
@@ -1222,11 +1220,11 @@
 		IO_Write(crtc_base+1,0);
 		/* Setup the linear frame buffer */
 		IO_Write(crtc_base,0x59);
-		IO_Write(crtc_base+1,(Bit8u)(S3_LFB_BASE >> 24));
+		IO_Write(crtc_base+1,(Bit8u)((S3_LFB_BASE >> 24)&0xff));
 		IO_Write(crtc_base,0x5a);
-		IO_Write(crtc_base+1,(Bit8u)(S3_LFB_BASE >> 16));
+		IO_Write(crtc_base+1,(Bit8u)((S3_LFB_BASE >> 16)&0xff));
 		IO_Write(crtc_base,0x6b); // BIOS scratchpad
-		IO_Write(crtc_base+1,(Bit8u)(S3_LFB_BASE >> 24));
+		IO_Write(crtc_base+1,(Bit8u)((S3_LFB_BASE >> 24)&0xff));
 		
 		/* Setup some remaining S3 registers */
 		IO_Write(crtc_base,0x41); // BIOS scratchpad
@@ -1255,7 +1253,7 @@
 		}
 		IO_WriteB(crtc_base,0x50); IO_WriteB(crtc_base+1,reg_50);
 
-		Bitu reg_31, reg_3a;
+		Bit8u reg_31, reg_3a;
 		switch (CurMode->type) {
 			case M_LIN15:
 			case M_LIN16:
@@ -1303,6 +1301,11 @@
 	}
 
 	FinishSetMode(clearmem);
+
+	/* Set vga attrib register into defined state */
+	IO_Read(mono_mode ? 0x3ba : 0x3da);
+	IO_Write(0x3c0,0x20);
+
 	/* Load text mode font */
 	if (CurMode->type==M_TEXT) {
 		if (IS_VGA_ARCH) INT10_LoadFont(Real2Phys(int10.rom.font_16),true,256,0,0,16);
diff -urN dosbox-0.73/src/ints/Makefile.in dosboxcvs/src/ints/Makefile.in
--- dosbox-0.73/src/ints/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/ints/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -56,7 +60,7 @@
 	int10_vptable.$(OBJEXT) bios.$(OBJEXT) bios_disk.$(OBJEXT) \
 	bios_keyboard.$(OBJEXT)
 libints_a_OBJECTS = $(am_libints_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -76,6 +80,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -87,6 +93,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -97,8 +104,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -108,7 +116,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -126,12 +133,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -143,43 +153,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libints.a
 libints_a_SOURCES = mouse.cpp xms.cpp xms.h ems.cpp \
@@ -252,26 +251,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/xms.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -283,8 +283,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -294,12 +294,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -313,21 +314,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -388,20 +390,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -421,22 +415,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/ints/mouse.cpp dosboxcvs/src/ints/mouse.cpp
--- dosbox-0.73/src/ints/mouse.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/ints/mouse.cpp	2009-06-16 22:00:26.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: mouse.cpp,v 1.79 2009/04/16 12:11:45 qbix79 Exp $ */
+/* $Id: mouse.cpp,v 1.80 2009/06/16 19:00:26 qbix79 Exp $ */
 
 #include <string.h>
 #include <math.h>
@@ -898,6 +898,12 @@
 		reg_cx=(Bit16u)mouse.max_x;
 		reg_dx=(Bit16u)mouse.max_y;
 		break;
+	case 0x31: /* Get Current Minimum/Maximum virtual coordinates */
+		reg_ax=(Bit16u)mouse.min_x;
+		reg_bx=(Bit16u)mouse.min_y;
+		reg_cx=(Bit16u)mouse.max_x;
+		reg_dx=(Bit16u)mouse.max_y;
+		break;
 	default:
 		LOG(LOG_MOUSE,LOG_ERROR)("Mouse Function %04X not implemented!",reg_ax);
 		break;
diff -urN dosbox-0.73/src/libs/.cvsignore dosboxcvs/src/libs/.cvsignore
--- dosbox-0.73/src/libs/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/.cvsignore	2006-02-28 23:14:48.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/libs/gui_tk/.cvsignore dosboxcvs/src/libs/gui_tk/.cvsignore
--- dosbox-0.73/src/libs/gui_tk/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/gui_tk/.cvsignore	2007-10-28 18:33:02.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/libs/gui_tk/Doxyfile dosboxcvs/src/libs/gui_tk/Doxyfile
--- dosbox-0.73/src/libs/gui_tk/Doxyfile	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/gui_tk/Doxyfile	2007-10-28 18:33:02.000000000 +0200
@@ -0,0 +1,238 @@
+# Doxyfile 1.5.2
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+DOXYFILE_ENCODING      = UTF-8
+PROJECT_NAME           = gui::tk
+PROJECT_NUMBER         = "Version 1.0"
+OUTPUT_DIRECTORY       = 
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = YES
+STRIP_FROM_PATH        = .
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = NO
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = YES
+INHERIT_DOCS           = YES
+SEPARATE_MEMBER_PAGES  = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = NO
+OPTIMIZE_OUTPUT_JAVA   = NO
+BUILTIN_STL_SUPPORT    = YES
+CPP_CLI_SUPPORT        = NO
+DISTRIBUTE_GROUP_DOC   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = NO
+EXTRACT_PRIVATE        = NO
+EXTRACT_STATIC         = NO
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = YES
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+SHOW_DIRECTORIES       = YES
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = NO
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = .
+INPUT_ENCODING         = UTF-8
+FILE_PATTERNS          = gui_tk.h \
+                         gui_tk.cpp
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXCLUDE_SYMBOLS        = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = *
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = YES
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+REFERENCES_LINK_SOURCE = YES
+USE_HTAGS              = NO
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 5
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = TESTING SDL_MAJOR_VERSION
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = DOSBox.tag
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+MSCGEN_PATH            = 
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = YES
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+GROUP_GRAPHS           = YES
+UML_LOOK               = YES
+TEMPLATE_RELATIONS     = YES
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = YES
+CALLER_GRAPH           = YES
+GRAPHICAL_HIERARCHY    = YES
+DIRECTORY_GRAPH        = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+DOT_GRAPH_MAX_NODES    = 50
+DOT_TRANSPARENT        = YES
+DOT_MULTI_TARGETS      = YES
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
diff -urN dosbox-0.73/src/libs/gui_tk/Makefile.in dosboxcvs/src/libs/gui_tk/Makefile.in
--- dosbox-0.73/src/libs/gui_tk/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/libs/gui_tk/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -50,7 +54,7 @@
 libgui_tk_a_LIBADD =
 am_libgui_tk_a_OBJECTS = gui_tk.$(OBJEXT)
 libgui_tk_a_OBJECTS = $(am_libgui_tk_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -70,6 +74,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -81,6 +87,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -91,8 +98,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -102,7 +110,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -120,12 +127,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -137,43 +147,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libgui_tk.a
 libgui_tk_a_SOURCES = gui_tk.cpp gui_tk.h
@@ -227,26 +226,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gui_tk.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -258,8 +258,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -269,12 +269,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -288,21 +289,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -363,20 +365,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -396,22 +390,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/libs/Makefile.am dosboxcvs/src/libs/Makefile.am
--- dosbox-0.73/src/libs/Makefile.am	2007-10-28 18:32:18.000000000 +0200
+++ dosboxcvs/src/libs/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -1,3 +1,4 @@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 
-SUBDIRS = zmbv gui_tk
+SUBDIRS = zmbv gui_tk porttalk
+
diff -urN dosbox-0.73/src/libs/Makefile.in dosboxcvs/src/libs/Makefile.in
--- dosbox-0.73/src/libs/Makefile.in	2009-05-20 21:29:06.000000000 +0300
+++ dosboxcvs/src/libs/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,11 +13,15 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -46,13 +50,10 @@
 DIST_SOURCES =
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -60,6 +61,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -71,6 +74,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -81,8 +85,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -92,7 +97,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -110,12 +114,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -127,45 +134,34 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
-SUBDIRS = zmbv gui_tk
+SUBDIRS = zmbv gui_tk porttalk
 all: all-recursive
 
 .SUFFIXES:
@@ -198,6 +194,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -230,7 +227,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -274,8 +272,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -300,8 +298,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -311,12 +309,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -330,21 +329,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -358,7 +358,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -366,8 +366,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -421,20 +419,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am:
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -453,23 +443,21 @@
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-generic ctags \
-	ctags-recursive distclean distclean-generic distclean-tags \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-recursive ctags ctags-recursive \
+	distclean distclean-generic distclean-recursive distclean-tags \
 	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic pdf pdf-am ps ps-am tags \
-	tags-recursive uninstall uninstall-am
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-recursive pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/libs/porttalk/Makefile.am dosboxcvs/src/libs/porttalk/Makefile.am
--- dosbox-0.73/src/libs/porttalk/Makefile.am	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/porttalk/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,4 @@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+
+noinst_LIBRARIES = libporttalk.a
+libporttalk_a_SOURCES = porttalk.cpp porttalk.h porttalk_IOCTL.h
diff -urN dosbox-0.73/src/libs/porttalk/Makefile.in dosboxcvs/src/libs/porttalk/Makefile.in
--- dosbox-0.73/src/libs/porttalk/Makefile.in	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/porttalk/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -0,0 +1,408 @@
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+subdir = src/libs/porttalk
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+LIBRARIES = $(noinst_LIBRARIES)
+AR = ar
+ARFLAGS = cru
+libporttalk_a_AR = $(AR) $(ARFLAGS)
+libporttalk_a_LIBADD =
+am_libporttalk_a_OBJECTS = porttalk.$(OBJEXT)
+libporttalk_a_OBJECTS = $(am_libporttalk_a_OBJECTS)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \
+	-o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+SOURCES = $(libporttalk_a_SOURCES)
+DIST_SOURCES = $(libporttalk_a_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALSA_CFLAGS = @ALSA_CFLAGS@
+ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SDL_CFLAGS = @SDL_CFLAGS@
+SDL_CONFIG = @SDL_CONFIG@
+SDL_LIBS = @SDL_LIBS@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+WINDRES = @WINDRES@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+AM_CPPFLAGS = -I$(top_srcdir)/include
+noinst_LIBRARIES = libporttalk.a
+libporttalk_a_SOURCES = porttalk.cpp porttalk.h porttalk_IOCTL.h
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/libs/porttalk/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/libs/porttalk/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+clean-noinstLIBRARIES:
+	-test -z "$(noinst_LIBRARIES)" || rm -f $(noinst_LIBRARIES)
+libporttalk.a: $(libporttalk_a_OBJECTS) $(libporttalk_a_DEPENDENCIES) 
+	-rm -f libporttalk.a
+	$(libporttalk_a_AR) libporttalk.a $(libporttalk_a_OBJECTS) $(libporttalk_a_LIBADD)
+	$(RANLIB) libporttalk.a
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/porttalk.Po@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LIBRARIES)
+installdirs:
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-noinstLIBRARIES ctags distclean distclean-compile \
+	distclean-generic distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN dosbox-0.73/src/libs/porttalk/porttalk.cpp dosboxcvs/src/libs/porttalk/porttalk.cpp
--- dosbox-0.73/src/libs/porttalk/porttalk.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/porttalk/porttalk.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,245 @@
+#include "config.h"
+#include "logging.h"
+
+#if defined (_MSC_VER) 
+void outportb(Bit32u portid, Bit8u value) {
+  __asm mov edx,portid
+  __asm mov al,value
+  __asm out dx,al
+}
+
+Bit8u inportb(Bit32u portid) {
+  Bit8u value;
+  
+  __asm mov edx,portid
+  __asm in al,dx
+  __asm mov value,al
+  return value;
+}
+
+void outportw(Bit32u portid, Bit16u value) {
+  __asm mov edx,portid
+  __asm mov ax,value
+  __asm out dx,ax
+}
+
+Bit16u inportw(Bit32u portid) {
+  Bit16u value;
+  
+  __asm mov edx,portid
+  __asm in ax,dx
+  __asm mov value,ax
+  return value;
+}
+
+void outportd(Bit32u portid, Bit32u value) {
+  __asm mov edx,portid
+  __asm mov eax,value
+  __asm out dx,eax
+}
+
+Bit32u inportd(Bit32u portid) {
+  Bit32u value;
+  
+  __asm mov edx,portid
+  __asm in eax,dx
+  __asm mov value,eax
+  return value;
+}
+
+#else
+void outportb(Bit32u portid, Bit8u value) {
+   __asm__ volatile (
+      "movl   %0,%%edx   \n"
+      "movb   %1,%%al      \n"
+      "outb   %%al,%%dx   "
+      :
+      :   "r" (portid), "r" (value)
+      :   "edx", "al"
+   );
+}
+Bit8u inportb(Bit32u portid) {
+   Bit8u value;
+   __asm__ volatile (
+      "movl   %1,%%edx   \n"
+      "inb   %%dx,%%al   \n"
+      "movb   %%al,%0      "
+      :   "=m" (value)
+      :   "r" (portid)
+      :   "edx", "al", "memory"
+   );
+  return value;
+}
+#endif
+
+#ifdef WIN32
+
+// WIN specific
+#include "sdl.h"
+#include <windows.h>
+#include <winioctl.h> // NEEDED by GCC
+#include "porttalk.h"
+#include <stdio.h>
+#include <process.h>
+
+// PortTalk_IOCTL.h can be downloaded with PortTalk
+#include "PortTalk_IOCTL.h"
+
+typedef struct driverpermstruct {
+	Bit16u offset;
+	Bit8u value;
+} permblock;
+
+static HANDLE porttalkhandle=INVALID_HANDLE_VALUE;
+static Bit8u ioperm[8192];
+static bool isNT = false;
+
+bool initPorttalk() {
+	// handles neded for starting service
+	SC_HANDLE  ServiceManager = NULL;
+	SC_HANDLE  PorttalkService = NULL;
+
+	// check which platform we are on
+	OSVERSIONINFO osvi;
+	memset(&osvi,0,sizeof(OSVERSIONINFO));
+	osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
+    if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) )
+		LOG_MSG("GET VERSION failed!");
+	if(osvi.dwPlatformId==2) isNT=true;
+	
+	if(isNT && porttalkhandle==INVALID_HANDLE_VALUE) {
+		porttalkhandle = CreateFile("\\\\.\\PortTalk", GENERIC_READ,
+				0, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_DEVICE, NULL);
+
+		if (porttalkhandle == INVALID_HANDLE_VALUE) {
+			Bitu retval=0;
+			// Porttalk service is not started. Attempt to start it.
+			ServiceManager = OpenSCManager (NULL,	// NULL is local machine
+					NULL,							// default database
+					SC_MANAGER_ENUMERATE_SERVICE);	// desired access
+			
+			if(ServiceManager==NULL) {
+				// No rights to enumerate services
+				LOG_MSG("You do not have the rights to enumerate services.");
+				return false;
+			}
+			PorttalkService = OpenService(ServiceManager,
+                                  "PortTalk",		// service name
+                                  SERVICE_START);	// desired access
+			
+			if(PorttalkService==NULL) {
+				// get causes
+				switch (retval=GetLastError()) {
+                case ERROR_ACCESS_DENIED:
+					LOG_MSG("You do not have the rights to enumerate services.");
+					break;
+                case ERROR_SERVICE_DOES_NOT_EXIST:
+					LOG_MSG("Porttalk service is not installed.");
+					break;
+				default:
+					LOG_MSG("Error %d occured accessing porttalk dirver.",retval);
+					break;
+				}
+				goto error;
+			}
+
+			// start it
+			retval = StartService (PorttalkService,
+				0,             // number of arguments
+				NULL);         // pointer to arguments
+			if(!retval) {
+				// couldn't start it
+				if((retval=GetLastError())!=ERROR_SERVICE_ALREADY_RUNNING) {
+					LOG_MSG("Could not start Porttalk service. Error %d.",retval);
+					goto error;
+				}
+			}
+			CloseServiceHandle(PorttalkService);
+			CloseServiceHandle(ServiceManager);
+
+			// try again
+			porttalkhandle = CreateFile("\\\\.\\PortTalk", GENERIC_READ,
+				0, NULL,OPEN_EXISTING, FILE_ATTRIBUTE_DEVICE, NULL);
+			
+			if (porttalkhandle == INVALID_HANDLE_VALUE) {
+				// bullshit
+				LOG_MSG(
+					"Porttalk driver could not be opened after being started successully.");
+				return false;
+			}
+
+		}
+		for(int i = 0; i < sizeof(ioperm); i++) ioperm[i]=0xff;
+		int retval;
+
+		DeviceIoControl(	porttalkhandle,
+				IOCTL_IOPM_RESTRICT_ALL_ACCESS,
+				NULL,0,
+				NULL,0,
+				(LPDWORD)&retval,
+				NULL);
+	}
+	return true;
+error:
+	if(PorttalkService) CloseServiceHandle(PorttalkService);
+	if(ServiceManager) CloseServiceHandle(ServiceManager);
+	return false;
+}
+void addIOPermission(Bit16u port) {
+	if(isNT)
+		ioperm[(port>>3)]&=(~(1<<(port&0x7)));
+}
+
+bool setPermissionList() {
+	if(!isNT) return true;
+	if(porttalkhandle!=INVALID_HANDLE_VALUE) {
+		permblock b;
+		int pid = _getpid();
+		int reetval=0;
+		Bit32u retval=0;
+		//output permission list to driver
+		for(int i = 0; i < sizeof(ioperm);i++) {
+			b.offset=i;
+			b.value=ioperm[i];
+			
+			retval=DeviceIoControl(	porttalkhandle,
+							IOCTL_SET_IOPM,
+							(LPDWORD)&b,3,
+							NULL,0,
+							(LPDWORD)&reetval,
+							NULL);
+			if(retval==0) return false;
+		}
+		
+		
+		reetval=DeviceIoControl(	porttalkhandle,
+							IOCTL_ENABLE_IOPM_ON_PROCESSID,
+							(LPDWORD)&pid,4,
+							NULL,0,
+							(LPDWORD)&retval,
+							NULL);
+		SDL_Delay(100);
+		return reetval!=0;
+	}
+	else return false;
+}
+#endif
+
+#ifdef LINUX
+// This Linux ioperm only works up to port 0x3FF
+#include <sys/perm.h>
+
+bool initPorttalk() {
+	if(ioperm(0x3da,1,1) < 0) return false;
+	return true;
+}
+
+void addIOPermission(Bit16u port) {
+	ioperm(port,1,1);
+}
+
+bool setPermissionList() {
+	return true;
+}
+
+#endif
diff -urN dosbox-0.73/src/libs/porttalk/porttalk.h dosboxcvs/src/libs/porttalk/porttalk.h
--- dosbox-0.73/src/libs/porttalk/porttalk.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/porttalk/porttalk.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,19 @@
+#ifndef PORTTALK_H
+#define PORTTALK_H
+
+#include "config.h"
+
+bool initPorttalk(void);
+bool setPermissionList();
+void addIOPermission(Bit16u port);
+
+void outportb(Bit32u portid, Bit8u value);
+Bit8u inportb(Bit32u portid);
+
+void outportd(Bit32u portid, Bit32u value);
+Bit32u inportd(Bit32u portid);
+
+void outportw(Bit32u portid, Bit16u value);
+Bit16u inportw(Bit32u portid);
+
+#endif
diff -urN dosbox-0.73/src/libs/porttalk/PortTalk_IOCTL.h dosboxcvs/src/libs/porttalk/PortTalk_IOCTL.h
--- dosbox-0.73/src/libs/porttalk/PortTalk_IOCTL.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/porttalk/PortTalk_IOCTL.h	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,37 @@
+/******************************************************************************/
+/*                                                                            */
+/*                    PortTalk Driver for Windows NT/2000/XP                  */
+/*                        Version 2.0, 12th January 2002                      */
+/*                          http://www.beyondlogic.org                        */
+/*                                                                            */
+/* Copyright  2002 Craig Peacock. Craig.Peacock@beyondlogic.org              */
+/* Any publication or distribution of this code in source form is prohibited  */
+/* without prior written permission of the copyright holder. This source code */
+/* is provided "as is", without any guarantee made as to its suitability or   */
+/* fitness for any particular use. Permission is herby granted to modify or   */
+/* enhance this sample code to produce a derivative program which may only be */
+/* distributed in compiled object form only.                                  */
+/******************************************************************************/
+
+#define PORTTALK_TYPE 40000 /* 32768-65535 are reserved for customers */
+
+// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
+
+#define IOCTL_IOPM_RESTRICT_ALL_ACCESS \
+    CTL_CODE(PORTTALK_TYPE, 0x900, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_IOPM_ALLOW_EXCUSIVE_ACCESS \
+    CTL_CODE(PORTTALK_TYPE, 0x901, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_SET_IOPM \
+    CTL_CODE(PORTTALK_TYPE, 0x902, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_ENABLE_IOPM_ON_PROCESSID \
+    CTL_CODE(PORTTALK_TYPE, 0x903, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_READ_PORT_UCHAR \
+    CTL_CODE(PORTTALK_TYPE, 0x904, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
+#define IOCTL_WRITE_PORT_UCHAR \
+    CTL_CODE(PORTTALK_TYPE, 0x905, METHOD_BUFFERED, FILE_ANY_ACCESS)
+
diff -urN dosbox-0.73/src/libs/zmbv/.cvsignore dosboxcvs/src/libs/zmbv/.cvsignore
--- dosbox-0.73/src/libs/zmbv/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/.cvsignore	2006-02-28 23:14:48.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/libs/zmbv/drvproc.cpp dosboxcvs/src/libs/zmbv/drvproc.cpp
--- dosbox-0.73/src/libs/zmbv/drvproc.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/drvproc.cpp	2009-05-27 12:15:42.000000000 +0300
@@ -0,0 +1,212 @@
+/*
+ *  Copyright (C) 2002-2009  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+//
+// Zipped Motion Block Video
+//
+// Based on Huffyuv by Ben Rudiak-Gould.
+// which was based on MSYUV sample code, which is:
+// Copyright (c) 1993 Microsoft Corporation.
+// All Rights Reserved.
+//
+
+#include "zmbv_vfw.h"
+
+/***************************************************************************
+ * DriverProc  -  The entry point for an installable driver.
+ *
+ * PARAMETERS
+ * dwDriverId:  For most messages, <dwDriverId> is the DWORD
+ *     value that the driver returns in response to a <DRV_OPEN> message.
+ *     Each time that the driver is opened, through the <DrvOpen> API,
+ *     the driver receives a <DRV_OPEN> message and can return an
+ *     arbitrary, non-zero value. The installable driver interface
+ *     saves this value and returns a unique driver handle to the
+ *     application. Whenever the application sends a message to the
+ *     driver using the driver handle, the interface routes the message
+ *     to this entry point and passes the corresponding <dwDriverId>.
+ *     This mechanism allows the driver to use the same or different
+ *     identifiers for multiple opens but ensures that driver handles
+ *     are unique at the application interface layer.
+ *
+ *     The following messages are not related to a particular open
+ *     instance of the driver. For these messages, the dwDriverId
+ *     will always be zero.
+ *
+ *         DRV_LOAD, DRV_FREE, DRV_ENABLE, DRV_DISABLE, DRV_OPEN
+ *
+ * hDriver: This is the handle returned to the application by the
+ *    driver interface.
+ *
+ * uiMessage: The requested action to be performed. Message
+ *     values below <DRV_RESERVED> are used for globally defined messages.
+ *     Message values from <DRV_RESERVED> to <DRV_USER> are used for
+ *     defined driver protocols. Messages above <DRV_USER> are used
+ *     for driver specific messages.
+ *
+ * lParam1: Data for this message.  Defined separately for
+ *     each message
+ *
+ * lParam2: Data for this message.  Defined separately for
+ *     each message
+ *
+ * RETURNS
+ *   Defined separately for each message.
+ *
+ ***************************************************************************/
+LRESULT PASCAL DriverProc(DWORD dwDriverID, HDRVR hDriver, UINT uiMessage, LPARAM lParam1, LPARAM lParam2) {
+  CodecInst* pi = (CodecInst*)dwDriverID;
+
+  switch (uiMessage) {
+    case DRV_LOAD:
+      return (LRESULT)1L;
+
+    case DRV_FREE:
+      return (LRESULT)1L;
+
+    case DRV_OPEN:
+      // GAAH! This used to return a pointer to 0xFFFF0000 when lParam==0!
+      return (LRESULT)(DWORD)(UINT) Open((ICOPEN*) lParam2);
+
+    case DRV_CLOSE:
+      if (pi) Close(pi);
+      return (LRESULT)1L;
+
+    /*********************************************************************
+
+      state messages
+
+    *********************************************************************/
+
+    // cwk
+    case DRV_QUERYCONFIGURE:    // configuration from drivers applet
+      return (LRESULT)1L;
+
+    case DRV_CONFIGURE:
+      pi->Configure((HWND)lParam1);
+      return DRV_OK;
+
+    case ICM_CONFIGURE:
+      //
+      //  return ICERR_OK if you will do a configure box, error otherwise
+      //
+      if (lParam1 == -1)
+        return pi->QueryConfigure() ? ICERR_OK : ICERR_UNSUPPORTED;
+      else
+        return pi->Configure((HWND)lParam1);
+
+    case ICM_ABOUT:
+      //
+      //  return ICERR_OK if you will do a about box, error otherwise
+      //
+      if (lParam1 == -1)
+        return pi->QueryAbout() ? ICERR_OK : ICERR_UNSUPPORTED;
+      else
+        return pi->About((HWND)lParam1);
+
+    case ICM_GETSTATE:
+      return pi->GetState((LPVOID)lParam1, (DWORD)lParam2);
+
+    case ICM_SETSTATE:
+      return pi->SetState((LPVOID)lParam1, (DWORD)lParam2);
+
+    case ICM_GETINFO:
+      return pi->GetInfo((ICINFO*)lParam1, (DWORD)lParam2);
+
+    case ICM_GETDEFAULTQUALITY:
+      if (lParam1) {
+        *((LPDWORD)lParam1) = 10000;
+        return ICERR_OK;
+      }
+      break;
+
+    /*********************************************************************
+
+      compression messages
+
+    *********************************************************************/
+
+    case ICM_COMPRESS_QUERY:
+      return pi->CompressQuery((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_COMPRESS_BEGIN:
+      return pi->CompressBegin((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_COMPRESS_GET_FORMAT:
+      return pi->CompressGetFormat((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_COMPRESS_GET_SIZE:
+      return pi->CompressGetSize((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_COMPRESS:
+      return pi->Compress((ICCOMPRESS*)lParam1, (DWORD)lParam2);
+
+    case ICM_COMPRESS_END:
+      return pi->CompressEnd();
+
+    /*********************************************************************
+
+      decompress messages
+
+    *********************************************************************/
+
+    case ICM_DECOMPRESS_QUERY:
+      return pi->DecompressQuery((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_DECOMPRESS_BEGIN:
+      return pi->DecompressBegin((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_DECOMPRESS_GET_FORMAT:
+      return pi->DecompressGetFormat((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_DECOMPRESS_GET_PALETTE:
+      return pi->DecompressGetPalette((LPBITMAPINFOHEADER)lParam1, (LPBITMAPINFOHEADER)lParam2);
+
+    case ICM_DECOMPRESS:
+      return pi->Decompress((ICDECOMPRESS*)lParam1, (DWORD)lParam2);
+
+    case ICM_DECOMPRESS_END:
+      return pi->DecompressEnd();
+
+    /*********************************************************************
+
+      standard driver messages
+
+    *********************************************************************/
+
+    case DRV_DISABLE:
+    case DRV_ENABLE:
+      return (LRESULT)1L;
+
+    case DRV_INSTALL:
+    case DRV_REMOVE:
+      return (LRESULT)DRV_OK;
+  }
+
+  if (uiMessage < DRV_USER)
+    return DefDriverProc(dwDriverID, hDriver, uiMessage, lParam1, lParam2);
+  else
+    return ICERR_UNSUPPORTED;
+}
+
+
+HMODULE hmoduleCodec=0;
+
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD, LPVOID) {
+  hmoduleCodec = (HMODULE) hinstDLL;
+  return TRUE;
+}
diff -urN dosbox-0.73/src/libs/zmbv/Makefile.in dosboxcvs/src/libs/zmbv/Makefile.in
--- dosbox-0.73/src/libs/zmbv/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/libs/zmbv/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,11 +13,15 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -48,6 +52,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -59,6 +65,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -69,8 +76,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -80,7 +88,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -98,12 +105,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -115,43 +125,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 EXTRA_DIST = zmbv.cpp zmbv.h
 all: all-am
 
@@ -185,6 +184,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 tags: TAGS
 TAGS:
 
@@ -193,21 +193,22 @@
 
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -266,20 +267,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -298,19 +291,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: all all-am check check-am clean clean-generic distclean \
 	distclean-generic distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/libs/zmbv/resource.h dosboxcvs/src/libs/zmbv/resource.h
--- dosbox-0.73/src/libs/zmbv/resource.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/resource.h	2006-01-30 12:10:04.000000000 +0200
@@ -0,0 +1,21 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+// Used by zmbv_vfw.rc
+//
+#define IDD_ABOUT                       101
+#define IDD_CONFIGURE                   102
+#define IDC_HOMEPAGE                    1000
+#define IDC_EMAIL                       1001
+#define IDC_SLIDER1                     1008
+
+// Next default values for new objects
+// 
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NO_MFC                     1
+#define _APS_NEXT_RESOURCE_VALUE        103
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1009
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
diff -urN dosbox-0.73/src/libs/zmbv/zmbv.def dosboxcvs/src/libs/zmbv/zmbv.def
--- dosbox-0.73/src/libs/zmbv/zmbv.def	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv.def	2006-01-30 12:10:04.000000000 +0200
@@ -0,0 +1,4 @@
+LIBRARY         ZMBV
+
+EXPORTS
+	DriverProc
diff -urN dosbox-0.73/src/libs/zmbv/zmbv.inf dosboxcvs/src/libs/zmbv/zmbv.inf
--- dosbox-0.73/src/libs/zmbv/zmbv.inf	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv.inf	2009-02-12 23:38:23.000000000 +0200
@@ -0,0 +1,105 @@
+[Version]
+Signature="$CHICAGO$"
+Provider=%ZMBV_PUBLISHER%
+Class=MEDIA
+
+
+[DefaultInstall]
+CopyFiles=ZMBV.Files.Inf,ZMBV.Files.Dll
+AddReg=ZMBV.Reg9x
+UpdateInis=ZMBV.INIs
+
+[DefaultInstall.ntx86]
+CopyFiles=ZMBV.Files.Inf,ZMBV.Files.Dll
+AddReg=ZMBV.RegNTx86
+UpdateInis=ZMBV.INIs
+
+[DefaultInstall.ntamd64]
+CopyFiles=ZMBV.Files.Inf,ZMBV.Files.Dll.NTamd64
+AddReg=ZMBV.RegNTamd64
+UpdateInis=ZMBV.INIs
+
+[DefaultUnInstall]
+DelFiles=ZMBV.Files.Dll,ZMBV.Files.Inf,ZMBV.Files.Ini
+DelReg=ZMBV.Reg9x
+UpdateInis=ZMBV.INIs.Del
+
+[DefaultUnInstall.ntx86]
+DelFiles=ZMBV.Files.Dll,ZMBV.Files.Inf,ZMBV.Files.Ini
+DelReg=ZMBV.RegNTx86
+UpdateInis=ZMBV.INIs.Del
+
+[DefaultUnInstall.ntamd64]
+DelFiles=ZMBV.Files.Dll.NTamd64,ZMBV.Files.Inf,ZMBV.Files.Ini
+DelReg=ZMBV.RegNTamd64
+UpdateInis=ZMBV.INIs.Del
+
+[SourceDisksNames]
+1="Zip Motion Block Video codec","",1
+
+[SourceDisksFiles]
+ZMBV.INF=1
+
+[DestinationDirs]
+ZMBV.Files.Inf=17
+ZMBV.Files.Dll=11
+ZMBV.Files.Dll.NTamd64=10,SysWOW64
+ZMBV.Files.Ini=25
+
+[ZMBV.Files.Inf]
+zmbv.inf
+
+[ZMBV.Files.Dll]
+zmbv.dll
+
+[ZMBV.Files.Dll.NTamd64]
+zmbv.dll
+
+[ZMBV.Files.Ini]
+zmbv.ini
+
+[ZMBV.Reg9x]
+HKLM,SYSTEM\CurrentControlSet\Control\MediaResources\icm\VIDC.ZMBV,Description,,"%ZMBV_DISPLAY_NAME%"
+HKLM,SYSTEM\CurrentControlSet\Control\MediaResources\icm\VIDC.ZMBV,Driver,,"zmbv.dll"
+HKLM,SYSTEM\CurrentControlSet\Control\MediaResources\icm\VIDC.ZMBV,FriendlyName,,"%ZMBV_DISPLAY_NAME%"
+
+HKLM,Software\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV
+HKLM,Software\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,DisplayName,,"%ZMBV_UNINST_DISPLAY_NAME%"
+HKLM,Software\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,UninstallString,,"rundll.exe setupx.dll,InstallHinfSection DefaultUninstall 132 %17%\ZMBV.INF"
+
+[ZMBV.RegNTx86]
+HKLM,SOFTWARE\Microsoft\Windows NT\CurrentVersion\drivers.desc,zmbv.dll,,"%ZMBV_DISPLAY_NAME%"
+HKLM,SOFTWARE\Microsoft\Windows NT\CurrentVersion\drivers32,vidc.zmbv,,zmbv.dll
+
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,DisplayName,,"%ZMBV_UNINST_DISPLAY_NAME%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,Publisher,,"%ZMBV_PUBLISHER%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,URLInfoAbout,,"%ZMBV_URL_HOMEPAGE%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,NoRepair,0x10001,01,00,00,00
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,NoModify,0x10001,01,00,00,00
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,UninstallString,,"rundll32.exe setupapi,InstallHinfSection DefaultUninstall 132 %17%\ZMBV.INF"
+
+[ZMBV.RegNTamd64]
+HKLM,SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\drivers.desc,zmbv.dll,,"%ZMBV_DISPLAY_NAME%"
+HKLM,SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\drivers32,vidc.zmbv,,zmbv.dll
+
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,DisplayName,,"%ZMBV_UNINST_DISPLAY_NAME%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,Publisher,,"%ZMBV_PUBLISHER%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,URLInfoAbout,,"%ZMBV_URL_HOMEPAGE%"
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,NoRepair,0x10001,01,00,00,00
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,NoModify,0x10001,01,00,00,00
+HKLM,SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\ZMBV,UninstallString,,"rundll32.exe setupapi.dll,InstallHinfSection DefaultUninstall 132 %17%\ZMBV.INF"
+
+[ZMBV.INIs]
+system.ini, drivers32,, "VIDC.ZMBV=zmbv.dll"
+
+[ZMBV.INIs.Del]
+system.ini, drivers32, "VIDC.ZMBV=zmbv.dll"
+
+[Strings]
+ZMBV_PUBLISHER = "DOSBox Team"
+ZMBV_DISPLAY_NAME = "Zip Motion Block Video [ZMBV]"
+ZMBV_UNINST_DISPLAY_NAME = "Zip Motion Block Video codec (Remove Only)"
+ZMBV_URL_HOMEPAGE = "http://www.dosbox.com/"
+CODEC_INSTALLATION_FINISHED = "Zip Motion Block Video codec installation is complete."
diff -urN dosbox-0.73/src/libs/zmbv/zmbv.sln dosboxcvs/src/libs/zmbv/zmbv.sln
--- dosbox-0.73/src/libs/zmbv/zmbv.sln	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv.sln	2006-01-30 12:10:04.000000000 +0200
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zmbv", "zmbv.vcproj", "{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}.Debug.ActiveCfg = Debug|Win32
+		{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}.Debug.Build.0 = Debug|Win32
+		{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}.Release.ActiveCfg = Release|Win32
+		{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -urN dosbox-0.73/src/libs/zmbv/zmbv.vcproj dosboxcvs/src/libs/zmbv/zmbv.vcproj
--- dosbox-0.73/src/libs/zmbv/zmbv.vcproj	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv.vcproj	2006-01-30 12:10:04.000000000 +0200
@@ -0,0 +1,141 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="zmbv"
+	ProjectGUID="{619CF3F9-C373-4BD5-93DA-025F5E16F8FA}"
+	Keyword="Win32Proj">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory="Debug"
+			IntermediateDirectory="Debug"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS"
+				MinimalRebuild="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="5"
+				BufferSecurityCheck="TRUE"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib odbc32.lib odbccp32.lib zlib.lib"
+				OutputFile="$(OutDir)/zmbv.dll"
+				LinkIncremental="2"
+				ModuleDefinitionFile="zmbv.def"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile="$(OutDir)/zmbv.pdb"
+				SubSystem="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory="Release"
+			IntermediateDirectory="Release"
+			ConfigurationType="2"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS"
+				RuntimeLibrary="4"
+				UsePrecompiledHeader="0"
+				WarningLevel="3"
+				Detect64BitPortabilityProblems="TRUE"
+				DebugInformationFormat="3"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="winmm.lib odbc32.lib odbccp32.lib zlib.lib"
+				OutputFile="$(OutDir)/zmbv.dll"
+				LinkIncremental="1"
+				ModuleDefinitionFile="zmbv.def"
+				GenerateDebugInformation="TRUE"
+				MapExports="TRUE"
+				SubSystem="2"
+				OptimizeReferences="2"
+				EnableCOMDATFolding="2"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\drvproc.cpp">
+		</File>
+		<File
+			RelativePath=".\Resource.h">
+		</File>
+		<File
+			RelativePath=".\zmbv.cpp">
+		</File>
+		<File
+			RelativePath=".\zmbv.def">
+		</File>
+		<File
+			RelativePath=".\zmbv.h">
+		</File>
+		<File
+			RelativePath=".\zmbv_vfw.cpp">
+		</File>
+		<File
+			RelativePath=".\zmbv_vfw.rc">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN dosbox-0.73/src/libs/zmbv/zmbv_vfw.cpp dosboxcvs/src/libs/zmbv/zmbv_vfw.cpp
--- dosbox-0.73/src/libs/zmbv/zmbv_vfw.cpp	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv_vfw.cpp	2009-05-27 12:15:42.000000000 +0300
@@ -0,0 +1,397 @@
+/*
+ *  Copyright (C) 2002-2009  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+//
+// Zipped Motion Block Video
+//
+// Based on Huffyuv by Ben Rudiak-Gould.
+// which was based on MSYUV sample code, which is:
+// Copyright (c) 1993 Microsoft Corporation.
+// All Rights Reserved.
+//
+
+#include "zmbv_vfw.h"
+#include "resource.h"
+
+#include <crtdbg.h>
+#include <string.h>
+
+TCHAR szDescription[] = TEXT("Zipped Motion Block Video v0.1");
+TCHAR szName[]        = TEXT(CODEC_4CC);
+
+#define VERSION         0x00000001      // 0.1
+
+/********************************************************************
+********************************************************************/
+
+CodecInst *encode_table_owner, *decode_table_owner;
+
+/********************************************************************
+********************************************************************/
+
+void Msg(const char fmt[], ...) {
+  DWORD written;
+  char buf[2000];
+  va_list val;
+  
+  va_start(val, fmt);
+  wvsprintf(buf, fmt, val);
+
+  const COORD _80x50 = {80,50};
+  static BOOL startup = (AllocConsole(), SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE), _80x50));
+  WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE), buf, lstrlen(buf), &written, 0);
+}
+
+
+/********************************************************************
+********************************************************************/
+
+CodecInst::CodecInst() {
+	codec = 0;
+}
+
+CodecInst* Open(ICOPEN* icinfo) {
+  if (icinfo && icinfo->fccType != ICTYPE_VIDEO)
+      return NULL;
+
+  CodecInst* pinst = new CodecInst();
+
+  if (icinfo) icinfo->dwError = pinst ? ICERR_OK : ICERR_MEMORY;
+
+  return pinst;
+}
+
+DWORD Close(CodecInst* pinst) {
+//    delete pinst;       // this caused problems when deleting at app close time
+    return 1;
+}
+
+/********************************************************************
+********************************************************************/
+
+
+/********************************************************************
+********************************************************************/
+
+BOOL CodecInst::QueryAbout() { return TRUE; }
+
+static BOOL CALLBACK AboutDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
+  if (uMsg == WM_COMMAND) {
+    switch (LOWORD(wParam)) {
+    case IDOK:
+      EndDialog(hwndDlg, 0);
+      break;
+    case IDC_HOMEPAGE:
+      ShellExecute(NULL, NULL, "http://www.dosbox.com", NULL, NULL, SW_SHOW);
+      break;
+    case IDC_EMAIL:
+      ShellExecute(NULL, NULL, "mailto:dosbox.crew@gmail.com", NULL, NULL, SW_SHOW);
+      break;
+    }
+  }
+  return FALSE;
+}
+DWORD CodecInst::About(HWND hwnd) {
+  DialogBox(hmoduleCodec, MAKEINTRESOURCE(IDD_ABOUT), hwnd, AboutDialogProc);
+  return ICERR_OK;
+}
+
+static BOOL CALLBACK ConfigureDialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {
+
+  if (uMsg == WM_INITDIALOG) {
+
+  } else if (uMsg == WM_COMMAND) {
+
+    switch (LOWORD(wParam)) {
+
+    case IDOK:
+
+    case IDCANCEL:
+      EndDialog(hwndDlg, 0);
+      break;
+
+    default:
+      return AboutDialogProc(hwndDlg, uMsg, wParam, lParam);    // handle email and home-page buttons
+    }
+  }
+  return FALSE;
+}
+
+BOOL CodecInst::QueryConfigure() { return TRUE; }
+
+DWORD CodecInst::Configure(HWND hwnd) {
+  DialogBox(hmoduleCodec, MAKEINTRESOURCE(IDD_CONFIGURE), hwnd, ConfigureDialogProc);
+  return ICERR_OK;
+}
+
+
+/********************************************************************
+********************************************************************/
+
+
+// we have no state information which needs to be stored
+
+DWORD CodecInst::GetState(LPVOID pv, DWORD dwSize) { return 0; }
+
+DWORD CodecInst::SetState(LPVOID pv, DWORD dwSize) { return 0; }
+
+
+DWORD CodecInst::GetInfo(ICINFO* icinfo, DWORD dwSize) {
+  if (icinfo == NULL)
+    return sizeof(ICINFO);
+
+  if (dwSize < sizeof(ICINFO))
+    return 0;
+
+  icinfo->dwSize            = sizeof(ICINFO);
+  icinfo->fccType           = ICTYPE_VIDEO;
+  memcpy(&icinfo->fccHandler,CODEC_4CC, 4);
+  icinfo->dwFlags           = VIDCF_FASTTEMPORALC | VIDCF_FASTTEMPORALD | VIDCF_TEMPORAL;
+
+  icinfo->dwVersion         = VERSION;
+  icinfo->dwVersionICM      = ICVERSION;
+  MultiByteToWideChar(CP_ACP, 0, szDescription, -1, icinfo->szDescription, sizeof(icinfo->szDescription)/sizeof(WCHAR));
+  MultiByteToWideChar(CP_ACP, 0, szName, -1, icinfo->szName, sizeof(icinfo->szName)/sizeof(WCHAR));
+
+  return sizeof(ICINFO);
+}
+
+/********************************************************************
+****************************************************************/
+
+static int GetInputBitDepth(const BITMAPINFOHEADER *lpbiIn) {
+	if (lpbiIn->biCompression == BI_RGB) {
+		if (lpbiIn->biPlanes != 1)
+			return -1;
+
+		switch(lpbiIn->biBitCount) {
+			case 8:
+				return 8;
+			case 16:
+				return 15;		// Standard Windows 16-bit RGB is 1555.
+			case 32:
+				return 32;
+		}
+
+	} else if (lpbiIn->biCompression == BI_BITFIELDS) {
+		// BI_BITFIELDS RGB masks lie right after the BITMAPINFOHEADER structure,
+		// at (ptr+40). This is true even for a BITMAPV4HEADER or BITMAPV5HEADER.
+		const DWORD *masks = (const DWORD *)(lpbiIn + 1);
+
+		if (lpbiIn->biBitCount == 16) {
+			// Test for 16 (555)
+			if (masks[0] == 0x7C00 && masks[1] == 0x03E0 && masks[2] == 0x001F)
+				return 15;
+
+			// Test for 16 (565)
+			if (masks[0] == 0xF800 && masks[1] == 0x07E0 && masks[2] == 0x001F)
+				return 16;
+		} else if (lpbiIn->biBitCount == 32) {
+			if (masks[0] == 0xFF0000 && masks[1] == 0x00FF00 && masks[2] == 0x0000FF)
+				return 32;
+		}
+	}
+
+	return -1;
+}
+
+static bool CanCompress(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut, bool requireOutput) {
+	if (lpbiIn) {
+		if (GetInputBitDepth(lpbiIn) < 0)
+			return false;
+	} else return false;
+	if (lpbiOut) {
+		if (memcmp(&lpbiOut->biCompression,CODEC_4CC, 4))
+			return false;
+	} else return !requireOutput;
+	return true;
+}
+
+/********************************************************************
+****************************************************************/
+
+DWORD CodecInst::CompressQuery(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	if (CanCompress(lpbiIn,lpbiOut,false)) return ICERR_OK;
+	return ICERR_BADFORMAT;
+}
+
+DWORD CodecInst::CompressGetFormat(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	if (!lpbiOut)
+		return sizeof(BITMAPINFOHEADER);
+	lpbiOut->biSize			= sizeof(BITMAPINFOHEADER);
+	lpbiOut->biWidth		= lpbiIn->biWidth;
+	lpbiOut->biHeight		= lpbiIn->biHeight;
+	lpbiOut->biPlanes		= 1;
+	lpbiOut->biCompression	= *(const DWORD *)CODEC_4CC;
+	lpbiOut->biBitCount		= lpbiIn->biBitCount;
+	lpbiOut->biSizeImage	= lpbiIn->biWidth * lpbiIn->biHeight * lpbiIn->biBitCount/8 + 1024;
+	lpbiOut->biXPelsPerMeter = lpbiIn->biXPelsPerMeter;
+	lpbiOut->biYPelsPerMeter = lpbiIn->biYPelsPerMeter;
+	lpbiOut->biClrUsed		= 0;
+	lpbiOut->biClrImportant	= 0;
+	return ICERR_OK;
+}
+
+DWORD CodecInst::CompressBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	CompressEnd();  // free resources if necessary
+	if (!CanCompress(lpbiIn, lpbiOut, true))
+		return ICERR_BADFORMAT;
+	codec = new VideoCodec();
+	if (!codec)
+		return ICERR_MEMORY;
+	if (!codec->SetupCompress( lpbiIn->biWidth, lpbiIn->biHeight))
+		return ICERR_MEMORY;
+	return ICERR_OK;
+}
+
+DWORD CodecInst::CompressGetSize(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	if (!CanCompress(lpbiIn, lpbiOut, true))
+		return ICERR_BADFORMAT;
+	return lpbiIn->biWidth * lpbiIn->biHeight * lpbiIn->biBitCount/8 + 1024;
+}
+
+DWORD CodecInst::Compress(ICCOMPRESS* icinfo, DWORD dwSize) {
+	int i, pitch;
+	zmbv_format_t format;
+	LPBITMAPINFOHEADER lpbiIn=icinfo->lpbiInput;
+	LPBITMAPINFOHEADER lpbiOut=icinfo->lpbiOutput;
+	if (!CanCompress(lpbiIn, lpbiOut, true))
+		return ICERR_BADFORMAT;
+	if (!icinfo->lpInput || !icinfo->lpOutput)
+		return ICERR_ABORT;
+	switch (GetInputBitDepth(lpbiIn)) {
+	case 8:
+		format = ZMBV_FORMAT_8BPP;
+		pitch = lpbiIn->biWidth;
+		break;
+	case 15:
+		format = ZMBV_FORMAT_15BPP;
+		pitch = lpbiIn->biWidth * 2;
+		break;
+	case 16:
+		format = ZMBV_FORMAT_16BPP;
+		pitch = lpbiIn->biWidth * 2;
+		break;
+	case 32:
+		format = ZMBV_FORMAT_32BPP;
+		pitch = lpbiIn->biWidth * 4;
+		break;
+	}
+
+	// DIB scanlines for RGB formats are always aligned to DWORD.
+	pitch = (pitch + 3) & ~3;
+
+	// force a key frame if requested by the client
+	int flags = 0;
+	if (icinfo->dwFlags & ICCOMPRESS_KEYFRAME)
+		flags |= 1;
+
+	codec->PrepareCompressFrame( flags, format, 0, icinfo->lpOutput, 99999999);
+	char *readPt = (char *)icinfo->lpInput + pitch*(lpbiIn->biHeight - 1);
+	for(i = 0;i<lpbiIn->biHeight;i++) {
+		codec->CompressLines(1, (void **)&readPt );
+		readPt -= pitch;
+	}
+	lpbiOut->biSizeImage = codec->FinishCompressFrame();
+
+	if (flags & 1)
+		*icinfo->lpdwFlags = AVIIF_KEYFRAME;
+	else
+		*icinfo->lpdwFlags = 0;
+
+	return ICERR_OK;
+}
+
+
+DWORD CodecInst::CompressEnd() {
+	if (codec) 
+		delete codec;
+	codec = 0;
+	return ICERR_OK;
+}
+
+/********************************************************************
+********************************************************************/
+
+static bool CanDecompress(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	if (memcmp(&lpbiIn->biCompression,CODEC_4CC,4))
+		return false;
+	if (lpbiOut) {
+		if (lpbiOut->biCompression!=0) return false;
+		if (lpbiOut->biBitCount != 24) return false;
+		if (lpbiIn->biWidth!=lpbiOut->biWidth || lpbiIn->biHeight!=lpbiOut->biHeight)
+            return false;
+	}
+	return true;
+}
+
+/********************************************************************
+********************************************************************/
+
+
+DWORD CodecInst::DecompressQuery(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	return CanDecompress(lpbiIn, lpbiOut) ? ICERR_OK : ICERR_BADFORMAT;
+}
+
+DWORD CodecInst::DecompressGetFormat(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	if (memcmp(&lpbiIn->biCompression,CODEC_4CC,4))
+		 return ICERR_BADFORMAT;
+	if (!lpbiOut) return sizeof(BITMAPINFOHEADER);
+	*lpbiOut = *lpbiIn;
+	lpbiOut->biPlanes		= 1;
+	lpbiOut->biSize			= sizeof(BITMAPINFOHEADER);
+	lpbiOut->biBitCount		= 24;
+	lpbiOut->biSizeImage	= ((lpbiOut->biWidth*3 + 3) & ~3) * lpbiOut->biHeight;
+	lpbiOut->biCompression	= BI_RGB;
+	lpbiOut->biClrUsed		= 0;
+	lpbiOut->biClrImportant	= 0;
+	return ICERR_OK;
+}
+
+DWORD CodecInst::DecompressBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	DecompressEnd();  // free resources if necessary
+	if (!CanDecompress(lpbiIn, lpbiOut))
+		return ICERR_BADFORMAT;
+	codec=new VideoCodec();
+	if (!codec)
+		return ICERR_MEMORY;
+	if (!codec->SetupDecompress( lpbiIn->biWidth, lpbiIn->biHeight))
+		return ICERR_MEMORY;
+	return ICERR_OK;
+}
+
+DWORD CodecInst::Decompress(ICDECOMPRESS* icinfo, DWORD dwSize) {
+	if (!codec || !icinfo)
+		return ICERR_ABORT;
+	if (codec->DecompressFrame( icinfo->lpInput, icinfo->lpbiInput->biSizeImage)) {
+		codec->Output_UpsideDown_24(icinfo->lpOutput);
+	} else return ICERR_DONTDRAW;
+	return ICERR_OK;
+}
+
+
+// palette-mapped output only
+DWORD CodecInst::DecompressGetPalette(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut) {
+	return ICERR_BADFORMAT;
+}
+
+DWORD CodecInst::DecompressEnd() {
+	if (codec) 
+		delete codec;
+	codec = 0;
+	return ICERR_OK;
+}
diff -urN dosbox-0.73/src/libs/zmbv/zmbv_vfw.h dosboxcvs/src/libs/zmbv/zmbv_vfw.h
--- dosbox-0.73/src/libs/zmbv/zmbv_vfw.h	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv_vfw.h	2006-01-30 12:10:04.000000000 +0200
@@ -0,0 +1,61 @@
+//
+// Huffyuv v2.1.1, by Ben Rudiak-Gould.
+// http://www.math.berkeley.edu/~benrg/huffyuv.html
+//
+// This file is copyright 2000 Ben Rudiak-Gould, and distributed under
+// the terms of the GNU General Public License, v2 or later.  See
+// http://www.gnu.org/copyleft/gpl.html.
+//
+// I edit these files in 10-point Verdana, a proportionally-spaced font.
+// You may notice formatting oddities if you use a monospaced font.
+//
+
+
+#include <windows.h>
+#include <vfw.h>
+#include <zlib.h>
+#include "zmbv.h"
+#pragma hdrstop
+
+extern HMODULE hmoduleCodec;
+
+
+// huffyuv.cpp
+
+class CodecInst {
+private:
+	VideoCodec * codec;
+public:
+  CodecInst();
+  ~CodecInst();
+
+  BOOL QueryAbout();
+  DWORD About(HWND hwnd);
+
+  BOOL QueryConfigure();
+  DWORD Configure(HWND hwnd);
+
+  DWORD GetState(LPVOID pv, DWORD dwSize);
+  DWORD SetState(LPVOID pv, DWORD dwSize);
+
+  DWORD GetInfo(ICINFO* icinfo, DWORD dwSize);
+
+  DWORD CompressQuery(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD CompressGetFormat(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD CompressBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD CompressGetSize(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD Compress(ICCOMPRESS* icinfo, DWORD dwSize);
+  DWORD CompressEnd();
+
+  DWORD DecompressQuery(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD DecompressGetFormat(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD DecompressBegin(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  
+  DWORD Decompress(ICDECOMPRESS* icinfo, DWORD dwSize);
+  DWORD DecompressGetPalette(LPBITMAPINFOHEADER lpbiIn, LPBITMAPINFOHEADER lpbiOut);
+  DWORD DecompressEnd();
+};
+
+CodecInst* Open(ICOPEN* icinfo);
+DWORD Close(CodecInst* pinst);
+
diff -urN dosbox-0.73/src/libs/zmbv/zmbv_vfw.rc dosboxcvs/src/libs/zmbv/zmbv_vfw.rc
--- dosbox-0.73/src/libs/zmbv/zmbv_vfw.rc	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/libs/zmbv/zmbv_vfw.rc	2009-02-04 23:47:57.000000000 +0200
@@ -0,0 +1,123 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "winres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (U.S.) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+#ifdef _WIN32
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE 
+BEGIN
+    "#include ""winres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Dialog
+//
+
+IDD_ABOUT DIALOGEX 0, 0, 167, 55
+STYLE DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_POPUP | WS_CAPTION | 
+    WS_SYSMENU
+CAPTION "DOSBox Video Codec v0.1"
+FONT 8, "MS Sans Serif", 0, 0, 0x0
+BEGIN
+    DEFPUSHBUTTON   "OK",IDOK,131,34,29,14
+    CTEXT           "Zipped Motion Block Video v 0.1\nCopyright 2009, DOSBox Team",
+                    IDC_STATIC,7,7,153,25,SS_NOPREFIX
+    PUSHBUTTON      "Email author",IDC_EMAIL,7,34,50,14
+    PUSHBUTTON      "Visit home page",IDC_HOMEPAGE,59,34,58,14
+END
+
+IDD_CONFIGURE DIALOGEX 0, 0, 213, 146
+STYLE DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_POPUP | WS_CAPTION | 
+    WS_SYSMENU
+CAPTION "ZMBV configuration dialog"
+FONT 8, "MS Sans Serif", 0, 0, 0x0
+BEGIN
+    PUSHBUTTON      "Email author",IDC_EMAIL,44,86,50,14
+    PUSHBUTTON      "Visit home page",IDC_HOMEPAGE,109,87,58,14
+    DEFPUSHBUTTON   "OK",IDOK,44,125,50,14
+    PUSHBUTTON      "Cancel",IDCANCEL,117,125,50,14
+    CONTROL         "",IDC_SLIDER1,"msctls_trackbar32",TBS_BOTH | 
+                    TBS_NOTICKS | WS_TABSTOP,57,30,92,18
+END
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// DESIGNINFO
+//
+
+#ifdef APSTUDIO_INVOKED
+GUIDELINES DESIGNINFO 
+BEGIN
+    IDD_ABOUT, DIALOG
+    BEGIN
+        LEFTMARGIN, 7
+        RIGHTMARGIN, 160
+        TOPMARGIN, 7
+        BOTTOMMARGIN, 48
+    END
+
+    IDD_CONFIGURE, DIALOG
+    BEGIN
+        LEFTMARGIN, 44
+        RIGHTMARGIN, 167
+        TOPMARGIN, 6
+        BOTTOMMARGIN, 139
+    END
+END
+#endif    // APSTUDIO_INVOKED
+
+#endif    // English (U.S.) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff -urN dosbox-0.73/src/Makefile.am dosboxcvs/src/Makefile.am
--- dosbox-0.73/src/Makefile.am	2009-04-28 10:02:37.000000000 +0300
+++ dosboxcvs/src/Makefile.am	2009-07-08 20:43:08.000000000 +0300
@@ -13,7 +13,8 @@
 
 dosbox_SOURCES = dosbox.cpp $(ico_stuff)
 dosbox_LDADD = cpu/libcpu.a debug/libdebug.a dos/libdos.a fpu/libfpu.a  hardware/libhardware.a gui/libgui.a \
-               ints/libints.a misc/libmisc.a shell/libshell.a hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
+               ints/libints.a misc/libmisc.a shell/libshell.a hardware/serialport/libserial.a hardware/parport/libparallel.a \
+               libs/gui_tk/libgui_tk.a libs/porttalk/libporttalk.a
 
 EXTRA_DIST = winres.rc dosbox.ico
 
diff -urN dosbox-0.73/src/Makefile.in dosboxcvs/src/Makefile.in
--- dosbox-0.73/src/Makefile.in	2009-05-20 21:29:05.000000000 +0300
+++ dosboxcvs/src/Makefile.in	2009-07-08 20:46:42.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -54,8 +58,9 @@
 dosbox_DEPENDENCIES = cpu/libcpu.a debug/libdebug.a dos/libdos.a \
 	fpu/libfpu.a hardware/libhardware.a gui/libgui.a \
 	ints/libints.a misc/libmisc.a shell/libshell.a \
-	hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+	hardware/serialport/libserial.a hardware/parport/libparallel.a \
+	libs/gui_tk/libgui_tk.a libs/porttalk/libporttalk.a
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -67,13 +72,10 @@
 DIST_SOURCES = $(am__dosbox_SOURCES_DIST)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -81,6 +83,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -92,6 +96,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -102,8 +107,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -113,7 +119,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -131,12 +136,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -148,49 +156,39 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 SUBDIRS = cpu debug dos fpu gui hardware libs ints misc shell platform 
 @HAVE_WINDRES_TRUE@ico_stuff = winres.rc
 dosbox_SOURCES = dosbox.cpp $(ico_stuff)
 dosbox_LDADD = cpu/libcpu.a debug/libdebug.a dos/libdos.a fpu/libfpu.a  hardware/libhardware.a gui/libgui.a \
-               ints/libints.a misc/libmisc.a shell/libshell.a hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
+               ints/libints.a misc/libmisc.a shell/libshell.a hardware/serialport/libserial.a hardware/parport/libparallel.a \
+               libs/gui_tk/libgui_tk.a libs/porttalk/libporttalk.a
 
 EXTRA_DIST = winres.rc dosbox.ico
 all: all-recursive
@@ -228,7 +226,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
+	test -z "$(bindir)" || $(mkdir_p) "$(DESTDIR)$(bindir)"
 	@list='$(bin_PROGRAMS)'; for p in $$list; do \
 	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
 	  if test -f $$p \
@@ -251,7 +249,7 @@
 	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
 dosbox$(EXEEXT): $(dosbox_OBJECTS) $(dosbox_DEPENDENCIES) 
 	@rm -f dosbox$(EXEEXT)
-	$(CXXLINK) $(dosbox_OBJECTS) $(dosbox_LDADD) $(LIBS)
+	$(CXXLINK) $(dosbox_LDFLAGS) $(dosbox_OBJECTS) $(dosbox_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -262,18 +260,19 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dosbox.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -306,7 +305,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -350,8 +350,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -376,8 +376,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -387,12 +387,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -406,21 +407,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -434,7 +436,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -442,8 +444,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -454,7 +454,7 @@
 installdirs: installdirs-recursive
 installdirs-am:
 	for dir in "$(DESTDIR)$(bindir)"; do \
-	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
 	done
 install: install-recursive
 install-exec: install-exec-recursive
@@ -502,20 +502,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am: install-binPROGRAMS
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -535,25 +527,23 @@
 
 ps-am:
 
-uninstall-am: uninstall-binPROGRAMS
+uninstall-am: uninstall-binPROGRAMS uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-binPROGRAMS \
-	clean-generic ctags ctags-recursive distclean \
-	distclean-compile distclean-generic distclean-tags distdir dvi \
-	dvi-am html html-am info info-am install install-am \
-	install-binPROGRAMS install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
-	install-strip installcheck installcheck-am installdirs \
-	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags tags-recursive uninstall uninstall-am \
-	uninstall-binPROGRAMS
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-binPROGRAMS clean-generic clean-recursive ctags \
+	ctags-recursive distclean distclean-compile distclean-generic \
+	distclean-recursive distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic \
+	maintainer-clean-recursive mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-recursive pdf pdf-am ps ps-am \
+	tags tags-recursive uninstall uninstall-am \
+	uninstall-binPROGRAMS uninstall-info-am
 
 
 .rc.o:
diff -urN dosbox-0.73/src/misc/.cvsignore dosboxcvs/src/misc/.cvsignore
--- dosbox-0.73/src/misc/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/misc/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/misc/Makefile.in dosboxcvs/src/misc/Makefile.in
--- dosbox-0.73/src/misc/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/misc/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -51,7 +55,7 @@
 am_libmisc_a_OBJECTS = cross.$(OBJEXT) messages.$(OBJEXT) \
 	programs.$(OBJEXT) setup.$(OBJEXT) support.$(OBJEXT)
 libmisc_a_OBJECTS = $(am_libmisc_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -67,6 +71,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -78,6 +84,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -88,8 +95,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -99,7 +107,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -117,12 +124,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -134,43 +144,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libmisc.a
 libmisc_a_SOURCES = cross.cpp messages.cpp programs.cpp setup.cpp support.cpp
@@ -228,26 +227,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/support.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -259,8 +259,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -270,12 +270,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -289,21 +290,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -364,20 +366,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -397,22 +391,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/misc/messages.cpp dosboxcvs/src/misc/messages.cpp
--- dosbox-0.73/src/misc/messages.cpp	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/misc/messages.cpp	2009-06-17 11:52:35.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: messages.cpp,v 1.22 2009/05/27 09:15:42 qbix79 Exp $ */
+/* $Id: messages.cpp,v 1.23 2009/06/17 08:52:35 qbix79 Exp $ */
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -99,8 +99,11 @@
 			strcpy(name,linein+1);
 		/* End of string marker */
 		} else if (linein[0]=='.') {
-		/* Replace/Add the string to the internal langaugefile */
-		   MSG_Replace(name,string);
+			/* Replace/Add the string to the internal langaugefile */
+			/* Remove last newline (marker is \n.\n) */
+			size_t ll = strlen(string);
+			if(ll && string[ll - 1] == '\n') string[ll - 1] = 0; //Second if should not be needed, but better be safe.
+			MSG_Replace(name,string);
 		} else {
 		/* Normal string to be added */
 			strcat(string,linein);
@@ -125,7 +128,7 @@
 	FILE* out=fopen(location,"w+t");
 	if(out==NULL) return;//maybe an error?
 	for(itmb tel=Lang.begin();tel!=Lang.end();tel++){
-		fprintf(out,":%s\n%s.\n",(*tel).name.c_str(),(*tel).val.c_str());
+		fprintf(out,":%s\n%s\n.\n",(*tel).name.c_str(),(*tel).val.c_str());
 	}
 	fclose(out);
 }
diff -urN dosbox-0.73/src/misc/setup.cpp dosboxcvs/src/misc/setup.cpp
--- dosbox-0.73/src/misc/setup.cpp	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/misc/setup.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -209,6 +209,15 @@
 bool Property::CheckValue(Value const& in, bool warn){
 	if(suggested_values.empty()) return true;
 	for(iter it = suggested_values.begin();it != suggested_values.end();it++) {
+		if( (*it).type == 4 /*Value::Etype::V_STRING*/ ) {
+			if((*it).ToString().c_str()[0]=='%') {
+				Bitu value;
+				if(sscanf(in.ToString().c_str(),(*it).ToString().c_str(),&value) == 1) {
+					return true;
+				}
+			}
+		}
+		
 		if ( (*it) == in) { //Match!
 			return true;
 		}
diff -urN dosbox-0.73/src/platform/.cvsignore dosboxcvs/src/platform/.cvsignore
--- dosbox-0.73/src/platform/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/platform/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/platform/Makefile.in dosboxcvs/src/platform/Makefile.in
--- dosbox-0.73/src/platform/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/platform/Makefile.in	2009-07-08 20:46:43.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,11 +13,15 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -46,13 +50,10 @@
 DIST_SOURCES =
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-dvi-recursive install-exec-recursive \
-	install-html-recursive install-info-recursive \
-	install-pdf-recursive install-ps-recursive install-recursive \
-	installcheck-recursive installdirs-recursive pdf-recursive \
-	ps-recursive uninstall-recursive
-RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
-  distclean-recursive maintainer-clean-recursive
+	install-exec-recursive install-info-recursive \
+	install-recursive installcheck-recursive installdirs-recursive \
+	pdf-recursive ps-recursive uninstall-info-recursive \
+	uninstall-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
@@ -60,6 +61,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -71,6 +74,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -81,8 +85,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -92,7 +97,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -110,12 +114,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -127,43 +134,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 SUBDIRS = visualc
 EXTRA_DIST = sdl-win32.diff
 all: all-recursive
@@ -198,6 +194,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -230,7 +227,8 @@
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-$(RECURSIVE_CLEAN_TARGETS):
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -274,8 +272,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -300,8 +298,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -311,12 +309,13 @@
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -330,21 +329,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -358,7 +358,7 @@
 	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -d "$(distdir)/$$subdir" \
-	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || $(mkdir_p) "$(distdir)/$$subdir" \
 	    || exit 1; \
 	    distdir=`$(am__cd) $(distdir) && pwd`; \
 	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
@@ -366,8 +366,6 @@
 	      $(MAKE) $(AM_MAKEFLAGS) \
 	        top_distdir="$$top_distdir" \
 	        distdir="$$distdir/$$subdir" \
-		am__remove_distdir=: \
-		am__skip_length_check=: \
 	        distdir) \
 	      || exit 1; \
 	  fi; \
@@ -421,20 +419,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-recursive
-
 install-exec-am:
 
-install-html: install-html-recursive
-
 install-info: install-info-recursive
 
 install-man:
 
-install-pdf: install-pdf-recursive
-
-install-ps: install-ps-recursive
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -453,23 +443,21 @@
 
 ps-am:
 
-uninstall-am:
+uninstall-am: uninstall-info-am
 
-.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
-	install-strip
+uninstall-info: uninstall-info-recursive
 
-.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
-	all all-am check check-am clean clean-generic ctags \
-	ctags-recursive distclean distclean-generic distclean-tags \
+.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am \
+	clean clean-generic clean-recursive ctags ctags-recursive \
+	distclean distclean-generic distclean-recursive distclean-tags \
 	distdir dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	installdirs-am maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-generic pdf pdf-am ps ps-am tags \
-	tags-recursive uninstall uninstall-am
+	maintainer-clean-recursive mostlyclean mostlyclean-generic \
+	mostlyclean-recursive pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/platform/visualc/config.h dosboxcvs/src/platform/visualc/config.h
--- dosbox-0.73/src/platform/visualc/config.h	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/platform/visualc/config.h	2009-07-08 20:43:21.000000000 +0300
@@ -6,12 +6,19 @@
 /* Define to 1 to enable screenshots, requires libpng */
 #define C_SSHOT 1
 
+#if C_SSHOT
+#define C_LIBPNG
+#endif
+
 /* Define to 1 to use opengl display output support */
 #define C_OPENGL 1
 
 /* Define to 1 to enable internal modem support, requires SDL_net */
 #define C_MODEM 1
 
+/* Define to 1 to enable NE2000 ethernet passthrough, requires libpcap */
+#define C_NE2000 1
+
 /* Define to 1 to enable IPX networking support, requires SDL_net */
 #define C_IPX 1
 
@@ -49,9 +56,19 @@
 /* Define to 1 if you have the <ddraw.h> header file. */
 #define HAVE_DDRAW_H 1
 
+/* Define to 1 if you have the <d3d9.h> header file. */
+#define HAVE_D3D9_H 1
+
+/* Define to 1 to use Direct3D shaders, requires d3d9.h and libd3dx9 */
+#define C_D3DSHADERS 1
+
 /* Define to 1 if you want serial passthrough support (Win32 only). */
 #define C_DIRECTSERIAL 1
 
+#define C_DIRECTLPT 1
+
+#define C_PRINTER 1
+
 #define GCC_ATTRIBUTE(x) /* attribute not supported */
 #define GCC_UNLIKELY(x) (x)
 
diff -urN dosbox-0.73/src/platform/visualc/.cvsignore dosboxcvs/src/platform/visualc/.cvsignore
--- dosbox-0.73/src/platform/visualc/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/platform/visualc/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/platform/visualc/Makefile.in dosboxcvs/src/platform/visualc/Makefile.in
--- dosbox-0.73/src/platform/visualc/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/platform/visualc/Makefile.in	2009-07-08 20:46:44.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,11 +13,15 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -48,6 +52,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -59,6 +65,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -69,8 +76,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -80,7 +88,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -98,12 +105,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -115,43 +125,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 EXTRA_DIST = unistd.h config.h ntddscsi.h ntddcdrm.h
 all: all-am
 
@@ -185,6 +184,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 tags: TAGS
 TAGS:
 
@@ -193,21 +193,22 @@
 
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -266,20 +267,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -298,19 +291,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: all all-am check check-am clean clean-generic distclean \
 	distclean-generic distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/shell/.cvsignore dosboxcvs/src/shell/.cvsignore
--- dosbox-0.73/src/shell/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/src/shell/.cvsignore	2003-03-06 14:03:41.000000000 +0200
@@ -0,0 +1,3 @@
+.deps
+Makefile
+Makefile.in
diff -urN dosbox-0.73/src/shell/Makefile.in dosboxcvs/src/shell/Makefile.in
--- dosbox-0.73/src/shell/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/src/shell/Makefile.in	2009-07-08 20:46:44.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -14,11 +14,15 @@
 
 @SET_MAKE@
 
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ../..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -51,7 +55,7 @@
 am_libshell_a_OBJECTS = shell.$(OBJEXT) shell_batch.$(OBJEXT) \
 	shell_cmds.$(OBJEXT) shell_misc.$(OBJEXT)
 libshell_a_OBJECTS = $(am_libshell_a_OBJECTS)
-DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -67,6 +71,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -78,6 +84,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -88,8 +95,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -99,7 +107,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -117,12 +124,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -134,43 +144,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 noinst_LIBRARIES = libshell.a
 libshell_a_SOURCES = shell.cpp shell_batch.cpp shell_cmds.cpp shell_misc.cpp
@@ -227,26 +226,27 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shell_misc.Po@am__quote@
 
 .cpp.o:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
 
 .cpp.obj:
-@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
-@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ `$(CYGPATH_W) '$<'`; \
+@am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+uninstall-info-am:
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -258,8 +258,8 @@
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -269,12 +269,13 @@
 CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
+	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
-	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -288,21 +289,22 @@
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -363,20 +365,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -396,22 +390,18 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
 	distclean-generic distclean-tags distdir dvi dvi-am html \
 	html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
 	installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN dosbox-0.73/src/shell/shell_batch.cpp dosboxcvs/src/shell/shell_batch.cpp
--- dosbox-0.73/src/shell/shell_batch.cpp	2009-05-27 12:15:42.000000000 +0300
+++ dosboxcvs/src/shell/shell_batch.cpp	2009-07-03 22:36:56.000000000 +0300
@@ -16,7 +16,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
  */
 
-/* $Id: shell_batch.cpp,v 1.35 2009/05/27 09:15:42 qbix79 Exp $ */
+/* $Id: shell_batch.cpp,v 1.36 2009/07/03 19:36:56 qbix79 Exp $ */
 
 #include <stdlib.h>
 #include <string.h>
@@ -32,6 +32,7 @@
 	char totalname[DOS_PATHLENGTH+4];
 	DOS_Canonicalize(name,totalname); // Get fullname including drive specificiation
 	cmd = new CommandLine(totalname,cmd_line);
+	filename = totalname;
 
 	//Test if file is openable
 	if (!DOS_OpenFile(totalname,128,&file_handle)) {
@@ -49,8 +50,8 @@
 
 bool BatchFile::ReadLine(char * line) {
 	//Open the batchfile and seek to stored postion
-	if (!DOS_OpenFile(cmd->GetFileName(),128,&file_handle)) {
-		LOG(LOG_MISC,LOG_ERROR)("ReadLine Can't open BatchFile %s",cmd->GetFileName());
+	if (!DOS_OpenFile(filename.c_str(),128,&file_handle)) {
+		LOG(LOG_MISC,LOG_ERROR)("ReadLine Can't open BatchFile %s",filename.c_str());
 		delete this;
 		return false;
 	}
@@ -143,8 +144,8 @@
 
 bool BatchFile::Goto(char * where) {
 	//Open bat file and search for the where string
-	if (!DOS_OpenFile(cmd->GetFileName(),128,&file_handle)) {
-		LOG(LOG_MISC,LOG_ERROR)("SHELL:Goto Can't open BatchFile %s",cmd->GetFileName());
+	if (!DOS_OpenFile(filename.c_str(),128,&file_handle)) {
+		LOG(LOG_MISC,LOG_ERROR)("SHELL:Goto Can't open BatchFile %s",filename.c_str());
 		delete this;
 		return false;
 	}
diff -urN dosbox-0.73/src/shell/shell_cmds.cpp dosboxcvs/src/shell/shell_cmds.cpp
--- dosbox-0.73/src/shell/shell_cmds.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/shell/shell_cmds.cpp	2009-07-08 20:43:08.000000000 +0300
@@ -30,12 +30,14 @@
 #include <cstdlib>
 #include <vector>
 #include <string>
+#include <time.h>
 
 static SHELL_Cmd cmd_list[]={
 {	"CHDIR",	1,			&DOS_Shell::CMD_CHDIR,		"SHELL_CMD_CHDIR_HELP"},
 {	"CD",		0,			&DOS_Shell::CMD_CHDIR,		"SHELL_CMD_CHDIR_HELP"},
 {	"CLS",		0,			&DOS_Shell::CMD_CLS,		"SHELL_CMD_CLS_HELP"},
 {	"COPY",		0,			&DOS_Shell::CMD_COPY,		"SHELL_CMD_COPY_HELP"},
+{	"DATE",		0,			&DOS_Shell::CMD_DATE,		"SHELL_CMD_DATE_HELP"},
 {	"DIR",		0,			&DOS_Shell::CMD_DIR,		"SHELL_CMD_DIR_HELP"},
 {	"DEL",		0,			&DOS_Shell::CMD_DELETE,		"SHELL_CMD_DELETE_HELP"},
 {	"DELETE",	1,			&DOS_Shell::CMD_DELETE,		"SHELL_CMD_DELETE_HELP"},
@@ -51,6 +53,7 @@
 {	"IF",		1,			&DOS_Shell::CMD_IF,			"SHELL_CMD_IF_HELP"},
 {	"GOTO",		1,			&DOS_Shell::CMD_GOTO,		"SHELL_CMD_GOTO_HELP"},
 {	"SHIFT",	1,			&DOS_Shell::CMD_SHIFT,		"SHELL_CMD_SHIFT_HELP"},
+{	"TIME",		0,			&DOS_Shell::CMD_TIME,		"SHELL_CMD_TIME_HELP"},
 {	"TYPE",		0,			&DOS_Shell::CMD_TYPE,		"SHELL_CMD_TYPE_HELP"},
 {	"REM",		1,			&DOS_Shell::CMD_REM,		"SHELL_CMD_REM_HELP"},
 {	"RENAME",	1,			&DOS_Shell::CMD_RENAME,		"SHELL_CMD_RENAME_HELP"},
@@ -404,6 +407,9 @@
 	bool optW=ScanCMDBool(args,"W");
 	ScanCMDBool(args,"S");
 	bool optP=ScanCMDBool(args,"P");
+	if(ScanCMDBool(args,"WP")||ScanCMDBool(args,"PW")) {
+		optW=optP=true;
+	}
 	bool optAD=ScanCMDBool(args,"AD");
 	char * rem=ScanCMDRemain(args);
 	if (rem) {
@@ -904,6 +910,115 @@
 	this->call=false;
 }
 
+void DOS_Shell::CMD_DATE(char * args) {
+	HELP("DATE");	
+	if(ScanCMDBool(args,"h")) {
+		// synchronize date with host parameter
+		time_t curtime;
+		struct tm *loctime;
+		curtime = time (NULL);
+		loctime = localtime (&curtime);
+		
+		reg_cx = loctime->tm_year+1900;
+		reg_dh = loctime->tm_mon+1;
+		reg_dl = loctime->tm_mday;
+
+		reg_ah=0x2b; // set system date
+		CALLBACK_RunRealInt(0x21);
+		return;
+	}
+	if(ScanCMDBool(args,"s")) {
+		dos.hostdate=true;
+		return;
+	}
+	if(ScanCMDBool(args,"f")) {
+		dos.hostdate=true;
+		return;
+	}
+	// check if a date was passed in command line
+	Bitu newday,newmonth,newyear;
+	if(sscanf(args,"%u-%u-%u",&newmonth,&newday,&newyear)==3) {
+		reg_cx = newyear;
+		reg_dh = newmonth;
+		reg_dl = newday;
+
+		reg_ah=0x2b; // set system date
+		CALLBACK_RunRealInt(0x21);
+		if(reg_al==0xff) WriteOut(MSG_Get("SHELL_CMD_DATE_ERROR"));
+		return;
+	}
+	// display the current date
+	reg_ah=0x2a; // get system date
+	CALLBACK_RunRealInt(0x21);
+
+	const char* datestring = MSG_Get("SHELL_CMD_DATE_DAYS");
+	Bit8u length;
+	char day[6] = {0};
+	if(sscanf(datestring,"%u",&length) && (length<5) && (strlen(datestring)==(length*7+1))) {
+		// date string appears valid
+		for(int i = 0; i < length; i++) day[i] = datestring[reg_al*length+1+i];
+	}
+	bool dateonly = ScanCMDBool(args,"t");
+	if(!dateonly) WriteOut(MSG_Get("SHELL_CMD_DATE_NOW"));
+
+	const char* formatstring = MSG_Get("SHELL_CMD_DATE_FORMAT");
+	if(strlen(formatstring)!=5) return;
+	char buffer[15] = {0};
+	Bitu bufferptr=0;
+	for(Bitu i = 0; i < 5; i++) {
+		if(i==1 || i==3) {
+			buffer[bufferptr] = formatstring[i];
+			bufferptr++;
+		} else {
+			if(formatstring[i]=='M') bufferptr += sprintf(buffer+bufferptr,"%02u",(Bitu)reg_dh);
+			if(formatstring[i]=='D') bufferptr += sprintf(buffer+bufferptr,"%02u",(Bitu)reg_dl);
+			if(formatstring[i]=='Y') bufferptr += sprintf(buffer+bufferptr,"%04u",(Bitu)reg_cx);
+		}
+	}
+	WriteOut("%s %s\n",day, buffer);
+	if(!dateonly) WriteOut(MSG_Get("SHELL_CMD_DATE_SETHLP"));
+};
+
+void DOS_Shell::CMD_TIME(char * args) {
+	HELP("TIME");
+	if(ScanCMDBool(args,"h")) {
+		// synchronize time with host parameter
+		time_t curtime;
+		struct tm *loctime;
+		curtime = time (NULL);
+		loctime = localtime (&curtime);
+		
+		//reg_cx = loctime->;
+		//reg_dh = loctime->;
+		//reg_dl = loctime->;
+
+		// reg_ah=0x2d; // set system time TODO
+		// CALLBACK_RunRealInt(0x21);
+		
+		Bit32u ticks=(Bit32u)(((double)(loctime->tm_hour*3600+
+										loctime->tm_min*60+
+										loctime->tm_sec))*18.206481481);
+		mem_writed(BIOS_TIMER,ticks);
+		return;
+	}
+	bool timeonly = ScanCMDBool(args,"t");
+
+	reg_ah=0x2c; // get system time
+	CALLBACK_RunRealInt(0x21);
+/*
+		reg_dl= // 1/100 seconds
+		reg_dh= // seconds
+		reg_cl= // minutes
+		reg_ch= // hours
+*/
+	if(timeonly) {
+		WriteOut("%2u:%02u\n",reg_ch,reg_cl);
+	} else {
+		WriteOut(MSG_Get("SHELL_CMD_TIME_NOW"));
+		WriteOut("%2u:%02u:%02u,%02u\n",reg_ch,reg_cl,reg_dh,reg_dl);
+	}
+};
+
 void DOS_Shell::CMD_SUBST (char * args) {
 /* If more that one type can be substed think of something else 
  * E.g. make basedir member dos_drive instead of localdrive
diff -urN dosbox-0.73/src/shell/shell.cpp dosboxcvs/src/shell/shell.cpp
--- dosbox-0.73/src/shell/shell.cpp	2009-05-25 21:44:47.000000000 +0300
+++ dosboxcvs/src/shell/shell.cpp	2009-07-08 20:43:48.000000000 +0300
@@ -376,6 +376,14 @@
 		if ( !control->cmdline->FindCommand(1,line) ) { 
 			if ( secure ) autoexec[12].Install("z:\\config.com -securemode");
 		} else {
+			if (line.find(':',((line[0]|0x20) >= 'a' && (line[0]|0x20) <= 'z')?2:0) != std::string::npos) {
+				/* a physfs source */
+				autoexec[12].Install(std::string("MOUNT C \"") + line + std::string("\""));
+				autoexec[13].Install("C:");
+				if(secure) autoexec[14].Install("z:\\config.com -securemode");
+				goto nomount;
+			}
+
 			struct stat test;
 			strcpy(buffer,line.c_str());
 			if (stat(buffer,&test)){
@@ -401,9 +409,18 @@
 				}
 				*name++ = 0;
 				if (access(buffer,F_OK)) goto nomount;
+				upcase(name);
+				if((strstr(name,".ZIP") != 0) || (strstr(name,".7Z") != 0)) {
+					//TODO:Add more extensions?
+					LOG_MSG("Mouting %s as PHYSFS write directory", buffer);
+					autoexec[12].Install(std::string("MOUNT C \"") + buffer + std::string(":") + name
+						+ std::string(":\""));
+					autoexec[13].Install("C:");
+					if(secure) autoexec[14].Install("z:\\config.com -securemode");
+					goto nomount;
+				}
 				autoexec[12].Install(std::string("MOUNT C \"") + buffer + "\"");
 				autoexec[13].Install("C:");
-				upcase(name);
 				if(strstr(name,".BAT") != 0) {
 					if(secure) autoexec[14].Install("z:\\config.com -securemode");
 					/* BATch files are called else exit will not work */
@@ -448,6 +465,23 @@
 	MSG_Add("SHELL_CMD_CHDIR_HINT","To change to different drive type \033[31m%c:\033[0m\n");
 	MSG_Add("SHELL_CMD_CHDIR_HINT_2","directoryname is longer than 8 charachters and/or contains spaces.\nTry \033[31mcd %s\033[0m\n");
 	MSG_Add("SHELL_CMD_CHDIR_HINT_3","You are still on drive Z:, change to a mounted drive with \033[31mC:\033[0m.\n");
+	MSG_Add("SHELL_CMD_DATE_HELP","Displays or changes the internal date.\n");
+	MSG_Add("SHELL_CMD_DATE_ERROR","The specified date is not correct.\n");
+	MSG_Add("SHELL_CMD_DATE_DAYS","3SunMonTueWedThuFriSat"); // "2SoMoDiMiDoFrSa"
+	MSG_Add("SHELL_CMD_DATE_NOW","Current date: ");
+	MSG_Add("SHELL_CMD_DATE_SETHLP","Type 'date MM-DD-YYYY' to change.\n");
+	MSG_Add("SHELL_CMD_DATE_FORMAT","M/D/Y");
+	MSG_Add("SHELL_CMD_DATE_HELP_LONG","DATE [[/T] [/H] [/S] | MM-DD-YYYY]\n"\
+									"  MM-DD-YYYY: new date to set\n"\
+									"  /S:         Permanently use host time and date as DOS time\n"\
+                                    "  /F:         Switch back to DOSBox internal time (opposite of /S)\n"\
+									"  /T:         Only display date\n"\
+									"  /H:         Synchronize with host\n");
+	MSG_Add("SHELL_CMD_TIME_HELP","Displays the internal time.\n");
+	MSG_Add("SHELL_CMD_TIME_NOW","Current time: ");
+	MSG_Add("SHELL_CMD_TIME_HELP_LONG","TIME [/T] [/H]\n"\
+									"  /T:         Display simple time\n"\
+									"  /H:         Synchronize with host\n");
 	MSG_Add("SHELL_CMD_MKDIR_ERROR","Unable to make: %s.\n");
 	MSG_Add("SHELL_CMD_RMDIR_ERROR","Unable to remove: %s.\n");
 	MSG_Add("SHELL_CMD_DEL_ERROR","Unable to delete: %s.\n");
@@ -550,6 +584,9 @@
 	MSG_Add("SHELL_CMD_ATTRIB_HELP","Does nothing. Provided for compatibility.\n");
 	MSG_Add("SHELL_CMD_PATH_HELP","Provided for compatibility.\n");
 	MSG_Add("SHELL_CMD_VER_HELP","View and set the reported DOS version.\n");
+	MSG_Add("SHELL_CMD_VER_HELP_LONG","VER [major minor]"\
+			"\n  Example: 'ver 6 22' changes to DOS 6.22");
+
 	MSG_Add("SHELL_CMD_VER_VER","DOSBox version %s. Reported DOS version %d.%02d.\n");
 
 	/* Regular startup */
@@ -607,13 +644,13 @@
 	 * In order to achieve this: First open 2 files. Close the first and
 	 * duplicate the second (so the entries get 01) */
 	Bit16u dummy=0;
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDIN  */
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDOUT */
-	DOS_CloseFile(0);							/* Close STDIN */
-	DOS_ForceDuplicateEntry(1,0);				/* "new" STDIN */
-	DOS_ForceDuplicateEntry(1,2);				/* STDERR */
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDAUX */
-	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);	/* STDPRN */
+	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);/* STDIN  */
+	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);/* STDOUT */
+	DOS_CloseFile(0);            /* Close STDIN */
+	DOS_ForceDuplicateEntry(1,0);/* "new" STDIN */
+	DOS_ForceDuplicateEntry(1,2);/* STDERR */
+	DOS_OpenFile("CON",OPEN_READWRITE,&dummy);/* STDAUX */
+	DOS_OpenFile("PRN",OPEN_READWRITE,&dummy);/* STDPRN */
 
 	psp.SetParent(psp_seg);
 	/* Set the environment */
diff -urN dosbox-0.73/VERSION dosboxcvs/VERSION
--- dosbox-0.73/VERSION	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/VERSION	2009-05-27 12:15:40.000000000 +0300
@@ -0,0 +1 @@
+0.73
diff -urN dosbox-0.73/visualc_net/.cvsignore dosboxcvs/visualc_net/.cvsignore
--- dosbox-0.73/visualc_net/.cvsignore	1970-01-01 02:00:00.000000000 +0200
+++ dosboxcvs/visualc_net/.cvsignore	2009-07-08 20:43:08.000000000 +0300
@@ -0,0 +1,14 @@
+Release
+Debug
+.deps
+Makefile
+Makefile.in
+capture
+dosbox.ncb
+dosbox.suo
+dosbox.conf
+dosbox.ncb
+dosbox.suo
+dosbox.ncb
+dosbox.suo
+dosbox.conf
diff -urN dosbox-0.73/visualc_net/dosbox.vcproj dosboxcvs/visualc_net/dosbox.vcproj
--- dosbox-0.73/visualc_net/dosbox.vcproj	2009-05-20 20:45:27.000000000 +0300
+++ dosboxcvs/visualc_net/dosbox.vcproj	2009-07-08 20:43:08.000000000 +0300
@@ -80,7 +80,7 @@
 			UseOfMFC="0"
 			ATLMinimizesCRunTimeLibraryUsage="FALSE"
 			CharacterSet="2"
-			WholeProgramOptimization="FALSE">
+			WholeProgramOptimization="TRUE">
 			<Tool
 				Name="VCCLCompilerTool"
 				Optimization="3"
@@ -92,7 +92,7 @@
 				OmitFramePointers="TRUE"
 				OptimizeForProcessor="2"
 				OptimizeForWindowsApplication="TRUE"
-				AdditionalIncludeDirectories="../include,../src/platform/visualc"
+				AdditionalIncludeDirectories="E:\Programmierumgebungen\pcap\WpdPack\Include;&quot;E:\Programmierumgebungen\Projekte\SDL-1.2.8\include&quot;;&quot;E:\Programmierumgebungen\freetype-2.1.10\include&quot;;E:\Programmierumgebungen\dlls\zlib;E:\Programmierumgebungen\dlls\lpng1216;&quot;E:\Programmierumgebungen\Projekte\SDL_net-1.2.5\include&quot;;E:\Programmierumgebungen\Projekte\pdcurse;../include;../src/platform/visualc"
 				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
 				StringPooling="TRUE"
 				RuntimeLibrary="2"
@@ -113,10 +113,11 @@
 				Name="VCCustomBuildTool"/>
 			<Tool
 				Name="VCLinkerTool"
-				AdditionalDependencies="opengl32.lib winmm.lib zlib.lib libpng.lib sdl_net.lib sdlmain.lib sdl.lib curses.lib odbc32.lib odbccp32.lib ws2_32.lib"
+				AdditionalDependencies="opengl32.lib winmm.lib zlib.lib libpng.lib sdl_net.lib sdlmain.lib sdl.lib curses.lib odbc32.lib odbccp32.lib Ws2_32.lib freetype2110.lib"
 				OutputFile=".\Release/dosbox.exe"
 				LinkIncremental="1"
 				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories="E:\Programmierumgebungen\Projekte\pdcurse24;&quot;E:\Programmierumgebungen\Projekte\SDL_net-1.2.5\lib&quot;;E:\Programmierumgebungen\dlls\lpng1216\projects\visualc71\Win32_LIB_Release\ZLib;&quot;E:\Programmierumgebungen\Projekte\SDL-1.2.8\lib&quot;;E:\Programmierumgebungen\dlls\lpng1216\projects\visualc71\Win32_LIB_Release;E:\Programmierumgebungen\freetype-2.1.10\objs"
 				GenerateDebugInformation="TRUE"
 				ProgramDatabaseFile=""
 				GenerateMapFile="TRUE"
@@ -309,10 +310,10 @@
 						RelativePath="..\src\cpu\core_dynrec\operators.h">
 					</File>
 					<File
-						RelativePath="..\src\cpu\core_dynrec\risc_x86.h">
+						RelativePath="..\src\cpu\core_dynrec\risc_x64.h">
 					</File>
 					<File
-						RelativePath="..\src\cpu\core_dynrec\risc_x64.h">
+						RelativePath="..\src\cpu\core_dynrec\risc_x86.h">
 					</File>
 				</Filter>
 			</Filter>
@@ -457,6 +458,9 @@
 					RelativePath="..\src\hardware\font-switch.h">
 				</File>
 				<File
+					RelativePath="..\src\hardware\hardopl.cpp">
+				</File>
+				<File
 					RelativePath="..\src\hardware\hardware.cpp">
 				</File>
 				<File
@@ -481,6 +485,9 @@
 					RelativePath="..\src\hardware\mixer.cpp">
 				</File>
 				<File
+					RelativePath="..\src\hardware\ne2000.cpp">
+				</File>
+				<File
 					RelativePath="..\src\hardware\pic.cpp">
 				</File>
 				<File
@@ -567,28 +574,16 @@
 					Name="serialport"
 					Filter="">
 					<File
-						RelativePath="..\src\hardware\serialport\directserial_os2.cpp">
-						<FileConfiguration
-							Name="Release|Win32"
-							ExcludedFromBuild="TRUE">
-							<Tool
-								Name="VCCLCompilerTool"/>
-						</FileConfiguration>
-					</File>
-					<File
-						RelativePath="..\src\hardware\serialport\directserial_os2.h">
-					</File>
-					<File
-						RelativePath="..\src\hardware\serialport\directserial_posix.cpp">
+						RelativePath="..\src\hardware\serialport\directserial.cpp">
 					</File>
 					<File
-						RelativePath="..\src\hardware\serialport\directserial_posix.h">
+						RelativePath="..\src\hardware\serialport\directserial.h">
 					</File>
 					<File
-						RelativePath="..\src\hardware\serialport\directserial_win32.cpp">
+						RelativePath="..\src\hardware\serialport\libserial.cpp">
 					</File>
 					<File
-						RelativePath="..\src\hardware\serialport\directserial_win32.h">
+						RelativePath="..\src\hardware\serialport\libserial.h">
 					</File>
 					<File
 						RelativePath="..\src\hardware\serialport\misc_util.cpp">
@@ -618,11 +613,57 @@
 						RelativePath="..\src\hardware\serialport\softmodem.h">
 					</File>
 				</Filter>
+				<Filter
+					Name="parport"
+					Filter="">
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_linux.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_linux.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_win32.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\directlpt_win32.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\filelpt.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\filelpt.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\parport.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_charmaps.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_if.h">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_redir.cpp">
+					</File>
+					<File
+						RelativePath="..\src\hardware\parport\printer_redir.h">
+					</File>
+				</Filter>
 			</Filter>
 			<Filter
 				Name="gui"
 				Filter="">
 				<File
+					RelativePath="..\src\libs\gui_tk\gui_tk.cpp">
+				</File>
+				<File
 					RelativePath="..\src\gui\midi.cpp">
 				</File>
 				<File
@@ -649,9 +690,6 @@
 				<File
 					RelativePath="..\src\gui\sdlmain.cpp">
 				</File>
-				<File
-					RelativePath="..\src\libs\gui_tk\gui_tk.cpp">
-				</File>
 			</Filter>
 			<Filter
 				Name="ints"
@@ -773,6 +811,23 @@
 					RelativePath="..\src\fpu\fpu_instructions_x86.h">
 				</File>
 			</Filter>
+			<Filter
+				Name="libs"
+				Filter="">
+				<Filter
+					Name="porttalk"
+					Filter="">
+					<File
+						RelativePath="..\src\libs\porttalk\porttalk.cpp">
+					</File>
+					<File
+						RelativePath="..\src\libs\porttalk\porttalk.h">
+					</File>
+					<File
+						RelativePath="..\src\libs\porttalk\PortTalk_IOCTL.h">
+					</File>
+				</Filter>
+			</Filter>
 		</Filter>
 		<Filter
 			Name="Header Files"
@@ -841,9 +896,15 @@
 				RelativePath="..\include\mouse.h">
 			</File>
 			<File
+				RelativePath="..\include\ne2000.h">
+			</File>
+			<File
 				RelativePath="..\include\paging.h">
 			</File>
 			<File
+				RelativePath="..\include\parport.h">
+			</File>
+			<File
 				RelativePath="..\include\pic.h">
 			</File>
 			<File
@@ -877,6 +938,341 @@
 				RelativePath="..\include\video.h">
 			</File>
 		</Filter>
+		<Filter
+			Name="deps"
+			Filter="">
+			<Filter
+				Name="wpcap"
+				Filter="">
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\bittypes.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\bucket_lookup.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\count_packets.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Devioctl.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Gnuc.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\ip6_misc.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\memory_t.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\normal_lookup.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Ntddndis.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Ntddpack.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Packet32.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\pcap-bpf.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\pcap-int.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\pcap-stdinc.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\pcap.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\pthread.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\remote-ext.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\sched.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\semaphore.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\tcp_session.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\time_calls.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\tme.h">
+				</File>
+				<File
+					RelativePath="..\..\..\pcap\WpdPack\Include\Win32-Extensions.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="sdl"
+				Filter="">
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\begin_code.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\close_code.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_active.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_audio.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_byteorder.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_cdrom.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_copying.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_cpuinfo.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_endian.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_error.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_events.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_getenv.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_joystick.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_keyboard.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_keysym.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_loadso.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_main.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_mouse.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_mutex.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_name.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_opengl.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_quit.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_rwops.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_syswm.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_thread.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_timer.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_types.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_version.h">
+				</File>
+				<File
+					RelativePath="..\..\SDL-1.2.8\include\SDL_video.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="freetype"
+				Filter="">
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\freetype.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\ft2build.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftbbox.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftbdf.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftbitmap.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftcache.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftchapters.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\fterrdef.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\fterrors.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftglyph.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftgzip.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftimage.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftincrem.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftlist.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftlzw.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftmac.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftmm.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftmodapi.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftmoderr.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftotval.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftoutln.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftpfr.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftrender.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsizes.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsnames.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftstroke.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsynth.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsysio.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsysmem.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftsystem.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\fttrigon.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\fttypes.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftwinfnt.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ftxf86.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\t1tables.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ttnameid.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\tttables.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\tttags.h">
+				</File>
+				<File
+					RelativePath="..\..\..\freetype-2.1.10\include\freetype\ttunpat.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="zlib"
+				Filter="">
+				<File
+					RelativePath="..\..\..\dlls\zlib\zlib.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="png"
+				Filter="">
+				<File
+					RelativePath="..\..\..\dlls\lpng1216\png.h">
+				</File>
+				<File
+					RelativePath="..\..\..\dlls\lpng1216\pngconf.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="sdlnet"
+				Filter="">
+				<File
+					RelativePath="..\..\SDL_net-1.2.5\include\SDL_net.h">
+				</File>
+			</Filter>
+			<Filter
+				Name="pdcurse"
+				Filter="">
+				<File
+					RelativePath="..\..\pdcurse\curses.h">
+				</File>
+				<File
+					RelativePath="..\..\pdcurse\curspriv.h">
+				</File>
+				<File
+					RelativePath="..\..\pdcurse\panel.h">
+				</File>
+				<File
+					RelativePath="..\..\pdcurse\xcurses.h">
+				</File>
+			</Filter>
+		</Filter>
+		<File
+			RelativePath=".\dosbox.conf">
+		</File>
 		<File
 			RelativePath="..\src\dosbox.ico">
 		</File>
diff -urN dosbox-0.73/visualc_net/Makefile.in dosboxcvs/visualc_net/Makefile.in
--- dosbox-0.73/visualc_net/Makefile.in	2009-05-20 21:29:07.000000000 +0300
+++ dosboxcvs/visualc_net/Makefile.in	2009-07-08 20:46:44.000000000 +0300
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# Makefile.in generated by automake 1.9.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# 2003, 2004, 2005  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,11 +13,15 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -48,6 +52,8 @@
 ACLOCAL = @ACLOCAL@
 ALSA_CFLAGS = @ALSA_CFLAGS@
 ALSA_LIBS = @ALSA_LIBS@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
@@ -59,6 +65,7 @@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CXX = @CXX@
+CXXCPP = @CXXCPP@
 CXXDEPMODE = @CXXDEPMODE@
 CXXFLAGS = @CXXFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -69,8 +76,9 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
-GREP = @GREP@
-INSTALL = @INSTALL@
+FREETYPE_CONFIG = @FREETYPE_CONFIG@
+HAVE_WINDRES_FALSE = @HAVE_WINDRES_FALSE@
+HAVE_WINDRES_TRUE = @HAVE_WINDRES_TRUE@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
@@ -80,7 +88,6 @@
 LIBS = @LIBS@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
-MKDIR_P = @MKDIR_P@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -98,12 +105,15 @@
 STRIP = @STRIP@
 VERSION = @VERSION@
 WINDRES = @WINDRES@
-abs_builddir = @abs_builddir@
-abs_srcdir = @abs_srcdir@
-abs_top_builddir = @abs_top_builddir@
-abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+ac_ct_WINDRES = @ac_ct_WINDRES@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__fastdepCXX_FALSE = @am__fastdepCXX_FALSE@
+am__fastdepCXX_TRUE = @am__fastdepCXX_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -115,43 +125,32 @@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
-builddir = @builddir@
 datadir = @datadir@
-datarootdir = @datarootdir@
-docdir = @docdir@
-dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
 host_cpu = @host_cpu@
 host_os = @host_os@
 host_vendor = @host_vendor@
-htmldir = @htmldir@
 includedir = @includedir@
 infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
-localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
-pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
-psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
-srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-top_builddir = @top_builddir@
-top_srcdir = @top_srcdir@
 EXTRA_DIST = dosbox.sln dosbox.vcproj
 all: all-am
 
@@ -185,6 +184,7 @@
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
 $(ACLOCAL_M4):  $(am__aclocal_m4_deps)
 	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+uninstall-info-am:
 tags: TAGS
 TAGS:
 
@@ -193,21 +193,22 @@
 
 
 distdir: $(DISTFILES)
-	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
-	list='$(DISTFILES)'; \
-	  dist_files=`for file in $$list; do echo $$file; done | \
-	  sed -e "s|^$$srcdirstrip/||;t" \
-	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
-	case $$dist_files in \
-	  */*) $(MKDIR_P) `echo "$$dist_files" | \
-			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
-			   sort -u` ;; \
-	esac; \
-	for file in $$dist_files; do \
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
 	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkdir_p) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
 	  if test -d $$d/$$file; then \
-	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
 	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
 	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
 	    fi; \
@@ -266,20 +267,12 @@
 
 install-data-am:
 
-install-dvi: install-dvi-am
-
 install-exec-am:
 
-install-html: install-html-am
-
 install-info: install-info-am
 
 install-man:
 
-install-pdf: install-pdf-am
-
-install-ps: install-ps-am
-
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -298,19 +291,16 @@
 
 ps-am:
 
-uninstall-am:
-
-.MAKE: install-am install-strip
+uninstall-am: uninstall-info-am
 
 .PHONY: all all-am check check-am clean clean-generic distclean \
 	distclean-generic distdir dvi dvi-am html html-am info info-am \
-	install install-am install-data install-data-am install-dvi \
-	install-dvi-am install-exec install-exec-am install-html \
-	install-html-am install-info install-info-am install-man \
-	install-pdf install-pdf-am install-ps install-ps-am \
+	install install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
